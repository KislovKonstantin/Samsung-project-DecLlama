trg,HR,out,sub_eval
"//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: safe
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, i;

    printf(""Enter the number of terms you want to generate in the Fibonacci Sequence: "");
    scanf(""%d"", &n);

    int fib[n];
    fib[0] = 0;
    fib[1] = 1;

    // starting with index 2, generates the remaining terms in the sequence
    for (i = 2; i < n; i++) {
        fib[i] = fib[i-1] + fib[i-2];
    }

    printf(""\\nFibonacci Sequence for %d terms is: "", n);

    // prints the sequence
    for (i = 0; i < n; i++) {
        printf(""%d "", fib[i]);
    }

    // visualizes the sequence using stars, with each star representing one term in the sequence
    printf(""\\n\\nVisualizing the Fibonacci Sequence:\\n"");

    for (i = 0; i < n; i++) {
        int j;
        for (j = 0; j < fib[i]; j++) {
            printf(""* "");
        }
        printf(""\\n"");
    }

    printf(""\\n"");
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch] BYREF
  int *v7; // [rsp+28h] [rbp-18h]
  __int64 v8; // [rsp+30h] [rbp-10h]
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Enter the number of terms you want to generate in the Fibonacci Sequence: "");
  scanf(""%d"", &v6);
  v8 = v6 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(4i64 * v6 + 15) >> 4));
  v7 = &v5;
  v5 = 0;
  v6 = 1;
  i = 2;
  printf(""\\nFibonacci Sequence for %d terms is: "", 1i64);
  for ( i = 0; i < v6; ++i )
    printf(""%d "", (unsigned int)v7[i]);
  printf(""\\n\\nVisualizing the Fibonacci Sequence:\\n"");
  for ( i = 0; i < v6; ++i )
  {
    for ( j = 0; j < v7[i]; ++j )
      printf(""* "");
    printf(""\\n"");
  }
  printf(""\\n"");
  return 0;
}
// 1400016CE: conditional instruction was optimized away because %var_34.4==2
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
int main() {
    int n, i, j, k, l, m, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30, n31, n32, n33, n34, n35, n36, n37, n38, n39, n40, n41, n42, n43, n44, n45, n46, n47, n48, n49, n50, n51, n52, n53, n54, n55, n56, n57, n58, n59, n60, n61, n62, n63, n64, n65, n66, n67, n68, n69, n70, n71, n72, n73, n74, n75, n76, n77, n78, n79, n80, n81, n82, n83, n84, n85, n86, n87, n88, n89, n90, n91, n92, n93, n94, n95, n96, n97, n98, n99, n100;
    printf(""Enter the number of terms you want to generate in the Fibonacci Sequence: "");
    scanf(""%d"", &n);
    int fib[n];
    fib[0] = 0;
    fib[1] = 1;
    for (i = 2; i < n; i++) {
        fib[i] = fib[i-1] + fib[i-2];
    }
    printf(""
Fibonacci Sequence for %d terms is: "", n);
    for (i = 0; i < n; i++) {
        printf(""%d "", fib[i]);
    }
    printf(""

Visualizing the Fibonacci Sequence:
"");
    for (i = 0; i < n; i++) {
        for (j = 0; j < fib[i]; j++) {
            printf(""* "");
        }
        printf(""
"");
    }
    printf(""
"");
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Levenshtein Distance Calculator ; Style: intelligent
#include <stdio.h> 
#include <string.h> 

int min(int x, int y, int z) {
    if (x <= y && x <= z) {
        return x;
    } else if (y <= x && y <= z) {
        return y;
    } else {
        return z;
    }
}

int levenshtein_distance(char *s, char *t) {
    int len_s = strlen(s);
    int len_t = strlen(t);
    
    int distance[len_s + 1][len_t + 1];
    
    for (int i = 0; i <= len_s; i++) {
        for (int j = 0; j <= len_t; j++) {
            if (i == 0) {
                distance[i][j] = j;
            } else if (j == 0) {
                distance[i][j] = i;
            } else if (s[i - 1] == t[j - 1]) {
                distance[i][j] = distance[i - 1][j - 1];
            } else {
                distance[i][j] = 1 + min(distance[i - 1][j], distance[i][j - 1], distance[i - 1][j - 1]);
            }
        }
    }
    
    return distance[len_s][len_t];
}

int main() {
    char s1[] = ""Hello, World!"";
    char s2[] = ""Hllo, Wrd!"";
    
    int distance = levenshtein_distance(s1, s2);
    
    printf(""Levenshtein Distance: %d\\n"", distance);
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall levenshtein_distance(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400018E0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[25]; // [rsp+23h] [rbp-1Dh] BYREF
  unsigned int v5; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(&v4[11], ""Hello, World!"");
  strcpy(v4, ""Hllo, Wrd!"");
  v5 = levenshtein_distance(&v4[11], v4);
  printf(""Levenshtein Distance: %d\\n"", v5);
  return 0;
}
// 1400015CE: using guessed type __int64 __fastcall levenshtein_distance(_QWORD, _QWORD);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <string.h>

int min(int a, int b, int c) {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= a && b <= c) {
        return b;
    } else {
        return c;
    }
}

int levenshtein_distance(char *s1, char *s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    int dp[len1 + 1][len2 + 1];
    
    for (int i = 0; i <= len1; i++) {
        dp[i][0] = i;
    }
    
    for (int j = 0; j <= len2; j++) {
        dp[0][j] = j;
    }
    
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
            }
        }
    }
    
    return dp[len1][len2];
}

int main() {
    char s1[] = ""Hello, World!"";
    char s2[] = ""Hllo, Wrd!"";
    int distance = levenshtein_distance(s1, s2);
    printf(""Levenshtein Distance: %d
"", distance);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Sudoku solver ; Style: post-apocalyptic
#include <stdio.h>
#include <stdlib.h>

#define SIZE 9

int board[SIZE][SIZE];

void print_board()
{
    int row, col;
    for (row = 0; row < SIZE; row++) {
        for (col = 0; col < SIZE; col++) {
            printf(""%d "", board[row][col]);
        }
        printf(""\\n"");
    }
}

void solve()
{
    int row, col, num;
    for (row = 0; row < SIZE; row++) {
        for (col = 0; col < SIZE; col++) {
            if (board[row][col] == 0) {
                for (num = 1; num <= SIZE; num++) {
                    int i, j;
                    int valid = 1;
                    for (i = 0; i < SIZE; i++) {
                        if (board[i][col] == num) {
                            valid = 0;
                            break;
                        }
                    }
                    for (j = 0; j < SIZE; j++) {
                        if (board[row][j] == num) {
                            valid = 0;
                            break;
                        }
                    }
                    int box_row = row / 3;
                    int box_col = col / 3;
                    for (i = box_row*3; i < box_row*3+3; i++) {
                        for (j = box_col*3; j < box_col*3+3; j++) {
                            if (board[i][j] == num) {
                                valid = 0;
                                break;
                            }
                        }
                    }
                    if (valid) {
                        board[row][col] = num;
                        solve();
                        board[row][col] = 0;
                    }
                }
                return;
            }
        }
    }
    print_board();
    exit(0);
}

int main()
{
    // Initialize the board
    int row, col;
    for (row = 0; row < SIZE; row++) {
        for (col = 0; col < SIZE; col++) {
            scanf(""%d"", &board[row][col]);
        }
    }
    // Solve the puzzle
    solve();
    printf(""No solution found."");
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 solve(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN board; // weak


//----- (00000001400018C4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int j; // [rsp+28h] [rbp-8h]
  int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  for ( i = 0; i <= 8; ++i )
  {
    for ( j = 0; j <= 8; ++j )
      scanf(""%d"", (char *)&board + 36 * i + 4 * j);
  }
  solve();
  printf(""No solution found."");
  return 0;
}
// 140001663: using guessed type __int64 solve(void);
// 140001A10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

#define BOARD_SIZE 9

int board[BOARD_SIZE][BOARD_SIZE];

void print_board() {
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            printf(""%d "", board[i][j]);
        }
        printf(""
"");
    }
}

int is_valid_move(int row, int col, int num) {
    // Check if the number is already in the row
    for (int i = 0; i < BOARD_SIZE; i++) {
        if (board[row][i] == num) {
            return 0;
        }
    }

    // Check if the number is already in the column
    for (int i = 0; i < BOARD_SIZE; i++) {
        if (board[i][col] == num) {
            return 0;
        }
    }

    // Check if the number is already in the 3x3 box
    int box_row = row - row % 3;
    int box_col = col - col % 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[i + box_row][j + box_col] == num) {
                return 0;
            }
        }
    }

    return 1;
}

void solve() {
    int row = 0;
    int col = 0;

    while (row < BOARD_SIZE && col < BOARD_SIZE) {
        if (board[row][col] == 0) {
            for (int num = 1; num <= 9; num++) {
                if (is_valid_move(row, col, num)) {
                    board[row][col] = num;
                    if (col < BOARD_SIZE - 1) {
                        col++;
                    } else {
                        col = 0;
                        row++;
                    }
                    if (row == BOARD_SIZE) {
                        print_board();
                        return;
                    }
                    solve();
                    board[row][col] = 0;
                    if (col == BOARD_SIZE - 1) {
                        col = 0;
                        row--;
                    } else {
                        col++;
                    }
                }
            }
            return;
        }
        if (col == BOARD_SIZE - 1) {
            col = 0;
            row++;
        } else {
            col++;
        }
    }
}

int main() {
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            scanf(""%d"", &board[i][j]);
        }
    }
    solve();
    printf(""No solution found."");
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define OPEN ' '
#define BLOCKED '#'

bool **grid; // 2D array to hold percolation grid
int size; // size of grid
int openSites = 0; // number of open sites in the grid

// Function to allocate memory for grid and initialize all sites to blocked
void makeGrid(){
    grid = malloc(sizeof(bool*) * size);
    for(int i = 0; i < size; i++){
        grid[i] = malloc(sizeof(bool) * size);
        for(int j = 0; j < size; j++){
            grid[i][j] = false;
        }
    }
}

// Function to randomly open up a site
void openSite(){
    int x = rand()%size;
    int y = rand()%size;
    if(!grid[x][y]){
        grid[x][y] = true;
        openSites++;
    }
}

// Function to check if a site is open
bool isOpen(int i, int j){
    if(i < 0 || j < 0 || i >= size || j >= size){
        return false;
    }
    return grid[i][j];
}

// Function to check if given site is connected to top
bool isTopConnected(int i, int j){
    if(i == 0){
        return true;
    }
    if(isOpen(i-1, j)){
        return true;
    }
    if(j > 0 && isOpen(i, j-1)){
        return true;
    }
    if(j < size-1 && isOpen(i, j+1)){
        return true;
    }
    return false;
}

// Function to check if given site is connected to bottom
bool isBottomConnected(int i, int j){
    if(i == size-1){
        return true;
    }
    if(isOpen(i+1, j)){
        return true;
    }
    if(j > 0 && isOpen(i, j-1)){
        return true;
    }
    if(j < size-1 && isOpen(i, j+1)){
        return true;
    }
    return false;
}

// Function to check if percolation has occured
bool doesPercolate(){
    for(int i = 0; i < size; i++){
        if(isOpen(size-1, i) && isTopConnected(size-1, i)){
            return true;
        }
    }
    return false;
}

// Function to print the current state of the grid
void printGrid(){
    for(int i = 0; i < size; i++){
        for(int j = 0; j < size; j++){
            if(grid[i][j]){
                printf(""%c "", OPEN);
            } else {
                printf(""%c "", BLOCKED);
            }
        }
        printf(""\\n"");
    }
    printf(""\\n"");
}

int main(){
    srand(time(NULL)); // Initialize random seed
    printf(""Enter size of grid: "");
    scanf(""%d"", &size);
    makeGrid();
    printf(""Initial grid:\\n"");
    printGrid();
    while(!doesPercolate()){ // continue until percolation occurs
        openSite();
        printGrid();
    }
    printf(""Percolation occured!\\n"");
    printf(""Total open sites: %d\\n"", openSites);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 makeGrid(void); // weak
__int64 openSite(void); // weak
__int64 doesPercolate(void); // weak
__int64 printGrid(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

int size; // weak
int openSites; // weak


//----- (00000001400019B6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf(""Enter size of grid: "");
  scanf(""%d"", &size);
  makeGrid();
  printf(""Initial grid:\\n"");
  printGrid();
  while ( (unsigned __int8)doesPercolate() != 1 )
  {
    openSite();
    printGrid();
  }
  printf(""Percolation occured!\\n"");
  printf(""Total open sites: %d\\n"", (unsigned int)openSites);
  return 0;
}
// 140001601: using guessed type __int64 makeGrid(void);
// 1400016A9: using guessed type __int64 openSite(void);
// 1400018A6: using guessed type __int64 doesPercolate(void);
// 140001906: using guessed type __int64 printGrid(void);
// 140001B10: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019048: using guessed type int size;
// 14001904C: using guessed type int openSites;

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

#define MAX_SIZE 100

int grid[MAX_SIZE][MAX_SIZE];
int size;
int openSites = 0;

void makeGrid() {
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            grid[i][j] = rand() % 2;
            if (grid[i][j] == 1) {
                openSites++;
            }
        }
    }
}

void openSite() {
    int row, col;
    do {
        row = rand() % size;
        col = rand() % size;
    } while (grid[row][col] == 0);
    grid[row][col] = 1;
    openSites++;
}

bool isValid(int row, int col) {
    return (row >= 0 && row < size && col >= 0 && col < size);
}

bool isOpen(int row, int col) {
    return (grid[row][col] == 1);
}

bool isFull(int row, int col) {
    for (int i = row - 1; i <= row + 1; i++) {
        for (int j = col - 1; j <= col + 1; j++) {
            if (isValid(i, j) && isOpen(i, j)) {
                return true;
            }
        }
    }
    return false;
}

bool doesPercolate() {
    for (int i = 0; i < size; i++) {
        if (isOpen(0, i)) {
            return true;
        }
    }
    return false;
}

void printGrid() {
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            printf(""%d "", grid[i][j]);
        }
        printf(""
"");
    }
}

int main() {
    srand(time(NULL));
    printf(""Enter size of grid: "");
    scanf(""%d"", &size);
    makeGrid();
    printf(""Initial grid:
"");
    printGrid();
    while (!doesPercolate()) {
        openSite();
        printGrid();
    }
    printf(""Percolation occured!
"");
    printf(""Total open sites: %d
"", openSites);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Banking Record System ; Style: invasive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure representing a bank account
struct account {
    char name[50];
    int account_number;
    float balance;
};

// Function to add a new account to the record system
void add_account(struct account *accounts, int *account_count) {
    char name[50];
    float balance;
    printf(""Enter name of account holder: "");
    scanf(""%s"", name);
    printf(""Enter initial balance: "");
    scanf(""%f"", &balance);
    accounts[*account_count].account_number = *account_count + 1000;
    strcpy(accounts[*account_count].name, name);
    accounts[*account_count].balance = balance;
    printf(""New account added successfully!\\n"");
    (*account_count)++;
}

// Function to display all the accounts in the record system
void display_accounts(struct account *accounts, int account_count) {
    printf(""Account Number\\tAccount Holder\\t\\tBalance\\n"");
    for (int i = 0; i < account_count; i++) {
        printf(""%d\\t\\t%s\\t\\t%.2f\\n"", accounts[i].account_number, accounts[i].name, accounts[i].balance);
    }
}

// Function to deposit money into an account
void deposit(struct account *accounts, int account_count) {
    int account_number;
    float amount;
    printf(""Enter account number: "");
    scanf(""%d"", &account_number);
    int account_index = -1;
    for (int i = 0; i < account_count; i++) {
        if (accounts[i].account_number == account_number) {
            account_index = i;
            break;
        }
    }
    if (account_index == -1) {
        printf(""Account not found!\\n"");
    } else {
        printf(""Enter amount to deposit: "");
        scanf(""%f"", &amount);
        accounts[account_index].balance += amount;
        printf(""Deposit successful! Updated balance: %.2f\\n"", accounts[account_index].balance);
    }
}

// Function to withdraw money from an account
void withdraw(struct account *accounts, int account_count) {
    int account_number;
    float amount;
    printf(""Enter account number: "");
    scanf(""%d"", &account_number);
    int account_index = -1;
    for (int i = 0; i < account_count; i++) {
        if (accounts[i].account_number == account_number) {
            account_index = i;
            break;
        }
    }
    if (account_index == -1) {
        printf(""Account not found!\\n"");
    } else {
        printf(""Enter amount to withdraw: "");
        scanf(""%f"", &amount);
        if (amount > accounts[account_index].balance) {
            printf(""Insufficient balance!\\n"");
        } else {
            accounts[account_index].balance -= amount;
            printf(""Withdrawal successful! Updated balance: %.2f\\n"", accounts[account_index].balance);
        }
    }
}

int main() {
    struct account accounts[100];
    int account_count = 0;
    int choice;
    while (1) {
        printf(""\\n*******************\\n"");
        printf(""1. Add account\\n"");
        printf(""2. Display all accounts\\n"");
        printf(""3. Deposit money\\n"");
        printf(""4. Withdraw money\\n"");
        printf(""5. Exit\\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                add_account(accounts, &account_count);
                break;
            case 2:
                display_accounts(accounts, account_count);
                break;
            case 3:
                deposit(accounts, account_count);
                break;
            case 4:
                withdraw(accounts, account_count);
                break;
            case 5:
                printf(""Exiting program...\\n"");
                exit(0);
            default:
                printf(""Invalid choice. Please try again.\\n"");
        }
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_account(_QWORD, _QWORD); // weak
__int64 __fastcall display_accounts(_QWORD, _QWORD); // weak
__int64 __fastcall deposit(_QWORD, _QWORD); // weak
__int64 __fastcall withdraw(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001ABE) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char v6[6000]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v5 = 0;
  while ( 1 )
  {
    printf(""\\n*******************\\n"");
    printf(""1. Add account\\n"");
    printf(""2. Display all accounts\\n"");
    printf(""3. Deposit money\\n"");
    printf(""4. Withdraw money\\n"");
    printf(""5. Exit\\n"");
    printf(""Enter your choice: "");
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        add_account(v6, &v5);
        break;
      case 2:
        display_accounts(v6, v5);
        break;
      case 3:
        deposit(v6, v5);
        break;
      case 4:
        withdraw(v6, v5);
        break;
      case 5:
        printf(""Exiting program...\\n"");
        exit(0);
      default:
        printf(""Invalid choice. Please try again.\\n"");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 __fastcall add_account(_QWORD, _QWORD);
// 1400016EC: using guessed type __int64 __fastcall display_accounts(_QWORD, _QWORD);
// 1400017BF: using guessed type __int64 __fastcall deposit(_QWORD, _QWORD);
// 14000191E: using guessed type __int64 __fastcall withdraw(_QWORD, _QWORD);
// 140001CB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum number of accounts
#define MAX_ACCOUNTS 100

// Define the maximum length of account number
#define MAX_ACCOUNT_LENGTH 10

// Define the maximum length of account holder name
#define MAX_NAME_LENGTH 50

// Define the maximum length of account balance
#define MAX_BALANCE_LENGTH 10

// Define the structure for an account
typedef struct {
    char account_number[MAX_ACCOUNT_LENGTH];
    char account_holder_name[MAX_NAME_LENGTH];
    float balance;
} Account;

// Function to add a new account
void add_account(Account accounts[], int *num_accounts) {
    // Check if the maximum number of accounts has been reached
    if (*num_accounts == MAX_ACCOUNTS) {
        printf(""Maximum number of accounts reached.
"");
        return;
    }

    // Get the account number
    printf(""Enter account number: "");
    scanf(""%s"", accounts[*num_accounts].account_number);

    // Get the account holder name
    printf(""Enter account holder name: "");
    scanf(""%s"", accounts[*num_accounts].account_holder_name);

    // Get the account balance
    printf(""Enter account balance: "");
    scanf(""%f"", &accounts[*num_accounts].balance);

    // Increment the number of accounts
    (*num_accounts)++;

    printf(""Account added successfully.
"");
}

// Function to display all accounts
void display_accounts(Account accounts[], int num_accounts) {
    // Check if there are any accounts
    if (num_accounts == 0) {
        printf(""No accounts found.
"");
        return;
    }

    // Display the account details for each account
    printf(""Account Number	Account Holder Name	Balance
"");
    for (int i = 0; i < num_accounts; i++) {
        printf(""%s		%s		%.2f
"", accounts[i].account_number, accounts[i].account_holder_name, accounts[i].balance);
    }
}

// Function to deposit money into an account
void deposit(Account accounts[], int num_accounts) {
    // Check if there are any accounts
    if (num_accounts == 0) {
        printf(""No accounts found.
"");
        return;
    }

    // Get the account number
    char account_number[MAX_ACCOUNT_LENGTH];
    printf(""Enter account number: "");
    scanf(""%s"", account_number);

    // Check if the account exists
    int found = 0;
    for (int i = 0; i < num_accounts; i++) {
        if (strcmp(accounts[i].account_number, account_number) == 0) {
            found = 1;
            break;
        }
    }

    // If the account does not exist, display an error message
    if (!found) {
        printf(""Account not found.
"");
        return;
    }

    // Get the amount to deposit
    float amount;
    printf(""Enter amount to deposit: "");
    scanf(""%f"", &amount);

    // Update the account balance
    accounts[i].balance += amount;

    printf(""Deposit successful.
"");
}

// Function to withdraw money from an account
void withdraw(Account accounts[], int num_accounts) {
    // Check if there are any accounts
    if (num_accounts == 0) {
        printf(""No accounts found.
"");
        return;
    }

    // Get the account number
    char account_number[MAX_ACCOUNT_",2
"//FormAI DATASET v1.0 Category: Arithmetic ; Style: portable
#include <stdio.h>

int main() {
    int x = 10;
    int y = 5;
    int z = 2;
    int result;

    // Addition
    result = x + y + z;
    printf(""%d + %d + %d = %d\\n"", x, y, z, result);

    // Subtraction
    result = x - y - z;
    printf(""%d - %d - %d = %d\\n"", x, y, z, result);

    // Multiplication
    result = x * y * z;
    printf(""%d * %d * %d = %d\\n"", x, y, z, result);

    // Division
    result = x / y;
    printf(""%d / %d = %d\\n"", x, y, result);

    // Modulus
    result = x % z;
    printf(""%d %% %d = %d\\n"", x, z, result);

    // Increment
    result = ++x;
    printf(""++%d = %d\\n"", x, result);

    // Decrement
    result = --y;
    printf(""--%d = %d\\n"", y, result);

    // Bitwise AND
    result = x & y;
    printf(""%d & %d = %d\\n"", x, y, result);

    // Bitwise OR
    result = x | y;
    printf(""%d | %d = %d\\n"", x, y, result);

    // Bitwise XOR
    result = x ^ y;
    printf(""%d ^ %d = %d\\n"", x, y, result);

    // Bitwise NOT
    result = ~x;
    printf(""~%d = %d\\n"", x, result);

    // Left shift
    result = x << 1;
    printf(""%d << 1 = %d\\n"", x, result);

    // Right shift
    result = y >> 1;
    printf(""%d >> 1 = %d\\n"", y, result);

    // Logical AND
    result = (x > y) && (y > z);
    printf(""(%d > %d) && (%d > %d) = %d\\n"", x, y, y, z, result);

    // Logical OR
    result = (x > y) || (y < z);
    printf(""(%d > %d) || (%d < %d) = %d\\n"", x, y, y, z, result);

    // Conditional operator
    result = (x > y) ? x : y;
    printf(""(%d > %d) ? %d : %d = %d\\n"", x, y, x, y, result);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-20h]
  __int64 v5; // [rsp+20h] [rbp-20h]
  __int64 v6; // [rsp+20h] [rbp-20h]
  __int64 v7; // [rsp+20h] [rbp-20h]
  __int64 v8; // [rsp+20h] [rbp-20h]
  __int64 v9; // [rsp+28h] [rbp-18h]
  __int64 v10; // [rsp+28h] [rbp-18h]

  _main(argc, argv, envp);
  printf(""%d + %d + %d = %d\\n"", 10i64, 5i64, 2i64, 17);
  LODWORD(v4) = 3;
  printf(""%d - %d - %d = %d\\n"", 10i64, 5i64, 2i64, v4);
  LODWORD(v5) = 100;
  printf(""%d * %d * %d = %d\\n"", 10i64, 5i64, 2i64, v5);
  printf(""%d / %d = %d\\n"", 10i64, 5i64, 2i64);
  printf(""%d %% %d = %d\\n"", 10i64, 2i64, 0i64);
  printf(""++%d = %d\\n"", 11i64, 11i64);
  printf(""--%d = %d\\n"", 4i64, 4i64);
  printf(""%d & %d = %d\\n"", 11i64, 4i64, 0i64);
  printf(""%d | %d = %d\\n"", 11i64, 4i64, 15i64);
  printf(""%d ^ %d = %d\\n"", 11i64, 4i64, 15i64);
  printf(""~%d = %d\\n"", 11i64, 4294967284i64);
  printf(""%d << 1 = %d\\n"", 11i64, 22i64);
  printf(""%d >> 1 = %d\\n"", 4i64, 2i64);
  LODWORD(v6) = 2;
  printf(""(%d > %d) && (%d > %d) = %d\\n"", 11i64, 4i64, 4i64, v6, 1);
  LODWORD(v9) = 1;
  LODWORD(v7) = 2;
  printf(""(%d > %d) || (%d < %d) = %d\\n"", 11i64, 4i64, 4i64, v7, v9);
  LODWORD(v10) = 11;
  LODWORD(v8) = 4;
  printf(""(%d > %d) ? %d : %d = %d\\n"", 11i64, 4i64, 11i64, v8, v10);
  return 0;
}
// 14000161A: variable 'v4' is possibly undefined
// 140001652: variable 'v5' is possibly undefined
// 14000181D: variable 'v6' is possibly undefined
// 14000186B: variable 'v7' is possibly undefined
// 14000186B: variable 'v9' is possibly undefined
// 1400018A8: variable 'v8' is possibly undefined
// 1400018A8: variable 'v10' is possibly undefined
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
int main() {
    int a = 10, b = 5, c = 2;
    
    // Addition
    printf(""%d + %d + %d = %d
"", a, b, c, a+b+c);
    
    // Subtraction
    printf(""%d - %d - %d = %d
"", a, b, c, a-b-c);
    
    // Multiplication
    printf(""%d * %d * %d = %d
"", a, b, c, a*b*c);
    
    // Division
    printf(""%d / %d = %d
"", a, b, a/b);
    
    // Modulus
    printf(""%d %% %d = %d
"", a, c, a%c);
    
    // Increment and Decrement
    printf(""++%d = %d
"", a, ++a);
    printf(""--%d = %d
"", b, --b);
    
    // Bitwise AND
    printf(""%d & %d = %d
"", a, b, a&b);
    
    // Bitwise OR
    printf(""%d | %d = %d
"", a, b, a|b);
    
    // Bitwise XOR
    printf(""%d ^ %d = %d
"", a, b, a^b);
    
    // Bitwise NOT
    printf(""~%d = %d
"", a, ~a);
    
    // Left Shift
    printf(""%d << 1 = %d
"", a, a<<1);
    
    // Right Shift
    printf(""%d >> 1 = %d
"", b, b>>1);
    
    // Logical AND
    printf(""(%d > %d) && (%d > %d) = %d
"", a, b, a, c, a>b && c>b);
    
    // Logical OR
    printf(""(%d > %d) || (%d < %d) = %d
"", a, b, a, c, a>b || a<c);
    
    // Ternary Operator
    printf(""(%d > %d) ? %d : %d = %d
"", a, b, a, b, a>b ? a : b);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Function to sanitize user input
char* sanitize_input(char* input) {
    int length = strlen(input);
    char* sanitized_input = (char*) malloc((length+1) * sizeof(char));
    int i, j;
    for(i = 0, j = 0; i < length; i++) {
        if(isalpha(input[i]) || isdigit(input[i])) { // check if the character is alphanumeric
            sanitized_input[j++] = input[i]; // add it to the sanitized input string
        }
    }
    sanitized_input[j] = '\\0'; // add null character to end of string
    return sanitized_input; // return the sanitized input string
}

int main() {
    char input[100];
    printf(""Enter your input: "");
    fgets(input, 100, stdin);
    char* sanitized_input = sanitize_input(input);
    printf(""Sanitized input: %s\\n"", sanitized_input);
    free(sanitized_input);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sanitize_input(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001656) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  void *Block; // [rsp+88h] [rbp-8h]

  _main(argc, argv, envp);
  printf(""Enter your input: "");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Block = (void *)sanitize_input(Buffer);
  printf(""Sanitized input: %s\\n"", (const char *)Block);
  free(Block);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall sanitize_input(_QWORD);
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to sanitize user input
char* sanitize_input(char* input) {
    int len = strlen(input);
    char* sanitized_input = (char*) malloc(len + 1);
    int i, j;
    for (i = 0, j = 0; i < len; i++) {
        if (input[i] == '
') {
            sanitized_input[j++] = '",2
"//FormAI DATASET v1.0 Category: String manipulation ; Style: satisfied
#include <stdio.h>
#include <string.h>

int main() {
   char str1[50], str2[50], temp[50];
   int i, j, len1, len2, flag = 0;

   printf(""Enter first string: "");
   scanf(""%s"", str1);

   printf(""Enter second string: "");
   scanf(""%s"", str2);

   len1 = strlen(str1);
   len2 = strlen(str2);

   for (i = 0; i < len1; i++) {
      for (j = i; j < len2; j++) {
         if (str1[i] == str2[j]) {
            flag = 1;
            break;
         }
      }
   }

   if (flag == 1) {
      printf(""After swapping the first half of the string 1 with second half of string 2, the string becomes: "");
      strncpy(temp, str1, len1/2);
      strncpy(str1, &str2[len2/2], len2 - len2/2);
      strncpy(&str1[len2 - len2/2], temp, len1/2);
      printf(""%s"", str1);
   }

   else {
      printf(""Strings are not compatible for swapping!"");
   }

   return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Destination[64]; // [rsp+20h] [rbp-D0h] BYREF
  char v5[64]; // [rsp+60h] [rbp-90h] BYREF
  char Str[60]; // [rsp+A0h] [rbp-50h] BYREF
  int v7; // [rsp+DCh] [rbp-14h]
  int v8; // [rsp+E0h] [rbp-10h]
  int v9; // [rsp+E4h] [rbp-Ch]
  int j; // [rsp+E8h] [rbp-8h]
  int i; // [rsp+ECh] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  printf(""Enter first string: "");
  scanf(""%s"", Str);
  printf(""Enter second string: "");
  scanf(""%s"", v5);
  v8 = strlen(Str);
  v7 = strlen(v5);
  for ( i = 0; i < v8; ++i )
  {
    for ( j = i; j < v7; ++j )
    {
      if ( Str[i] == v5[j] )
      {
        v9 = 1;
        break;
      }
    }
  }
  if ( v9 == 1 )
  {
    printf(""After swapping the first half of the string 1 with second half of string 2, the string becomes: "");
    strncpy(Destination, Str, v8 / 2);
    strncpy(Str, &v5[v7 / 2], v7 / -2 + v7);
    strncpy(&Str[v7 / -2 + v7], Destination, v8 / 2);
    printf(""%s"", Str);
  }
  else
  {
    printf(""Strings are not compatible for swapping!"");
  }
  return 0;
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[60];
// 1400015E2: using guessed type char var_90[64];

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <string.h>

int main() {
    char str1[50], str2[50], temp[50];
    int len1, len2, i, j, flag = 0;

    printf(""Enter first string: "");
    scanf(""%s"", str1);

    printf(""Enter second string: "");
    scanf(""%s"", str2);

    len1 = strlen(str1);
    len2 = strlen(str2);

    for (i = 0; i < len1; i++) {
        for (j = i; j < len2; j++) {
            if (str1[i] == str2[j]) {
                flag = 1;
                break;
            }
        }
    }

    if (flag == 1) {
        printf(""After swapping the first half of the string 1 with second half of string 2, the string becomes: "");

        // Copying the first half of string 1 to temp
        strncpy(temp, str1, len1 / 2);

        // Copying the second half of string 2 to str1
        strncpy(str1, str2 + len2 / 2, len2 / 2);

        // Copying the first half of string 2 to the second half of str1
        strncpy(str1 + len2 / 2, temp, len1 / 2);

        printf(""%s"", str1);
    } else {
        printf(""Strings are not compatible for swapping!"");
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Computer Biology ; Style: cheerful
#include <stdio.h>

int main() {
  int dna[100];
  int i, j;
  
  // Populate the DNA array randomly with 0's and 1's
  srand(time(NULL));
  for (i = 0; i < 100; i++) {
    dna[i] = rand() % 2;
  }
  
  // Print out the DNA sequence
  printf(""The DNA sequence is: "");
  for (i = 0; i < 100; i++) {
    printf(""%d"", dna[i]);
  }
  
  // Check for mutations
  int num_mutations = 0;
  for (i = 1; i < 100; i++) {
    if (dna[i] != dna[i-1]) {
      num_mutations++;
    }
  }
  
  // Print out the number of mutations
  if (num_mutations == 0) {
    printf(""\\nThere are no mutations in this DNA sequence! :D\\n"");
  } else {
    printf(""\\nThere are %d mutations in this DNA sequence! :( \\n"", num_mutations);
  }
  
  // Display a cheerful message
  printf(""\\nThanks for checking out this DNA sequence! Have a great day! :)\\n"");
  
  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// static time_t __cdecl time(time_t *const Time);
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[102]; // [rsp+20h] [rbp-60h]
  unsigned int v6; // [rsp+1B8h] [rbp+138h]
  int i; // [rsp+1BCh] [rbp+13Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 99; ++i )
    v5[i] = rand() % 2;
  printf(""The DNA sequence is: "");
  for ( i = 0; i <= 99; ++i )
    printf(""%d"", (unsigned int)v5[i]);
  v6 = 0;
  for ( i = 1; i <= 99; ++i )
  {
    if ( v5[i] != v5[i - 1] )
      ++v6;
  }
  if ( v6 )
    printf(""\\nThere are %d mutations in this DNA sequence! :( \\n"", v6);
  else
    printf(""\\nThere are no mutations in this DNA sequence! :D\\n"");
  printf(""\\nThanks for checking out this DNA sequence! Have a great day! :)\\n"");
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type int var_1A0[102];

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

int main() {
    int i, j, n = 100, mutations = 0;
    int dna[n];
    srand(time(NULL)); // seed the random number generator

    // Generate a random DNA sequence
    for (i = 0; i < n; i++) {
        dna[i] = rand() % 2; // generate a random 0 or 1
    }

    // Print the DNA sequence
    printf(""The DNA sequence is: "");
    for (i = 0; i < n; i++) {
        printf(""%d"", dna[i]);
    }

    // Count the number of mutations
    for (i = 1; i < n; i++) {
        if (dna[i] != dna[i-1]) {
            mutations++;
        }
    }

    // Print the number of mutations
    if (mutations == 0) {
        printf(""
There are no mutations in this DNA sequence! :D
"");
    } else {
        printf(""
There are %d mutations in this DNA sequence! :( 
"", mutations);
    }

    printf(""
Thanks for checking out this DNA sequence! Have a great day! :)
"");

    return 0;
}",2
"//FormAI DATASET v1.0 Category: System event logger ; Style: real-life
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void log_event(char* event) {
    time_t current_time;
    char* time_string;

    current_time = time(NULL);
    time_string = ctime(&current_time);

    // Remove trailing newline character from time string
    time_string[strlen(time_string) - 1] = '\\0';

    // Open log file in append mode
    FILE* log_file = fopen(""event.log"", ""a"");

    // Print the current time and event to the log file
    fprintf(log_file, ""%s - %s\\n"", time_string, event);

    // Close the log file
    fclose(log_file);
}

int main() {
    // Log some example events
    log_event(""System started"");
    log_event(""User logged in"");
    log_event(""System shutdown initiated"");

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall log_event(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001653) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  log_event(""System started"");
  log_event(""User logged in"");
  log_event(""System shutdown initiated"");
  return 0;
}
// 1400015C1: using guessed type __int64 __fastcall log_event(_QWORD);
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void log_event(char* event) {
    time_t now = time(NULL);
    struct tm* tm_now = localtime(&now);
    char timestamp[20];
    strftime(timestamp, 20, ""%Y-%m-%d %H:%M:%S"", tm_now);
    printf(""%s - %s
"", timestamp, event);
}

int main() {
    log_event(""System started"");
    log_event(""User logged in"");
    log_event(""System shutdown initiated"");
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Sorting ; Style: optimized
#include <stdio.h>

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void quickSort(int arr[], int low, int high) {
    if(low < high) {
        int pivot = arr[high];
        int i = low - 1;
        for(int j = low; j < high; j++) {
            if(arr[j] < pivot) {
                i++;
                swap(&arr[i], &arr[j]);
            }
        }
        swap(&arr[i+1], &arr[high]);
        int pi = i + 1;
        quickSort(arr, low, pi-1);
        quickSort(arr, pi+1, high);
    }
}

int main() {
    int arr[] = {5, 2, 7, 1, 8, 3, 6, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    quickSort(arr, 0, n-1);
    printf(""Sorted Array: "");
    for(int i = 0; i < n; i++) {
        printf(""%d "", arr[i]);
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall quickSort(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016DC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[10]; // [rsp+20h] [rbp-30h] BYREF
  int v5; // [rsp+48h] [rbp-8h]
  int i; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v4[0] = 5;
  v4[1] = 2;
  v4[2] = 7;
  v4[3] = 1;
  v4[4] = 8;
  v4[5] = 3;
  v4[6] = 6;
  v4[7] = 4;
  v5 = 8;
  quickSort(v4, 0i64, 7i64);
  printf(""Sorted Array: "");
  for ( i = 0; i < v5; ++i )
    printf(""%d "", (unsigned int)v4[i]);
  return 0;
}
// 1400015C6: using guessed type __int64 __fastcall quickSort(_QWORD, _QWORD, _QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pivot = low;
        int i = low + 1;
        int j = high;
        while (i <= j) {
            if (arr[i] < arr[pivot]) {
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                i++;
            } else {
                j--;
            }
        }
        int temp = arr[pivot];
        arr[pivot] = arr[j];
        arr[j] = temp;
        quickSort(arr, low, j - 1);
        quickSort(arr, j + 1, high);
    }
}

int main() {
    int arr[] = {5, 2, 7, 1, 8, 3, 6, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    quickSort(arr, 0, n - 1);
    printf(""Sorted Array: "");
    for (int i = 0; i < n; i++) {
        printf(""%d "", arr[i]);
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: System process viewer ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <ctype.h>
#include <time.h>
#include <stdbool.h>

#define MAX_NAME_LEN 256
#define STATE_LEN 1
#define CMDLINE_LEN 256

typedef struct Process {
    char name[MAX_NAME_LEN];
    char state[STATE_LEN];
    char cmdline[CMDLINE_LEN];
    time_t start_time;
} Process;

void format_time(time_t secs, char *buf, size_t len) {
    strftime(buf, len, ""%Y-%m-%d %H:%M:%S"", localtime(&secs));
}

void print_process(Process *process) {
    char start_time[20];
    format_time(process->start_time, start_time, sizeof(start_time));
    printf(""%-20s%-10s%-20s%s\\n"", process->name, process->state, start_time, process->cmdline);
}

int main() {
    DIR *dir;
    struct dirent *entry;
    Process process;
    FILE *fp;
    char path[MAX_NAME_LEN];
    char line[CMDLINE_LEN];
    char name[MAX_NAME_LEN];
    int pid;
    bool reading_cmdline = false;

    printf(""\\n******** Welcome to the Surrealist Process Viewer ********\\n\\n"");
    printf(""We can only show you what we think the processes look like.\\n"");
    printf(""Ready to see some magic?\\n\\n"");

    dir = opendir(""/proc"");
    if (dir == NULL) {
        perror(""Error opening /proc"");
        exit(1);
    }

    printf(""%-20s%-10s%-20s%s\\n"", ""Name"", ""State"", ""Start Time"", ""Command Line"");

    while ((entry = readdir(dir)) != NULL) {
        if (!isdigit(*entry->d_name)) {
            continue;
        }
        pid = atoi(entry->d_name);

        snprintf(path, sizeof(path), ""/proc/%d/status"", pid);
        fp = fopen(path, ""r"");
        if (fp == NULL) {
            continue;
        }
        while (fgets(line, sizeof(line), fp)) {
            if (strncmp(line, ""Name:"", 5) == 0) {
                sscanf(line + 5, ""%[^ ]"", name);
                strncpy(process.name, name, MAX_NAME_LEN);
            } else if (strncmp(line, ""State:"", 6) == 0) {
                sscanf(line + 6, ""%s"", process.state);
            } else if (strncmp(line, ""Start Time:"", 11) == 0) {
                int sec;
                sscanf(line + 11, "" %d"", &sec);
                process.start_time = time(NULL) - sec;
            } else if (strncmp(line, ""Cmdline:"", 8) == 0) {
                reading_cmdline = true;
                break;
            }
        }
        fclose(fp);

        if (!reading_cmdline) {
            continue;
        }

        snprintf(path, sizeof(path), ""/proc/%d/cmdline"", pid);
        fp = fopen(path, ""r"");
        if (fp == NULL) {
            continue;
        }
        fgets(line, sizeof(line), fp);

        // Replace null bytes with space for better visualization
        for (int i = 0; i < strlen(line); i++) {
            if (line[i] == '\\0') {
                line[i] = ' ';
            }
        }
        strncpy(process.cmdline, line, CMDLINE_LEN);
        fclose(fp);

        print_process(&process);

        // Prepare for next process
        memset(&process, 0, sizeof(Process));
        reading_cmdline = false;
    }

    closedir(dir);
    printf(""\\nThat's all for now, hope you enjoyed the show!\\n"");
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sscanf(const char *const Buffer, const char *const Format, ...);
int printf(const char *const Format, ...);
int snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall print_process(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall opendir(char *Path); // idb
__int64 __fastcall readdir(_QWORD); // weak
__int64 __fastcall closedir(void *Block); // idb
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// size_t __cdecl strlen(const char *Str);
// void __cdecl perror(const char *ErrMsg);
// void *__cdecl memset(void *, int Val, size_t Size);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// int __cdecl atoi(const char *String);


//----- (0000000140001705) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+3Ch] [rbp-44h] BYREF
  char Source[256]; // [rsp+40h] [rbp-40h] BYREF
  char Str1[5]; // [rsp+140h] [rbp+C0h] BYREF
  char v7; // [rsp+145h] [rbp+C5h] BYREF
  char v8[5]; // [rsp+146h] [rbp+C6h] BYREF
  char v9[245]; // [rsp+14Bh] [rbp+CBh] BYREF
  char Buffer[256]; // [rsp+240h] [rbp+1C0h] BYREF
  char Destination[536]; // [rsp+340h] [rbp+2C0h] BYREF
  FILE *Stream; // [rsp+558h] [rbp+4D8h]
  unsigned int v13; // [rsp+564h] [rbp+4E4h]
  __int64 v14; // [rsp+568h] [rbp+4E8h]
  void *Block; // [rsp+570h] [rbp+4F0h]
  int i; // [rsp+578h] [rbp+4F8h]
  char v17; // [rsp+57Fh] [rbp+4FFh]

  _main(argc, argv, envp);
  v17 = 0;
  printf(""\\n******** Welcome to the Surrealist Process Viewer ********\\n\\n"");
  printf(""We can only show you what we think the processes look like.\\n"");
  printf(""Ready to see some magic?\\n\\n"");
  Block = (void *)opendir(""/proc"");
  if ( !Block )
  {
    perror(""Error opening /proc"");
    exit(1);
  }
  printf(""%-20s%-10s%-20s%s\\n"", ""Name"", ""State"", ""Start Time"", ""Command Line"");
  while ( 1 )
  {
    v14 = readdir(Block);
    if ( !v14 )
      break;
    if ( (unsigned int)(*(char *)(v14 + 8) - 48) <= 9 )
    {
      v13 = atoi((const char *)(v14 + 8));
      snprintf(Buffer, 0x100ui64, ""/proc/%d/status"", v13);
      Stream = fopen(Buffer, ""r"");
      if ( Stream )
      {
        while ( fgets(Str1, 256, Stream) )
        {
          if ( !strncmp(Str1, ""Name:"", 5ui64) )
          {
            sscanf(&v7, ""%[^ ]"", Source);
            strncpy(Destination, Source, 0x100ui64);
          }
          else if ( !strncmp(Str1, ""State:"", 6ui64) )
          {
            sscanf(v8, ""%s"", &Destination[256]);
          }
          else if ( !strncmp(Str1, ""Start Time:"", 0xBui64) )
          {
            sscanf(v9, "" %d"", &v4);
            *(_QWORD *)&Destination[520] = time(0i64) - v4;
          }
          else if ( !strncmp(Str1, ""Cmdline:"", 8ui64) )
          {
            v17 = 1;
            break;
          }
        }
        fclose(Stream);
        if ( v17 == 1 )
        {
          snprintf(Buffer, 0x100ui64, ""/proc/%d/cmdline"", v13);
          Stream = fopen(Buffer, ""r"");
          if ( Stream )
          {
            fgets(Str1, 256, Stream);
            for ( i = 0; i < strlen(Str1); ++i )
            {
              if ( !Str1[i] )
                Str1[i] = 32;
            }
            strncpy(&Destination[257], Str1, 0x100ui64);
            fclose(Stream);
            print_process(Destination);
            memset(Destination, 0, 0x210ui64);
            v17 = 0;
          }
        }
      }
    }
  }
  closedir(Block);
  printf(""\\nThat's all for now, hope you enjoyed the show!\\n"");
  return 0;
}
// 14000169D: using guessed type __int64 __fastcall print_process(_QWORD);
// 140001BF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140002E50: using guessed type __int64 __fastcall readdir(_QWORD);
// 140001705: using guessed type char Str1[5];
// 140001705: using guessed type char Source[256];
// 140001705: using guessed type char anonymous_1[5];
// 140001705: using guessed type char anonymous_2[245];

// nfuncs=203 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <ctype.h>
#include <time.h>

#define MAX_PROCESS_NAME_LENGTH 256
#define MAX_PROCESS_STATE_LENGTH 256
#define MAX_PROCESS_START_TIME_LENGTH 256
#define MAX_PROCESS_COMMAND_LENGTH 256

typedef struct {
    char name[MAX_PROCESS_NAME_LENGTH];
    char state[MAX_PROCESS_STATE_LENGTH];
    char start_time[MAX_PROCESS_START_TIME_LENGTH];
    char command[MAX_PROCESS_COMMAND_LENGTH];
} Process;

void print_process(Process process) {
    printf(""%-20s%-10s%-20s%s
"", process.name, process.state, process.start_time, process.command);
}

int main() {
    DIR *dir;
    struct dirent *entry;
    Process process;
    char buffer[MAX_PROCESS_NAME_LENGTH];
    char status_file[MAX_PROCESS_NAME_LENGTH];
    char command_file[MAX_PROCESS_NAME_LENGTH];
    FILE *status_file_ptr;
    FILE *command_file_ptr;
    char line[MAX_PROCESS_COMMAND_LENGTH];
    char *token;
    int pid;
    int i;
    int has_command = 0;

    printf(""
******** Welcome to the Surrealist Process Viewer ********

"");
    printf(""We can only show you what we think the processes look like.
"");
    printf(""Ready to see some magic?

"");

    dir = opendir(""/proc"");
    if (dir == NULL) {
        perror(""Error opening /proc"");
        exit(EXIT_FAILURE);
    }

    printf(""%-20s%-10s%-20s%s
"", ""Name"", ""State"", ""Start Time"", ""Command Line"");

    while ((entry = readdir(dir)) != NULL) {
        if (isdigit(entry->d_name[0])) {
            pid = atoi(entry->d_name);
            snprintf(status_file, MAX_PROCESS_NAME_LENGTH, ""/proc/%d/status"", pid);
            status_file_ptr = fopen(status_file, ""r"");
            if (status_file_ptr == NULL) {
                continue;
            }

            while (fgets(line, MAX_PROCESS_COMMAND_LENGTH, status_file_ptr) != NULL) {
                if (strncmp(line, ""Name:"", 5) == 0) {
                    sscanf(line + 5, ""%[^ ]"", buffer);
                    strncpy(process.name, buffer, MAX_PROCESS_NAME_LENGTH);
                } else if (strncmp(line, ""State:"", 6) == 0) {
                    sscanf(line + 6, ""%s"", process.state);
                } else if (strncmp(line, ""Start Time:"", 11) == 0) {
                    sscanf(line + 11, "" %d"", &i);
                    process.start_time[0] = '",2
"//FormAI DATASET v1.0 Category: HTML beautifier ; Style: retro
#include <stdio.h>

int main(void) {
    char code[5000];
    printf(""Enter the HTML code to beautify:\\n"");
    scanf(""%[^\\n]"", code);

    int tab_count = 0;
    int i = 0;

    while (code[i]) {
        if (code[i] == '<') {
            if (code[i+1] == '/') {
                tab_count--;
            }
            for (int j = 0; j < tab_count; j++) {
                printf(""\\t"");
            }
            printf(""%c"", code[i]);
            if (code[i+1] != '/') {
                tab_count++;
            }
        }
        else if (code[i] == '>') {
            printf(""%c\\n"", code[i]);
        }
        else {
            printf(""%c"", code[i]);
        }
        i++;
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[5012]; // [rsp+20h] [rbp-60h] BYREF
  int j; // [rsp+13B4h] [rbp+1334h]
  int i; // [rsp+13B8h] [rbp+1338h]
  int v7; // [rsp+13BCh] [rbp+133Ch]

  _main(argc, argv, envp);
  printf(""Enter the HTML code to beautify:\\n"");
  scanf(""%[^\\n]"", v4);
  v7 = 0;
  for ( i = 0; v4[i]; ++i )
  {
    if ( v4[i] == 60 )
    {
      if ( v4[i + 1] == 47 )
        --v7;
      for ( j = 0; j < v7; ++j )
        printf(""\\t"");
      printf(""%c"", (unsigned int)v4[i]);
      if ( v4[i + 1] != 47 )
        ++v7;
    }
    else if ( v4[i] == 62 )
    {
      printf(""%c\\n"", (unsigned int)v4[i]);
    }
    else
    {
      printf(""%c"", (unsigned int)v4[i]);
    }
  }
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_13A0[5012];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
"," C Beautifier v1.0 by [Chatbot](https://github.com/ChatbotIO/C-Beautifier)
// Chatbot is a free and open-source beautifier for C code.
// It can beautify your code by indenting it properly.
// It can also beautify your code by removing unnecessary spaces and tabs.
// It can beautify your code by removing comments.
// It can beautify your code by removing empty lines.
// It can beautify your code by removing unused variables.
// It can beautify your code by removing unused functions.
// It can beautify your code by removing unused includes.
// It can beautify your code by removing unused structs.
// It can beautify your code by removing unused enums.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedefs.
// It can beautify your code by removing unused typedef",0
"//FormAI DATASET v1.0 Category: QR code reader ; Style: shape shifting
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_CODE_SIZE 100

// A shape shifting QR code reader example program

int main()
{
    char qr_code[MAX_CODE_SIZE];
    int code_size = 0;
    bool is_round = false;
    bool is_square = false;
    bool is_triangle = false;

    // Read QR code
    printf(""Enter QR code: "");
    scanf(""%s"", qr_code);

    // Determine code type and size
    for (int i = 0; qr_code[i] != '\\0'; i++) {
        code_size++;
        if (qr_code[i] == 'o') {
            is_round = true;
        } else if (qr_code[i] == 's') {
            is_square = true;
        } else if (qr_code[i] == 't') {
            is_triangle = true;
        }
    }

    // Shape shift the QR code
    if (is_round) {
        printf(""Shape shifted QR code: circle\\n"");
    } else if (is_square) {
        printf(""Shape shifted QR code: square\\n"");
    } else if (is_triangle) {
        printf(""Shape shifted QR code: triangle\\n"");
    } else {
        printf(""Unknown QR code type.\\n"");
    }

    // Print QR code info
    printf(""QR code size: %d\\n"", code_size);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[100]; // [rsp+20h] [rbp-70h] BYREF
  int i; // [rsp+84h] [rbp-Ch]
  char v6; // [rsp+89h] [rbp-7h]
  char v7; // [rsp+8Ah] [rbp-6h]
  char v8; // [rsp+8Bh] [rbp-5h]
  unsigned int v9; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  printf(""Enter QR code: "");
  scanf(""%s"", v4);
  for ( i = 0; v4[i]; ++i )
  {
    ++v9;
    switch ( v4[i] )
    {
      case 'o':
        v8 = 1;
        break;
      case 's':
        v7 = 1;
        break;
      case 't':
        v6 = 1;
        break;
    }
  }
  if ( v8 )
  {
    printf(""Shape shifted QR code: circle\\n"");
  }
  else if ( v7 )
  {
    printf(""Shape shifted QR code: square\\n"");
  }
  else if ( v6 )
  {
    printf(""Shape shifted QR code: triangle\\n"");
  }
  else
  {
    printf(""Unknown QR code type.\\n"");
  }
  printf(""QR code size: %d\\n"", v9);
  return 0;
}
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_70[100];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
int main() {
    char qrCode[100];
    int size = 0;
    int circle = 0;
    int square = 0;
    int triangle = 0;

    printf(""Enter QR code: "");
    scanf(""%s"", qrCode);

    for (int i = 0; qrCode[i] != '",1
"//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: complete
#include <stdio.h>

int fibonacci(int n);

int main() {
    int n, i, result;
    
    printf(""Welcome to the Fibonacci sequence visualizer!\\n"");
    printf(""How many numbers of the Fibonacci sequence would you like to visualize?\\n"");
    scanf(""%d"", &n);

    for(i = 1; i <= n; i++) {
        result = fibonacci(i);
        printf(""%d "", result);
    }
    
    printf(""\\n"");
    return 0;
}

int fibonacci(int n) {
    if(n == 1 || n == 2) {
        return 1;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall fibonacci(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  unsigned int v5; // [rsp+28h] [rbp-8h]
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Welcome to the Fibonacci sequence visualizer!\\n"");
  printf(""How many numbers of the Fibonacci sequence would you like to visualize?\\n"");
  scanf(""%d"", &v4);
  for ( i = 1; (int)i <= v4; ++i )
  {
    v5 = fibonacci(i);
    printf(""%d "", v5);
  }
  printf(""\\n"");
  return 0;
}
// 140001673: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int fibonacci(int n);

int main() {
    int n, i;
    printf(""Welcome to the Fibonacci sequence visualizer!
"");
    printf(""How many numbers of the Fibonacci sequence would you like to visualize?
"");
    scanf(""%d"", &n);
    for (i = 1; i <= n; i++) {
        int fib = fibonacci(i);
        printf(""%d "", fib);
    }
    printf(""
"");
    return 0;
}

int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
}",2
"//FormAI DATASET v1.0 Category: Color Code Converter ; Style: peaceful
#include <stdio.h>

int main() {
  char hex[10], character;
  int num, red, green, blue;

  printf(""Enter a hex code: "");
  scanf(""%s"", hex);

  num = (int)strtol(hex, NULL, 16); // converts hex to decimal

  red = (num >> 16) & 0xFF; // bitwise operation to extract red value
  green = (num >> 8) & 0xFF; // bitwise operation to extract green value
  blue = num & 0xFF; // bitwise operation to extract blue value

  printf(""\\nRGB color: (%d, %d, %d)"", red, green, blue);

  printf(""\\n\\nEnter an RGB color (r,g,b): "");
  scanf(""%d,%d,%d"", &red, &green, &blue);

  printf(""\\nHex code: #%02x%02x%02x"", red, green, blue); 
    // %02x formats hex values with leading zeros if needed
  
  printf(""\\n\\nEnter a character: "");
  fflush(stdin); // flushes stdin buffer to prevent issue with scanf
  
  scanf(""%c"", &character);

  printf(""\\nASCII code for %c is %d"", character, character);

  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strtol(const char *String, char **EndPtr, int Radix);
// int __cdecl fflush(FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+24h] [rbp-1Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-18h] BYREF
  int v7; // [rsp+2Ch] [rbp-14h] BYREF
  char v8; // [rsp+31h] [rbp-Fh] BYREF
  char String[10]; // [rsp+32h] [rbp-Eh] BYREF
  int v10; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Enter a hex code: "");
  scanf(""%s"", String);
  v10 = strtol(String, 0i64, 16);
  v7 = BYTE2(v10);
  v6 = BYTE1(v10);
  v5 = (unsigned __int8)v10;
  printf(""\\nRGB color: (%d, %d, %d)"", BYTE2(v10), BYTE1(v10), (unsigned __int8)v10);
  printf(""\\n\\nEnter an RGB color (r,g,b): "");
  scanf(""%d,%d,%d"", &v7, &v6, &v5);
  printf(""\\nHex code: #%02x%02x%02x"", (unsigned int)v7, v6, v5);
  printf(""\\n\\nEnter a character: "");
  v3 = __acrt_iob_func(0);
  fflush(v3);
  scanf(""%c"", &v8);
  printf(""\\nASCII code for %c is %d"", (unsigned int)v8, (unsigned int)v8);
  return 0;
}
// 1400017E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type unsigned int var_14;

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

int main() {
    char hex[10];
    int r, g, b;
    char c;

    printf(""Enter a hex code: "");
    scanf(""%s"", hex);

    int hex_int = strtol(hex, NULL, 16);

    r = (hex_int >> 16) & 0xFF;
    g = (hex_int >> 8) & 0xFF;
    b = hex_int & 0xFF;

    printf(""
RGB color: (%d, %d, %d)"", r, g, b);

    printf(""

Enter an RGB color (r,g,b): "");
    scanf(""%d,%d,%d"", &r, &g, &b);

    printf(""
Hex code: #%02x%02x%02x"", r, g, b);

    printf(""

Enter a character: "");
    fflush(stdin);
    scanf(""%c"", &c);

    printf(""
ASCII code for %c is %d"", c, c);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROAD_LENGTH 20 // length of the road in units
#define TRAFFIC_DENSITY 0.2 // traffic density as a fraction

typedef enum {
    EMPTY,
    CAR
} RoadCell;

int main() {
    // seed random number generator for placing cars
    srand(time(NULL));

    // initialize road
    RoadCell road[ROAD_LENGTH];
    int i;
    for (i = 0; i < ROAD_LENGTH; i++) {
        road[i] = EMPTY;
    }

    // calculate number of cars to place on road based on traffic density
    int num_cars = (int)(TRAFFIC_DENSITY * ROAD_LENGTH);

    // randomly place cars on road
    for (i = 0; i < num_cars; i++) {
        int pos = rand() % ROAD_LENGTH;
        while (road[pos] == CAR) {
            pos = rand() % ROAD_LENGTH;
        }
        road[pos] = CAR;
    }

    // print initial state of road
    printf(""Initial state of road:\\n"");
    for (i = 0; i < ROAD_LENGTH; i++) {
        printf(""%c"", road[i] == EMPTY ? '.' : 'X');
    }
    printf(""\\n"");

    // simulate traffic flow
    int time_step;
    for (time_step = 0; time_step < 10; time_step++) {
        // initialize new road with all cells empty
        RoadCell new_road[ROAD_LENGTH];
        for (i = 0; i < ROAD_LENGTH; i++) {
            new_road[i] = EMPTY;
        }

        // move cars forward
        for (i = 0; i < ROAD_LENGTH; i++) {
            if (road[i] == CAR) {
                if (i == ROAD_LENGTH - 1 || road[i+1] == CAR) {
                    new_road[i] = CAR;
                } else {
                    new_road[i+1] = CAR;
                }
            }
        }

        // update road
        for (i = 0; i < ROAD_LENGTH; i++) {
            road[i] = new_road[i];
        }

        // print state of road at current time step
        printf(""State of road at time step %d:\\n"", time_step+1);
        for (i = 0; i < ROAD_LENGTH; i++) {
            printf(""%c"", road[i] == EMPTY ? '.' : 'X');
        }
        printf(""\\n"");
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  int v7[40]; // [rsp+20h] [rbp-B0h]
  int v8; // [rsp+C0h] [rbp-10h]
  int j; // [rsp+C4h] [rbp-Ch]
  int v10; // [rsp+C8h] [rbp-8h]
  int i; // [rsp+CCh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 19; ++i )
    v7[i + 20] = 0;
  v8 = 4;
  for ( i = 0; i < v8; ++i )
  {
    do
      v10 = rand() % 20;
    while ( v7[v10 + 20] == 1 );
    v7[v10 + 20] = 1;
  }
  printf(""Initial state of road:\\n"");
  for ( i = 0; i <= 19; ++i )
  {
    if ( v7[i + 20] )
      v4 = 88;
    else
      v4 = 46;
    printf(""%c"", v4);
  }
  printf(""\\n"");
  for ( j = 0; j <= 9; ++j )
  {
    for ( i = 0; i <= 19; ++i )
      v7[i] = 0;
    for ( i = 0; i <= 19; ++i )
    {
      if ( v7[i + 20] == 1 )
      {
        if ( i == 19 || v7[i + 21] == 1 )
          v7[i] = 1;
        else
          v7[i + 1] = 1;
      }
    }
    for ( i = 0; i <= 19; ++i )
      v7[i + 20] = v7[i];
    printf(""State of road at time step %d:\\n"", (unsigned int)(j + 1));
    for ( i = 0; i <= 19; ++i )
    {
      if ( v7[i + 20] )
        v5 = 88;
      else
        v5 = 46;
      printf(""%c"", v5);
    }
    printf(""\\n"");
  }
  return 0;
}
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROAD_LENGTH 20
#define MAX_CARS 4

int main() {
    int i, j, cars_on_road = 0;
    int road[ROAD_LENGTH];
    srand(time(NULL));

    // Initialize road with no cars
    for (i = 0; i < ROAD_LENGTH; i++) {
        road[i] = 0;
    }

    // Add cars to road randomly
    for (i = 0; i < MAX_CARS; i++) {
        int car_position;
        do {
            car_position = rand() % ROAD_LENGTH;
        } while (road[car_position] == 1);
        road[car_position] = 1;
    }

    // Print initial state of road
    printf(""Initial state of road:
"");
    for (i = 0; i < ROAD_LENGTH; i++) {
        printf(""%c"", road[i] == 1 ? 'X' : '.');
    }
    printf(""
"");

    // Simulate traffic flow
    for (j = 0; j < 10; j++) {
        // Reset road
        for (i = 0; i < ROAD_LENGTH; i++) {
            road[i] = 0;
        }

        // Move cars forward
        for (i = 0; i < ROAD_LENGTH; i++) {
            if (road[i] == 1) {
                if (i == ROAD_LENGTH - 1 || road[i+1] == 1) {
                    // Car at end of road
                    road[i] = 1;
                } else {
                    // Car can move forward
                    road[i+1] = 1;
                }
            }
        }

        // Copy new state of road to previous state
        for (i = 0; i < ROAD_LENGTH; i++) {
            road[i] = road[i+ROAD_LENGTH];
        }

        // Print state of road at current time step
        printf(""State of road at time step %d:
"", j+1);
        for (i = 0; i < ROAD_LENGTH; i++) {
            printf(""%c"", road[i] == 1 ? 'X' : '.');
        }
        printf(""
"");
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Password management ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

//Function declarations
bool login(char* username, char* password);
void register_user();
void change_password(char* username);
void list_users();

//Struct to store username and password
struct user {
    char* username;
    char* password;
};

//Global variables
int num_users = 0; //Number of registered users
struct user** user_table = NULL; //Table of registered users

int main() {
    printf(""Welcome to the Password Management System\\n"");
    char choice;
    do {
        printf(""\\nMenu:\\n"");
        printf(""1. Login\\n"");
        printf(""2. Register\\n"");
        printf(""3. Change Password\\n"");
        printf(""4. List Users\\n"");
        printf(""5. Exit\\n"");
        printf(""Enter your choice: "");
        scanf("" %c"", &choice);
        
        switch (choice) {
            case '1':
                //Login
                {
                    char username[20], password[20];
                    printf(""Username: "");
                    scanf(""%s"", username);
                    printf(""Password: "");
                    scanf(""%s"", password);
                    if (login(username, password)) {
                        printf(""Login successful!\\n"");
                    }
                    else {
                        printf(""Invalid username or password.\\n"");
                    }
                }
                break;
            case '2':
                //Register
                register_user();
                break;
            case '3':
                //Change Password
                {
                    char username[20];
                    printf(""Username: "");
                    scanf(""%s"", username);
                    change_password(username);
                }
                break;
            case '4':
                //List Users
                list_users();
                break;
            case '5':
                //Exit
                printf(""Goodbye!\\n"");
                break;
            default:
                //Invalid choice
                printf(""Invalid choice. Please try again.\\n"");
                break;
        }
    } while (choice != '5');
    
    //Free memory
    for (int i = 0; i < num_users; i++) {
        free(user_table[i]->username);
        free(user_table[i]->password);
        free(user_table[i]);
    }
    free(user_table);
    
    return 0;
}

bool login(char* username, char* password) {
    //Search for user in user table
    for (int i = 0; i < num_users; i++) {
        if (strcmp(user_table[i]->username, username) == 0) {
            //User exists, check password
            if (strcmp(user_table[i]->password, password) == 0) {
                //Password is correct
                return true;
            }
            else {
                //Password is incorrect
                return false;
            }
        }
    }
    //User does not exist
    return false;
}

void register_user() {
    //Allocate memory for new user
    struct user* new_user = (struct user*) malloc(sizeof(struct user));
    new_user->username = (char*) malloc(20 * sizeof(char));
    new_user->password = (char*) malloc(20 * sizeof(char));
    
    //Get username and password from user
    printf(""Username: "");
    scanf(""%s"", new_user->username);
    printf(""Password: "");
    scanf(""%s"", new_user->password);
    
    //Add new user to user table
    num_users++;
    user_table = (struct user**) realloc(user_table, num_users * sizeof(struct user*));
    user_table[num_users - 1] = new_user;
    
    printf(""Registration successful!\\n"");
}

void change_password(char* username) {
    //Search for user in user table
    for (int i = 0; i < num_users; i++) {
        if (strcmp(user_table[i]->username, username) == 0) {
            //User exists, get new password from user
            printf(""Enter new password: "");
            scanf(""%s"", user_table[i]->password);
            printf(""Password changed successfully!\\n"");
            return;
        }
    }
    //User does not exist
    printf(""Invalid username.\\n"");
}

void list_users() {
    //Print list of registered users
    printf(""Registered users:\\n"");
    for (int i = 0; i < num_users; i++) {
        printf(""%s\\n"", user_table[i]->username);
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall login(_QWORD, _QWORD); // weak
__int64 register_user(void); // weak
__int64 __fastcall change_password(_QWORD); // weak
__int64 list_users(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

int num_users; // weak
void *user_table; // idb


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[32]; // [rsp+20h] [rbp-60h] BYREF
  char v5[32]; // [rsp+40h] [rbp-40h] BYREF
  char v6[27]; // [rsp+60h] [rbp-20h] BYREF
  char v7; // [rsp+7Bh] [rbp-5h] BYREF
  int i; // [rsp+7Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Welcome to the Password Management System\\n"");
  do
  {
    printf(""\\nMenu:\\n"");
    printf(""1. Login\\n"");
    printf(""2. Register\\n"");
    printf(""3. Change Password\\n"");
    printf(""4. List Users\\n"");
    printf(""5. Exit\\n"");
    printf(""Enter your choice: "");
    scanf("" %c"", &v7);
    switch ( v7 )
    {
      case '1':
        printf(""Username: "");
        scanf(""%s"", v6);
        printf(""Password: "");
        scanf(""%s"", v5);
        if ( (unsigned __int8)login(v6, v5) )
          printf(""Login successful!\\n"");
        else
          printf(""Invalid username or password.\\n"");
        break;
      case '2':
        register_user();
        break;
      case '3':
        printf(""Username: "");
        scanf(""%s"", v4);
        change_password(v4);
        break;
      case '4':
        list_users();
        break;
      case '5':
        printf(""Goodbye!\\n"");
        break;
      default:
        printf(""Invalid choice. Please try again.\\n"");
        break;
    }
  }
  while ( v7 != 53 );
  for ( i = 0; i < num_users; ++i )
  {
    free(**((void ***)user_table + i));
    free(*(void **)(*((_QWORD *)user_table + i) + 8i64));
    free(*((void **)user_table + i));
  }
  free(user_table);
  return 0;
}
// 140001833: using guessed type __int64 __fastcall login(_QWORD, _QWORD);
// 1400018C7: using guessed type __int64 register_user(void);
// 1400019C3: using guessed type __int64 __fastcall change_password(_QWORD);
// 140001A76: using guessed type __int64 list_users(void);
// 140001B90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019040: using guessed type int num_users;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_USERS 100
#define MAX_PASSWORD_LENGTH 20

typedef struct {
    char username[MAX_PASSWORD_LENGTH];
    char password[MAX_PASSWORD_LENGTH];
} User;

User* user_table[MAX_USERS];
int num_users = 0;

bool login(char* username, char* password);
void register_user();
void change_password(char* username);
void list_users();

int main() {
    char choice;
    printf(""Welcome to the Password Management System\\n"");
    do {
        printf(""\\nMenu:\\n"");
        printf(""1. Login\\n"");
        printf(""2. Register\\n"");
        printf(""3. Change Password\\n"");
        printf(""4. List Users\\n"");
        printf(""5. Exit\\n"");
        printf(""Enter your choice: "");
        scanf("" %c"", &choice);
        switch (choice) {
            case '1': {
                char username[MAX_PASSWORD_LENGTH];
                char password[MAX_PASSWORD_LENGTH];
                printf(""Username: "");
                scanf(""%s"", username);
                printf(""Password: "");
                scanf(""%s"", password);
                if (login(username, password)) {
                    printf(""Login successful!\\n"");
                } else {
                    printf(""Invalid username or password.\\n"");
                }
                break;
            }
            case '2': {
                register_user();
                break;
            }
            case '3': {
                char username[MAX_PASSWORD_LENGTH];
                printf(""Username: "");
                scanf(""%s"", username);
                change_password(username);
                break;
            }
            case '4': {
                list_users();
                break;
            }
            case '5': {
                printf(""Goodbye!\\n"");
                break;
            }
            default: {
                printf(""Invalid choice. Please try again.\\n"");
                break;
            }
        }
    } while (choice != '5');
    for (int i = 0; i < num_users; i++) {
        free(user_table[i]->username);
        free(user_table[i]->password);
        free(user_table[i]);
    }
    free(user_table);
    return 0;
}

bool login(char* username, char* password) {
    for (int i = 0; i < num_users; i++) {
        if (strcmp(user_table[i]->username, username) == 0 && strcmp(user_table[i]->password, password) == 0) {
            return true;
        }
    }
    return false;
}

void register_user() {
    if (num_users >= MAX_USERS) {
        printf(""Maximum number of users reached.\\n"");
        return;
    }
    User* new_user = (User*) malloc(sizeof(User));
    printf(""Username: "");
    scanf(""%s"", new_user->username);
    printf(""Password: "");
    scanf(""%s"", new_user->password);
    user_table[num_users++] = new_user;
    printf(""User registered successfully!\\n"");
}

void change_password(char* username) {
    for (int i = 0; i < num_users; i++) {
        if (strcmp(user_table[i]->username, username) == 0) {
            char old_password[MAX_PASSWORD_LENGTH];
            char new_password[MAX_PASSWORD_LENGTH];
            printf(""Old Password: "");
            scanf(""%s"", old_password);
            printf(""New Password: "");
            scanf(""%s"", new_password);
            if (strcmp(user_table[i]->password, old_password) == 0) {
                strcpy(user_table[i",2
"//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: Cyberpunk
#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>

int main()
{
    // Cyberpunk Solar System Simulation
    int i, j, k, n = 9, steps = 365;
    double G = 6.67408e-11, dt = 86400.0, softener = 1e10;
    double R[n][3], V[n][3], A[n][3], M[n], F[3];
    char* name[] = {""Sun"", ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""};
    srand(time(NULL));

    // Initial conditions
    M[0] = 1.9885e30; R[0][0] = R[0][1] = R[0][2] = 0.0; V[0][0] = V[0][1] = V[0][2] = 0.0;
    M[1] = 3.302e23; R[1][0] = 0.39 * 1.496e11; R[1][1] = 0.0; R[1][2] = 0.0; V[1][0] = 0.0; V[1][1] = 4.79e4; V[1][2] = 0.0;
    M[2] = 4.869e24; R[2][0] = 0.72 * 1.496e11; R[2][1] = 0.0; R[2][2] = 0.0; V[2][0] = 0.0; V[2][1] = 3.503e4; V[2][2] = 0.0;
    M[3] = 5.97e24; R[3][0] = R[3][1] = 0.0; R[3][2] = 0.0; V[3][0] = -2.978e4; V[3][1] = 0.0; V[3][2] = 0.0;
    M[4] = 6.39e23; R[4][0] = 0.0; R[4][1] = 1.52 * 1.496e11; R[4][2] = 0.0; V[4][0] = 0.0; V[4][1] = -2.41e4; V[4][2] = 0.0;
    M[5] = 1.898e27; R[5][0] = 5.20 * 1.496e11; R[5][1] = 0.0; R[5][2] = 0.0; V[5][0] = 0.0; V[5][1] = 1.307e4; V[5][2] = 0.0;
    M[6] = 5.69e26; R[6][0] = 9.54 * 1.496e11; R[6][1] = 0.0; R[6][2] = 0.0; V[6][0] = 0.0; V[6][1] = 9.64e3; V[6][2] = 0.0;
    M[7] = 8.68e25; R[7][0] = 19.18 * 1.496e11; R[7][1] = 0.0; R[7][2] = 0.0; V[7][0] = 0.0; V[7][1] = 6.80e3; V[7][2] = 0.0;
    M[8] = 1.02e26; R[8][0] = 30.07 * 1.496e11; R[8][1] = 0.0; R[8][2] = 0.0; V[8][0] = 0.0; V[8][1] = 5.43e3; V[8][2] = 0.0;

    // Simulation
    for (i = 0; i < steps; i++){
        // Reset accelerations to zero
        for (j = 0; j < n; j++){
            for (k = 0; k < 3; k++){
                A[j][k] = 0.0;
            }
        }

        // Compute forces and accelerations
        for (j = 0; j < n; j++){
            for (k = 0; k < n; k++){
                if (j != k){
                    F[0] = R[k][0] - R[j][0];
                    F[1] = R[k][1] - R[j][1];
                    F[2] = R[k][2] - R[j][2];
                    double d = sqrt(F[0]*F[0] + F[1]*F[1] + F[2]*F[2]);
                    double Fg = G * M[j] * M[k] / (d*d + softener*softener);
                    A[j][0] += Fg * F[0] / d;
                    A[j][1] += Fg * F[1] / d;
                    A[j][2] += Fg * F[2] / d;
                }
            }
        }

        // Update positions and velocities using leapfrog algorithm
        for (j = 0; j < n; j++){
            for (k = 0; k < 3; k++){
                R[j][k] += V[j][k] * dt + 0.5 * A[j][k] * dt * dt;
                V[j][k] += 0.5 * A[j][k] * dt;
            }
        }

        // Print output for each step
        printf(""Step %d:\\n"", i+1);
        for (j = 0; j < n; j++){
            printf(""%s : x = %g, y = %g, z = %g\\n"", name[j], R[j][0], R[j][1], R[j][2]);
        }
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
// void __cdecl srand(unsigned int Seed);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000C000; // weak


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  void *v4; // rsp
  void *v5; // rsp
  void *v6; // rsp
  unsigned int v7; // eax
  __int64 v9[10]; // [rsp+30h] [rbp-50h] BYREF
  __int64 v10[10]; // [rsp+80h] [rbp+0h]
  double v11; // [rsp+D0h] [rbp+50h]
  double v12; // [rsp+D8h] [rbp+58h]
  double v13; // [rsp+E0h] [rbp+60h]
  double v14; // [rsp+F0h] [rbp+70h]
  double v15; // [rsp+F8h] [rbp+78h]
  __int64 *v16; // [rsp+100h] [rbp+80h]
  __int64 v17; // [rsp+108h] [rbp+88h]
  __int64 *v18; // [rsp+110h] [rbp+90h]
  __int64 v19; // [rsp+118h] [rbp+98h]
  __int64 *v20; // [rsp+120h] [rbp+A0h]
  __int64 v21; // [rsp+128h] [rbp+A8h]
  __int64 *v22; // [rsp+130h] [rbp+B0h]
  __int64 v23; // [rsp+138h] [rbp+B8h]
  double v24; // [rsp+140h] [rbp+C0h]
  double v25; // [rsp+148h] [rbp+C8h]
  double v26; // [rsp+150h] [rbp+D0h]
  int v27; // [rsp+15Ch] [rbp+DCh]
  int v28; // [rsp+160h] [rbp+E0h]
  int k; // [rsp+164h] [rbp+E4h]
  int j; // [rsp+168h] [rbp+E8h]
  int i; // [rsp+16Ch] [rbp+ECh]

  _main(argc, argv, envp);
  v28 = 9;
  v27 = 365;
  v26 = 6.67408e-11;
  v25 = 86400.0;
  v24 = 1.0e10;
  v23 = 8i64;
  v3 = alloca(224i64);
  v22 = v9;
  v21 = 8i64;
  v9[8] = 9i64;
  v9[9] = 0i64;
  v4 = alloca(224i64);
  v20 = v9;
  v19 = 8i64;
  v9[6] = 9i64;
  v9[7] = 0i64;
  v9[4] = 9i64;
  v9[5] = 0i64;
  v5 = alloca(224i64);
  v18 = v9;
  v17 = 8i64;
  v9[2] = 9i64;
  v9[3] = 0i64;
  v9[0] = 9i64;
  v9[1] = 0i64;
  v6 = alloca(80i64);
  v16 = v9;
  v10[0] = (__int64)&unk_14000C000;
  v10[1] = (__int64)""Mercury"";
  v10[2] = (__int64)""Venus"";
  v10[3] = (__int64)""Earth"";
  v10[4] = (__int64)""Mars"";
  v10[5] = (__int64)""Jupiter"";
  v10[6] = (__int64)""Saturn"";
  v10[7] = (__int64)""Uranus"";
  v10[8] = (__int64)""Neptune"";
  v7 = time(0i64);
  srand(v7);
  *v16 = 0x46391930A5E75F0Ci64;
  v22[2] = 0i64;
  v22[1] = v22[2];
  *v22 = v22[1];
  v20[2] = 0i64;
  v20[1] = v20[2];
  *v20 = v20[1];
  v16[1] = 0x44D17B0B622F5AF0i64;
  v22[3] = 0x422B2B2594000000i64;
  v22[4] = 0i64;
  v22[5] = 0i64;
  v20[3] = 0i64;
  v20[4] = 0x40E7638000000000i64;
  v20[5] = 0i64;
  v16[2] = 0x45101C341358518Di64;
  v22[6] = 0x42391422B0000000i64;
  v22[7] = 0i64;
  v22[8] = 0i64;
  v20[6] = 0i64;
  v20[7] = 0x40E11AC000000000i64;
  v20[8] = 0i64;
  v16[3] = 0x4513C0C964D9C187i64;
  v22[10] = 0i64;
  v22[9] = v22[10];
  v22[11] = 0i64;
  v20[9] = 0xC0DD150000000000ui64;
  v20[10] = 0i64;
  v20[11] = 0i64;
  v16[4] = 0x44E0EA084D181CD6i64;
  v22[12] = 0i64;
  v22[13] = 0x424A78CF48000000i64;
  v22[14] = 0i64;
  v20[12] = 0i64;
  v20[13] = 0xC0D7890000000000ui64;
  v20[14] = 0i64;
  v16[5] = 0x459887F488ACED67i64;
  v22[15] = 0x4266A3F4A6000000i64;
  v22[16] = 0i64;
  v22[17] = 0i64;
  v20[15] = 0i64;
  v20[16] = 0x40C9870000000000i64;
  v20[17] = 0i64;
  v16[6] = 0x457D6AA6FCEA57C3i64;
  v22[18] = 0x4274C4ACB9BFFFFFi64;
  v22[19] = 0i64;
  v22[20] = 0i64;
  v20[18] = 0i64;
  v20[19] = 0x40C2D40000000000i64;
  v20[20] = 0i64;
  v16[7] = 0x4551F3275B6DF88Bi64;
  v22[21] = 0x4284E08A35A00000i64;
  v22[22] = 0i64;
  v22[23] = 0i64;
  v20[21] = 0i64;
  v20[22] = 0x40BA900000000000i64;
  v20[23] = 0i64;
  v16[8] = 0x455517D5C51969ACi64;
  v22[24] = 0x42905D874D680000i64;
  v22[25] = 0i64;
  v22[26] = 0i64;
  v20[24] = 0i64;
  v20[25] = 0x40B5360000000000i64;
  v20[26] = 0i64;
  for ( i = 0; i < v27; ++i )
  {
    for ( j = 0; j < v28; ++j )
    {
      for ( k = 0; k <= 2; ++k )
        v18[3 * j + k] = 0i64;
    }
    for ( j = 0; j < v28; ++j )
    {
      for ( k = 0; k < v28; ++k )
      {
        if ( j != k )
        {
          v11 = *(double *)&v22[3 * k] - *(double *)&v22[3 * j];
          v12 = *(double *)&v22[3 * k + 1] - *(double *)&v22[3 * j + 1];
          v13 = *(double *)&v22[3 * k + 2] - *(double *)&v22[3 * j + 2];
          v15 = sqrt(v11 * v11 + v12 * v12 + v13 * v13);
          v14 = *(double *)&v16[j] * v26 * *(double *)&v16[k] / (v15 * v15 + v24 * v24);
          *(double *)&v18[3 * j] = v11 * v14 / v15 + *(double *)&v18[3 * j];
          *(double *)&v18[3 * j + 1] = v12 * v14 / v15 + *(double *)&v18[3 * j + 1];
          *(double *)&v18[3 * j + 2] = v13 * v14 / v15 + *(double *)&v18[3 * j + 2];
        }
      }
    }
    for ( j = 0; j < v28; ++j )
    {
      for ( k = 0; k <= 2; ++k )
      {
        *(double *)&v22[3 * j + k] = 0.5 * *(double *)&v18[3 * j + k] * v25 * v25
                                   + *(double *)&v20[3 * j + k] * v25
                                   + *(double *)&v22[3 * j + k];
        *(double *)&v20[3 * j + k] = 0.5 * *(double *)&v18[3 * j + k] * v25 + *(double *)&v20[3 * j + k];
      }
    }
    printf(""Step %d:\\n"", (unsigned int)(i + 1));
    for ( j = 0; j < v28; ++j )
      printf(
        ""%s : x = %g, y = %g, z = %g\\n"",
        (const char *)v10[j],
        *(double *)&v22[3 * j],
        *(double *)&v22[3 * j + 1],
        *(double *)&v22[3 * j + 2]);
  }
  return 0;
}
// 140002540: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define G 6.67408e-11 // gravitational constant
#define TIME_STEP 86400 // time step in seconds
#define MASS_SCALE 1e10 // mass scale factor

typedef struct {
    double x, y, z; // position
    double vx, vy, vz; // velocity
    double mass; // mass
} Body;

int main() {
    int num_bodies = 9; // number of bodies
    int num_steps = 365; // number of time steps
    double G = 6.67408e-11; // gravitational constant
    double time_step = 86400; // time step in seconds
    double mass_scale = 1e10; // mass scale factor
    
    Body bodies[num_bodies]; // array of bodies
    
    // initialize bodies
    srand(time(NULL));
    
    // Mercury
    bodies[0].x = 0.38709833e9;
    bodies[0].y = 0;
    bodies[0].z = 0;
    bodies[0].vx = 0;
    bodies[0].vy = 0;
    bodies[0].vz = 0;
    bodies[0].mass = 3.285e23 * mass_scale;
    
    // Venus
    bodies[1].x = 0.77810621e9;
    bodies[1].y = 0;
    bodies[1].z = 0;
    bodies[1].vx = 0;
    bodies[1].vy = 0;
    bodies[1].vz = 0;
    bodies[1].mass = 4.867e24 * mass_scale;
    
    // Earth
    bodies[2].x = 1.4959787e11;
    bodies[2].y = 0;
    bodies[2].z = 0;
    bodies[2].vx = 0;
    bodies[2].vy = 0;
    bodies[2].vz = 0;
    bodies[2].mass = 5.972e24 * mass_scale;
    
    // Mars
    bodies[3].x = 2.2793e11;
    bodies[3].y = 0;
    bodies[3].z = 0;
    bodies[3].vx = 0;
    bodies[3].vy = 0;
    bodies[3].vz = 0;
    bodies[3].mass = 6.39e23 * mass_scale;
    
    // Jupiter
    bodies[4].x = 7.402e11;
    bodies[4].y = 0;
    bodies[4].z = 0;
    bodies[4].vx = 0;
    bodies[4].vy = 0;
    bodies[4].vz = 0;
    bodies[4].mass = 1.898e27 * mass_scale;
    
    // Saturn
    bodies[5].x = 1.427e12;
    bodies[5].y = 0;
    bodies[5].z = 0;
    bodies[5].vx = 0;
    bodies[5].vy = 0;
    bodies[5].vz = 0;
    bodies[5].mass = 5.683e26 * mass_scale;
    
    // Uranus
    bodies[6].x = 2.002e12;
    bodies[6].y = 0;
    bodies[6].z",2
"//FormAI DATASET v1.0 Category: Expense Tracker ; Style: calm
// This program keeps track of expenses for a user

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_EXPENSES 100

struct Expense {
  char name[50];
  float amount;
  char category[30];
};

void printMenu() {
  printf(""=======================\\n"");
  printf(""      EXPENSE TRACKER\\n"");
  printf(""=======================\\n"");
  printf(""1. Add a new expense\\n"");
  printf(""2. View all expenses\\n"");
  printf(""3. View expenses by category\\n"");
  printf(""4. Quit\\n"");
  printf(""=======================\\n"");
}

int main() {
  struct Expense expenses[MAX_EXPENSES];
  int numExpenses = 0; // keeps track of number of expenses added by user

  while (1) { // loop runs until user quits
    printMenu();
    
    int choice;
    printf(""Enter your choice: "");
    scanf(""%d"", &choice);
    
    switch(choice) {
      case 1: {
        printf(""\\nEnter expense name: "");
        scanf(""%s"", expenses[numExpenses].name);
        printf(""Enter amount ($): "");
        scanf(""%f"", &expenses[numExpenses].amount);
        printf(""Enter category: "");
        scanf(""%s"", expenses[numExpenses].category);
        numExpenses++;
        printf(""\\nExpense added successfully!\\n\\n"");
        break;
      }
      case 2: {
        if (numExpenses == 0) {
          printf(""\\nNo expenses added yet!\\n\\n"");
          break;
        }
        printf(""\\nAll expenses:\\n"");
        for (int i = 0; i < numExpenses; i++) {
          printf(""%s - $%.2f - %s\\n"", expenses[i].name, expenses[i].amount, expenses[i].category);
        }
        printf(""\\n"");
        break;
      }
      case 3: {
        if (numExpenses == 0) {
          printf(""\\nNo expenses added yet!\\n\\n"");
          break;
        }
        char searchCategory[30];
        printf(""\\nEnter category to search for: "");
        scanf(""%s"", searchCategory);
        printf(""\\nExpenses in category %s:\\n"", searchCategory);
        for (int i = 0; i < numExpenses; i++) {
          if (strcmp(expenses[i].category, searchCategory) == 0) {
            printf(""%s - $%.2f\\n"", expenses[i].name, expenses[i].amount);
          }
        }
        printf(""\\n"");
        break;
      }
      case 4: {
        printf(""\\nThank you for using the expense tracker! Goodbye!\\n"");
        exit(0);
        break;
      }
      default: {
        printf(""\\nInvalid choice! Please try again.\\n\\n"");
        break;
      }
    }
  }

  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 printMenu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001669) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  char Str2[44]; // [rsp+20h] [rbp-60h] BYREF
  int v4[13]; // [rsp+4Ch] [rbp-34h] BYREF
  _BYTE v5[8756]; // [rsp+80h] [rbp+0h] BYREF
  int i; // [rsp+22B4h] [rbp+2234h]
  int j; // [rsp+22B8h] [rbp+2238h]
  int v8; // [rsp+22BCh] [rbp+223Ch]

  _main(argc, argv, envp);
  v8 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        printMenu();
        printf(""Enter your choice: "");
        scanf(""%d"", v4);
        if ( v4[0] == 4 )
        {
          printf(""\\nThank you for using the expense tracker! Goodbye!\\n"");
          exit(0);
        }
        if ( v4[0] <= 4 )
          break;
LABEL_23:
        printf(""\\nInvalid choice! Please try again.\\n\\n"");
      }
      if ( v4[0] != 3 )
        break;
      if ( !v8 )
        goto LABEL_10;
      printf(""\\nEnter category to search for: "");
      scanf(""%s"", Str2);
      printf(""\\nExpenses in category %s:\\n"", Str2);
      for ( i = 0; i < v8; ++i )
      {
        if ( !strcmp(&v5[88 * i + 8], Str2) )
          printf(""%s - $%.2f\\n"", (const char *)&v4[22 * i + 1], *(float *)&v5[88 * i + 4]);
      }
LABEL_14:
      printf(""\\n"");
    }
    if ( v4[0] == 1 )
    {
      printf(""\\nEnter expense name: "");
      scanf(""%s"", &v4[22 * v8 + 1]);
      printf(""Enter amount ($): "");
      scanf(""%f"", &v5[88 * v8 + 4]);
      printf(""Enter category: "");
      scanf(""%s"", &v5[88 * v8++ + 8]);
      printf(""\\nExpense added successfully!\\n\\n"");
    }
    else
    {
      if ( v4[0] != 2 )
        goto LABEL_23;
      if ( v8 )
      {
        printf(""\\nAll expenses:\\n"");
        for ( j = 0; j < v8; ++j )
          printf(""%s - $%.2f - %s\\n"", (const char *)&v4[22 * j + 1], *(float *)&v5[88 * j + 4], &v5[88 * j + 8]);
        goto LABEL_14;
      }
LABEL_10:
      printf(""\\nNo expenses added yet!\\n\\n"");
    }
  }
}
// 1400016D9: conditional instruction was optimized away because %var_2274.4<3
// 1400015E2: using guessed type __int64 printMenu(void);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_EXPENSES 100

typedef struct {
    char name[40];
    float amount;
    char category[20];
} Expense;

void printMenu() {
    printf(""
Expense Tracker
"");
    printf(""1. Add Expense
"");
    printf(""2. View All Expenses
"");
    printf(""3. Search Expenses by Category
"");
    printf(""4. Exit
"");
}

int main() {
    Expense expenses[MAX_EXPENSES];
    int numExpenses = 0;
    int choice;

    while (1) {
        printMenu();
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""
Enter expense name: "");
                scanf(""%s"", expenses[numExpenses].name);
                printf(""Enter amount ($): "");
                scanf(""%f"", &expenses[numExpenses].amount);
                printf(""Enter category: "");
                scanf(""%s"", expenses[numExpenses].category);
                numExpenses++;
                printf(""
Expense added successfully!

"");
                break;

            case 2:
                if (numExpenses == 0) {
                    printf(""
No expenses added yet!

"");
                    break;
                }
                printf(""
All expenses:
"");
                for (int i = 0; i < numExpenses; i++) {
                    printf(""%s - $%.2f - %s
"", expenses[i].name, expenses[i].amount, expenses[i].category);
                }
                printf(""
"");
                break;

            case 3:
                if (numExpenses == 0) {
                    printf(""
No expenses added yet!

"");
                    break;
                }
                printf(""
Enter category to search for: "");
                char searchCategory[20];
                scanf(""%s"", searchCategory);
                printf(""
Expenses in category %s:
"", searchCategory);
                for (int i = 0; i < numExpenses; i++) {
                    if (strcmp(expenses[i].category, searchCategory) == 0) {
                        printf(""%s - $%.2f
"", expenses[i].name, expenses[i].amount);
                    }
                }
                printf(""
"");
                break;

            case 4:
                printf(""
Thank you for using the expense tracker! Goodbye!
"");
                exit(0);

            default:
                printf(""
Invalid choice! Please try again.

"");
        }
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: intelligent
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/**
 * This program is a sample metadata extractor that can read a file and extract useful metadata from it.
 * It has been written in C for performance and portability, and is able to work with a wide variety of file types.
 * The metadata extracted includes file name, file size, and file type.
 * This program can serve as a starting point for more advanced metadata extraction tasks.
 */

int main(int argc, char *argv[]) {

    if (argc < 2) {
        printf(""Usage: %s <filename>\\n"", argv[0]);
        return 1;
    }

    FILE *fp = fopen(argv[1], ""r"");

    if (!fp) {
        printf(""Unable to open file: %s\\n"", argv[1]);
        return 1;
    }

    // Get file size
    fseek(fp, 0L, SEEK_END);
    long size = ftell(fp);
    fseek(fp, 0L, SEEK_SET);

    // Extract file type
    char *extension = strrchr(argv[1], '.');

    if (extension == NULL) {
        printf(""Unable to determine file type\\n"");
        return 1;
    }

    char type[10];

    if (strcmp(extension, "".txt"") == 0) {
        strcpy(type, ""TEXT"");
    } else if (strcmp(extension, "".jpg"") == 0 || strcmp(extension, "".jpeg"") == 0) {
        strcpy(type, ""JPEG"");
    } else if (strcmp(extension, "".png"") == 0) {
        strcpy(type, ""PNG"");
    } else if (strcmp(extension, "".pdf"") == 0) {
        strcpy(type, ""PDF"");
    } else {
        strcpy(type, ""UNKNOWN"");
    }

    printf(""File Name: %s\\n"", argv[1]);
    printf(""File Size: %ld bytes\\n"", size);
    printf(""File Type: %s\\n"", type);

    fclose(fp);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strrchr(const char *Str, int Ch);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[10]; // [rsp+2Eh] [rbp-22h] BYREF
  char *Str1; // [rsp+38h] [rbp-18h]
  unsigned int v6; // [rsp+44h] [rbp-Ch]
  FILE *Stream; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    Stream = fopen(argv[1], ""r"");
    if ( Stream )
    {
      fseek(Stream, 0, 2);
      v6 = ftell(Stream);
      fseek(Stream, 0, 0);
      Str1 = strrchr(argv[1], 46);
      if ( Str1 )
      {
        if ( !strcmp(Str1, "".txt"") )
        {
          strcpy(v4, ""TEXT"");
        }
        else if ( !strcmp(Str1, "".jpg"") || !strcmp(Str1, "".jpeg"") )
        {
          strcpy(v4, ""JPEG"");
        }
        else if ( !strcmp(Str1, "".png"") )
        {
          strcpy(v4, ""PNG"");
        }
        else if ( !strcmp(Str1, "".pdf"") )
        {
          strcpy(v4, ""PDF"");
        }
        else
        {
          strcpy(v4, ""UNKNOWN"");
        }
        printf(""File Name: %s\\n"", argv[1]);
        printf(""File Size: %ld bytes\\n"", v6);
        printf(""File Type: %s\\n"", v4);
        fclose(Stream);
        return 0;
      }
      else
      {
        printf(""Unable to determine file type\\n"");
        return 1;
      }
    }
    else
    {
      printf(""Unable to open file: %s\\n"", argv[1]);
      return 1;
    }
  }
  else
  {
    printf(""Usage: %s <filename>\\n"", *argv);
    return 1;
  }
}
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf(""Usage: %s <filename>
"", argv[0]);
        return 1;
    }

    FILE *fp;
    fp = fopen(argv[1], ""r"");
    if (fp == NULL) {
        printf(""Unable to open file: %s
"", argv[1]);
        return 1;
    }

    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    char *file_type = strrchr(argv[1], '.');
    if (file_type == NULL) {
        printf(""Unable to determine file type
"");
        return 1;
    }

    char file_type_str[10];
    if (strcmp(file_type, "".txt"") == 0) {
        strcpy(file_type_str, ""TEXT"");
    } else if (strcmp(file_type, "".jpg"") == 0 || strcmp(file_type, "".jpeg"") == 0) {
        strcpy(file_type_str, ""JPEG"");
    } else if (strcmp(file_type, "".png"") == 0) {
        strcpy(file_type_str, ""PNG"");
    } else if (strcmp(file_type, "".pdf"") == 0) {
        strcpy(file_type_str, ""PDF"");
    } else {
        strcpy(file_type_str, ""UNKNOWN"");
    }

    printf(""File Name: %s
"", argv[1]);
    printf(""File Size: %ld bytes
"", file_size);
    printf(""File Type: %s
"", file_type_str);

    fclose(fp);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Geometric algorithms ; Style: energetic
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int x[3], y[3], i;
    float area;

    printf(""Enter the coordinates of the three vertices of the triangle.\\n"");

    for (i = 0; i < 3; i++) {
        printf(""Vertex %d (x, y): "", i+1);
        scanf(""%d %d"", &x[i], &y[i]);
    }

    // Calculate the area using the Shoelace Formula
    area = abs((x[0] * y[1] + x[1] * y[2] + x[2] * y[0]) - (y[0] * x[1] + y[1] * x[2] + y[2] * x[0])) / 2.0;

    printf(""The area of the triangle is %.2f square units.\\n"", area);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // r8d
  int v4; // eax
  float v5; // xmm0_4
  int v7; // [rsp+20h] [rbp-20h] BYREF
  int v8; // [rsp+24h] [rbp-1Ch]
  int v9; // [rsp+28h] [rbp-18h]
  int v10; // [rsp+2Ch] [rbp-14h] BYREF
  int v11; // [rsp+30h] [rbp-10h]
  int v12; // [rsp+34h] [rbp-Ch]
  float v13; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Enter the coordinates of the three vertices of the triangle.\\n"");
  for ( i = 0; i <= 2; ++i )
  {
    printf(""Vertex %d (x, y): "", (unsigned int)(i + 1));
    scanf(""%d %d"", &v10 + i, &v7 + i);
  }
  v3 = v8 * v12 + v11 * v7;
  v4 = v12 * v7 + v11 * v9 + v8 * v10 - (v3 + v9 * v10);
  if ( v3 + v9 * v10 - (v12 * v7 + v11 * v9 + v8 * v10) >= 0 )
    v4 = v3 + v9 * v10 - (v12 * v7 + v11 * v9 + v8 * v10);
  v5 = (double)v4 / 2.0;
  v13 = v5;
  printf(""The area of the triangle is %.2f square units.\\n"", v5);
  return 0;
}
// 1400017C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
int main() {
    int x1, y1, x2, y2, x3, y3;
    float area;

    printf(""Enter the coordinates of the three vertices of the triangle.
"");

    for (int i = 0; i < 3; i++) {
        printf(""Vertex %d (x, y): "", i+1);
        scanf(""%d %d"", &x1, &y1);
    }

    area = (x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2;

    printf(""The area of the triangle is %.2f square units.
"", area);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define ROWS 10
#define COLS 10

char maze[ROWS][COLS] = {
    {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '.', '.', '#', '.', '.', '.', '#'},
    {'#', '.', '#', '#', '.', '#', '.', '#', '.', '#'},
    {'#', '.', '.', '#', '.', '.', '.', '#', '.', '#'},
    {'#', '#', '.', '.', '.', '#', '.', '#', '.', '#'},
    {'#', '.', '.', '#', '.', '#', '.', '#', '.', '#'},
    {'#', '#', '.', '#', '.', '#', '.', '#', '.', '#'},
    {'#', '.', '.', '.', '.', '.', '.', '.', '.', '#'},
    {'#', '#', '#', '#', '#', '#', '#', '#', '.', '#'},
    {'#', '.', '.', '.', '.', '.', '.', '.', '.', '#'}
};

struct Coordinate {
    int x;
    int y;
};

struct Stack {
    struct Coordinate data[ROWS*COLS];
    int top;
};

void initializeStack(struct Stack* stack) {
    stack->top = -1;
}

bool isEmpty(struct Stack* stack) {
    return stack->top == -1;
}

bool isFull(struct Stack* stack) {
    return stack->top == ROWS*COLS - 1;
}

void push(struct Stack* stack, struct Coordinate coord) {
    if (isFull(stack)) {
        printf(""Error: Stack is full\\n"");
        exit(EXIT_FAILURE);
    }
    stack->data[++(stack->top)] = coord;
}

struct Coordinate pop(struct Stack* stack) {
    if (isEmpty(stack)) {
        printf(""Error: Stack is empty\\n"");
        exit(EXIT_FAILURE);
    }
    return stack->data[(stack->top)--];
}

bool isOnMaze(int x, int y) {
    return x >= 0 && x < ROWS && y >= 0 && y < COLS;
}

bool isPath(struct Coordinate coord) {
    return isOnMaze(coord.x, coord.y) && maze[coord.x][coord.y] == '.';
}

void printMaze() {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf(""%c "", maze[i][j]);
        }
        printf(""\\n"");
    }
    printf(""\\n"");
}

int main() {
    struct Stack stack;
    struct Coordinate start = {1, 1};
    struct Coordinate end = {ROWS-2, COLS-2};
    initializeStack(&stack);
    push(&stack, start);
    struct Coordinate current;
    while (!isEmpty(&stack)) {
        current = pop(&stack);
        if (current.x == end.x && current.y == end.y) {
            break;
        }
        maze[current.x][current.y] = '@'; //mark as visited
        struct Coordinate next;
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                next.x = current.x + i;
                next.y = current.y + j;
                if ((i == 0 || j == 0) && isPath(next)) {
                    push(&stack, next);
                }
            }
        }
    }
    if (current.x == end.x && current.y == end.y) {
        printf(""Path found!\\n"");
        maze[start.x][start.y] = 'S';
        maze[end.x][end.y] = 'E';
        printMaze();
    } else {
        printf(""No path found\\n"");
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall initializeStack(_QWORD); // weak
__int64 __fastcall isEmpty(_QWORD); // weak
__int64 __fastcall push(_QWORD, _QWORD); // weak
__int64 __fastcall pop(_QWORD); // weak
__int64 __fastcall isPath(_QWORD); // weak
__int64 printMaze(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

char maze[101] = ""###########....#...##.##.#.#.##..#...#.###...#.#.##..#.#.#.###.#.#.#.##........#########.##........#""; // weak


//----- (00000001400017C8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-60h]
  __int64 v5; // [rsp+28h] [rbp-58h]
  char v6[808]; // [rsp+40h] [rbp-40h] BYREF
  int j; // [rsp+368h] [rbp+2E8h]
  int i; // [rsp+36Ch] [rbp+2ECh]

  _main(argc, argv, envp);
  initializeStack(v6);
  push(v6, 0x100000001i64);
  while ( (unsigned __int8)isEmpty(v6) != 1 )
  {
    v5 = pop(v6);
    if ( v5 == 0x800000008i64 )
      break;
    maze[10 * (int)v5 + SHIDWORD(v5)] = 64;
    for ( i = -1; i <= 1; ++i )
    {
      for ( j = -1; j <= 1; ++j )
      {
        LODWORD(v4) = v5 + i;
        HIDWORD(v4) = HIDWORD(v5) + j;
        if ( !i || !j )
        {
          if ( (unsigned __int8)isPath(v4) )
            push(v6, v4);
        }
      }
    }
  }
  if ( v5 == 0x800000008i64 )
  {
    printf(""Path found!\\n"");
    maze[11] = 83;
    maze[88] = 69;
    printMaze();
  }
  else
  {
    printf(""No path found\\n"");
  }
  return 0;
}
// 140001914: variable 'v5' is possibly undefined
// 140001591: using guessed type __int64 __fastcall initializeStack(_QWORD);
// 1400015AA: using guessed type __int64 __fastcall isEmpty(_QWORD);
// 1400015DE: using guessed type __int64 __fastcall push(_QWORD, _QWORD);
// 14000164B: using guessed type __int64 __fastcall pop(_QWORD);
// 1400016D7: using guessed type __int64 __fastcall isPath(_QWORD);
// 140001737: using guessed type __int64 printMaze(void);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define ROWS 11
#define COLS 11

typedef struct {
    int row;
    int col;
} Position;

typedef struct {
    Position top;
    int size;
    int capacity;
} Stack;

char maze[ROWS][COLS] = {
    {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '#', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '.', '.', '#', '#', '#', '#', '#', '#', '#', '#'},
    {'#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'}
};

void initializeStack(Stack *stack) {
    stack->size = 0;
    stack->capacity = 100;
    stack->top = (Position) {0, 0};
}

bool isEmpty(Stack *stack) {
    return stack->size == 0;
}

void push(Stack *stack, Position position) {
    if (stack->size == stack->capacity) {
        printf(""Stack overflow
"");
        exit(1);
    }
    stack->size++;
    stack->top = position;
}

Position pop(Stack *stack) {
    if (isEmpty(stack)) {
        printf(""Stack underflow
"");
        exit(1);
    }
    stack->size--;
    return stack->top;
}

bool isPath(Position position) {
    return maze[position.row][position.col] == '.';
}

void printMaze() {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf(""%c"", maze[i][j]);
        }
        printf(""
"");
    }
}

int main() {
    Stack stack;
    initializeStack(&stack);
    push(&stack, (Position) {0, 0});
    while (!isEmpty(&stack)) {
        Position current = pop(&stack);
        if (current.row == ROWS - 1 && current.col == COLS - 1) {
            printf(""Path found!
"");
            maze[current.row][current.col] = 'G';
            maze[ROWS - 2][COLS - 2] = 'E';
            printMaze();
            break;
        }
        maze[current.row][current.col] = ' ';
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                Position neighbor = (Position) {current.row + i, current.col + j};
                if (i == 0 && j == 0) {
                    if (isPath(neighbor)) {
                        push(&stack, neighbor);
                    }
                } else {
                    if (isPath(neighbor)) {
                        push(&stack, neighbor);
                    }
                }
            }",2
"//FormAI DATASET v1.0 Category: Image Editor ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>

#define WIDTH 150
#define HEIGHT 150

void grayscale(unsigned char* img)
{
    int i;
    for(i = 0; i < WIDTH * HEIGHT; i++) {
        unsigned char r, g, b, gray;
        r = *(img + i * 3);
        g = *(img + i * 3 + 1);
        b = *(img + i * 3 + 2);
        gray = (r + g + b) / 3;
        *(img + i * 3) = gray;
        *(img + i * 3 + 1) = gray;
        *(img + i * 3 + 2) = gray;
    }
}

void flipHorizontally(unsigned char* img)
{
    int x, y;
    for(y = 0; y < HEIGHT; y++) {
        for(x = 0; x < WIDTH / 2; x++) {
            unsigned char* pixel1 = img + (y * WIDTH + x) * 3;
            unsigned char* pixel2 = img + (y * WIDTH + (WIDTH - x - 1)) * 3;
            unsigned char tempR = *pixel1, tempG = *(pixel1 + 1), tempB = *(pixel1 + 2);
            *pixel1 = *pixel2;
            *(pixel1 + 1) = *(pixel2 + 1);
            *(pixel1 + 2) = *(pixel2 + 2);
            *pixel2 = tempR;
            *(pixel2 + 1) = tempG;
            *(pixel2 + 2) = tempB;
        }
    }
}

void flipVertically(unsigned char* img)
{
    int x, y;
    for(y = 0; y < HEIGHT / 2; y++) {
        for(x = 0; x < WIDTH; x++) {
            unsigned char* pixel1 = img + (y * WIDTH + x) * 3;
            unsigned char* pixel2 = img + ((HEIGHT - y - 1) * WIDTH + x) * 3;
            unsigned char tempR = *pixel1, tempG = *(pixel1 + 1), tempB = *(pixel1 + 2);
            *pixel1 = *pixel2;
            *(pixel1 + 1) = *(pixel2 + 1);
            *(pixel1 + 2) = *(pixel2 + 2);
            *pixel2 = tempR;
            *(pixel2 + 1) = tempG;
            *(pixel2 + 2) = tempB;
        }
    }
}

int main()
{
    FILE *inFile, *outFile;
    unsigned char buffer[WIDTH * HEIGHT * 3];
    
    // Read the input file
    inFile = fopen(""input.img"", ""rb"");
    if(inFile == NULL) {
        printf(""Error opening input file.\\n"");
        return 1;
    }
    fread(buffer, sizeof(unsigned char), WIDTH * HEIGHT * 3, inFile);
    fclose(inFile);
    
    // Apply the transformations
    grayscale(buffer);
    flipHorizontally(buffer);
    flipVertically(buffer);
    
    // Write the output file
    outFile = fopen(""output.img"", ""wb"");
    if(outFile == NULL) {
        printf(""Error opening output file.\\n"");
        return 1;
    }
    fwrite(buffer, sizeof(unsigned char), WIDTH * HEIGHT * 3, outFile);
    fclose(outFile);
    
    printf(""Image processing complete.\\n"");
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall grayscale(_QWORD); // weak
__int64 __fastcall flipHorizontally(_QWORD); // weak
__int64 __fastcall flipVertically(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);


//----- (00000001400018A4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Buffer[67504]; // [rsp+20h] [rbp-60h] BYREF
  FILE *v5; // [rsp+107D0h] [rbp+10750h]
  FILE *Stream; // [rsp+107D8h] [rbp+10758h]

  _main(argc, argv, envp);
  Stream = fopen(""input.img"", ""rb"");
  if ( Stream )
  {
    fread(Buffer, 1ui64, 0x107ACui64, Stream);
    fclose(Stream);
    grayscale(Buffer);
    flipHorizontally(Buffer);
    flipVertically(Buffer);
    v5 = fopen(""output.img"", ""wb"");
    if ( v5 )
    {
      fwrite(Buffer, 1ui64, 0x107ACui64, v5);
      fclose(v5);
      printf(""Image processing complete.\\n"");
      return 0;
    }
    else
    {
      printf(""Error opening output file.\\n"");
      return 1;
    }
  }
  else
  {
    printf(""Error opening input file.\\n"");
    return 1;
  }
}
// 140001591: using guessed type __int64 __fastcall grayscale(_QWORD);
// 14000168E: using guessed type __int64 __fastcall flipHorizontally(_QWORD);
// 140001799: using guessed type __int64 __fastcall flipVertically(_QWORD);
// 140001AA0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define WIDTH 100
#define HEIGHT 100

// Function to convert RGB image to grayscale
void grayscale(unsigned char image[WIDTH][HEIGHT][3]) {
    unsigned char gray[WIDTH][HEIGHT];
    for (int i = 0; i < WIDTH; i++) {
        for (int j = 0; j < HEIGHT; j++) {
            gray[i][j] = (image[i][j][0] + image[i][j][1] + image[i][j][2]) / 3;
        }
    }
    memcpy(image, gray, sizeof(gray));
}

// Function to flip image horizontally
void flipHorizontally(unsigned char image[WIDTH][HEIGHT][3]) {
    unsigned char temp[WIDTH][HEIGHT][3];
    for (int i = 0; i < WIDTH; i++) {
        for (int j = 0; j < HEIGHT; j++) {
            for (int k = 0; k < 3; k++) {
                temp[i][j][k] = image[WIDTH - i - 1][j][k];
            }
        }
    }
    memcpy(image, temp, sizeof(temp));
}

// Function to flip image vertically
void flipVertically(unsigned char image[WIDTH][HEIGHT][3]) {
    unsigned char temp[WIDTH][HEIGHT][3];
    for (int i = 0; i < WIDTH; i++) {
        for (int j = 0; j < HEIGHT; j++) {
            for (int k = 0; k < 3; k++) {
                temp[i][j][k] = image[i][HEIGHT - j - 1][k];
            }
        }
    }
    memcpy(image, temp, sizeof(temp));
}

int main() {
    // Read image from file
    FILE *input = fopen(""input.img"", ""rb"");
    if (input == NULL) {
        printf(""Error opening input file.
"");
        return 1;
    }
    unsigned char image[WIDTH][HEIGHT][3];
    fread(image, sizeof(unsigned char), WIDTH * HEIGHT * 3, input);
    fclose(input);

    // Apply image processing functions
    grayscale(image);
    flipHorizontally(image);
    flipVertically(image);

    // Write image to file
    FILE *output = fopen(""output.img"", ""wb"");
    if (output == NULL) {
        printf(""Error opening output file.
"");
        return 1;
    }
    fwrite(image, sizeof(unsigned char), WIDTH * HEIGHT * 3, output);
    fclose(output);

    printf(""Image processing complete.
"");
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Temperature Converter ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>

int main() {
    float celsius, fahrenheit;
    int choice;
    printf(""Choose an option:\\n1. Celsius to Fahrenheit\\n2. Fahrenheit to Celsius\\n"");
    scanf(""%d"",&choice);
    switch(choice){
        case 1: // Celsius to Fahrenheit conversion
            printf(""Enter temperature in Celsius: "");
            scanf(""%f"", &celsius);
            fahrenheit = (celsius * 9 / 5) + 32;
            printf(""%.2fВ°C = %.2fВ°F"", celsius, fahrenheit);
            break;

        case 2: // Fahrenheit to Celsius conversion
            printf(""Enter temperature in Fahrenheit: "");
            scanf(""%f"", &fahrenheit);
            celsius = (fahrenheit - 32) * 5 / 9;
            printf(""%.2fВ°F = %.2fВ°C"", fahrenheit, celsius);
            break;

        default:
            printf(""Invalid option"");
            break;
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  float v5; // [rsp+28h] [rbp-8h] BYREF
  float v6; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf(""Choose an option:\\n1. Celsius to Fahrenheit\\n2. Fahrenheit to Celsius\\n"");
  scanf(""%d"", &v4);
  if ( v4 == 1 )
  {
    printf(""Enter temperature in Celsius: "");
    scanf(""%f"", &v6);
    v5 = (float)((float)(9.0 * v6) / 5.0) + 32.0;
    printf(""%.2fВ°C = %.2fВ°F"", v6, v5);
  }
  else if ( v4 == 2 )
  {
    printf(""Enter temperature in Fahrenheit: "");
    scanf(""%f"", &v5);
    v6 = (float)(5.0 * (float)(v5 - 32.0)) / 9.0;
    printf(""%.2fВ°F = %.2fВ°C"", v5, v6);
  }
  else
  {
    printf(""Invalid option"");
  }
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    float celsius, fahrenheit;
    int option;

    printf(""Choose an option:
1. Celsius to Fahrenheit
2. Fahrenheit to Celsius
"");
    scanf(""%d"", &option);

    if (option == 1) {
        printf(""Enter temperature in Celsius: "");
        scanf(""%f"", &celsius);

        fahrenheit = (celsius * 9 / 5) + 32;
        printf(""%.2fВ°C = %.2fВ°F"", celsius, fahrenheit);
    } else if (option == 2) {
        printf(""Enter temperature in Fahrenheit: "");
        scanf(""%f"", &fahrenheit);

        celsius = (fahrenheit - 32) * 5 / 9;
        printf(""%.2fВ°F = %.2fВ°C"", fahrenheit, celsius);
    } else {
        printf(""Invalid option"");
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Building a JSON Parser ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 1024

typedef enum {
    JSON_NULL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NUMBER,
    JSON_STRING,
    JSON_ARRAY,
    JSON_OBJECT
} json_value_type;

typedef struct {
    json_value_type type;
    union {
        double number;
        char *string;
        struct {
            struct json_node_t *head;
            struct json_node_t *tail;
        } array;
        struct {
            struct json_member_t *head;
            struct json_member_t *tail;
        } object;
    } value;
} json_value_t;

typedef struct json_node_t {
    json_value_t value;
    struct json_node_t *next;
} json_node_t;

typedef struct {
    char *key;
    int key_len;
    json_value_t value;
    struct json_member_t *next;
} json_member_t;

char *json_str;
char *pos;

json_value_t json_parse_value();

void skip_space() {
    while (*pos == ' ' || *pos == '\\n' || *pos == '\\r' || *pos == '\\t') {
        pos++;
    }
}

void next_expect(char c) {
    skip_space();
    if (*pos != c) {
        printf(""Expecting '%c' but found '%c'\\n"", c, *pos);
        exit(1);
    }
    pos++;
}

void parse_error(char *msg) {
    printf(""Error: %s\\n"", msg);
    exit(1);
}

void parse_number(json_value_t *value) {
    char *start = pos;
    if (*pos == '-') {
        pos++;
    }
    if (*pos == '0') {
        pos++;
    } else if (*pos >= '1' && *pos <= '9') {
        pos++;
        while (*pos >= '0' && *pos <= '9') {
            pos++;
        }
    } else {
        parse_error(""Invalid number format"");
    }
    if (*pos == '.') {
        pos++;
        if (*pos >= '0' && *pos <= '9') {
            pos++;
            while (*pos >= '0' && *pos <= '9') {
                pos++;
            }
        } else {
            parse_error(""Invalid number format"");
        }
    }
    if (*pos == 'e' || *pos == 'E') {
        pos++;
        if (*pos == '+' || *pos == '-') {
            pos++;
        }
        if (*pos >= '0' && *pos <= '9') {
            pos++;
            while (*pos >= '0' && *pos <= '9') {
                pos++;
            }
        } else {
            parse_error(""Invalid number format"");
        }
    }
    double number = atof(start);
    value->type = JSON_NUMBER;
    value->value.number = number;
}

void parse_string(json_value_t *value) {
    char *start = ++pos;
    char *cur = pos;
    while (*cur != '\\""' && *cur != '\\0') {
        if (*cur == '\\\\') {
            cur++;
        }
        cur++;
    }
    if (*cur == '\\0') {
        parse_error(""Expecting '\\""' but found EOF"");
    }
    int len = cur - start;
    value->type = JSON_STRING;
    value->value.string = (char *) malloc(len);
    memcpy(value->value.string, start, len);
    value->value.string[len] = '\\0';
    pos = cur + 1;
}

void parse_array(json_value_t *value) {
    pos++;
    json_node_t *head = NULL;
    json_node_t *tail = NULL;
    while (*pos != ']') {
        json_node_t *node = (json_node_t *) malloc(sizeof(json_node_t));
        node->value = json_parse_value();
        node->next = NULL;
        if (head == NULL) {
            head = node;
            tail = node;
        } else {
            tail->next = node;
            tail = node;
        }
        skip_space();
        if (*pos == ',') {
            pos++;
        } else if (*pos != ']') {
            parse_error(""Invalid syntax"");
        }
    }
    pos++;
    value->type = JSON_ARRAY;
    value->value.array.head = head;
    value->value.array.tail = tail;
}

void parse_object(json_value_t *value) {
    pos++;
    json_member_t *head = NULL;
    json_member_t *tail = NULL;
    while (*pos != '}') {
        char *key;
        int key_len;
        json_value_t key_value;
        skip_space();
        if (*pos != '\\""') {
            parse_error(""Expecting '\\""'"");
        }
        key = ++pos;
        while (*pos != '\\""' && *pos != '\\0') {
            if (*pos == '\\\\') {
                pos++;
            }
            pos++;
        }
        if (*pos == '\\0') {
            parse_error(""Expecting '\\""' but found EOF"");
        }
        key_len = pos - key;
        key_value.type = JSON_STRING;
        key_value.value.string = (char *) malloc(key_len);
        memcpy(key_value.value.string, key, key_len);
        key_value.value.string[key_len] = '\\0';
        pos++;
        next_expect(':');
        json_value_t value_value = json_parse_value();
        json_member_t *member = (json_member_t *) malloc(sizeof(json_member_t));
        member->key = key_value.value.string;
        member->key_len = key_len;
        member->value = value_value;
        member->next = NULL;
        if (head == NULL) {
            head = member;
            tail = member;
        } else {
            tail->next = member;
            tail = member;
        }
        skip_space();
        if (*pos == ',') {
            pos++;
        } else if (*pos != '}') {
            parse_error(""Invalid syntax"");
        }
    }
    pos++;
    value->type = JSON_OBJECT;
    value->value.object.head = head;
    value->value.object.tail = tail;
}

json_value_t json_parse_value() {
    skip_space();
    switch (*pos) {
        case 'n':
            if (strncmp(pos, ""null"", 4) == 0) {
                pos += 4;
                return (json_value_t) {JSON_NULL, {0}};
            } else {
                parse_error(""Invalid syntax"");
            }
            break;
        case 't':
            if (strncmp(pos, ""true"", 4) == 0) {
                pos += 4;
                return (json_value_t) {JSON_TRUE, {1}};
            } else {
                parse_error(""Invalid syntax"");
            }
            break;
        case 'f':
            if (strncmp(pos, ""false"", 5) == 0) {
                pos += 5;
                return (json_value_t) {JSON_FALSE, {0}};
            } else {
                parse_error(""Invalid syntax"");
            }
            break;
        case '\\""':
            {
                json_value_t value;
                parse_string(&value);
                return value;
            }
        case '[':
            {
                json_value_t value;
                parse_array(&value);
                return value;
            }
        case '{':
            {
                json_value_t value;
                parse_object(&value);
                return value;
            }
        case '-':
        case '0' ... '9':
            {
                json_value_t value;
                parse_number(&value);
                return value;
            }
        default:
            parse_error(""Invalid syntax"");
    }
}

json_value_t json_parse(char *str) {
    json_str = str;
    pos = json_str;
    return json_parse_value();
}

int main() {
    char str[MAX_LENGTH] = ""{\\""a\\"":\\""foo\\"",\\""b\\"":42.123,\\""c\\"":{\\""d\\"":[1,2,3],\\""e\\"":false}}"";
    json_value_t value = json_parse(str);
    printf(""Type: %d\\n"", value.type);
    switch (value.type) {
        case JSON_NULL:
            printf(""NULL\\n"");
            break;
        case JSON_TRUE:
            printf(""TRUE\\n"");
            break;
        case JSON_FALSE:
            printf(""FALSE\\n"");
            break;
        case JSON_NUMBER:
            printf(""NUMBER: %f\\n"", value.value.number);
            break;
        case JSON_STRING:
            printf(""STRING: %s\\n"", value.value.string);
            break;
        case JSON_ARRAY:
            {
                printf(""ARRAY:\\n"");
                json_node_t *p = value.value.array.head;
                while (p != NULL) {
                    printf(""  - "");
                    switch (p->value.type) {
                        case JSON_NULL:
                            printf(""NULL\\n"");
                            break;
                        case JSON_TRUE:
                            printf(""TRUE\\n"");
                            break;
                        case JSON_FALSE:
                            printf(""FALSE\\n"");
                            break;
                        case JSON_NUMBER:
                            printf(""NUMBER: %f\\n"", p->value.value.number);
                            break;
                        case JSON_STRING:
                            printf(""STRING: %s\\n"", p->value.value.string);
                            break;
                        case JSON_ARRAY:
                            printf(""ARRAY (length %d):\\n"", 0);
                            break;
                        case JSON_OBJECT:
                            printf(""OBJECT (keys %d):\\n"", 0);
                            break;
                    }
                    p = p->next;
                }
            }
            break;
        case JSON_OBJECT:
            {
                printf(""OBJECT:\\n"");
                json_member_t *p = value.value.object.head;
                while (p != NULL) {
                    printf(""  %.*s: "", p->key_len, p->key);
                    switch (p->value.type) {
                        case JSON_NULL:
                            printf(""NULL\\n"");
                            break;
                        case JSON_TRUE:
                            printf(""TRUE\\n"");
                            break;
                        case JSON_FALSE:
                            printf(""FALSE\\n"");
                            break;
                        case JSON_NUMBER:
                            printf(""NUMBER: %f\\n"", p->value.value.number);
                            break;
                        case JSON_STRING:
                            printf(""STRING: %s\\n"", p->value.value.string);
                            break;
                        case JSON_ARRAY:
                            printf(""ARRAY (length %d):\\n"", 0);
                            break;
                        case JSON_OBJECT:
                            printf(""OBJECT (keys %d):\\n"", 0);
                            break;
                    }
                    p = p->next;
                }
            }
            break;
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall json_parse(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000206B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+20h] [rbp-60h] BYREF
  const char *v5; // [rsp+28h] [rbp-58h]
  _DWORD v6[14]; // [rsp+40h] [rbp-40h] BYREF
  __int64 v7; // [rsp+78h] [rbp-8h]
  _BYTE v8[960]; // [rsp+80h] [rbp+0h] BYREF
  const char *j; // [rsp+440h] [rbp+3C0h]
  const char *i; // [rsp+448h] [rbp+3C8h]

  _main(argc, argv, envp);
  strcpy((char *)v6, ""{\\""a\\"":\\""foo\\"",\\""b\\"":42.123,\\""c\\"":{\\""d\\"":[1,2,3],\\""e\\"":false}}"");
  HIBYTE(v6[12]) = 0;
  v6[13] = 0;
  v7 = 0i64;
  memset(v8, 0, sizeof(v8));
  json_parse(&v4, v6);
  printf(""Type: %d\\n"", v4);
  switch ( v4 )
  {
    case 0u:
      printf(""NULL\\n"");
      break;
    case 1u:
      printf(""TRUE\\n"");
      break;
    case 2u:
      printf(""FALSE\\n"");
      break;
    case 3u:
      printf(""NUMBER: %f\\n"", *(double *)&v5);
      break;
    case 4u:
      printf(""STRING: %s\\n"", v5);
      break;
    case 5u:
      printf(""ARRAY:\\n"");
      for ( i = v5; i; i = (const char *)*((_QWORD *)i + 3) )
      {
        printf(""  - "");
        switch ( *(_DWORD *)i )
        {
          case 0:
            printf(""NULL\\n"");
            break;
          case 1:
            printf(""TRUE\\n"");
            break;
          case 2:
            printf(""FALSE\\n"");
            break;
          case 3:
            printf(""NUMBER: %f\\n"", *((double *)i + 1));
            break;
          case 4:
            printf(""STRING: %s\\n"", *((const char **)i + 1));
            break;
          case 5:
            printf(""ARRAY (length %d):\\n"", 0i64);
            break;
          case 6:
            printf(""OBJECT (keys %d):\\n"", 0i64);
            break;
          default:
            continue;
        }
      }
      break;
    case 6u:
      printf(""OBJECT:\\n"");
      for ( j = v5; j; j = (const char *)*((_QWORD *)j + 5) )
      {
        printf(""  %.*s: "", *((_DWORD *)j + 2), *(const char **)j);
        switch ( *((_DWORD *)j + 4) )
        {
          case 0:
            printf(""NULL\\n"");
            break;
          case 1:
            printf(""TRUE\\n"");
            break;
          case 2:
            printf(""FALSE\\n"");
            break;
          case 3:
            printf(""NUMBER: %f\\n"", *((double *)j + 3));
            break;
          case 4:
            printf(""STRING: %s\\n"", *((const char **)j + 3));
            break;
          case 5:
            printf(""ARRAY (length %d):\\n"", 0i64);
            break;
          case 6:
            printf(""OBJECT (keys %d):\\n"", 0i64);
            break;
          default:
            continue;
        }
      }
      break;
    default:
      return 0;
  }
  return 0;
}
// 14000202C: using guessed type __int64 __fastcall json_parse(_QWORD, _QWORD);
// 140002520: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=147 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_JSON_DEPTH 10

typedef enum {
    JSON_NULL,
    JSON_TRUE,
    JSON_FALSE,
    JSON_NUMBER,
    JSON_STRING,
    JSON_ARRAY,
    JSON_OBJECT
} JSONType;

typedef struct {
    JSONType type;
    union {
        double number;
        char *string;
        struct {
            int length;
            JSONType *items;
        } array;
        struct {
            int length;
            char **keys;
            JSONType *values;
        } object;
    } value;
} JSONValue;

JSONValue json_parse(char *json, int depth) {
    if (depth > MAX_JSON_DEPTH) {
        printf(""Maximum JSON depth exceeded!
"");
        exit(1);
    }

    JSONValue result;
    result.type = JSON_NULL;

    if (strcmp(json, ""null"") == 0) {
        result.type = JSON_NULL;
    } else if (strcmp(json, ""true"") == 0) {
        result.type = JSON_TRUE;
    } else if (strcmp(json, ""false"") == 0) {
        result.type = JSON_FALSE;
    } else if (json[0] == '""') {
        result.type = JSON_STRING;
        result.value.string = json + 1;
        int len = strlen(result.value.string);
        result.value.string[len - 1] = '",2
"//FormAI DATASET v1.0 Category: File Encyptor ; Style: automated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 1024

void encrypt(char *cipher_text, int key)
{
    int len = strlen(cipher_text);
    for(int i=0;i<len;i++)
        cipher_text[i] += key;
}

void decrypt(char *cipher_text, int key)
{
    int len = strlen(cipher_text);
    for(int i=0;i<len;i++)
        cipher_text[i] -= key;
}

int main(){
    char cipher_text[MAX_SIZE];
    int key;

    printf(""Enter text to encrypt: "");
    fgets(cipher_text, MAX_SIZE, stdin);

    printf(""Enter key: "");
    scanf(""%d"", &key);

    printf(""Original Text: %s\\n"", cipher_text);

    encrypt(cipher_text, key);
    printf(""Encrypted Text: %s\\n"", cipher_text);

    decrypt(cipher_text, key);
    printf(""Decrypted Text: %s\\n"", cipher_text);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (00000001400016A5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char Buffer[1024]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  printf(""Enter text to encrypt: "");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 1024, v3);
  printf(""Enter key: "");
  scanf(""%d"", &v5);
  printf(""Original Text: %s\\n"", Buffer);
  encrypt(Buffer, v5);
  printf(""Encrypted Text: %s\\n"", Buffer);
  decrypt(Buffer, v5);
  printf(""Decrypted Text: %s\\n"", Buffer);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 140001643: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <string.h>

void encrypt(char *str, int key) {
    int len = strlen(str);
    for (int i = 0; i < len; i++) {
        str[i] = str[i] + key;
    }
}

void decrypt(char *str, int key) {
    int len = strlen(str);
    for (int i = 0; i < len; i++) {
        str[i] = str[i] - key;
    }
}

int main() {
    char text[1024];
    int key;

    printf(""Enter text to encrypt: "");
    fgets(text, 1024, stdin);

    printf(""Enter key: "");
    scanf(""%d"", &key);

    printf(""Original Text: %s
"", text);

    encrypt(text, key);
    printf(""Encrypted Text: %s
"", text);

    decrypt(text, key);
    printf(""Decrypted Text: %s
"", text);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: URL Sanitizer ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_URL_LENGTH 2048

// Function to replace characters with underscores
void sanitize(char* url) {
    int i, len = strlen(url);
    for(i = 0; i < len; i++) {
        if(!isalnum(url[i]) && url[i] != '.' && url[i] != '/' && url[i] != '-' && url[i] != '_') {
            url[i] = '_';
        }
    }
}

int main() {
    printf(""Enter a URL:\\n"");

    // Allocate memory for URL string
    char* url = (char*) malloc(sizeof(char) * MAX_URL_LENGTH);

    // Get URL input from user
    fgets(url, MAX_URL_LENGTH, stdin);
    url[strcspn(url, ""\\n"")] = 0;

    // Sanitize URL
    sanitize(url);

    // Print sanitized URL
    printf(""Sanitized URL: %s\\n"", url);

    free(url);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall sanitize(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (000000014000164F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rdx
  char *Buffer; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  printf(""Enter a URL:\\n"");
  Buffer = (char *)malloc(0x800ui64);
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 2048, v3);
  Buffer[strcspn(Buffer, ""\\n"")] = 0;
  sanitize(Buffer);
  printf(""Sanitized URL: %s\\n"", Buffer);
  free(Buffer);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall sanitize(_QWORD);
// 1400017B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void sanitize(char *url) {
    int i, j;
    char *temp = (char *)malloc(strlen(url) * sizeof(char));
    for (i = 0, j = 0; i < strlen(url); i++) {
        if (url[i] == '<' || url[i] == '>' || url[i] == '""' || url[i] == ''' || url[i] == '\\') {
            continue;
        } else {
            temp[j++] = url[i];
        }
    }
    temp[j] = '",2
"//FormAI DATASET v1.0 Category: Percolation Simulator ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define FILL_PROB 0.6 // Probability of filling a site
#define SIZE 20 // Grid size

// Struct for a site
typedef struct {
    int x;
    int y;
    int filled;
} Site;

// Prints the grid
void print_grid(Site grid[SIZE][SIZE]) {
    int i, j;
    printf(""\\n"");
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            if (grid[i][j].filled) {
                printf(""в–€ "");
            } else {
                printf(""  "");
            }
        }
        printf(""\\n"");
    }
    printf(""\\n"");
}

int main() {
    Site grid[SIZE][SIZE];
    int i, j, k;

    // Initialize grid
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            grid[i][j].x = i;
            grid[i][j].y = j;
            grid[i][j].filled = 0;
        }
    }

    // Fill random sites
    srand(time(NULL));
    for (k = 1; k <= 10; k++) {
        for (i = 0; i < SIZE; i++) {
            for (j = 0; j < SIZE; j++) {
                if ((double) rand() / RAND_MAX < FILL_PROB) {
                    grid[i][j].filled = 1;
                }
            }
        }
        print_grid(grid);
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall print_grid(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (000000014000167C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[96]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v6[4708]; // [rsp+80h] [rbp+0h] BYREF
  int k; // [rsp+12E4h] [rbp+1264h]
  int j; // [rsp+12E8h] [rbp+1268h]
  int i; // [rsp+12ECh] [rbp+126Ch]

  _main(argc, argv, envp);
  for ( i = 0; i <= 19; ++i )
  {
    for ( j = 0; j <= 19; ++j )
    {
      *(_DWORD *)&v6[240 * i - 96 + 12 * j] = i;
      *(_DWORD *)&v6[240 * i - 92 + 12 * j] = j;
      *(_DWORD *)&v6[240 * i - 88 + 12 * j] = 0;
    }
  }
  v3 = time(0i64);
  srand(v3);
  for ( k = 1; k <= 10; ++k )
  {
    for ( i = 0; i <= 19; ++i )
    {
      for ( j = 0; j <= 19; ++j )
      {
        if ( (double)rand() / 32767.0 < 0.6 )
          *(_DWORD *)&v6[240 * i - 88 + 12 * j] = 1;
      }
    }
    print_grid(v5);
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall print_grid(_QWORD);
// 140001980: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000167C: using guessed type char var_12D0[96];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 20
#define COLS 20
#define PROB 0.6

typedef struct {
    int row;
    int col;
    int alive;
} Cell;

void print_grid(Cell grid[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (grid[i][j].alive) {
                printf(""* "");
            } else {
                printf("". "");
            }
        }
        printf(""
"");
    }
}

int main() {
    Cell grid[ROWS][COLS];
    int i, j;

    // Initialize grid with all cells dead
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            grid[i][j].row = i;
            grid[i][j].col = j;
            grid[i][j].alive = 0;
        }
    }

    // Randomly set some cells to be alive
    srand(time(NULL));
    for (int k = 1; k <= 10; k++) {
        for (i = 0; i < ROWS; i++) {
            for (j = 0; j < COLS; j++) {
                if ((double)rand() / RAND_MAX < PROB) {
                    grid[i][j].alive = 1;
                }
            }
        }
        print_grid(grid);
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Metadata Extractor ; Style: multivariable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct metadata {
  char author[20];
  char title[50];
  char date[20];
  char version[10];
} Metadata;

Metadata extractMetadata(char* filename) {
  FILE* fp = fopen(filename, ""r"");
  Metadata metadata;
  if (fp == NULL) {
    printf(""Unable to open file '%s'\\n"", filename);
    exit(0);
  }
  char line[100];
  char* token;
  while (fgets(line, sizeof(line), fp)) {
    if (strstr(line, ""Author:"")) {
      token = strtok(line, "":"");
      strcpy(metadata.author, strtok(NULL, ""\\n""));
    } else if (strstr(line, ""Title:"")) {
      token = strtok(line, "":"");
      strcpy(metadata.title, strtok(NULL, ""\\n""));
    } else if (strstr(line, ""Date:"")) {
      token = strtok(line, "":"");
      strcpy(metadata.date, strtok(NULL, ""\\n""));
    } else if (strstr(line, ""Version:"")) {
      token = strtok(line, "":"");
      strcpy(metadata.version, strtok(NULL, ""\\n""));
    }
  }
  fclose(fp);
  return metadata;
}

int main() {
  char filename[50];
  printf(""Enter filename:"");
  scanf(""%s"", filename);
  Metadata metadata = extractMetadata(filename);
  printf(""\\nMetadata for file '%s':\\n"", filename);
  printf(""Author: %s\\n"", metadata.author);
  printf(""Title: %s\\n"", metadata.title);
  printf(""Date: %s\\n"", metadata.date);
  printf(""Version: %s\\n"", metadata.version);
  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall extractMetadata(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000186B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[20]; // [rsp+20h] [rbp-B0h] BYREF
  char v5[50]; // [rsp+34h] [rbp-9Ch] BYREF
  char v6[20]; // [rsp+66h] [rbp-6Ah] BYREF
  char v7[22]; // [rsp+7Ah] [rbp-56h] BYREF
  char v8[64]; // [rsp+90h] [rbp-40h] BYREF

  _main(argc, argv, envp);
  printf(""Enter filename:"");
  scanf(""%s"", v8);
  extractMetadata(v4, v8);
  printf(""\\nMetadata for file '%s':\\n"", v8);
  printf(""Author: %s\\n"", v4);
  printf(""Title: %s\\n"", v5);
  printf(""Date: %s\\n"", v6);
  printf(""Version: %s\\n"", v7);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall extractMetadata(_QWORD, _QWORD);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000186B: using guessed type char anonymous_0[50];
// 14000186B: using guessed type char anonymous_1[20];
// 14000186B: using guessed type char anonymous_2[22];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a struct to hold metadata
typedef struct {
    char author[50];
    char title[50];
    char date[20];
    char version[20];
} Metadata;

// Function to extract metadata from a file
void extractMetadata(Metadata *metadata, char *filename) {
    FILE *file = fopen(filename, ""r"");
    if (file == NULL) {
        printf(""Error: Could not open file '%s'
"", filename);
        exit(1);
    }

    char line[100];
    while (fgets(line, sizeof(line), file)) {
        if (strstr(line, ""Author: "")) {
            strcpy(metadata->author, line + strlen(""Author: ""));
        } else if (strstr(line, ""Title: "")) {
            strcpy(metadata->title, line + strlen(""Title: ""));
        } else if (strstr(line, ""Date: "")) {
            strcpy(metadata->date, line + strlen(""Date: ""));
        } else if (strstr(line, ""Version: "")) {
            strcpy(metadata->version, line + strlen(""Version: ""));
        }
    }

    fclose(file);
}

int main() {
    char filename[50];
    printf(""Enter filename:"");
    scanf(""%s"", filename);

    Metadata metadata;
    extractMetadata(&metadata, filename);

    printf(""
Metadata for file '%s':
"", filename);
    printf(""Author: %s
"", metadata.author);
    printf(""Title: %s
"", metadata.title);
    printf(""Date: %s
"", metadata.date);
    printf(""Version: %s
"", metadata.version);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Graph Coloring Problem ; Style: irregular
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>

#define V 7 //number of vertices

bool isSafe(int vertex, int graph[V][V], int color[], int c)
{
    for(int i=0; i<V; i++)
    {
        if(graph[vertex][i] && c==color[i])
            return false;
    }
    return true;
}

bool graphColoring(int graph[V][V], int m, int color[], int vertex)
{
    if(vertex == V)
        return true;
    for(int c=1; c<=m; c++)
    {
        if(isSafe(vertex, graph, color, c))
        {
            color[vertex] = c;
            if(graphColoring(graph, m, color, vertex+1))
                return true;
            color[vertex] = 0;
        }
    }
    return false;
}

int main()
{
    int graph[V][V] = {{0, 1, 0, 1, 0, 0, 0}, //irregular adjacency matrix
                       {1, 0, 1, 1, 0, 0, 0}, 
                       {0, 1, 0, 0, 1, 0, 1}, 
                       {1, 1, 0, 0, 1, 1, 0}, 
                       {0, 0, 1, 1, 0, 1, 0}, 
                       {0, 0, 0, 1, 1, 0, 1}, 
                       {0, 0, 1, 0, 0, 1, 0}}; 
    int m = 3; //number of colors
    int color[V];
    for(int i=0; i<V; i++)
        color[i] = 0;
    if(graphColoring(graph, m, color, 0))
    {
        printf(""The vertex colors are: \\n"");
        for(int i=0; i<V; i++)
            printf(""%d "", color[i]);
    }
    else
        printf(""No solution exists"");
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall graphColoring(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016D8) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[8]; // [rsp+20h] [rbp-60h] BYREF
  int v5[49]; // [rsp+40h] [rbp-40h] BYREF
  unsigned int v6; // [rsp+104h] [rbp+84h]
  int j; // [rsp+108h] [rbp+88h]
  int i; // [rsp+10Ch] [rbp+8Ch]

  _main(argc, argv, envp);
  v5[0] = 0;
  v5[1] = 1;
  v5[2] = 0;
  v5[3] = 1;
  v5[4] = 0;
  v5[5] = 0;
  v5[6] = 0;
  v5[7] = 1;
  v5[8] = 0;
  v5[9] = 1;
  v5[10] = 1;
  v5[11] = 0;
  v5[12] = 0;
  v5[13] = 0;
  v5[14] = 0;
  v5[15] = 1;
  v5[16] = 0;
  v5[17] = 0;
  v5[18] = 1;
  v5[19] = 0;
  v5[20] = 1;
  v5[21] = 1;
  v5[22] = 1;
  v5[23] = 0;
  v5[24] = 0;
  v5[25] = 1;
  v5[26] = 1;
  v5[27] = 0;
  v5[28] = 0;
  v5[29] = 0;
  v5[30] = 1;
  v5[31] = 1;
  v5[32] = 0;
  v5[33] = 1;
  v5[34] = 0;
  v5[35] = 0;
  v5[36] = 0;
  v5[37] = 0;
  v5[38] = 1;
  v5[39] = 1;
  v5[40] = 0;
  v5[41] = 1;
  v5[42] = 0;
  v5[43] = 0;
  v5[44] = 1;
  v5[45] = 0;
  v5[46] = 0;
  v5[47] = 1;
  v5[48] = 0;
  v6 = 3;
  for ( i = 0; i <= 6; ++i )
    v4[i] = 0;
  if ( (unsigned __int8)graphColoring(v5, v6, v4, 0i64) )
  {
    printf(""The vertex colors are: \\n"");
    for ( j = 0; j <= 6; ++j )
      printf(""%d "", (unsigned int)v4[j]);
  }
  else
  {
    printf(""No solution exists"");
  }
  return 0;
}
// 140001612: using guessed type __int64 __fastcall graphColoring(_QWORD, _QWORD, _QWORD, _QWORD);
// 1400019C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400016D8: using guessed type int var_F0[8];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

//Defining the graph
int graph[8][8] = {
    {0, 1, 0, 1, 0, 0, 0, 1},
    {1, 0, 1, 1, 0, 1, 0, 1},
    {0, 1, 0, 0, 1, 0, 1, 0},
    {1, 1, 0, 0, 1, 1, 0, 1},
    {0, 0, 1, 1, 0, 1, 0, 0},
    {0, 1, 0, 1, 1, 0, 1, 0},
    {0, 0, 1, 0, 0, 1, 0, 1},
    {1, 1, 0, 1, 0, 0, 1, 0}
};

//Function to check if the vertex is safe to color
bool isSafe(int graph[8][8], int vertex, int color, int colors[], int n) {
    for (int i = 0; i < n; i++) {
        if (graph[vertex][i] && colors[i] == color) {
            return false;
        }
    }
    return true;
}

//Function to perform graph coloring
bool graphColoring(int graph[8][8], int n, int colors[], int vertex) {
    if (vertex == n) {
        return true;
    }
    for (int color = 1; color <= n; color++) {
        if (isSafe(graph, vertex, color, colors, n)) {
            colors[vertex] = color;
            if (graphColoring(graph, n, colors, vertex + 1)) {
                return true;
            }
            colors[vertex] = 0;
        }
    }
    return false;
}

int main() {
    int n = 8; //Number of vertices
    int colors[n]; //Array to store the vertex colors
    for (int i = 0; i < n; i++) {
        colors[i] = 0; //Initializing all the vertex colors to 0
    }
    if (graphColoring(graph, n, colors, 0)) {
        printf(""The vertex colors are: 
"");
        for (int i = 0; i < n; i++) {
            printf(""%d "", colors[i]);
        }
    } else {
        printf(""No solution exists"");
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Digital signal processing ; Style: shape shifting
/* This program uses digital signal processing techniques to shape shift a sound signal. 
It takes an input audio file and applies filters and modulation effects to transform it into a new sound. */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define MAX_SAMPLE 44100
#define MAX_FREQ 22050
#define PI 3.14159265358979323846

double input_signal[MAX_SAMPLE];
double output_signal[MAX_SAMPLE];

double freq_modulation[MAX_SAMPLE];
double amplitude_modulation[MAX_SAMPLE];

double lowpass_filter[MAX_SAMPLE];
double highpass_filter[MAX_SAMPLE];

double resonance = 0.8;

double lfo_frequency = 0.5;
double modulation_depth = 0.02;

int main(int argc, char *argv[]) {

    if (argc < 2) {
        printf(""ERROR: No input file specified.\\n"");
        return 1;
    }

    char *input_filename = argv[1];
    char *output_filename = ""output.wav"";

    double cutoff_frequency = 1000.0;

    // Load input signal
    FILE *input_file = fopen(input_filename, ""rb"");
    if (!input_file) {
        printf(""ERROR: Failed to open input file.\\n"");
        return 1;
    }

    int num_samples = 0;

    while (!feof(input_file) && num_samples < MAX_SAMPLE) {
        fread(&input_signal[num_samples], sizeof(double), 1, input_file);
        num_samples++;
    }

    fclose(input_file);

    // Create lowpass filter
    for (int i = 0; i < MAX_FREQ; i++) {
        double frequency_ratio = ((double)i) / MAX_FREQ;
        lowpass_filter[i] = 1.0 / (1.0 + pow((frequency_ratio / cutoff_frequency), 2 * resonance));
    }

    // Create highpass filter
    for (int i = 0; i < MAX_FREQ; i++) {
        double frequency_ratio = ((double)i) / MAX_FREQ;
        highpass_filter[i] = frequency_ratio / (cutoff_frequency + pow(frequency_ratio, 2 * resonance));
    }

    // Create frequency modulation LFO
    for (int i = 0; i < num_samples; i++) {
        freq_modulation[i] = sin(2 * PI * lfo_frequency * ((double)i) / MAX_SAMPLE);
    }

    // Create amplitude modulation LFO
    for (int i = 0; i < num_samples; i++) {
        amplitude_modulation[i] = 1.0 + modulation_depth * sin(2 * PI * lfo_frequency * ((double)i) / MAX_SAMPLE);
    }

    // Apply lowpass filter
    for (int i = 0; i < num_samples; i++) {
        double filtered_signal = 0.0;
        for (int j = 0; j < MAX_FREQ; j++) {
            if (j <= i) {
                filtered_signal += input_signal[i - j] * lowpass_filter[j];
            }
        }
        output_signal[i] = filtered_signal;
    }

    // Apply highpass filter
    for (int i = 0; i < num_samples; i++) {
        double filtered_signal = 0.0;
        for (int j = 0; j < MAX_FREQ; j++) {
            if (j <= i) {
                filtered_signal += input_signal[i - j] * highpass_filter[j];
            }
        }
        output_signal[i] = filtered_signal;
    }

    // Apply frequency modulation
    for (int i = 0; i < num_samples; i++) {
        double modulated_frequency = MAX_FREQ + MAX_FREQ * freq_modulation[i];
        double modulated_index = MAX_SAMPLE * modulated_frequency / MAX_FREQ;
        output_signal[i] = input_signal[(int)modulated_index];
    }

    // Apply amplitude modulation
    for (int i = 0; i < num_samples; i++) {
        output_signal[i] *= amplitude_modulation[i];
    }

    // Write output signal to file
    FILE *output_file = fopen(output_filename, ""wb"");
    if (!output_file) {
        printf(""ERROR: Failed to open output file.\\n"");
        return 1;
    }

    for (int i = 0; i < num_samples; i++) {
        fwrite(&output_signal[i], sizeof(double), 1, output_file);
    }

    fclose(output_file);

    printf(""Output saved to %s\\n"", output_filename);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl feof(FILE *Stream);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

__int64 resonance = 4605380978949069210i64; // weak
__int64 lfo_frequency = 4602678819172646912i64; // weak
__int64 modulation_depth = 4581421828931458171i64; // weak
double input_signal[44100]; // weak
double output_signal[44100]; // weak
double freq_modulation[44100]; // weak
double amplitude_modulation[44100]; // weak
double lowpass_filter[44100]; // weak
double highpass_filter[44100]; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v4; // [rsp+48h] [rbp-68h]
  FILE *Stream; // [rsp+50h] [rbp-60h]
  int i2; // [rsp+70h] [rbp-40h]
  int i1; // [rsp+74h] [rbp-3Ch]
  int nn; // [rsp+78h] [rbp-38h]
  int mm; // [rsp+7Ch] [rbp-34h]
  double v10; // [rsp+80h] [rbp-30h]
  int kk; // [rsp+88h] [rbp-28h]
  int jj; // [rsp+8Ch] [rbp-24h]
  double v13; // [rsp+90h] [rbp-20h]
  int ii; // [rsp+98h] [rbp-18h]
  int n; // [rsp+9Ch] [rbp-14h]
  int m; // [rsp+A0h] [rbp-10h]
  int k; // [rsp+A4h] [rbp-Ch]
  int j; // [rsp+A8h] [rbp-8h]
  int i; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    Stream = fopen(argv[1], ""rb"");
    if ( Stream )
    {
      for ( i = 0; !feof(Stream) && i <= 44099; ++i )
        fread(&input_signal[i], 8ui64, 1ui64, Stream);
      fclose(Stream);
      for ( j = 0; j <= 22049; ++j )
        lowpass_filter[j] = 1.0
                          / (pow((double)j / 22050.0 / 1000.0, *(double *)&resonance + *(double *)&resonance) + 1.0);
      for ( k = 0; k <= 22049; ++k )
        highpass_filter[k] = (double)k
                           / 22050.0
                           / (pow((double)k / 22050.0, *(double *)&resonance + *(double *)&resonance) + 1000.0);
      for ( m = 0; m < i; ++m )
        freq_modulation[m] = sin((double)m * (*(double *)&lfo_frequency * 6.283185307179586) / 44100.0);
      for ( n = 0; n < i; ++n )
        amplitude_modulation[n] = *(double *)&modulation_depth
                                * sin((double)n * (*(double *)&lfo_frequency * 6.283185307179586) / 44100.0)
                                + 1.0;
      for ( ii = 0; ii < i; ++ii )
      {
        v13 = 0.0;
        for ( jj = 0; jj <= 22049; ++jj )
        {
          if ( jj <= ii )
            v13 = lowpass_filter[jj] * input_signal[ii - jj] + v13;
        }
        output_signal[ii] = v13;
      }
      for ( kk = 0; kk < i; ++kk )
      {
        v10 = 0.0;
        for ( mm = 0; mm <= 22049; ++mm )
        {
          if ( mm <= kk )
            v10 = highpass_filter[mm] * input_signal[kk - mm] + v10;
        }
        output_signal[kk] = v10;
      }
      for ( nn = 0; nn < i; ++nn )
        output_signal[nn] = input_signal[(int)(44100.0 * (freq_modulation[nn] * 22050.0 + 22050.0) / 22050.0)];
      for ( i1 = 0; i1 < i; ++i1 )
        output_signal[i1] = amplitude_modulation[i1] * output_signal[i1];
      v4 = fopen(""output.wav"", ""wb"");
      if ( v4 )
      {
        for ( i2 = 0; i2 < i; ++i2 )
          fwrite(&output_signal[i2], 8ui64, 1ui64, v4);
        fclose(v4);
        printf(""Output saved to %s\\n"", ""output.wav"");
        return 0;
      }
      else
      {
        printf(""ERROR: Failed to open output file.\\n"");
        return 1;
      }
    }
    else
    {
      printf(""ERROR: Failed to open input file.\\n"");
      return 1;
    }
  }
  else
  {
    printf(""ERROR: No input file specified.\\n"");
    return 1;
  }
}
// 140001C50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000B010: using guessed type __int64 resonance;
// 14000B018: using guessed type __int64 lfo_frequency;
// 14000B020: using guessed type __int64 modulation_depth;
// 140010040: using guessed type double input_signal[44100];
// 140066260: using guessed type double output_signal[44100];
// 1400BC480: using guessed type double freq_modulation[44100];
// 1401126A0: using guessed type double amplitude_modulation[44100];
// 1401688C0: using guessed type double lowpass_filter[44100];
// 1401BEAE0: using guessed type double highpass_filter[44100];

// nfuncs=148 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
"," Code generated by the 'Clang 6.0 (trunk 3183533)' compiler.
//
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Clang 6.0 (trunk 3183533) compiler.
// This is a sample of a C program generated by the Cl",0
"//FormAI DATASET v1.0 Category: Banking Record System ; Style: futuristic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_CUSTOMERS 1000

struct Customer {
    int id;
    char name[50];
    double balance;
};

struct Bank {
    struct Customer customers[MAX_CUSTOMERS];
    int num_customers;
};

struct Bank myBank;

// Function to add a new customer to the bank's record
void addCustomer(int id, char name[], double balance) {
    if (myBank.num_customers >= MAX_CUSTOMERS) {
        printf(""Error: Maximum number of customers reached!\\n"");
        return;
    }

    struct Customer newCustomer;
    newCustomer.id = id;
    strcpy(newCustomer.name, name);
    newCustomer.balance = balance;

    myBank.customers[myBank.num_customers] = newCustomer;
    myBank.num_customers++;
    printf(""New customer added successfully!\\n"");
}

// Function to display all of the bank's customers
void displayAllCustomers() {
    printf(""Customer ID\\tName\\t\\tBalance\\n"");
    printf(""----------------------------------------\\n"");

    for (int i = 0; i < myBank.num_customers; i++) {
        printf(""%d\\t\\t%s\\t\\t$%.2f\\n"", myBank.customers[i].id,
            myBank.customers[i].name, myBank.customers[i].balance);
    }
}

// Function to search for a customer by name
void searchCustomerByName(char name[]) {
    printf(""Search Results:\\n"");
    printf(""Customer ID\\tName\\t\\tBalance\\n"");
    printf(""----------------------------------------\\n"");

    int found = 0;
    for (int i = 0; i < myBank.num_customers; i++) {
        if (strcmp(myBank.customers[i].name, name) == 0) {
            printf(""%d\\t\\t%s\\t\\t$%.2f\\n"", myBank.customers[i].id,
                myBank.customers[i].name, myBank.customers[i].balance);
            found = 1;
        }
    }

    if (!found) {
        printf(""No results found for \\""%s\\""\\n"", name);
    }
}

// Function to search for a customer by ID
void searchCustomerById(int id) {
    printf(""Search Results:\\n"");
    printf(""Customer ID\\tName\\t\\tBalance\\n"");
    printf(""----------------------------------------\\n"");

    int found = 0;
    for (int i = 0; i < myBank.num_customers; i++) {
        if (myBank.customers[i].id == id) {
            printf(""%d\\t\\t%s\\t\\t$%.2f\\n"", myBank.customers[i].id,
                myBank.customers[i].name, myBank.customers[i].balance);
            found = 1;
            break;
        }
    }

    if (!found) {
        printf(""No results found for ID %d\\n"", id);
    }
}

// Function to remove a customer from the bank's record
void removeCustomer(int id) {
    int found = 0;
    for (int i = 0; i < myBank.num_customers; i++) {
        if (myBank.customers[i].id == id) {
            // Shift all customers after this one down one index
            for (int j = i; j < myBank.num_customers - 1; j++) {
                myBank.customers[j] = myBank.customers[j+1];
            }
            myBank.num_customers--;
            found = 1;
            break;
        }
    }

    if (found) {
        printf(""Customer with ID %d successfully removed!\\n"", id);
    }
    else {
        printf(""No customer found with ID %d\\n"", id);
    }
}

int main() {
    myBank.num_customers = 0;

    addCustomer(1001, ""Jane Smith"", 1500.00);
    addCustomer(1002, ""John Doe"", 2500.00);
    addCustomer(1003, ""Samuel Johnson"", 1000.00);

    displayAllCustomers();

    searchCustomerByName(""John Doe"");

    searchCustomerById(1003);

    removeCustomer(1002);

    displayAllCustomers();

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall addCustomer(_QWORD, _QWORD); // weak
__int64 displayAllCustomers(void); // weak
__int64 __fastcall searchCustomerByName(_QWORD); // weak
__int64 __fastcall searchCustomerById(_QWORD); // weak
__int64 __fastcall removeCustomer(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

int dword_14001EA40; // weak


//----- (0000000140001A8C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  dword_14001EA40 = 0;
  addCustomer(1001i64, ""Jane Smith"");
  addCustomer(1002i64, ""John Doe"");
  addCustomer(1003i64, ""Samuel Johnson"");
  displayAllCustomers();
  searchCustomerByName(""John Doe"");
  searchCustomerById(1003i64);
  removeCustomer(1002i64);
  displayAllCustomers();
  return 0;
}
// 140001591: using guessed type __int64 __fastcall addCustomer(_QWORD, _QWORD);
// 140001670: using guessed type __int64 displayAllCustomers(void);
// 140001726: using guessed type __int64 __fastcall searchCustomerByName(_QWORD);
// 140001846: using guessed type __int64 __fastcall searchCustomerById(_QWORD);
// 140001957: using guessed type __int64 __fastcall removeCustomer(_QWORD);
// 140001BF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14001EA40: using guessed type int dword_14001EA40;

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum number of customers
#define MAX_CUSTOMERS 100

// Define the structure for a customer
typedef struct {
    int id;
    char name[50];
} Customer;

// Define an array to hold the customers
Customer customers[MAX_CUSTOMERS];

// Define a variable to keep track of the number of customers
int numCustomers = 0;

// Function to add a new customer
void addCustomer(int id, char* name) {
    // Check if the customer already exists
    for (int i = 0; i < numCustomers; i++) {
        if (customers[i].id == id) {
            printf(""Customer with ID %d already exists.
"", id);
            return;
        }
    }
    
    // Add the new customer to the array
    Customer newCustomer;
    newCustomer.id = id;
    strcpy(newCustomer.name, name);
    customers[numCustomers] = newCustomer;
    numCustomers++;
    
    printf(""Customer with ID %d added successfully.
"", id);
}

// Function to display all customers
void displayAllCustomers() {
    if (numCustomers == 0) {
        printf(""No customers found.
"");
        return;
    }
    
    printf(""ID	Name
"");
    for (int i = 0; i < numCustomers; i++) {
        printf(""%d	%s
"", customers[i].id, customers[i].name);
    }
}

// Function to search for a customer by name
void searchCustomerByName(char* name) {
    for (int i = 0; i < numCustomers; i++) {
        if (strcmp(customers[i].name, name) == 0) {
            printf(""Customer with name %s found.
"", name);
            printf(""ID: %d
"", customers[i].id);
            return;
        }
    }
    
    printf(""Customer with name %s not found.
"", name);
}

// Function to search for a customer by ID
void searchCustomerById(int id) {
    for (int i = 0; i < numCustomers; i++) {
        if (customers[i].id == id) {
            printf(""Customer with ID %d found.
"", id);
            printf(""Name: %s
"", customers[i].name);
            return;
        }
    }
    
    printf(""Customer with ID %d not found.
"", id);
}

// Function to remove a customer
void removeCustomer(int id) {
    for (int i = 0; i < numCustomers; i++) {
        if (customers[i].id == id) {
            for (int j = i; j < numCustomers - 1; j++) {
                customers[j] = customers[j+1];
            }
            numCustomers--;
            printf(""Customer with ID %d removed successfully.
"", id);
            return;
        }
    }
    
    printf(""Customer with ID %d not found.
"", id);
}

// Main function
int main() {
    // Add some customers
    addCustomer(1001, ""Jane Smith"");
    addCustomer(1002, ""John Doe"");
    addCustomer(1003, ""Samuel Johnson"");
    
    // Display all customers
    displayAllCustomers();
    
    // Search for a customer by name
    searchCustomerByName(""John Doe"");
    
    // Search for a customer by ID
    searchCustomerById(1003);
    
    // Remove a customer
    removeCustomer(1002);
    
    // Display all customers again
    displayAllCustomers();
    
    return 0;
}
// } Driver",2
"//FormAI DATASET v1.0 Category: Hotel Management System ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
  char name[50];
  int roomNumber;
  int nights;
  double pricePerNight;
  double totalPrice;
} Booking;

void printMenu();
void addBooking();
void viewBookings();
void deleteBooking();
void editBooking();
void saveBookings();
void loadBookings();

Booking bookings[100];
int bookingCount = 0;

int main() {
  loadBookings();

  int choice;
  do {
    printMenu();
    printf(""Enter your choice: "");
    scanf(""%d"", &choice);
    switch (choice) {
      case 1:
        addBooking();
        break;
      case 2:
        viewBookings();
        break;
      case 3:
        deleteBooking();
        break;
      case 4:
        editBooking();
        break;
      case 5:
        saveBookings();
        break;
      case 6:
        printf(""Exiting program...\\n"");
        break;
      default:
        printf(""Invalid choice!\\n"");
        break;
    }
  } while (choice != 6);

  return 0;
}

void printMenu() {
  printf(""==========================================\\n"");
  printf(""=== Welcome to the C Hotel Management System ===\\n"");
  printf(""==========================================\\n"");
  printf(""1. Add Booking\\n"");
  printf(""2. View Bookings\\n"");
  printf(""3. Delete Booking\\n"");
  printf(""4. Edit Booking\\n"");
  printf(""5. Save Bookings\\n"");
  printf(""6. Exit\\n"");
}

void addBooking() {
  printf(""Adding Booking...\\n"");
  Booking booking;
  printf(""Enter name: "");
  scanf(""%s"", booking.name);
  printf(""Enter room number: "");
  scanf(""%d"", &booking.roomNumber);
  printf(""Enter number of nights: "");
  scanf(""%d"", &booking.nights);
  printf(""Enter price per night: "");
  scanf(""%lf"", &booking.pricePerNight);
  booking.totalPrice = booking.nights * booking.pricePerNight;
  bookings[bookingCount++] = booking;
  printf(""Booking added!\\n"");
}

void viewBookings() {
  printf(""Viewing Bookings...\\n"");
  if (bookingCount == 0) {
    printf(""No bookings to display.\\n"");
    return;
  }
  for (int i = 0; i < bookingCount; i++) {
    Booking booking = bookings[i];
    printf(""Name: %s | Room Number: %d | Nights: %d | Price per Night: %.2f | Total Price: %.2f\\n"",
           booking.name, booking.roomNumber, booking.nights, booking.pricePerNight, booking.totalPrice);
  }
}

void deleteBooking() {
  printf(""Deleting Booking...\\n"");
  if (bookingCount == 0) {
    printf(""No bookings to delete.\\n"");
    return;
  }
  int roomNumber;
  printf(""Enter room number to delete: "");
  scanf(""%d"", &roomNumber);
  int found = 0;
  for (int i = 0; i < bookingCount; i++) {
    if (bookings[i].roomNumber == roomNumber) {
      found = 1;
      for (int j = i; j < bookingCount - 1; j++) {
        bookings[j] = bookings[j + 1];
      }
      bookingCount--;
      printf(""Booking deleted!\\n"");
      break;
    }
  }
  if (!found) {
    printf(""Booking not found.\\n"");
  }
}

void editBooking() {
  printf(""Editing Booking...\\n"");
  if (bookingCount == 0) {
    printf(""No bookings to edit.\\n"");
    return;
  }
  int roomNumber;
  printf(""Enter room number to edit: "");
  scanf(""%d"", &roomNumber);
  int found = 0;
  for (int i = 0; i < bookingCount; i++) {
    if (bookings[i].roomNumber == roomNumber) {
      found = 1;
      Booking booking = bookings[i];
      printf(""Name (current: %s): "", booking.name);
      scanf(""%s"", booking.name);
      printf(""Room Number (current: %d): "", booking.roomNumber);
      scanf(""%d"", &booking.roomNumber);
      printf(""Nights (current: %d): "", booking.nights);
      scanf(""%d"", &booking.nights);
      printf(""Price per Night (current: %.2f): "", booking.pricePerNight);
      scanf(""%lf"", &booking.pricePerNight);
      booking.totalPrice = booking.nights * booking.pricePerNight;
      bookings[i] = booking;
      printf(""Booking edited!\\n"");
      break;
    }
  }
  if (!found) {
    printf(""Booking not found.\\n"");
  }
}

void saveBookings() {
  printf(""Saving Bookings...\\n"");
  FILE *fp;
  fp = fopen(""bookings.txt"", ""w"");
  fprintf(fp, ""%d\\n"", bookingCount);
  for (int i = 0; i < bookingCount; i++) {
    Booking booking = bookings[i];
    fprintf(fp, ""%s\\n%d\\n%d\\n%.2f\\n"", booking.name, booking.roomNumber, booking.nights, booking.pricePerNight);
  }
  fclose(fp);
  printf(""Bookings saved!\\n"");
}

void loadBookings() {
  printf(""Loading Bookings...\\n"");
  FILE *fp;
  fp = fopen(""bookings.txt"", ""r"");
  if (fp == NULL) {
    printf(""No bookings file found.\\n"");
    return;
  }
  fscanf(fp, ""%d"", &bookingCount);
  for (int i = 0; i < bookingCount; i++) {
    Booking booking;
    fscanf(fp, ""%s %d %d %lf"", booking.name, &booking.roomNumber, &booking.nights, &booking.pricePerNight);
    booking.totalPrice = booking.nights * booking.pricePerNight;
    bookings[i] = booking;
  }
  fclose(fp);
  printf(""Bookings loaded!\\n"");
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 printMenu(void); // weak
__int64 addBooking(void); // weak
__int64 viewBookings(void); // weak
__int64 deleteBooking(void); // weak
__int64 editBooking(void); // weak
__int64 saveBookings(void); // weak
__int64 loadBookings(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001668) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  loadBookings();
  do
  {
    printMenu();
    printf(""Enter your choice: "");
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        addBooking();
        break;
      case 2:
        viewBookings();
        break;
      case 3:
        deleteBooking();
        break;
      case 4:
        editBooking();
        break;
      case 5:
        saveBookings();
        break;
      case 6:
        printf(""Exiting program...\\n"");
        break;
      default:
        printf(""Invalid choice!\\n"");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 140001729: using guessed type __int64 printMenu(void);
// 1400017BF: using guessed type __int64 addBooking(void);
// 14000192C: using guessed type __int64 viewBookings(void);
// 140001A44: using guessed type __int64 deleteBooking(void);
// 140001BF6: using guessed type __int64 editBooking(void);
// 140001EB6: using guessed type __int64 saveBookings(void);
// 140002000: using guessed type __int64 loadBookings(void);
// 140002240: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BOOKINGS 100

typedef struct {
    int id;
    char name[50];
    char email[50];
    char phone[15];
    char address[100];
    int numRooms;
    int numNights;
    int price;
} Booking;

Booking bookings[MAX_BOOKINGS];
int numBookings = 0;

void printMenu();
void addBooking();
void viewBookings();
void deleteBooking();
void editBooking();
void saveBookings();
void loadBookings();

int main() {
    loadBookings();
    int choice;
    do {
        printMenu();
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                addBooking();
                break;
            case 2:
                viewBookings();
                break;
            case 3:
                deleteBooking();
                break;
            case 4:
                editBooking();
                break;
            case 5:
                saveBookings();
                break;
            case 6:
                printf(""Exiting program...\\n"");
                break;
            default:
                printf(""Invalid choice!\\n"");
        }
    } while (choice != 6);
    return 0;
}

void printMenu() {
    printf(""\\nBooking System\\n"");
    printf(""1. Add Booking\\n"");
    printf(""2. View Bookings\\n"");
    printf(""3. Delete Booking\\n"");
    printf(""4. Edit Booking\\n"");
    printf(""5. Save Bookings\\n"");
    printf(""6. Exit\\n"");
}

void addBooking() {
    if (numBookings == MAX_BOOKINGS) {
        printf(""Maximum number of bookings reached!\\n"");
        return;
    }
    Booking newBooking;
    printf(""Enter booking details:\\n"");
    printf(""ID: "");
    scanf(""%d"", &newBooking.id);
    printf(""Name: "");
    scanf(""%s"", newBooking.name);
    printf(""Email: "");
    scanf(""%s"", newBooking.email);
    printf(""Phone: "");
    scanf(""%s"", newBooking.phone);
    printf(""Address: "");
    scanf(""%s"", newBooking.address);
    printf(""Number of rooms: "");
    scanf(""%d"", &newBooking.numRooms);
    printf(""Number of nights: "");
    scanf(""%d"", &newBooking.numNights);
    printf(""Price: "");
    scanf(""%d"", &newBooking.price);
    bookings[numBookings++] = newBooking;
    printf(""Booking added successfully!\\n"");
}

void viewBookings() {
    if (numBookings == 0) {
        printf(""No bookings found!\\n"");
        return;
    }
    printf(""Bookings:\\n"");
    for (int i = 0; i < numBookings; i++) {
        printf(""ID: %d\\n"", bookings[i].id);
        printf(""Name: %s\\n"", bookings[i].name);
        printf(""Email: %s\\n"", bookings[i].email);
        printf(""Phone: %s\\n"", bookings[i].phone);
        printf(""Address: %s\\n"", bookings[i].address);
        printf(""Number of rooms: %d\\n"", bookings[i].numRooms);
        printf(""Number of nights: %d\\n"", bookings[i].numNights);
        printf(""Price: %d\\n"", bookings[i].price);
        printf(""\\n"");
    }
}

void deleteBooking() {
    if (numBookings == 0) {
        printf",2
"//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
  char message[1000] = ""Surrealism is a cultural movement that began in the early 1920s in France, and is best known for its visual artwork and writings. One of the key tools used in this movement is the concept of the 'unconscious mind', and the idea that it can be harnessed to create new and unexpected connections and meanings. In this program, we will use a similar method to create a unique digital watermarking technique."";

  int watermark[] = { 5, 13, 27, 32, 45, 61, 77, 83, 92, 99 }; // indexes of characters to mark
  int count = sizeof(watermark)/sizeof(int); // number of characters to mark

  int watermarkChar = 33; // ASCII code for '!'
  int nonWatermarkChar = 42; // ASCII code for '*'

  int i;
  for(i=0; i<count; i++) {
    message[watermark[i]] = watermarkChar; // mark character with watermark
  }

  for(i=0; i<strlen(message); i++) {
    if(message[i] != watermarkChar) { // if character is not already marked
      message[i] = nonWatermarkChar; // mark it with non-watermark character
    }
  }

  printf(""%s\\n"", message); // output the marked message

  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[12]; // [rsp+20h] [rbp-60h]
  char Str[406]; // [rsp+50h] [rbp-30h] BYREF
  __int16 v6; // [rsp+1E6h] [rbp+166h]
  _BYTE v7[592]; // [rsp+1E8h] [rbp+168h] BYREF
  int v8; // [rsp+440h] [rbp+3C0h]
  int v9; // [rsp+444h] [rbp+3C4h]
  int v10; // [rsp+448h] [rbp+3C8h]
  int i; // [rsp+44Ch] [rbp+3CCh]

  _main(argc, argv, envp);
  strcpy(
    Str,
    ""Surrealism is a cultural movement that began in the early 1920s in France, and is best known for its visual artwork ""
    ""and writings. One of the key tools used in this movement is the concept of the 'unconscious mind', and the idea that""
    "" it can be harnessed to create new and unexpected connections and meanings. In this program, we will use a similar m""
    ""ethod to create a unique digital watermarking technique."");
  Str[405] = 0;
  v6 = 0;
  memset(v7, 0, sizeof(v7));
  v4[0] = 5;
  v4[1] = 13;
  v4[2] = 27;
  v4[3] = 32;
  v4[4] = 45;
  v4[5] = 61;
  v4[6] = 77;
  v4[7] = 83;
  v4[8] = 92;
  v4[9] = 99;
  v10 = 10;
  v9 = 33;
  v8 = 42;
  for ( i = 0; i < v10; ++i )
    Str[v4[i]] = v9;
  for ( i = 0; i < strlen(Str); ++i )
  {
    if ( v9 != Str[i] )
      Str[i] = v8;
  }
  printf(""%s\\n"", Str);
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char message[] = ""Surrealism is a cultural movement that began in the early 1920s in France, and is best known for its visual artwork and writings. One of the key tools used in this movement is the concept of the 'unconscious mind', and the idea that it can be harnessed to create new and unexpected connections and meanings. In this program, we will use a similar method to create a unique digital watermarking technique."";
    char watermark[] = """";
    int i, j, k;
    int key[10] = {5, 13, 27, 32, 45, 61, 77, 83, 92, 99};
    int key_length = 10;
    int ascii_value = 33;
    int ascii_value_2 = 42;
    
    // Generate the watermark
    for (i = 0; i < key_length; i++) {
        watermark[i] = ascii_value;
    }
    
    // Encrypt the message
    for (i = 0; i < strlen(message); i++) {
        if (message[i] != watermark[i % key_length]) {
            message[i] = ascii_value_2;
        }
    }
    
    // Print the encrypted message
    printf(""%s
"", message);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Password management ; Style: peaceful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_USERS 10
#define MAX_USERNAME_LEN 20
#define MAX_PASSWORD_LEN 20

typedef struct {
    char username[MAX_USERNAME_LEN];
    char password[MAX_PASSWORD_LEN];
} User;

User users[MAX_USERS];
int num_users = 0;

void add_user(char* username, char* password) {
    if (num_users < MAX_USERS) {
        strcpy(users[num_users].username, username);
        strcpy(users[num_users].password, password);
        num_users++;
        printf(""User added successfully!\\n"");
    }
    else {
        printf(""Maximum number of users reached!\\n"");
    }
}

int main() {
    char buffer[MAX_USERNAME_LEN + MAX_PASSWORD_LEN + 2]; // +2 for space and newline
    int choice = -1;
    char username[MAX_USERNAME_LEN];
    char password[MAX_PASSWORD_LEN];

    while (choice != 0) {
        printf(""Choose an option:\\n"");
        printf(""1) Add user\\n"");
        printf(""2) Check password\\n"");
        printf(""0) Exit\\n"");
        printf(""Choice: "");
        scanf(""%d"", &choice);

        switch(choice) {
            case 1:
                printf(""Enter username and password separated by a space: "");
                scanf(""%s"", buffer);
                sscanf(buffer, ""%s %s"", username, password);
                add_user(username, password);
                break;
            case 2:
                printf(""Enter username and password separated by a space: "");
                scanf(""%s"", buffer);
                sscanf(buffer, ""%s %s"", username, password);
                int found = 0;
                for (int i = 0; i < num_users; i++) {
                    if (strcmp(users[i].username, username) == 0 &&
                        strcmp(users[i].password, password) == 0) {
                        printf(""Password correct!\\n"");
                        found = 1;
                        break;
                    }
                }
                if (!found) {
                    printf(""Password incorrect or user not found!\\n"");
                }
                break;
            case 0:
                printf(""Exiting...\\n"");
                break;
            default:
                printf(""Invalid choice!\\n"");
                break;
        }
        printf(""\\n"");
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int sscanf(const char *const Buffer, const char *const Format, ...);
int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_user(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);

//-------------------------------------------------------------------------
// Data declarations

char users[400]; // weak
int num_users; // weak


//----- (00000001400016DC) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[32]; // [rsp+20h] [rbp-80h] BYREF
  char Str2[28]; // [rsp+40h] [rbp-60h] BYREF
  int v6; // [rsp+5Ch] [rbp-44h] BYREF
  char Buffer[56]; // [rsp+60h] [rbp-40h] BYREF
  int i; // [rsp+98h] [rbp-8h]
  int v9; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = -1;
  while ( v6 )
  {
    printf(""Choose an option:\\n"");
    printf(""1) Add user\\n"");
    printf(""2) Check password\\n"");
    printf(""0) Exit\\n"");
    printf(""Choice: "");
    scanf(""%d"", &v6);
    if ( v6 == 2 )
    {
      printf(""Enter username and password separated by a space: "");
      scanf(""%s"", Buffer);
      sscanf(Buffer, ""%s %s"", Str2, v4);
      v9 = 0;
      for ( i = 0; i < num_users; ++i )
      {
        if ( !strcmp(&users[40 * i], Str2) && !strcmp(&users[40 * i + 20], v4) )
        {
          printf(""Password correct!\\n"");
          v9 = 1;
          break;
        }
      }
      if ( !v9 )
        printf(""Password incorrect or user not found!\\n"");
    }
    else
    {
      if ( v6 <= 2 )
      {
        if ( !v6 )
        {
          printf(""Exiting...\\n"");
          goto LABEL_17;
        }
        if ( v6 == 1 )
        {
          printf(""Enter username and password separated by a space: "");
          scanf(""%s"", Buffer);
          sscanf(Buffer, ""%s %s"", Str2, v4);
          add_user(Str2, v4);
          goto LABEL_17;
        }
      }
      printf(""Invalid choice!\\n"");
    }
LABEL_17:
    printf(""\\n"");
  }
  return 0;
}
// 140001625: using guessed type __int64 __fastcall add_user(_QWORD, _QWORD);
// 1400019E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400191D0: using guessed type int num_users;

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_USERS 100

typedef struct {
    char username[20];
    char password[20];
} User;

User users[MAX_USERS];
int num_users = 0;

void add_user(char *username, char *password) {
    if (num_users >= MAX_USERS) {
        printf(""Maximum number of users reached!
"");
        return;
    }
    User new_user;
    strcpy(new_user.username, username);
    strcpy(new_user.password, password);
    users[num_users++] = new_user;
    printf(""User added successfully!
"");
}

int main() {
    int choice = -1;
    while (choice != 0) {
        printf(""Choose an option:
"");
        printf(""1) Add user
"");
        printf(""2) Check password
"");
        printf(""0) Exit
"");
        printf(""Choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1: {
                char username[20], password[20];
                printf(""Enter username and password separated by a space: "");
                scanf(""%s"", username);
                sscanf(username, ""%s %s"", username, password);
                add_user(username, password);
                break;
            }
            case 2: {
                char username[20], password[20];
                printf(""Enter username and password separated by a space: "");
                scanf(""%s"", username);
                sscanf(username, ""%s %s"", username, password);
                int found = 0;
                for (int i = 0; i < num_users; i++) {
                    if (strcmp(users[i].username, username) == 0 && strcmp(users[i].password, password) == 0) {
                        printf(""Password correct!
"");
                        found = 1;
                        break;
                    }
                }
                if (!found) {
                    printf(""Password incorrect or user not found!
"");
                }
                break;
            }
            case 0: {
                printf(""Exiting...
"");
                break;
            }
            default: {
                printf(""Invalid choice!
"");
                break;
            }
        }
        printf(""
"");
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Password Stength Checker ; Style: imaginative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {

  char password[52];
  int length, i, lower, upper, digit, special;
  int score = 0;

  printf(""Enter your password (must be at least 8 characters): "");
  scanf(""%s"", password);

  length = strlen(password);

  if(length < 8) {
    printf(""Password is too short. It should be at least 8 characters long."");
    exit(0);
  }

  for(i = 0; i < length; i++) {
    if(password[i] >= 'a' && password[i] <= 'z') {
      lower = 1;
    }
    else if(password[i] >= 'A' && password[i] <= 'Z') {
      upper = 1;
    }
    else if(password[i] >= '0' && password[i] <= '9') {
      digit = 1;
    }
    else {
      special = 1;
    }

    // Calculate password score based on complexity
    if(lower && upper && digit && special) {
      score = 5;
    }
    else if(lower && upper && digit) {
      score = 4;
    }
    else if(lower && upper) {
      score = 3;
    }
    else if(lower && digit) {
      score = 2;
    }
    else if(upper && digit) {
      score = 2;
    }

    // Output password complexity score and suggestions
    printf(""\\nPassword Complexity Score: %d\\n"", score);
    if(score >= 4) {
      printf(""Your password is STRONG."");
    }
    else if(score == 3) {
      printf(""Your password is MEDIUM."");
      printf(""\\nConsider including special characters to add additional complexity."");
    }
    else {
      printf(""Your password is WEAK."");
      printf(""\\nConsider including uppercase letters, lowercase letters, numbers, and special characters to improve its complexity."");
    }

  }

  return 0;

}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Str[52]; // [rsp+20h] [rbp-50h] BYREF
  int v5; // [rsp+54h] [rbp-1Ch]
  unsigned int v6; // [rsp+58h] [rbp-18h]
  int v7; // [rsp+5Ch] [rbp-14h]
  int v8; // [rsp+60h] [rbp-10h]
  int v9; // [rsp+64h] [rbp-Ch]
  int v10; // [rsp+68h] [rbp-8h]
  int i; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0;
  printf(""Enter your password (must be at least 8 characters): "");
  scanf(""%s"", Str);
  v5 = strlen(Str);
  if ( v5 <= 7 )
  {
    printf(""Password is too short. It should be at least 8 characters long."");
    exit(0);
  }
  for ( i = 0; i < v5; ++i )
  {
    if ( Str[i] <= 96 || Str[i] > 122 )
    {
      if ( Str[i] <= 64 || Str[i] > 90 )
      {
        if ( Str[i] <= 47 || Str[i] > 57 )
          v7 = 1;
        else
          v8 = 1;
      }
      else
      {
        v9 = 1;
      }
    }
    else
    {
      v10 = 1;
    }
    if ( v10 && v9 && v8 && v7 )
    {
      v6 = 5;
    }
    else if ( v10 && v9 && v8 )
    {
      v6 = 4;
    }
    else if ( v10 && v9 )
    {
      v6 = 3;
    }
    else if ( v10 && v8 )
    {
      v6 = 2;
    }
    else if ( v9 && v8 )
    {
      v6 = 2;
    }
    printf(""\\nPassword Complexity Score: %d\\n"", v6);
    if ( (int)v6 <= 3 )
    {
      if ( v6 == 3 )
      {
        printf(""Your password is MEDIUM."");
        printf(""\\nConsider including special characters to add additional complexity."");
      }
      else
      {
        printf(""Your password is WEAK."");
        printf(
          ""\\n""
          ""Consider including uppercase letters, lowercase letters, numbers, and special characters to improve its complexity."");
      }
    }
    else
    {
      printf(""Your password is STRONG."");
    }
  }
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char Str[52];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char password[50];
    int length, i, score = 0;
    
    printf(""Enter your password (must be at least 8 characters): "");
    scanf(""%s"", password);
    
    length = strlen(password);
    
    if (length < 8) {
        printf(""Password is too short. It should be at least 8 characters long."");
        exit(0);
    }
    
    for (i = 0; i < length; i++) {
        if (password[i] >= 'a' && password[i] <= 'z') {
            score += 1;
        } else if (password[i] >= 'A' && password[i] <= 'Z') {
            score += 2;
        } else if (password[i] >= '0' && password[i] <= '9') {
            score += 3;
        } else if (password[i] >= '!' && password[i] <= '/') {
            score += 4;
        } else if (password[i] >= ':' && password[i] <= '@') {
            score += 5;
        }
    }
    
    printf(""
Password Complexity Score: %d
"", score);
    
    if (score >= 4) {
        printf(""Your password is STRONG."");
    } else if (score == 3) {
        printf(""Your password is MEDIUM."");
        printf(""
Consider including special characters to add additional complexity."");
    } else {
        printf(""Your password is WEAK."");
        printf(""
Consider including uppercase letters, lowercase letters, numbers, and special characters to improve its complexity."");
    }
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Simulation of the Solar System ; Style: random
#include <stdio.h>
#include <math.h>

#define G 6.67430e-11

typedef struct {
    double x, y, z;
} Vector3;

typedef struct {
    Vector3 pos, vel, acc, force;
    double mass;
} Body;

int main() {
    int i, j, k;
    double dt = 0.1;
    int nsteps = 1000;
    int num_bodies = 3;
    Body bodies[3] = {
        {
            {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, 
            1.99e30
        },
        {
            {149.6e9, 0.0, 0.0}, {0.0, 29.78e3, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, 
            5.97e24
        },
        {
            {227.9e9, 0.0, 0.0}, {0.0, 24.077e3, 0.0}, {0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}, 
            6.39e23
        }
    };
    
    for (i = 0; i < nsteps; i++) {
        for (j = 0; j < num_bodies; j++) {
            bodies[j].force.x = 0.0;
            bodies[j].force.y = 0.0;
            bodies[j].force.z = 0.0;
            for (k = 0; k < num_bodies; k++) {
                if (j != k) {
                    Vector3 r;
                    r.x = bodies[k].pos.x - bodies[j].pos.x;
                    r.y = bodies[k].pos.y - bodies[j].pos.y;
                    r.z = bodies[k].pos.z - bodies[j].pos.z;
                    double dist = sqrt(r.x * r.x + r.y * r.y + r.z * r.z);
                    double mag = G * bodies[j].mass * bodies[k].mass / (dist * dist * dist);
                    bodies[j].force.x += mag * r.x;
                    bodies[j].force.y += mag * r.y;
                    bodies[j].force.z += mag * r.z;
                }
            }
        }
        for (j = 0; j < num_bodies; j++) {
            bodies[j].acc.x = bodies[j].force.x / bodies[j].mass;
            bodies[j].acc.y = bodies[j].force.y / bodies[j].mass;
            bodies[j].acc.z = bodies[j].force.z / bodies[j].mass;
            bodies[j].vel.x += bodies[j].acc.x * dt;
            bodies[j].vel.y += bodies[j].acc.y * dt;
            bodies[j].vel.z += bodies[j].acc.z * dt;
            bodies[j].pos.x += bodies[j].vel.x * dt;
            bodies[j].pos.y += bodies[j].vel.y * dt;
            bodies[j].pos.z += bodies[j].vel.z * dt;
        }
        printf(""Step %d:\\n"", i);
        for (j = 0; j < num_bodies; j++) {
            printf(""  Body %d: position = (%e, %e, %e), velocity = (%e, %e, %e)\\n"", 
                j, bodies[j].pos.x, bodies[j].pos.y, bodies[j].pos.z, bodies[j].vel.x, 
                bodies[j].vel.y, bodies[j].vel.z);
        }
    }
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  double v4; // [rsp+40h] [rbp-40h]
  double v5; // [rsp+48h] [rbp-38h]
  double v6; // [rsp+50h] [rbp-30h]
  __int64 v7[39]; // [rsp+60h] [rbp-20h] BYREF
  double v8; // [rsp+1A0h] [rbp+120h]
  double v9; // [rsp+1A8h] [rbp+128h]
  int v10; // [rsp+1B0h] [rbp+130h]
  int v11; // [rsp+1B4h] [rbp+134h]
  double v12; // [rsp+1B8h] [rbp+138h]
  int k; // [rsp+1C4h] [rbp+144h]
  int j; // [rsp+1C8h] [rbp+148h]
  unsigned int i; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  v12 = 0.1;
  v11 = 1000;
  v10 = 3;
  memset(v7, 0, sizeof(v7));
  v7[12] = 0x46391E096B424EC5i64;
  v7[13] = 0x42416A6D6C000000i64;
  v7[17] = 0x40DD150000000000i64;
  v7[25] = 0x4513C0C964D9C187i64;
  v7[26] = 0x424A87F303800000i64;
  v7[30] = 0x40D7834000000000i64;
  v7[38] = 0x44E0EA084D181CD6i64;
  for ( i = 0; (int)i < v11; ++i )
  {
    for ( j = 0; j < v10; ++j )
    {
      v7[13 * j + 9] = 0i64;
      v7[13 * j + 10] = 0i64;
      v7[13 * j + 11] = 0i64;
      for ( k = 0; k < v10; ++k )
      {
        if ( j != k )
        {
          v4 = *(double *)&v7[13 * k] - *(double *)&v7[13 * j];
          v5 = *(double *)&v7[13 * k + 1] - *(double *)&v7[13 * j + 1];
          v6 = *(double *)&v7[13 * k + 2] - *(double *)&v7[13 * j + 2];
          v9 = sqrt(v4 * v4 + v5 * v5 + v6 * v6);
          v8 = *(double *)&v7[13 * j + 12] * 6.674299999999999e-11 * *(double *)&v7[13 * k + 12] / (v9 * v9 * v9);
          *(double *)&v7[13 * j + 9] = v4 * v8 + *(double *)&v7[13 * j + 9];
          *(double *)&v7[13 * j + 10] = v5 * v8 + *(double *)&v7[13 * j + 10];
          *(double *)&v7[13 * j + 11] = v6 * v8 + *(double *)&v7[13 * j + 11];
        }
      }
    }
    for ( j = 0; j < v10; ++j )
    {
      *(double *)&v7[13 * j + 6] = *(double *)&v7[13 * j + 9] / *(double *)&v7[13 * j + 12];
      *(double *)&v7[13 * j + 7] = *(double *)&v7[13 * j + 10] / *(double *)&v7[13 * j + 12];
      *(double *)&v7[13 * j + 8] = *(double *)&v7[13 * j + 11] / *(double *)&v7[13 * j + 12];
      *(double *)&v7[13 * j + 3] = *(double *)&v7[13 * j + 6] * v12 + *(double *)&v7[13 * j + 3];
      *(double *)&v7[13 * j + 4] = *(double *)&v7[13 * j + 7] * v12 + *(double *)&v7[13 * j + 4];
      *(double *)&v7[13 * j + 5] = *(double *)&v7[13 * j + 8] * v12 + *(double *)&v7[13 * j + 5];
      *(double *)&v7[13 * j] = *(double *)&v7[13 * j + 3] * v12 + *(double *)&v7[13 * j];
      *(double *)&v7[13 * j + 1] = *(double *)&v7[13 * j + 4] * v12 + *(double *)&v7[13 * j + 1];
      *(double *)&v7[13 * j + 2] = *(double *)&v7[13 * j + 5] * v12 + *(double *)&v7[13 * j + 2];
    }
    printf(""Step %d:\\n"", i);
    for ( j = 0; j < v10; ++j )
      printf(
        ""  Body %d: position = (%e, %e, %e), velocity = (%e, %e, %e)\\n"",
        (unsigned int)j,
        *(double *)&v7[13 * j],
        *(double *)&v7[13 * j + 1],
        *(double *)&v7[13 * j + 2],
        *(double *)&v7[13 * j + 3],
        *(double *)&v7[13 * j + 4],
        *(double *)&v7[13 * j + 5]);
  }
  return 0;
}
// 140002320: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define G 6.6743e-11 // gravitational constant

typedef struct {
    double x, y, z; // position
    double vx, vy, vz; // velocity
    double ax, ay, az; // acceleration
    double mass; // mass
} Particle;

int main() {
    double dt = 0.1; // time step
    int n = 1000; // number of time steps
    int n_particles = 3; // number of particles
    Particle particles[n_particles]; // array of particles

    // initialize particles
    particles[0].x = 0.0;
    particles[0].y = 0.0;
    particles[0].z = 0.0;
    particles[0].vx = 0.0;
    particles[0].vy = 0.0;
    particles[0].vz = 0.0;
    particles[0].ax = 0.0;
    particles[0].ay = 0.0;
    particles[0].az = 0.0;
    particles[0].mass = 1.0;

    particles[1].x = 1.0;
    particles[1].y = 0.0;
    particles[1].z = 0.0;
    particles[1].vx = 0.0;
    particles[1].vy = 0.0;
    particles[1].vz = 0.0;
    particles[1].ax = 0.0;
    particles[1].ay = 0.0;
    particles[1].az = 0.0;
    particles[1].mass = 1.0;

    particles[2].x = 0.0;
    particles[2].y = 1.0;
    particles[2].z = 0.0;
    particles[2].vx = 0.0;
    particles[2].vy = 0.0;
    particles[2].vz = 0.0;
    particles[2].ax = 0.0;
    particles[2].ay = 0.0;
    particles[2].az = 0.0;
    particles[2].mass = 1.0;

    // simulate motion
    for (int i = 0; i < n; i++) {
        // calculate acceleration
        for (int j = 0; j < n_particles; j++) {
            particles[j].ax = 0.0;
            particles[j].ay = 0.0;
            particles[j].az = 0.0;
            for (int k = 0; k < n_particles; k++) {
                if (j != k) {
                    double dx = particles[k].x - particles[j].x;
                    double dy = particles[k].y - particles[j].y;
                    double dz = particles[k].z - particles[j].z;
                    double r = sqrt(dx*dx + dy*dy + dz*dz);
                    double f = G * particles[j].mass * particles[k].mass / (r*r*r);
                    particles[j].ax += f * dx / r;
                    particles[j].ay += f * dy / r;
                    particles[j].az += f * dz / r;
                }
            }
        }

        // update position and velocity
        for (int j = 0; j < n_particles; j++) {
            particles[j].vx += particles[j].ax * dt;
            particles[j].vy += particles[j].ay * dt;
            particles[j].vz += particles[j].az * dt;
            particles[j].x += particles[j].vx * dt;
            particles[j].y += particles[j].vy * dt;
            particles[j].",2
"//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: interoperable
#include <stdio.h>
#include <stdbool.h>

bool is_prime(int n){
    if(n<=1)
        return false;
    for(int i=2;i*i<=n;i++){
        if(n%i==0)
            return false;
    }
    return true;
}

int main(){
    int limit;
    printf(""Enter the limit for prime number generation: "");
    scanf(""%d"",&limit);
    printf(""Prime numbers from 2 to %d: "",limit);
    for(int i=2;i<=limit;i++){
        if(is_prime(i))
            printf(""%d "",i);
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall is_prime(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001631) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+28h] [rbp-8h] BYREF
  unsigned int i; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Enter the limit for prime number generation: "");
  scanf(""%d"", &v4);
  printf(""Prime numbers from 2 to %d: "", v4);
  for ( i = 2; (int)i <= (int)v4; ++i )
  {
    if ( (unsigned __int8)is_prime(i) )
      printf(""%d "", i);
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall is_prime(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdbool.h>

bool is_prime(int n) {
    if (n <= 1) {
        return false;
    }
    for (int i = 2; i <= n / 2; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int limit;
    printf(""Enter the limit for prime number generation: "");
    scanf(""%d"", &limit);
    printf(""Prime numbers from 2 to %d: "", limit);
    for (int i = 2; i <= limit; i++) {
        if (is_prime(i)) {
            printf(""%d "", i);
        }
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Data recovery tool ; Style: Donald Knuth
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void recover_data(char *filename){
    FILE *file;
    char *data;
    int lSize; 
 
 
    file = fopen(filename , ""rb"" );
    if( !file ) perror(filename), exit(1);

    fseek( file , 0L , SEEK_END);
    lSize = ftell( file );
    rewind( file );

    data = calloc( 1, lSize+1 );
    if( !data ) fclose(file),fputs(""memory alloc fails"",stderr),exit(1);

    if( 1!=fread( data , lSize, 1 , file) )
    fclose(file),free(data),fputs(""entire read fails"",stderr),exit(1);

   char* backup_data = data;
   char* ptr = NULL;
   while ( (ptr = strstr(data, ""RECOVER"")) != NULL ) {
      int size = strlen(ptr) - 7;
      printf(""%.*s"", size, ptr + 7);
      ptr += size + 7;
   }

   fclose(file);
   free(backup_data);
}

int main(){
    char* filename = ""data.bin"";
    recover_data(filename);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall recover_data(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001760) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  recover_data(""data.bin"");
  return 0;
}
// 140001591: using guessed type __int64 __fastcall recover_data(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=146 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

// Function to recover data from a corrupted file
void recover_data(char *filename) {
    FILE *file = fopen(filename, ""rb"");
    if (file == NULL) {
        printf(""Error: Could not open file %s
"", filename);
        return;
    }

    // Read the first 100 bytes of the file
    char buffer[100];
    fread(buffer, sizeof(char), 100, file);

    // Find the first occurrence of the string ""DATA:""
    char *data_start = strstr(buffer, ""DATA:"");
    if (data_start == NULL) {
        printf(""Error: Could not find data in file %s
"", filename);
        fclose(file);
        return;
    }

    // Calculate the length of the data
    int data_length = strlen(data_start) - strlen(""DATA:"");

    // Allocate memory for the data
    char *data = (char *) malloc(data_length + 1);
    if (data == NULL) {
        printf(""Error: Could not allocate memory for data
"");
        fclose(file);
        return;
    }

    // Copy the data from the file to the buffer
    fseek(file, data_start - buffer + strlen(""DATA:""), SEEK_SET);
    fread(data, sizeof(char), data_length, file);
    data[data_length] = '",2
"//FormAI DATASET v1.0 Category: Modern Encryption ; Style: optimized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 1000

void xor(char *str, char *key, int len) {
    int key_len = strlen(key);
    for (int i = 0; i < len; i++) {
        str[i] ^= key[i % key_len];
    }
}

int main() {
    char plain_text[MAX_LENGTH];
    char key[MAX_LENGTH];

    printf(""Enter plaintext: "");
    scanf(""%[^\\n]"", plain_text);

    printf(""Enter key: "");
    scanf("" %[^\\n]"", key);

    int len = strlen(plain_text);

    xor(plain_text, key, len);

    printf(""Encrypted text: %s\\n"", plain_text);

    xor(plain_text, key, len);

    printf(""Decrypted text: %s\\n"", plain_text);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall xor(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (0000000140001659) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[1008]; // [rsp+20h] [rbp-60h] BYREF
  char Str[1004]; // [rsp+410h] [rbp+390h] BYREF
  unsigned int v6; // [rsp+7FCh] [rbp+77Ch]

  _main(argc, argv, envp);
  printf(""Enter plaintext: "");
  scanf(""%[^\\n]"", Str);
  printf(""Enter key: "");
  scanf("" %[^\\n]"", v4);
  v6 = strlen(Str);
  xor(Str, v4, v6);
  printf(""Encrypted text: %s\\n"", Str);
  xor(Str, v4, v6);
  printf(""Decrypted text: %s\\n"", Str);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall xor(_QWORD, _QWORD, _QWORD);
// 140001800: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <string.h>

void xor(char *plaintext, char *key, int len) {
    for (int i = 0; i < len; i++) {
        plaintext[i] ^= key[i % strlen(key)];
    }
}

int main() {
    char plaintext[1000], key[1000];
    int len;

    printf(""Enter plaintext: "");
    scanf(""%[^
]"", plaintext);

    printf(""Enter key: "");
    scanf("" %[^
]"", key);

    len = strlen(plaintext);

    xor(plaintext, key, len);

    printf(""Encrypted text: %s
"", plaintext);

    xor(plaintext, key, len);

    printf(""Decrypted text: %s
"", plaintext);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Chess engine ; Style: standalone
#include <stdio.h>

#define BOARD_SIZE 8

char board[BOARD_SIZE][BOARD_SIZE];

void init_board() {
  int i, j;
  for (i = 0; i < BOARD_SIZE; i++) {
    for (j = 0; j < BOARD_SIZE; j++) {
      board[i][j] = '-';
    }
  }
}
void print_board() {
  int i, j;
  printf(""\\n"");
  printf(""  A B C D E F G H\\n"");
  for (i = 0; i < BOARD_SIZE; i++) {
    printf(""%d"", 8 - i);
    for (j = 0; j < BOARD_SIZE; j++) {
      printf("" %c"", board[i][j]);
    }
    printf(""\\n"");
  }
  printf(""\\n"");
}
int main() {
  init_board();
  print_board();
  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 init_board(void); // weak
__int64 print_board(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400016A3) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  init_board();
  print_board();
  return 0;
}
// 140001591: using guessed type __int64 init_board(void);
// 1400015E6: using guessed type __int64 print_board(void);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

// Define the size of the board
#define BOARD_SIZE 3

// Define the player symbols
#define PLAYER_X 'X'
#define PLAYER_O 'O'

// Define the board
char board[BOARD_SIZE][BOARD_SIZE];

// Define the winning combinations
char winning_combinations[8][3] = {
    {0, 1, 2},
    {3, 4, 5},
    {6, 7, 8},
    {0, 3, 6},
    {1, 4, 7},
    {2, 5, 8},
    {0, 4, 8},
    {2, 4, 6}
};

// Define the function to initialize the board
void init_board() {
    int i, j;
    for (i = 0; i < BOARD_SIZE; i++) {
        for (j = 0; j < BOARD_SIZE; j++) {
            board[i][j] = ' ';
        }
    }
}

// Define the function to print the board
void print_board() {
    int i, j;
    printf(""
"");
    for (i = 0; i < BOARD_SIZE; i++) {
        for (j = 0; j < BOARD_SIZE; j++) {
            printf("" %c "", board[i][j]);
        }
        printf(""
"");
    }
}

// Define the function to check if the game is over
int game_over() {
    int i, j, k;
    char player;
    for (i = 0; i < 8; i++) {
        player = winning_combinations[i][0];
        for (j = 0; j < 3; j++) {
            if (board[winning_combinations[i][j]][0] != player ||
                board[winning_combinations[i][j]][1] != player ||
                board[winning_combinations[i][j]][2] != player) {
                break;
            }
            if (j == 2) {
                return 1;
            }
        }
    }
    return 0;
}

// Define the function to get the player's move
int get_move(char player) {
    int move;
    printf(""Player %c, enter your move (1-9): "", player);
    scanf(""%d"", &move);
    while (move < 1 || move > 9 || board[move-1][0] != ' ') {
        printf(""Invalid move. Player %c, enter your move (1-9): "", player);
        scanf(""%d"", &move);
    }
    return move-1;
}

// Define the function to play the game
void play_game() {
    int i, j, move;
    char player;
    init_board();
    while (!game_over()) {
        for (i = 0; i < 2; i++) {
            if (i == 0) {
                player = PLAYER_X;
            } else {
                player = PLAYER_O;
            }
            move = get_move(player);
            board[move][0] = player;
            print_board();
            if (game_over()) {
                printf(""Player %c wins!
"", player);
                return;
            }
        }
    }
    printf(""Game over! No winner.
"");
}

// Define the main function
int main() {
    play_game();
    return 0;
}",1
"//FormAI DATASET v1.0 Category: Encryption ; Style: satisfied
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

void encrypt(char* message, int key){
    int len = strlen(message);
    for(int i=0; i<len; i++){
        if(message[i] >= 'a' && message[i] <= 'z'){
            message[i] = (char)((int)message[i] + key);
            if(message[i] > 'z'){
                message[i] = (char)((int)message[i] - 26);
            }
        }
        else if(message[i] >= 'A' && message[i] <= 'Z'){
            message[i] = (char)((int)message[i] + key);
            if(message[i] > 'Z'){
                message[i] = (char)((int)message[i] - 26);
            }
        }
    }
}

void decrypt(char* message, int key){
    int len = strlen(message);
    for(int i=0; i<len; i++){
        if(message[i] >= 'a' && message[i] <= 'z'){
            message[i] = (char)((int)message[i] - key);
            if(message[i] < 'a'){
                message[i] = (char)((int)message[i] + 26);
            }
        }
        else if(message[i] >= 'A' && message[i] <= 'Z'){
            message[i] = (char)((int)message[i] - key);
            if(message[i] < 'A'){
                message[i] = (char)((int)message[i] + 26);
            }
        }
    }
}

int main(){
    char message[100];
    int key;

    printf(""Enter a message to encrypt: "");
    fgets(message, 100, stdin);
    message[strcspn(message, ""\\n"")] = 0; //removes newline character from the string
    
    printf(""Enter a key (between 1 and 25): "");
    scanf(""%d"", &key);
    
    if(key<1 || key>25){
        printf(""Invalid key!\\n"");
        exit(0);
    }
    
    printf(""Original Message: %s\\n"", message);
    encrypt(message, key);
    printf(""Encrypted Message: %s\\n"", message);
    decrypt(message, key); //decrypting the message using the same key used to encrypt
    printf(""Decrypted Message: %s\\n"", message);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
__int64 __fastcall decrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strcspn(const char *Str, const char *Control);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001898) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  unsigned int v5; // [rsp+2Ch] [rbp-74h] BYREF
  char Buffer[112]; // [rsp+30h] [rbp-70h] BYREF

  _main(argc, argv, envp);
  printf(""Enter a message to encrypt: "");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  Buffer[strcspn(Buffer, ""\\n"")] = 0;
  printf(""Enter a key (between 1 and 25): "");
  scanf(""%d"", &v5);
  if ( (int)v5 <= 0 || (int)v5 > 25 )
  {
    printf(""Invalid key!\\n"");
    exit(0);
  }
  printf(""Original Message: %s\\n"", Buffer);
  encrypt(Buffer, v5);
  printf(""Encrypted Message: %s\\n"", Buffer);
  decrypt(Buffer, v5);
  printf(""Decrypted Message: %s\\n"", Buffer);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 14000173C: using guessed type __int64 __fastcall decrypt(_QWORD, _QWORD);
// 140001A60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001898: using guessed type char Buffer[112];

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void encrypt(char *message, int key) {
    int i;
    for (i = 0; message[i] != '",1
"//FormAI DATASET v1.0 Category: Product Inventory System ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PRODUCTS 100

// Structure for storing product details
struct product {
    char name[50];
    int id;
    int price;
    int quantity;
};

// Array to store products
struct product products[MAX_PRODUCTS];

// Function to add a new product to inventory
void add_product() {
    // Check if there is space in array
    int i, flag = 0;
    for(i = 0; i < MAX_PRODUCTS; i++) {
        if(products[i].id == 0) {
            flag = 1;
            break;
        }
    }
    if(!flag) {
        printf(""Inventory is full! Cannot add more products.\\n"");
        return;
    }
    // Get product details from user
    struct product p;
    printf(""Enter product name: "");
    scanf(""%s"", p.name);
    printf(""Enter product ID: "");
    scanf(""%d"", &p.id);
    printf(""Enter product price: "");
    scanf(""%d"", &p.price);
    printf(""Enter product quantity: "");
    scanf(""%d"", &p.quantity);
    // Check if product already exists
    for(i = 0; i < MAX_PRODUCTS; i++)
        if(products[i].id == p.id) {
            printf(""Product with ID %d already exists.\\n"", p.id);
            return;
        }
    // Add new product to array
    products[i] = p;
    printf(""Product added to inventory.\\n"");
}

// Function to remove product from inventory
void remove_product() {
    int id, i, flag = 0;
    printf(""Enter product ID: "");
    scanf(""%d"", &id);
    for(i = 0; i < MAX_PRODUCTS; i++) {
        if(products[i].id == id) {
            flag = 1;
            products[i].id = 0;
            products[i].price = 0;
            products[i].quantity = 0;
            memset(products[i].name, 0, sizeof(products[i].name));
            break;
        }
    }
    if(flag)
        printf(""Product removed from inventory.\\n"");
    else
        printf(""Product with ID %d not found in inventory.\\n"", id);
}

// Function to update product details
void update_product() {
    int id, i, flag = 0;
    printf(""Enter product ID: "");
    scanf(""%d"", &id);
    for(i = 0; i < MAX_PRODUCTS; i++) {
        if(products[i].id == id) {
            flag = 1;
            printf(""Current details of product with ID %d:\\n"", id);
            printf(""Name: %s\\n"", products[i].name);
            printf(""Price: %d\\n"", products[i].price);
            printf(""Quantity: %d\\n"", products[i].quantity);
            printf(""Enter new details:\\n"");
            printf(""Name: "");
            scanf(""%s"", products[i].name);
            printf(""Price: "");
            scanf(""%d"", &products[i].price);
            printf(""Quantity: "");
            scanf(""%d"", &products[i].quantity);
            break;
        }
    }
    if(flag)
        printf(""Product details updated.\\n"");
    else
        printf(""Product with ID %d not found in inventory.\\n"", id);
}

// Function to display inventory
void display_inventory() {
    printf(""ID\\tName\\tPrice\\tQuantity\\n"");
    int i;
    for(i = 0; i < MAX_PRODUCTS; i++) {
        if(products[i].id != 0)
            printf(""%d\\t%s\\t%d\\t%d\\n"", products[i].id, products[i].name, products[i].price, products[i].quantity);
    }
}

int main() {
    int choice;
    printf(""Welcome to Product Inventory System\\n"");
    while(1) {
        printf(""\\nMenu:\\n"");
        printf(""1. Add product\\n"");
        printf(""2. Remove product\\n"");
        printf(""3. Update product details\\n"");
        printf(""4. Display inventory\\n"");
        printf(""5. Exit\\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch(choice) {
            case 1:
                add_product();
                break;
            case 2:
                remove_product();
                break;
            case 3:
                update_product();
                break;
            case 4:
                display_inventory();
                break;
            case 5:
                printf(""Thank you for using Product Inventory System!\\n"");
                exit(0);
            default:
                printf(""Invalid choice. Please try again.\\n"");
        }
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_product(void); // weak
__int64 remove_product(void); // weak
__int64 update_product(void); // weak
__int64 display_inventory(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B76) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf(""Welcome to Product Inventory System\\n"");
  while ( 1 )
  {
    printf(""\\nMenu:\\n"");
    printf(""1. Add product\\n"");
    printf(""2. Remove product\\n"");
    printf(""3. Update product details\\n"");
    printf(""4. Display inventory\\n"");
    printf(""5. Exit\\n"");
    printf(""Enter your choice: "");
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        add_product();
        break;
      case 2:
        remove_product();
        break;
      case 3:
        update_product();
        break;
      case 4:
        display_inventory();
        break;
      case 5:
        printf(""Thank you for using Product Inventory System!\\n"");
        exit(0);
      default:
        printf(""Invalid choice. Please try again.\\n"");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 add_product(void);
// 14000179B: using guessed type __int64 remove_product(void);
// 1400018BC: using guessed type __int64 update_product(void);
// 140001AAE: using guessed type __int64 display_inventory(void);
// 140001D40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PRODUCTS 100

typedef struct {
    int id;
    char name[50];
    float price;
    int quantity;
} Product;

Product inventory[MAX_PRODUCTS];
int num_products = 0;

void add_product() {
    if (num_products == MAX_PRODUCTS) {
        printf(""Inventory is full. Cannot add more products.\\n"");
        return;
    }

    Product new_product;
    printf(""Enter product ID: "");
    scanf(""%d"", &new_product.id);

    printf(""Enter product name: "");
    scanf(""%s"", new_product.name);

    printf(""Enter product price: "");
    scanf(""%f"", &new_product.price);

    printf(""Enter product quantity: "");
    scanf(""%d"", &new_product.quantity);

    inventory[num_products++] = new_product;
    printf(""Product added successfully.\\n"");
}

void remove_product() {
    int id;
    printf(""Enter product ID to remove: "");
    scanf(""%d"", &id);

    int index = -1;
    for (int i = 0; i < num_products; i++) {
        if (inventory[i].id == id) {
            index = i;
            break;
        }
    }

    if (index == -1) {
        printf(""Product not found in inventory.\\n"");
        return;
    }

    for (int i = index; i < num_products - 1; i++) {
        inventory[i] = inventory[i+1];
    }

    num_products--;
    printf(""Product removed successfully.\\n"");
}

void update_product() {
    int id;
    printf(""Enter product ID to update: "");
    scanf(""%d"", &id);

    int index = -1;
    for (int i = 0; i < num_products; i++) {
        if (inventory[i].id == id) {
            index = i;
            break;
        }
    }

    if (index == -1) {
        printf(""Product not found in inventory.\\n"");
        return;
    }

    printf(""Enter new product name: "");
    scanf(""%s"", inventory[index].name);

    printf(""Enter new product price: "");
    scanf(""%f"", &inventory[index].price);

    printf(""Enter new product quantity: "");
    scanf(""%d"", &inventory[index].quantity);

    printf(""Product updated successfully.\\n"");
}

void display_inventory() {
    if (num_products == 0) {
        printf(""Inventory is empty.\\n"");
        return;
    }

    printf(""ID\\tName\\tPrice\\tQuantity\\n"");
    for (int i = 0; i < num_products; i++) {
        printf(""%d\\t%s\\t%.2f\\t%d\\n"", inventory[i].id, inventory[i].name, inventory[i].price, inventory[i].quantity);
    }
}

int main() {
    printf(""Welcome to Product Inventory System\\n"");

    while (1) {
        printf(""\\nMenu:\\n"");
        printf(""1. Add product\\n"");
        printf(""2. Remove product\\n"");
        printf(""3. Update product details\\n"");
        printf(""4. Display inventory\\n"");
        printf(""5. Exit\\n"");

        int choice;
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                add_product();
                break;
            case 2:
                remove_product();
                break",2
"//FormAI DATASET v1.0 Category: User Input Sanitizer ; Style: visionary
#include<stdio.h>
#include<string.h>

#define MAX_SIZE 100 /* Maximum size of array */

int main()
{
    char user_input[MAX_SIZE]; /* To store user input */
    
    printf(""Please enter a string: "");
    fgets(user_input, MAX_SIZE, stdin); /* Get user input */
    
    /* Removing unwanted characters */
    for(int i=0; i<strlen(user_input); i++)
    {
        if(user_input[i] == '\\n' || user_input[i] == '\\r')
            user_input[i] = '\\0';
    }
    
    /* Checking user input for unacceptable characters */
    for(int i=0; i<strlen(user_input); i++)
    {
        if(user_input[i] == '<' || user_input[i] == '>' || user_input[i] == '&' || user_input[i] == '""' || user_input[i] == '\\'' || user_input[i] == '/')
        {
            printf(""Unacceptable character found in input. Exiting program."");
            exit(0);
        }
    }
    
    printf(""Processed input: %s"", user_input);
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// void __cdecl __noreturn exit(int Code);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[104]; // [rsp+20h] [rbp-70h] BYREF
  int j; // [rsp+88h] [rbp-8h]
  int i; // [rsp+8Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Please enter a string: "");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  for ( i = 0; i < strlen(Buffer); ++i )
  {
    if ( Buffer[i] == 10 || Buffer[i] == 13 )
      Buffer[i] = 0;
  }
  for ( j = 0; j < strlen(Buffer); ++j )
  {
    if ( Buffer[j] == 60 || Buffer[j] == 62 || Buffer[j] == 38 || Buffer[j] == 34 || Buffer[j] == 39 || Buffer[j] == 47 )
    {
      printf(""Unacceptable character found in input. Exiting program."");
      exit(0);
    }
  }
  printf(""Processed input: %s"", Buffer);
  return 0;
}
// 140001790: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[104];

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char input[100];
    printf(""Please enter a string: "");
    fgets(input, 100, stdin);

    // Remove newline character from input
    for (int i = 0; i < strlen(input); i++) {
        if (input[i] == '
' || input[i] == '') {
            input[i] = '",1
"//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: realistic
#include <stdio.h>
#include <stdlib.h>

void fibonacci(int n) {
    int a = 0, b = 1, c, i;

    printf(""Fibonacci sequence:\\n"");

    for (i = 0; i < n; i++) {
        printf(""%d "", a);

        c = a + b;
        a = b;
        b = c;
    }
}

int main() {
    int n;

    printf(""Enter the number of terms in the sequence: "");
    scanf(""%d"", &n);

    fibonacci(n);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001652) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf(""Enter the number of terms in the sequence: "");
  scanf(""%d"", &v4);
  fibonacci(v4);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

void fibonacci(int n) {
    int a = 0, b = 1, c, i;
    printf(""%d %d "", a, b);
    for (i = 2; i < n; i++) {
        c = a + b;
        printf(""%d "", c);
        a = b;
        b = c;
    }
}

int main() {
    int n;
    printf(""Enter the number of terms in the sequence: "");
    scanf(""%d"", &n);
    fibonacci(n);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Digital Watermarking ; Style: irregular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/************************************************************
 * This program implements a unique digital watermarking   *
 * algorithm in an irregular style. The algorithm involves *
 * randomly inserting characters into a string in a way    *
 * that can be detected but not easily removed.             *
 *                                                          *
 * Note that this program is for demonstration purposes    *
 * only and not intended for serious use.                   *
 ************************************************************/

/* Function prototypes */
void watermark(char *str, char *mark);
void extract_mark(char *str, char *mark);

int main() {
    /* Define input strings */
    char str[] = ""The quick brown fox jumps over the lazy dog."";
    char mark[] = ""Watermark"";

    /* Call the watermark function */
    watermark(str, mark);

    /* Print the marked string */
    printf(""Marked string: \\n%s\\n"", str);

    /* Extract the mark from the marked string */
    extract_mark(str, mark);

    /* Print the extracted mark */
    printf(""Extracted mark: \\n%s\\n"", mark);

    return 0;
}

/* Function to insert the mark into the string */
void watermark(char *str, char *mark) {
    int len_str = strlen(str);
    int len_mark = strlen(mark);
    int i, j;

    /* Insert the mark into the string */
    for (i = 0; i < len_mark; i++) {
        /* Generate a random position for the character */
        j = rand() % len_str;

        /* Insert the character at the random position */
        str[j] = mark[i];
    }
}

/* Function to extract the mark from the marked string */
void extract_mark(char *str, char *mark) {
    int len_str = strlen(str);
    int len_mark = strlen(mark);
    int i, j, k;

    /* Loop through the string to find the mark */
    for (i = 0; i < len_str - len_mark; i++) {
        /* Check if this substring matches the mark */
        if (strncmp(str + i, mark, len_mark) == 0) {
            /* Remove the mark from the string */
            for (j = i; j < i + len_mark; j++) {
                /* Generate a random character to insert */
                k = rand() % 26;
                str[j] = 'a' + k;
            }

            /* Exit the loop */
            break;
        }
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall watermark(_QWORD, _QWORD); // weak
__int64 __fastcall extract_mark(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[58]; // [rsp+26h] [rbp-3Ah] BYREF

  _main(argc, argv, envp);
  strcpy(&v4[10], ""The quick brown fox jumps over the lazy dog."");
  strcpy(v4, ""Watermark"");
  watermark(&v4[10], v4);
  printf(""Marked string: \\n%s\\n"", &v4[10]);
  extract_mark(&v4[10], v4);
  printf(""Extracted mark: \\n%s\\n"", v4);
  return 0;
}
// 14000165A: using guessed type __int64 __fastcall watermark(_QWORD, _QWORD);
// 1400016CD: using guessed type __int64 __fastcall extract_mark(_QWORD, _QWORD);
// 140001860: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STRING_LENGTH 100

void watermark(char *str, char *mark);
void extract_mark(char *str, char *mark);

int main() {
    char str[MAX_STRING_LENGTH] = ""The quick brown fox jumps over the lazy dog."";
    char mark[MAX_STRING_LENGTH] = ""Watermark"";

    watermark(str, mark);
    printf(""Marked string: 
%s
"", str);

    extract_mark(str, mark);
    printf(""Extracted mark: 
%s
"", mark);

    return 0;
}

void watermark(char *str, char *mark) {
    int len = strlen(str);
    int mark_len = strlen(mark);
    int i, j;

    for (i = 0; i < len; i++) {
        if (str[i] == ' ') {
            continue;
        }

        for (j = 0; j < mark_len; j++) {
            if (str[i + j] != mark[j]) {
                break;
            }
        }

        if (j == mark_len) {
            str[i] = '*';
        }
    }
}

void extract_mark(char *str, char *mark) {
    int len = strlen(str);
    int mark_len = strlen(mark);
    int i, j;

    for (i = 0; i < len; i++) {
        if (str[i] == ' ') {
            continue;
        }

        for (j = 0; j < mark_len; j++) {
            if (str[i + j] != mark[j]) {
                break;
            }
        }

        if (j == mark_len) {
            str[i] = ' ';
        }
    }
}",2
"//FormAI DATASET v1.0 Category: Music Library Management System ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Struct for storing information about music albums
typedef struct album {
    char title[50];
    char artist[30];
    int year;
    int rating;
} Album;

// Function to get user input for a new album
Album getNewAlbum() {
    Album newAlbum;
    printf(""Enter the title of the album: "");
    scanf(""%s"", newAlbum.title);
    printf(""Enter the name of the artist: "");
    scanf(""%s"", newAlbum.artist);
    printf(""Enter the year the album was released: "");
    scanf(""%d"", &newAlbum.year);
    printf(""Enter your rating of the album (out of 10): "");
    scanf(""%d"", &newAlbum.rating);
    return newAlbum;
}

// Function to display information about an album
void displayAlbum(Album album) {
    printf(""\\nTitle: %s\\n"", album.title);
    printf(""Artist: %s\\n"", album.artist);
    printf(""Year: %d\\n"", album.year);
    printf(""Your rating: %d/10\\n"", album.rating);
}

// Function to search for an album in the library
void searchForAlbum(Album library[], int numAlbums) {
    char searchTitle[50];
    printf(""Enter the title of the album to search for: "");
    scanf(""%s"", searchTitle);

    // Loop through all the albums in the library
    for (int i = 0; i < numAlbums; i++) {
        if (strcmp(library[i].title, searchTitle) == 0) {
            printf(""\\nAlbum found!\\n"");
            displayAlbum(library[i]);
            return;
        }
    }
    printf(""\\nAlbum not found. Sorry!\\n"");
}

// Function to delete an album from the library
int deleteAlbum(Album library[], int numAlbums) {
    char deleteTitle[50];
    printf(""Enter the title of the album to delete: "");
    scanf(""%s"", deleteTitle);

    // Loop through all the albums in the library
    for (int i = 0; i < numAlbums; i++) {
        if (strcmp(library[i].title, deleteTitle) == 0) {
            printf(""\\nAlbum deleted!\\n"");
            // Shift all the albums after the deleted album over
            for (int j = i; j < numAlbums - 1; j++) {
                library[j] = library[j+1];
            }
            return numAlbums - 1;
        }
    }
    printf(""\\nAlbum not found. Sorry!\\n"");
    return numAlbums;
}

int main() {
    Album musicLibrary[100];
    int numAlbums = 0;
    bool done = false;
    while (!done) {
        printf(""\\n\\n\\t\\tWelcome to the Music Library Management System!\\n\\n"");
        printf(""What would you like to do?\\n"");
        printf(""1. Add a new album\\n"");
        printf(""2. Search for an album\\n"");
        printf(""3. Delete an album\\n"");
        printf(""4. Display all albums\\n"");
        printf(""5. Exit\\n\\n"");
        printf(""Enter your choice (1-5): "");
        int choice;
        scanf(""%d"", &choice);

        switch (choice) {
            case 1: // Add a new album
                musicLibrary[numAlbums++] = getNewAlbum();
                printf(""\\nAlbum added successfully!\\n"");
                break;

            case 2: // Search for an album
                searchForAlbum(musicLibrary, numAlbums);
                break;

            case 3: // Delete an album
                numAlbums = deleteAlbum(musicLibrary, numAlbums);
                break;

            case 4: // Display all albums
                printf(""\\n\\nYour music library:\\n\\n"");
                for (int i = 0; i < numAlbums; i++) {
                    displayAlbum(musicLibrary[i]);
                }
                break;

            case 5: // Exit
                printf(""\\nGoodbye!\\n"");
                done = true;
                break;

            default: // Invalid choice
                printf(""\\nInvalid choice. Try again!\\n"");
        }
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall getNewAlbum(_QWORD); // weak
__int64 __fastcall displayAlbum(_QWORD); // weak
__int64 __fastcall searchForAlbum(_QWORD, _QWORD); // weak
__int64 __fastcall deleteAlbum(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A38) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  _QWORD *v4; // rbx
  __int64 v5; // rdx
  __int64 v6; // rdx
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 *v10; // rax
  __int64 v11; // rbx
  __int64 v12; // rbx
  __int64 v13; // rbx
  __int64 v14; // rbx
  __int64 v15; // rbx
  __int64 v17; // [rsp+20h] [rbp-60h] BYREF
  __int64 v18; // [rsp+28h] [rbp-58h]
  __int64 v19; // [rsp+30h] [rbp-50h]
  __int64 v20; // [rsp+38h] [rbp-48h]
  __int64 v21; // [rsp+40h] [rbp-40h]
  __int64 v22; // [rsp+48h] [rbp-38h]
  __int64 v23; // [rsp+50h] [rbp-30h]
  __int64 v24; // [rsp+58h] [rbp-28h]
  __int64 v25; // [rsp+60h] [rbp-20h]
  __int64 v26; // [rsp+68h] [rbp-18h]
  __int64 v27; // [rsp+70h] [rbp-10h]
  _BYTE v28[12]; // [rsp+80h] [rbp+0h] BYREF
  int v29; // [rsp+8Ch] [rbp+Ch] BYREF
  char v30[8804]; // [rsp+90h] [rbp+10h] BYREF
  int i; // [rsp+22F4h] [rbp+2274h]
  char v32; // [rsp+22FBh] [rbp+227Bh]
  unsigned int v33; // [rsp+22FCh] [rbp+227Ch]

  _main(argc, argv, envp);
  v33 = 0;
  v32 = 0;
  while ( v32 != 1 )
  {
    printf(""\\n\\n\\t\\tWelcome to the Music Library Management System!\\n\\n"");
    printf(""What would you like to do?\\n"");
    printf(""1. Add a new album\\n"");
    printf(""2. Search for an album\\n"");
    printf(""3. Delete an album\\n"");
    printf(""4. Display all albums\\n"");
    printf(""5. Exit\\n\\n"");
    printf(""Enter your choice (1-5): "");
    scanf(""%d"", &v29);
    switch ( v29 )
    {
      case 1:
        v3 = v33++;
        v4 = &v28[88 * v3 + 16];
        getNewAlbum(&v17);
        v5 = v18;
        *v4 = v17;
        v4[1] = v5;
        v6 = v20;
        v4[2] = v19;
        v4[3] = v6;
        v7 = v22;
        v4[4] = v21;
        v4[5] = v7;
        v8 = v24;
        v4[6] = v23;
        v4[7] = v8;
        v9 = v26;
        v4[8] = v25;
        v4[9] = v9;
        v4[10] = v27;
        printf(""\\nAlbum added successfully!\\n"");
        break;
      case 2:
        searchForAlbum(v30, v33);
        break;
      case 3:
        v33 = deleteAlbum(v30, v33);
        break;
      case 4:
        printf(""\\n\\nYour music library:\\n\\n"");
        for ( i = 0; i < (int)v33; ++i )
        {
          v10 = (__int64 *)&v28[88 * i + 16];
          v11 = v10[1];
          v17 = *v10;
          v18 = v11;
          v12 = v10[3];
          v19 = v10[2];
          v20 = v12;
          v13 = v10[5];
          v21 = v10[4];
          v22 = v13;
          v14 = v10[7];
          v23 = v10[6];
          v24 = v14;
          v15 = v10[9];
          v25 = v10[8];
          v26 = v15;
          v27 = v10[10];
          displayAlbum(&v17);
        }
        break;
      case 5:
        printf(""\\nGoodbye!\\n"");
        v32 = 1;
        break;
      default:
        printf(""\\nInvalid choice. Try again!\\n"");
        break;
    }
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall getNewAlbum(_QWORD);
// 140001700: using guessed type __int64 __fastcall displayAlbum(_QWORD);
// 140001766: using guessed type __int64 __fastcall searchForAlbum(_QWORD, _QWORD);
// 1400018BB: using guessed type __int64 __fastcall deleteAlbum(_QWORD, _QWORD);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum length of the album title
#define MAX_TITLE_LENGTH 50

// Define the maximum length of the artist name
#define MAX_ARTIST_LENGTH 50

// Define the maximum length of the genre
#define MAX_GENRE_LENGTH 20

// Define the maximum number of albums
#define MAX_ALBUMS 100

// Define the album structure
typedef struct {
    char title[MAX_TITLE_LENGTH];
    char artist[MAX_ARTIST_LENGTH];
    char genre[MAX_GENRE_LENGTH];
} Album;

// Define the function to get the new album details from the user
void getNewAlbum(Album *album) {
    printf(""\\nEnter the album title: "");
    scanf(""%s"", album->title);
    printf(""Enter the artist name: "");
    scanf(""%s"", album->artist);
    printf(""Enter the genre: "");
    scanf(""%s"", album->genre);
}

// Define the function to display the album details
void displayAlbum(Album album) {
    printf(""\\nAlbum Title: %s"", album.title);
    printf(""\\nArtist: %s"", album.artist);
    printf(""\\nGenre: %s"", album.genre);
}

// Define the function to search for an album
void searchForAlbum(Album albums[], int numAlbums) {
    char searchTitle[MAX_TITLE_LENGTH];
    printf(""\\nEnter the album title to search for: "");
    scanf(""%s"", searchTitle);
    for (int i = 0; i < numAlbums; i++) {
        if (strcmp(albums[i].title, searchTitle) == 0) {
            printf(""\\nAlbum found!\\n"");
            displayAlbum(albums[i]);
            return;
        }
    }
    printf(""\\nAlbum not found!\\n"");
}

// Define the function to delete an album
int deleteAlbum(Album albums[], int numAlbums) {
    char searchTitle[MAX_TITLE_LENGTH];
    printf(""\\nEnter the album title to delete: "");
    scanf(""%s"", searchTitle);
    for (int i = 0; i < numAlbums; i++) {
        if (strcmp(albums[i].title, searchTitle) == 0) {
            for (int j = i; j < numAlbums - 1; j++) {
                albums[j] = albums[j+1];
            }
            numAlbums--;
            printf(""\\nAlbum deleted successfully!\\n"");
            return numAlbums;
        }
    }
    printf(""\\nAlbum not found!\\n"");
    return numAlbums;
}

int main() {
    Album albums[MAX_ALBUMS];
    int numAlbums = 0;
    int choice = 0;
    int exit = 0;
    while (!exit) {
        printf(""\\n\\n\\t\\tWelcome to the Music Library Management System!\\n\\n"");
        printf(""What would you like to do?\\n"");
        printf(""1. Add a new album\\n"");
        printf(""2. Search for an album\\n"");
        printf(""3. Delete an album\\n"");
        printf(""4. Display all albums\\n"");
        printf(""5. Exit\\n\\n"");
        printf(""Enter your choice (1-5): "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                getNewAlbum(&albums[numAlbums++]);
                printf(""\\nAlbum added successfully!\\n"");
                break;
            case 2:
                searchForAlbum(albums, numAlbums);
                break;
            case 3:
                numAlbums = deleteAlbum(albums, num",2
"//FormAI DATASET v1.0 Category: Classical Circuit Simulator ; Style: happy
#include <stdio.h>

int main() {
    // Define the circuit components
    int resistance = 100;
    int voltage = 5;
    int current = voltage / resistance;

    // Print the results
    printf(""The current flowing through the circuit is %d amps.\\n"", current);
    
    return 0;    
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  printf(""The current flowing through the circuit is %d amps.\\n"", 0i64);
  return 0;
}
// 140001690: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    int resistance = 1000; // Ohms
    int voltage = 12; // Volts
    int current = voltage / resistance; // Amps
    
    printf(""The current flowing through the circuit is %d amps.
"", current);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: detailed
#include <stdio.h>
#include <stdlib.h>

#define ROWS 10
#define COLS 10

// Function to print the maze
void printMaze(int maze[ROWS][COLS]) {
    for(int i=0; i < ROWS; i++) {
        for(int j=0; j < COLS; j++) {
            printf(""%d "", maze[i][j]);
        }
        printf(""\\n"");
    }
}

// Function to check if a cell is valid or not
int isValidCell(int row, int col, int maze[ROWS][COLS]) {
    if(row >= 0 && row < ROWS && col >= 0 && col < COLS && maze[row][col] == 1) {
        return 1;
    }
    return 0;
}

// Function to find the route through the maze
int findRoute(int row, int col, int maze[ROWS][COLS], int path[ROWS][COLS]) {
    // Check if we have reached the end of the maze
    if(row == ROWS-1 && col == COLS-1) {
        path[row][col] = 1;
        return 1;
    }
    
    // Check if the current cell is valid or not
    if(isValidCell(row, col, maze) == 1) {
        path[row][col] = 1;
        
        // Move right
        if(findRoute(row, col+1, maze, path) == 1) {
            return 1;
        }
        
        // Move down
        if(findRoute(row+1, col, maze, path) == 1) {
            return 1;
        }
        
        // If we cannot move right or down, backtrack and mark current cell as 0
        path[row][col] = 0;
        return 0;
    }
    
    return 0;
}

int main() {
    // Initialize the maze
    int maze[ROWS][COLS] = {
        {1, 1, 1, 1, 1, 1, 0, 1, 1, 1},
        {1, 0, 0, 0, 1, 1, 1, 0, 1, 1},
        {1, 1, 1, 0, 1, 1, 0, 1, 1, 1},
        {1, 1, 1, 0, 0, 0, 0, 0, 0, 1},
        {0, 0, 1, 1, 1, 1, 1, 1, 0, 1},
        {1, 0, 1, 0, 0, 0, 0, 1, 0, 1},
        {1, 0, 1, 1, 1, 1, 1, 1, 1, 1},
        {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
        {0, 0, 0, 0, 1, 1, 1, 1, 1, 1}
    };
    
    // Initialize the path
    int path[ROWS][COLS] = {0};

    // Find the route through the maze
    if(findRoute(0, 0, maze, path) == 0) {
        printf(""No path found\\n"");
        return 0;
    }
    
    // Print the solution
    printf(""Solution:\\n"");
    printMaze(path);
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall printMaze(_QWORD); // weak
__int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_14000A020; // weak


//----- (000000014000179D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[400]; // [rsp+20h] [rbp-60h] BYREF
  char v5[416]; // [rsp+1B0h] [rbp+130h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v5, &unk_14000A020, 0x190ui64);
  memset(v4, 0, sizeof(v4));
  if ( (unsigned int)findRoute(0i64, 0i64, v5, v4) )
  {
    printf(""Solution:\\n"");
    printMaze(v4);
  }
  else
  {
    printf(""No path found\\n"");
  }
  return 0;
}
// 140001591: using guessed type __int64 __fastcall printMaze(_QWORD);
// 140001670: using guessed type __int64 __fastcall findRoute(_QWORD, _QWORD, _QWORD, _QWORD);
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

#define ROWS 10
#define COLS 10

// Maze structure
typedef struct {
    int row;
    int col;
} Position;

// Maze data
int maze[ROWS][COLS] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

// Print maze
void printMaze(int maze[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf(""%d "", maze[i][j]);
        }
        printf(""
"");
    }
}

// Check if position is valid
int isValid(Position pos) {
    if (pos.row < 0 || pos.row >= ROWS || pos.col < 0 || pos.col >= COLS) {
        return 0;
    }
    return maze[pos.row][pos.col];
}

// Check if position is valid and unvisited
int isValidUnvisited(Position pos, int visited[ROWS][COLS]) {
    if (!isValid(pos)) {
        return 0;
    }
    if (visited[pos.row][pos.col]) {
        return 0;
    }
    return 1;
}

// Find route
int findRoute(Position start, Position end, int maze[ROWS][COLS], int visited[ROWS][COLS]) {
    Position current = start;
    visited[current.row][current.col] = 1;
    while (current.row != end.row || current.col != end.col) {
        if (current.row < end.row) {
            if (isValidUnvisited(Position{current.row + 1, current.col}, maze, visited)) {
                current = Position{current.row + 1, current.col};
                visited[current.row][current.col] = 1;
            }
            else {
                return 0;
            }
        }
        else if (current.row > end.row) {
            if (isValidUnvisited(Position{current.row - 1, current.col}, maze, visited)) {
                current = Position{current.row - 1, current.col};
                visited[current.row][current.col] = 1;
            }
            else {
                return 0;
            }
        }
        else if (current.col < end.col) {
            if (isValidUnvisited(Position{current.row, current.col + 1}, maze, visited)) {
                current = Position",2
"//FormAI DATASET v1.0 Category: Text processing ; Style: automated
#include <stdio.h>
#include <ctype.h>
#define MAX_SIZE 100

int main()
{
   char text[MAX_SIZE];
   int alphabetCount = 0, digitsCount = 0, specialCharsCount = 0;
   int i;

   printf(""Enter any text: "");
   fgets(text, MAX_SIZE, stdin);

   for(i=0; text[i] != '\\0'; i++)
   {
      if(isalpha(text[i]))
      {
         alphabetCount++;
      }
      else if(isdigit(text[i]))
      {
         digitsCount++;
      }
      else
      {
         specialCharsCount++;
      }
   }

   printf(""\\n\\nTotal Alphabets: %d"", alphabetCount);
   printf(""\\nTotal Digits: %d"", digitsCount);
   printf(""\\nTotal Special Characters: %d"", specialCharsCount);

   return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
FILE *__cdecl _acrt_iob_func(unsigned int Ix);
FILE *__cdecl __acrt_iob_func(unsigned int Ix);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalpha)(int C);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rax
  char Buffer[112]; // [rsp+20h] [rbp-80h] BYREF
  int i; // [rsp+90h] [rbp-10h]
  unsigned int v7; // [rsp+94h] [rbp-Ch]
  unsigned int v8; // [rsp+98h] [rbp-8h]
  unsigned int v9; // [rsp+9Ch] [rbp-4h]

  _main(argc, argv, envp);
  v9 = 0;
  v8 = 0;
  v7 = 0;
  printf(""Enter any text: "");
  v3 = __acrt_iob_func(0);
  fgets(Buffer, 100, v3);
  for ( i = 0; Buffer[i]; ++i )
  {
    if ( isalpha(Buffer[i]) )
    {
      ++v9;
    }
    else if ( (unsigned int)(Buffer[i] - 48) > 9 )
    {
      ++v7;
    }
    else
    {
      ++v8;
    }
  }
  printf(""\\n\\nTotal Alphabets: %d"", v9);
  printf(""\\nTotal Digits: %d"", v8);
  printf(""\\nTotal Special Characters: %d"", v7);
  return 0;
}
// 140001740: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type char Buffer[112];

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <ctype.h>

int main() {
    char str[100];
    int i, alph=0, num=0, spec=0;

    printf(""Enter any text: "");
    fgets(str, 100, stdin);

    for(i=0; str[i]!='",2
"//FormAI DATASET v1.0 Category: Graph representation ; Style: realistic
#include <stdio.h>
#include <stdlib.h>

// define constants for the maximum number of vertices and edges possible
#define MAX_VERTICES 20
#define MAX_EDGES 25

int vertices[MAX_VERTICES]; // array to store vertices
int edges[MAX_EDGES][2]; // array to store edges

// function to add a vertex to the graph
void add_vertex(int v_index) {
    vertices[v_index] = 1;
}

// function to add an edge to the graph
void add_edge(int e_index, int u, int v) {
    edges[e_index][0] = u;
    edges[e_index][1] = v;
}

// function to display the graph
void display_graph(int num_vertices, int num_edges) {
    printf(""Vertices: "");
    for (int i = 0; i < num_vertices; i++) {
        if (vertices[i] == 1) {
            printf(""%d "", i);
        }
    }
    printf(""\\n"");

    printf(""Edges: "");
    for (int i = 0; i < num_edges; i++) {
        printf(""(%d, %d) "", edges[i][0], edges[i][1]);
    }
    printf(""\\n"");
}

int main() {
    int num_vertices, num_edges;
    printf(""Enter the number of vertices in the graph (maximum %d): "", MAX_VERTICES);
    scanf(""%d"", &num_vertices);

    if (num_vertices > MAX_VERTICES) {
        printf(""Error: Number of vertices cannot exceed %d.\\n"", MAX_VERTICES);
        exit(1);
    }

    printf(""Enter the number of edges in the graph (maximum %d): "", MAX_EDGES);
    scanf(""%d"", &num_edges);

    if (num_edges > MAX_EDGES) {
        printf(""Error: Number of edges cannot exceed %d.\\n"", MAX_EDGES);
        exit(1);
    }

    printf(""Enter the edges of the graph in the format 'u v':\\n"");

    for (int i = 0; i < num_edges; i++) {
        int u, v;
        scanf(""%d %d"", &u, &v);

        // add vertices to the graph
        add_vertex(u);
        add_vertex(v);

        // add edges to the graph
        add_edge(i, u, v);
    }

    // display the graph
    display_graph(num_vertices, num_edges);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_vertex(_QWORD); // weak
__int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall display_graph(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001739) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v5; // [rsp+30h] [rbp-10h] BYREF
  int v6; // [rsp+34h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+38h] [rbp-8h] BYREF
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Enter the number of vertices in the graph (maximum %d): "", 20i64);
  scanf(""%d"", &v7);
  if ( (int)v7 > 20 )
  {
    printf(""Error: Number of vertices cannot exceed %d.\\n"", 20i64);
    exit(1);
  }
  printf(""Enter the number of edges in the graph (maximum %d): "", 25i64);
  scanf(""%d"", &v6);
  if ( v6 > 25 )
  {
    printf(""Error: Number of edges cannot exceed %d.\\n"", 25i64);
    exit(1);
  }
  printf(""Enter the edges of the graph in the format 'u v':\\n"");
  for ( i = 0; (int)i < v6; ++i )
  {
    scanf(""%d %d"", &v5, &v4);
    add_vertex(v5);
    add_vertex(v4);
    add_edge(i, v5, v4);
  }
  display_graph(v7, (unsigned int)v6);
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall add_vertex(_QWORD);
// 140001607: using guessed type __int64 __fastcall add_edge(_QWORD, _QWORD, _QWORD);
// 14000164C: using guessed type __int64 __fastcall display_graph(_QWORD, _QWORD);
// 140001920: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 20
#define MAX_EDGES 25

int adj_matrix[MAX_VERTICES][MAX_VERTICES];
int num_vertices = 0;
int num_edges = 0;

void add_vertex(int vertex) {
    if (vertex >= MAX_VERTICES) {
        printf(""Error: Maximum number of vertices exceeded.
"");
        exit(1);
    }
    if (adj_matrix[vertex][vertex] == 0) {
        adj_matrix[vertex][vertex] = 1;
        num_vertices++;
    }
}

void add_edge(int edge_num, int u, int v) {
    if (edge_num >= MAX_EDGES) {
        printf(""Error: Maximum number of edges exceeded.
"");
        exit(1);
    }
    if (u >= MAX_VERTICES || v >= MAX_VERTICES) {
        printf(""Error: Invalid vertex number.
"");
        exit(1);
    }
    if (adj_matrix[u][v] == 0) {
        adj_matrix[u][v] = 1;
        adj_matrix[v][u] = 1;
        num_edges++;
    }
}

void display_graph(int num_vertices, int num_edges) {
    int i, j;
    printf(""Adjacency Matrix for Graph:
"");
    for (i = 0; i < num_vertices; i++) {
        for (j = 0; j < num_vertices; j++) {
            printf(""%d "", adj_matrix[i][j]);
        }
        printf(""
"");
    }
}

int main() {
    int num_vertices, num_edges, u, v, i;
    printf(""Enter the number of vertices in the graph (maximum %d): "", MAX_VERTICES);
    scanf(""%d"", &num_vertices);
    if (num_vertices > MAX_VERTICES) {
        printf(""Error: Number of vertices cannot exceed %d.
"", MAX_VERTICES);
        exit(1);
    }
    printf(""Enter the number of edges in the graph (maximum %d): "", MAX_EDGES);
    scanf(""%d"", &num_edges);
    if (num_edges > MAX_EDGES) {
        printf(""Error: Number of edges cannot exceed %d.
"", MAX_EDGES);
        exit(1);
    }
    printf(""Enter the edges of the graph in the format 'u v':
"");
    for (i = 0; i < num_edges; i++) {
        scanf(""%d %d"", &u, &v);
        add_vertex(u);
        add_vertex(v);
        add_edge(i, u, v);
    }
    display_graph(num_vertices, num_edges);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Scientific Calculator Implementation ; Style: energetic
#include<stdio.h>
#include<math.h>

int main(){

    printf(""Welcome to the Scientific Calculator!\\n"");

    int choice, num1, num2;
    float result;

    printf(""Please select an operation to perform:\\n"");
    printf(""1. Addition\\n 2. Subtraction\\n 3. Multiplication\\n 4. Division\\n 5. Square root\\n 6. Square\\n 7. Cube\\n 8. Power\\n 9. Sine\\n 10. Cosine\\n 11. Tangent\\n"");
    scanf(""%d"", &choice);

    switch(choice){

        case 1: //Addition
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = num1 + num2;
            printf(""The addition of %d and %d is %.2f\\n"", num1, num2, result);
            break;

        case 2: //Subtraction
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = num1 - num2;
            printf(""The subtraction of %d and %d is %.2f\\n"", num1, num2, result);
            break;

        case 3: //Multiplication
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = num1 * num2;
            printf(""The multiplication of %d and %d is %.2f\\n"", num1, num2, result);
            break;

        case 4: //Division
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = (float) num1 / num2;
            printf(""The division of %d and %d is %.2f\\n"", num1, num2, result);
            break;

        case 5: //Square root
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            result = sqrt(num1);
            printf(""The square root of %d is %.2f\\n"", num1, result);
            break;

        case 6: //Square
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            result = pow(num1, 2);
            printf(""The square of %d is %.2f\\n"", num1, result);
            break;

        case 7: //Cube
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            result = pow(num1, 3);
            printf(""The cube of %d is %.2f\\n"", num1, result);
            break;

        case 8: //Power
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            printf(""Enter the power: "");
            scanf(""%d"", &num2);
            result = pow(num1, num2);
            printf(""%d raised to the power of %d is %.2f\\n"", num1, num2, result);
            break;

        case 9: //Sine
            printf(""Enter the angle in degrees: "");
            scanf(""%d"", &num1);
            result = sin(num1 * M_PI/180);
            printf(""The sine of %d is %.2f\\n"", num1, result);
            break;

        case 10: //Cosine
            printf(""Enter the angle in degrees: "");
            scanf(""%d"", &num1);
            result = cos(num1 * M_PI/180);
            printf(""The cosine of %d is %.2f\\n"", num1, result);
            break;

        case 11: //Tangent
            printf(""Enter the angle in degrees: "");
            scanf(""%d"", &num1);
            result = tan(num1 * M_PI/180);
            printf(""The tangent of %d is %.2f\\n"", num1, result);
            break;

        default:
            printf(""Invalid choice\\n"");
    }

    return 0; 
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
double __cdecl sqrt(double X);
double __cdecl cos(double X);
double __cdecl pow(double X, double Y);
double __cdecl sin(double X);
// double __cdecl tan(double X);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  float v7; // xmm0_4
  float v8; // xmm0_4
  float v9; // xmm0_4
  unsigned int v11; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v12; // [rsp+24h] [rbp-Ch] BYREF
  int v13; // [rsp+28h] [rbp-8h] BYREF
  float v14; // [rsp+2Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Welcome to the Scientific Calculator!\\n"");
  printf(""Please select an operation to perform:\\n"");
  printf(
    ""1. Addition\\n""
    "" 2. Subtraction\\n""
    "" 3. Multiplication\\n""
    "" 4. Division\\n""
    "" 5. Square root\\n""
    "" 6. Square\\n""
    "" 7. Cube\\n""
    "" 8. Power\\n""
    "" 9. Sine\\n""
    "" 10. Cosine\\n""
    "" 11. Tangent\\n"");
  scanf(""%d"", &v13);
  switch ( v13 )
  {
    case 1:
      printf(""Enter the first number: "");
      scanf(""%d"", &v12);
      printf(""Enter the second number: "");
      scanf(""%d"", &v11);
      v14 = (float)(int)(v12 + v11);
      printf(""The addition of %d and %d is %.2f\\n"", v12, v11, v14);
      break;
    case 2:
      printf(""Enter the first number: "");
      scanf(""%d"", &v12);
      printf(""Enter the second number: "");
      scanf(""%d"", &v11);
      v14 = (float)(int)(v12 - v11);
      printf(""The subtraction of %d and %d is %.2f\\n"", v12, v11, v14);
      break;
    case 3:
      printf(""Enter the first number: "");
      scanf(""%d"", &v12);
      printf(""Enter the second number: "");
      scanf(""%d"", &v11);
      v14 = (float)(int)(v12 * v11);
      printf(""The multiplication of %d and %d is %.2f\\n"", v12, v11, v14);
      break;
    case 4:
      printf(""Enter the first number: "");
      scanf(""%d"", &v12);
      printf(""Enter the second number: "");
      scanf(""%d"", &v11);
      v14 = (float)(int)v12 / (float)(int)v11;
      printf(""The division of %d and %d is %.2f\\n"", v12, v11, v14);
      break;
    case 5:
      printf(""Enter a number: "");
      scanf(""%d"", &v12);
      v3 = sqrt((double)(int)v12);
      v14 = v3;
      printf(""The square root of %d is %.2f\\n"", v12, v3);
      break;
    case 6:
      printf(""Enter a number: "");
      scanf(""%d"", &v12);
      v4 = pow((double)(int)v12, 2.0);
      v14 = v4;
      printf(""The square of %d is %.2f\\n"", v12, v4);
      break;
    case 7:
      printf(""Enter a number: "");
      scanf(""%d"", &v12);
      v5 = pow((double)(int)v12, 3.0);
      v14 = v5;
      printf(""The cube of %d is %.2f\\n"", v12, v5);
      break;
    case 8:
      printf(""Enter a number: "");
      scanf(""%d"", &v12);
      printf(""Enter the power: "");
      scanf(""%d"", &v11);
      v6 = pow((double)(int)v12, (double)(int)v11);
      v14 = v6;
      printf(""%d raised to the power of %d is %.2f\\n"", v12, v11, v6);
      break;
    case 9:
      printf(""Enter the angle in degrees: "");
      scanf(""%d"", &v12);
      v7 = sin(3.141592653589793 * (double)(int)v12 / 180.0);
      v14 = v7;
      printf(""The sine of %d is %.2f\\n"", v12, v7);
      break;
    case 10:
      printf(""Enter the angle in degrees: "");
      scanf(""%d"", &v12);
      v8 = cos(3.141592653589793 * (double)(int)v12 / 180.0);
      v14 = v8;
      printf(""The cosine of %d is %.2f\\n"", v12, v8);
      break;
    case 11:
      printf(""Enter the angle in degrees: "");
      scanf(""%d"", &v12);
      v9 = tan(3.141592653589793 * (double)(int)v12 / 180.0);
      v14 = v9;
      printf(""The tangent of %d is %.2f\\n"", v12, v9);
      break;
    default:
      printf(""Invalid choice\\n"");
      break;
  }
  return 0;
}
// 140001DB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=187 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main() {
    int choice, num1, num2;
    float result;

    printf(""Welcome to the Scientific Calculator!\\n"");
    printf(""Please select an operation to perform:\\n"");
    printf(""1. Addition\\n2. Subtraction\\n3. Multiplication\\n4. Division\\n5. Square root\\n6. Square\\n7. Cube\\n8. Power\\n9. Sine\\n10. Cosine\\n11. Tangent\\n"");
    scanf(""%d"", &choice);

    switch(choice) {
        case 1:
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = num1 + num2;
            printf(""The addition of %d and %d is %.2f\\n"", num1, num2, result);
            break;
        case 2:
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = num1 - num2;
            printf(""The subtraction of %d and %d is %.2f\\n"", num1, num2, result);
            break;
        case 3:
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = num1 * num2;
            printf(""The multiplication of %d and %d is %.2f\\n"", num1, num2, result);
            break;
        case 4:
            printf(""Enter the first number: "");
            scanf(""%d"", &num1);
            printf(""Enter the second number: "");
            scanf(""%d"", &num2);
            result = (float)num1 / (float)num2;
            printf(""The division of %d and %d is %.2f\\n"", num1, num2, result);
            break;
        case 5:
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            result = sqrt(num1);
            printf(""The square root of %d is %.2f\\n"", num1, result);
            break;
        case 6:
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            result = pow(num1, 2);
            printf(""The square of %d is %.2f\\n"", num1, result);
            break;
        case 7:
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            result = pow(num1, 3);
            printf(""The cube of %d is %.2f\\n"", num1, result);
            break;
        case 8:
            printf(""Enter a number: "");
            scanf(""%d"", &num1);
            printf(""Enter the power: "");
            scanf(""%d"", &num2);
            result = pow(num1, num2);
            printf(""%d raised to the power of %d is %.2f\\n"", num1, num2, result);
            break;
        case 9:
            printf(""Enter the angle in degrees: "");
            scanf(""%d"", &num1);
            result = sin(num1 * M_PI / 180);
            printf(""The sine of %d is %.2f\\n"", num1, result);
            break;
        case 10:
            printf(""Enter the angle in degrees: "");
            scanf(""%d"", &num1);
            result = cos(num1 * M_PI / 180);
            printf(""The cosine of %d is %.2f\\n"", num1, result);
            break;
        case 11:
            printf(""Enter the angle in degrees: """,2
"//FormAI DATASET v1.0 Category: HTML beautifier ; Style: funny
#include <stdio.h>
#include <stdlib.h>

int main() {
    char* input = ""<html><head><title>My Funny HTML Page</title></head><body><h1>Welcome to my page</h1><p>This is a paragraph.</p></body></html>"";
    char* output = malloc(sizeof(char) * strlen(input));
    int indent_level = 0;
    int i = 0;

    while (input[i] != '\\0') {
        // check for opening and closing tags
        if (input[i] == '<' && input[i+1] != '/') {
            printf(""\\n"");
            for (int j = 0; j < indent_level*4; j++) {
                printf("" "");
            }
            printf(""%c"", input[i]);
            printf(""%c"", input[i+1]);
            indent_level++;
            i += 2;
        } else if (input[i] == '<' && input[i+1] == '/') {
            printf(""\\n"");
            indent_level--;
            for (int j = 0; j < indent_level*4; j++) {
                printf("" "");
            }
            printf(""%c"", input[i]);
            printf(""%c"", input[i+1]);
            i += 2;
        } else {
            printf(""%c"", input[i]);
            i++;
        }
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void *__cdecl malloc(size_t Size);

//-------------------------------------------------------------------------
// Data declarations

char aHtmlHeadTitleM[127] = ""<html><head><title>My Funny HTML Page</title></head><body><h1>Welcome to my page</h1><p>This is a paragraph.</p></body></html>""; // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v3; // rax
  int i; // [rsp+30h] [rbp-10h]
  int j; // [rsp+34h] [rbp-Ch]
  int v7; // [rsp+38h] [rbp-8h]
  int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = strlen(
         ""<html><head><title>My Funny HTML Page</title></head><body><h1>Welcome to my page</h1><p>This is a paragraph.</p></body></html>"");
  malloc(v3);
  v8 = 0;
  v7 = 0;
  while ( aHtmlHeadTitleM[v7] )
  {
    if ( aHtmlHeadTitleM[v7] != 60 || aHtmlHeadTitleM[v7 + 1] == 47 )
    {
      if ( aHtmlHeadTitleM[v7] == 60 && aHtmlHeadTitleM[v7 + 1] == 47 )
      {
        printf(""\\n"");
        --v8;
        for ( i = 0; i < 4 * v8; ++i )
          printf("" "");
        printf(""%c"", (unsigned int)aHtmlHeadTitleM[v7]);
        printf(""%c"", (unsigned int)aHtmlHeadTitleM[v7 + 1]);
        v7 += 2;
      }
      else
      {
        printf(""%c"", (unsigned int)aHtmlHeadTitleM[v7++]);
      }
    }
    else
    {
      printf(""\\n"");
      for ( j = 0; j < 4 * v8; ++j )
        printf("" "");
      printf(""%c"", (unsigned int)aHtmlHeadTitleM[v7]);
      printf(""%c"", (unsigned int)aHtmlHeadTitleM[v7 + 1]);
      ++v8;
      v7 += 2;
    }
  }
  return 0;
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char htmlHeadTitle[] = ""<html><head><title>My Funny HTML Page</title></head><body><h1>Welcome to my page</h1><p>This is a paragraph.</p></body></html>"";

int main() {
    char *beautifiedHtml = malloc(strlen(htmlHeadTitle) * sizeof(char));
    int indentLevel = 0;
    int i = 0;
    while (htmlHeadTitle[i] != '",1
"//FormAI DATASET v1.0 Category: Password management ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Function prototypes
void add_password();
void view_all_passwords();
void search_password();
void update_password();
void delete_password();
int is_valid_password(char password[]);

// Password structure
struct Password {
    char website[50];
    char username[50];
    char password[50];
};

int main() {
    int option;
    do {
        printf(""\\n\\nMENU\\n"");
        printf(""1. Add a password\\n"");
        printf(""2. View all passwords\\n"");
        printf(""3. Search a password\\n"");
        printf(""4. Update a password\\n"");
        printf(""5. Delete a password\\n"");
        printf(""6. Exit\\n"");
        printf(""Enter your option: "");
        scanf(""%d"", &option);

        switch (option) {
            case 1:
                add_password();
                break;
            case 2:
                view_all_passwords();
                break;
            case 3:
                search_password();
                break;
            case 4:
                update_password();
                break;
            case 5:
                delete_password();
                break;
            case 6:
                printf(""Goodbye!\\n"");
                break;
            default:
                printf(""Invalid option!\\n"");
        }
    } while (option != 6);

    return 0;
}

// Add Password function
void add_password() {
    printf(""\\nADD PASSWORD\\n"");

    // Create new password structure
    struct Password password;

    // Get website
    printf(""Enter website: "");
    scanf(""%s"", password.website);

    // Get username
    printf(""Enter username: "");
    scanf(""%s"", password.username);

    // Get password
    char password_string[50];
    printf(""Enter password: "");
    scanf(""%s"", password_string);

    // Validate password
    if (is_valid_password(password_string)) {
        // Store password into structure
        strcpy(password.password, password_string);

        // Open password file in append mode
        FILE *file = fopen(""passwords.txt"", ""a"");

        // Write to file
        fprintf(file, ""%s, %s, %s\\n"", password.website, password.username, password.password);

        // Close file
        fclose(file);

        printf(""Password added successfully!\\n"");
    } else {
        printf(""Invalid password. Password must be at least 8 characters long and contain at least one digit and one uppercase letter.\\n"");
    }
}

// View All Passwords function
void view_all_passwords() {
    printf(""\\nVIEW ALL PASSWORDS\\n"");

    // Open password file in read mode
    FILE *file = fopen(""passwords.txt"", ""r"");

    // Read file and print each line
    char line[100];
    while (fgets(line, sizeof(line), file) != NULL) {
        printf(""%s"", line);
    }

    // Close file
    fclose(file);
}

// Search Password function
void search_password() {
    printf(""\\nSEARCH PASSWORD\\n"");

    // Get search query from user
    char query[50];
    printf(""Enter something to search for: "");
    scanf(""%s"", query);

    // Open password file in read mode
    FILE *file = fopen(""passwords.txt"", ""r"");

    // Read file and print matching lines
    char line[100];
    int found = 0;
    while (fgets(line, sizeof(line), file) != NULL) {
        if (strstr(line, query) != NULL) {
            printf(""%s"", line);
            found = 1;
        }
    }

    // Close file
    fclose(file);

    // Display message if no matching passwords found
    if (!found) {
        printf(""No matching passwords found.\\n"");
    }
}

// Update Password function
void update_password() {
    printf(""\\nUPDATE PASSWORD\\n"");

    // Get website to update
    char website[50];
    printf(""Enter website to update: "");
    scanf(""%s"", website);

    // Open password file in read mode
    FILE *file = fopen(""passwords.txt"", ""r"");

    // Create temporary file to store updated passwords
    FILE *temp_file = fopen(""temp.txt"", ""w"");

    // Read file and update matching password
    char line[100];
    int found = 0;
    while (fgets(line, sizeof(line), file) != NULL) {
        // Check if line contains website to update
        if (strstr(line, website) != NULL) {
            // Get new password
            char password_string[50];
            printf(""Enter new password: "");
            scanf(""%s"", password_string);

            // Validate password
            if (is_valid_password(password_string)) {
                // Update password in structure
                struct Password password;
                char *token = strtok(line, "", "");
                strcpy(password.website, token);
                token = strtok(NULL, "", "");
                strcpy(password.username, token);
                strcpy(password.password, password_string);

                // Write updated password to temporary file
                fprintf(temp_file, ""%s, %s, %s\\n"", password.website, password.username, password.password);

                found = 1;

                printf(""Password updated successfully!\\n"");
            } else {
                printf(""Invalid password. Password must be at least 8 characters long and contain at least one digit and one uppercase letter.\\n"");
                // Write original password to temporary file
                fprintf(temp_file, ""%s"", line);
            }
        } else {
            // Write original password to temporary file
            fprintf(temp_file, ""%s"", line);
        }
    }

    // Close files
    fclose(file);
    fclose(temp_file);

    // Replace original file with temporary file
    remove(""passwords.txt"");
    rename(""temp.txt"", ""passwords.txt"");

    // Display message if website not found
    if (!found) {
        printf(""Website not found.\\n"");
    }
}

// Delete Password function
void delete_password() {
    printf(""\\nDELETE PASSWORD\\n"");

    // Get website to delete
    char website[50];
    printf(""Enter website to delete: "");
    scanf(""%s"", website);

    // Open password file in read mode
    FILE *file = fopen(""passwords.txt"", ""r"");

    // Create temporary file to store remaining passwords
    FILE *temp_file = fopen(""temp.txt"", ""w"");

    // Read file and delete matching password
    char line[100];
    int found = 0;
    while (fgets(line, sizeof(line), file) != NULL) {
        // Check if line does not contain website to delete
        if (strstr(line, website) == NULL) {
            // Write password to temporary file
            fprintf(temp_file, ""%s"", line);
        } else {
            found = 1;
            printf(""Password deleted successfully!\\n"");
        }
    }

    // Close files
    fclose(file);
    fclose(temp_file);

    // Replace original file with temporary file
    remove(""passwords.txt"");
    rename(""temp.txt"", ""passwords.txt"");

    // Display message if website not found
    if (!found) {
        printf(""Website not found.\\n"");
    }
}

// Password Validation function
int is_valid_password(char password[]) {
    int length = strlen(password);
    // Check length is at least 8 characters
    if (length < 8) {
        return 0;
    }
    // Check for at least one digit
    int has_digit = 0;
    for (int i = 0; i < length; i++) {
        if (isdigit(password[i])) {
            has_digit = 1;
            break;
        }
    }
    if (!has_digit) {
        return 0;
    }
    // Check for at least one uppercase letter
    int has_uppercase = 0;
    for (int i = 0; i < length; i++) {
        if (isupper(password[i])) {
            has_uppercase = 1;
            break;
        }
    }
    if (!has_uppercase) {
        return 0;
    }

    // If no validation errors, return 1
    return 1;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 add_password(void); // weak
__int64 view_all_passwords(void); // weak
__int64 search_password(void); // weak
__int64 update_password(void); // weak
__int64 delete_password(void); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001625) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf(""\\n\\nMENU\\n"");
    printf(""1. Add a password\\n"");
    printf(""2. View all passwords\\n"");
    printf(""3. Search a password\\n"");
    printf(""4. Update a password\\n"");
    printf(""5. Delete a password\\n"");
    printf(""6. Exit\\n"");
    printf(""Enter your option: "");
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        add_password();
        break;
      case 2:
        view_all_passwords();
        break;
      case 3:
        search_password();
        break;
      case 4:
        update_password();
        break;
      case 5:
        delete_password();
        break;
      case 6:
        printf(""Goodbye!\\n"");
        break;
      default:
        printf(""Invalid option!\\n"");
        break;
    }
  }
  while ( v4 != 6 );
  return 0;
}
// 140001744: using guessed type __int64 add_password(void);
// 14000188C: using guessed type __int64 view_all_passwords(void);
// 14000190E: using guessed type __int64 search_password(void);
// 1400019F6: using guessed type __int64 update_password(void);
// 140001C8A: using guessed type __int64 delete_password(void);
// 140001F60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=191 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PASSWORDS 100

struct Password {
    char website[50];
    char username[50];
    char password[50];
};

struct Password passwords[MAX_PASSWORDS];
int num_passwords = 0;

void add_password();
void view_all_passwords();
void search_password();
void update_password();
void delete_password();

int main() {
    int option;
    do {
        printf(""\\n\\nMENU\\n"");
        printf(""1. Add a password\\n"");
        printf(""2. View all passwords\\n"");
        printf(""3. Search a password\\n"");
        printf(""4. Update a password\\n"");
        printf(""5. Delete a password\\n"");
        printf(""6. Exit\\n"");
        printf(""Enter your option: "");
        scanf(""%d"", &option);
        switch (option) {
            case 1:
                add_password();
                break;
            case 2:
                view_all_passwords();
                break;
            case 3:
                search_password();
                break;
            case 4:
                update_password();
                break;
            case 5:
                delete_password();
                break;
            case 6:
                printf(""Goodbye!\\n"");
                break;
            default:
                printf(""Invalid option!\\n"");
        }
    } while (option != 6);
    return 0;
}

void add_password() {
    if (num_passwords == MAX_PASSWORDS) {
        printf(""Maximum number of passwords reached!\\n"");
        return;
    }
    struct Password new_password;
    printf(""Enter website: "");
    scanf(""%s"", new_password.website);
    printf(""Enter username: "");
    scanf(""%s"", new_password.username);
    printf(""Enter password: "");
    scanf(""%s"", new_password.password);
    passwords[num_passwords++] = new_password;
    printf(""Password added successfully!\\n"");
}

void view_all_passwords() {
    if (num_passwords == 0) {
        printf(""No passwords found!\\n"");
        return;
    }
    printf(""Website\\tUsername\\tPassword\\n"");
    for (int i = 0; i < num_passwords; i++) {
        printf(""%s\\t%s\\t%s\\n"", passwords[i].website, passwords[i].username, passwords[i].password);
    }
}

void search_password() {
    char website[50];
    printf(""Enter website to search: "");
    scanf(""%s"", website);
    for (int i = 0; i < num_passwords; i++) {
        if (strcmp(passwords[i].website, website) == 0) {
            printf(""Website\\tUsername\\tPassword\\n"");
            printf(""%s\\t%s\\t%s\\n"", passwords[i].website, passwords[i].username, passwords[i].password);
            return;
        }
    }
    printf(""Password not found!\\n"");
}

void update_password() {
    char website[50];
    printf(""Enter website to update: "");
    scanf(""%s"", website);
    for (int i = 0; i < num_passwords; i++) {
        if (strcmp(passwords[i].website, website) == 0) {
            printf(""Enter new username: "");
            scanf(""%s"", passwords[i].username);
            printf(""Enter new password: "");
            scanf(""%s"", passwords[i].password);
            printf(""Password updated successfully!\\n"");
            return;
        }
    }
    printf(""Password not found!\\n"");
}

void delete_password() {
    char website[50];
    printf(""Enter website to delete",2
"//FormAI DATASET v1.0 Category: Text-Based Adventure Game ; Style: ephemeral
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    printf(""Welcome to the Ephemeral Adventure Game!\\n"");
    printf(""Are you ready to begin? (y/n): "");
    
    char input;
    scanf("" %c"", &input);
    
    if (input == 'y') {
        printf(""Great! Let's begin...\\n"");
        
        // Define game variables
        int health = 100;
        int attack = 10;
        int defense = 5;
        int gold = 0;
        int level = 1;
        int boss_health = 150;
        
        // Define enemy variables
        char* enemies[] = {""Goblin"", ""Ogre"", ""Troll"", ""Dragon""};
        int enemy_attacks[] = {8, 12, 15, 20};
        int enemy_defenses[] = {2, 4, 6, 10};
        int enemy_healths[] = {50, 75, 100, 150};
        int enemy_gold[] = {10, 20, 30, 50};
        int enemy_levels[] = {1, 2, 3, 5};
        int num_enemies = sizeof(enemies) / sizeof(char*);
        
        // Define shop variables
        int shop_attack = 15;
        int shop_defense = 10;
        int shop_health = 50;
        int shop_price = 25;
        int has_potion = 0;
        
        // Seed random number generator
        srand(time(NULL));
        
        // Begin game loop
        while (health > 0) {
            // Print current stats
            printf(""\\nLEVEL: %d\\nHEALTH: %d\\nATTACK: %d\\nDEFENSE: %d\\nGOLD: %d\\n"", level, health, attack, defense, gold);
            
            // Print menu
            printf(""\\nWhat would you like to do?\\n1) Go into the forest\\n2) Visit the shop\\n3) View inventory\\n4) Quit game\\n"");
            
            int choice;
            scanf(""%d"", &choice);
            
            // Handle menu choice
            switch (choice) {
                case 1:
                    printf(""\\nYou enter the forest...\\n"");
                    
                    // Generate random enemy
                    int enemy_index = rand() % num_enemies;
                    char* enemy = enemies[enemy_index];
                    int enemy_attack = enemy_attacks[enemy_index];
                    int enemy_defense = enemy_defenses[enemy_index];
                    int enemy_health = enemy_healths[enemy_index];
                    int enemy_level = enemy_levels[enemy_index];
                    int enemy_reward = enemy_gold[enemy_index];
                    
                    printf(""You stumble upon a %s!\\n"", enemy);
                    
                    // Begin battle loop
                    while (1) {
                        // Print health and enemy health
                        printf(""\\nYOUR HEALTH: %d\\nENEMY HEALTH: %d\\n"", health, enemy_health);
                        
                        // Player's turn
                        printf(""It's your turn to attack! How much damage do you want to deal? (1 - %d): "", attack);
                        
                        int player_attack;
                        scanf(""%d"", &player_attack);
                        
                        if (player_attack < 1 || player_attack > attack) {
                            printf(""Invalid input. You lose your turn.\\n"");
                        }
                        else {
                            enemy_health -= player_attack;
                            printf(""\\nYou dealt %d damage! The %s has %d health remaining.\\n"", player_attack, enemy, enemy_health);
                        }
                        
                        // Check if enemy defeated
                        if (enemy_health <= 0) {
                            printf(""\\nCongratulations, you have defeated the %s! You earned %d gold.\\n"", enemy, enemy_reward);
                            gold += enemy_reward;
                            level += enemy_level;
                            break;
                        }
                        
                        // Enemy's turn
                        printf(""\\nIt's the %s's turn to attack! The %s deals %d damage. How much will you defend? (1 - %d): "", enemy, enemy, enemy_attack, defense);
                        
                        int player_defense;
                        scanf(""%d"", &player_defense);
                        
                        if (player_defense < 1 || player_defense > defense) {
                            printf(""Invalid input. You lose your turn.\\n"");
                        }
                        else {
                            int damage = enemy_attack - player_defense;
                            if (damage <= 0) {
                                damage = 1;
                            }
                            health -= damage;
                            printf(""\\nThe %s dealt %d damage! You have %d health remaining.\\n"", enemy, damage, health);
                        }
                        
                        // Check if player defeated
                        if (health <= 0) {
                            printf(""\\nYou have been defeated!\\n"");
                            break;
                        }
                    }
                    
                    break;
                
                case 2:
                    printf(""\\nWelcome to the shop!\\n"");
                    printf(""You can purchase a potion for 25 gold. This will restore your health to %d.\\n"", shop_health);
                    printf(""You can also upgrade your attack for 25 gold, or your defense for 25 gold.\\n"");
                    printf(""What would you like to purchase?\\n1) Potion\\n2) Attack upgrade\\n3) Defense upgrade\\n4) Leave shop\\n"");
                    
                    int shop_choice;
                    scanf(""%d"", &shop_choice);
                    
                    switch (shop_choice) {
                        case 1:
                            if (gold < shop_price) {
                                printf(""\\nYou do not have enough gold to purchase this item.\\n"");
                            }
                            else {
                                gold -= shop_price;
                                health = shop_health;
                                has_potion = 1;
                            }
                            break;
                        
                        case 2:
                            if (gold < shop_price) {
                                printf(""\\nYou do not have enough gold to purchase this item.\\n"");
                            }
                            else {
                                gold -= shop_price;
                                attack = shop_attack;
                            }
                            break;
                        
                        case 3:
                            if (gold < shop_price) {
                                printf(""\\nYou do not have enough gold to purchase this item.\\n"");
                            }
                            else {
                                gold -= shop_price;
                                defense = shop_defense;
                            }
                            break;
                        
                        case 4:
                            printf(""\\nThanks for stopping by!\\n"");
                            break;
                        
                        default:
                            printf(""\\nInvalid input.\\n"");
                            break;
                    }
                    
                    break;
                
                case 3:
                    printf(""\\nINVENTORY:\\n"");
                    
                    if (has_potion) {
                        printf(""- Potion\\n"");
                    }
                    else {
                        printf(""- No items\\n"");
                    }
                    
                    break;
                
                case 4:
                    printf(""\\nThanks for playing the Ephemeral Adventure Game!\\n"");
                    return 0;
                
                default:
                    printf(""\\nInvalid input.\\n"");
                    break;
            }
            
            // Check if player can battle boss
            if (level == 10) {
                printf(""\\nYou have reached the end of your journey!\\n"");
                printf(""A ferocious dragon awaits you. Are you ready to take on the challenge? (y/n): "");
                
                char boss_input;
                scanf("" %c"", &boss_input);
                
                if (boss_input == 'y') {
                    printf(""\\nYou face the dragon...\\n"");
                    
                    while (1) {
                        // Print health and boss health
                        printf(""\\nYOUR HEALTH: %d\\nENEMY HEALTH: %d\\n"", health, boss_health);
                        
                        // Player's turn
                        printf(""It's your turn to attack! How much damage do you want to deal? (1 - %d): "", attack);
                        
                        int player_attack;
                        scanf(""%d"", &player_attack);
                        
                        if (player_attack < 1 || player_attack > attack) {
                            printf(""Invalid input. You lose your turn.\\n"");
                        }
                        else {
                            boss_health -= player_attack;
                            printf(""\\nYou dealt %d damage! The dragon has %d health remaining.\\n"", player_attack, boss_health);
                        }
                        
                        // Check if boss defeated
                        if (boss_health <= 0) {
                            printf(""\\nCongratulations, you have defeated the dragon! You have won the game!\\n"");
                            return 0;
                        }
                        
                        // Boss's turn
                        printf(""\\nIt's the dragon's turn to attack! The dragon deals %d damage. How much will you defend? (1 - %d): "", 25, defense);
                        
                        int player_defense;
                        scanf(""%d"", &player_defense);
                        
                        if (player_defense < 1 || player_defense > defense) {
                            printf(""Invalid input. You lose your turn.\\n"");
                        }
                        else {
                            int damage = 25 - player_defense;
                            if (damage <= 0) {
                                damage = 1;
                            }
                            health -= damage;
                            printf(""\\nThe dragon dealt %d damage! You have %d health remaining.\\n"", damage, health);
                        }
                        
                        // Check if player defeated
                        if (health <= 0) {
                            printf(""\\nYou have been defeated!\\n"");
                            break;
                        }
                    }
                }
                else {
                    printf(""\\nGame over.\\n"");
                    return 0;
                }
            }
        }
    }
    else {
        printf(""Goodbye!\\n"");
    }
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (0000000140001601) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  __int64 v5; // [rsp+20h] [rbp-60h]
  __int64 v6; // [rsp+28h] [rbp-58h]
  __int64 v7[4]; // [rsp+30h] [rbp-50h]
  int v8; // [rsp+54h] [rbp-2Ch] BYREF
  int v9; // [rsp+58h] [rbp-28h] BYREF
  char v10; // [rsp+5Fh] [rbp-21h] BYREF
  int v11; // [rsp+60h] [rbp-20h] BYREF
  int v12; // [rsp+64h] [rbp-1Ch] BYREF
  int v13; // [rsp+68h] [rbp-18h] BYREF
  int v14; // [rsp+6Ch] [rbp-14h] BYREF
  int v15[4]; // [rsp+70h] [rbp-10h]
  int v16[4]; // [rsp+80h] [rbp+0h]
  int v17[4]; // [rsp+90h] [rbp+10h]
  int v18[4]; // [rsp+A0h] [rbp+20h]
  int v19[5]; // [rsp+B0h] [rbp+30h]
  char v20; // [rsp+C7h] [rbp+47h] BYREF
  unsigned int v21; // [rsp+C8h] [rbp+48h]
  int v22; // [rsp+CCh] [rbp+4Ch]
  int v23; // [rsp+D0h] [rbp+50h]
  unsigned int v24; // [rsp+D4h] [rbp+54h]
  const char *v25; // [rsp+D8h] [rbp+58h]
  int v26; // [rsp+E0h] [rbp+60h]
  int v27; // [rsp+E4h] [rbp+64h]
  unsigned int v28; // [rsp+E8h] [rbp+68h]
  int v29; // [rsp+ECh] [rbp+6Ch]
  unsigned int v30; // [rsp+F0h] [rbp+70h]
  int v31; // [rsp+F4h] [rbp+74h]
  unsigned int v32; // [rsp+F8h] [rbp+78h]
  unsigned int v33; // [rsp+FCh] [rbp+7Ch]
  unsigned int v34; // [rsp+100h] [rbp+80h]
  int v35; // [rsp+104h] [rbp+84h]
  unsigned int v36; // [rsp+108h] [rbp+88h]
  unsigned int v37; // [rsp+10Ch] [rbp+8Ch]
  int v38; // [rsp+110h] [rbp+90h]
  int v39; // [rsp+114h] [rbp+94h]
  unsigned int v40; // [rsp+118h] [rbp+98h]
  unsigned int v41; // [rsp+11Ch] [rbp+9Ch]

  _main(argc, argv, envp);
  printf(""Welcome to the Ephemeral Adventure Game!\\n"");
  printf(""Are you ready to begin? (y/n): "");
  scanf("" %c"", &v20);
  if ( v20 == 121 )
  {
    printf(""Great! Let's begin...\\n"");
    v41 = 100;
    v40 = 10;
    v39 = 5;
    v38 = 0;
    v37 = 1;
    v36 = 150;
    v7[0] = (__int64)""Goblin"";
    v7[1] = (__int64)""Ogre"";
    v7[2] = (__int64)""Troll"";
    v7[3] = (__int64)""Dragon"";
    v19[0] = 8;
    v19[1] = 12;
    v19[2] = 15;
    v19[3] = 20;
    v18[0] = 2;
    v18[1] = 4;
    v18[2] = 6;
    v18[3] = 10;
    v17[0] = 50;
    v17[1] = 75;
    v17[2] = 100;
    v17[3] = 150;
    v16[0] = 10;
    v16[1] = 20;
    v16[2] = 30;
    v16[3] = 50;
    v15[0] = 1;
    v15[1] = 2;
    v15[2] = 3;
    v15[3] = 5;
    v31 = 4;
    v30 = 15;
    v29 = 10;
    v28 = 50;
    v27 = 25;
    v35 = 0;
    v3 = time(0i64);
    srand(v3);
    while ( 1 )
    {
      if ( (int)v41 <= 0 )
        return 0;
      LODWORD(v6) = v38;
      LODWORD(v5) = v39;
      printf(""\\nLEVEL: %d\\nHEALTH: %d\\nATTACK: %d\\nDEFENSE: %d\\nGOLD: %d\\n"", v37, v41, v40, v5, v6);
      printf(""\\nWhat would you like to do?\\n1) Go into the forest\\n2) Visit the shop\\n3) View inventory\\n4) Quit game\\n"");
      scanf(""%d"", &v14);
      if ( v14 == 4 )
      {
        printf(""\\nThanks for playing the Ephemeral Adventure Game!\\n"");
        return 0;
      }
      if ( v14 > 4 )
        goto LABEL_44;
      if ( v14 == 3 )
      {
        printf(""\\nINVENTORY:\\n"");
        if ( v35 )
          printf(""- Potion\\n"");
        else
          printf(""- No items\\n"");
        goto LABEL_45;
      }
      if ( v14 == 1 )
      {
        printf(""\\nYou enter the forest...\\n"");
        v26 = rand() % v31;
        v25 = (const char *)v7[v26];
        v24 = v19[v26];
        v23 = v18[v26];
        v34 = v17[v26];
        v22 = v15[v26];
        v21 = v16[v26];
        printf(""You stumble upon a %s!\\n"", v25);
        do
        {
          printf(""\\nYOUR HEALTH: %d\\nENEMY HEALTH: %d\\n"", v41, v34);
          printf(""It's your turn to attack! How much damage do you want to deal? (1 - %d): "", v40);
          scanf(""%d"", &v12);
          if ( v12 > 0 && (int)v40 >= v12 )
          {
            v34 -= v12;
            printf(""\\nYou dealt %d damage! The %s has %d health remaining.\\n"", (unsigned int)v12, v25, v34);
          }
          else
          {
            printf(""Invalid input. You lose your turn.\\n"");
          }
          if ( (int)v34 <= 0 )
          {
            printf(""\\nCongratulations, you have defeated the %s! You earned %d gold.\\n"", v25, v21);
            v38 += v21;
            v37 += v22;
            goto LABEL_45;
          }
          LODWORD(v5) = v39;
          printf(
            ""\\nIt's the %s's turn to attack! The %s deals %d damage. How much will you defend? (1 - %d): "",
            v25,
            v25,
            v24,
            v5);
          scanf(""%d"", &v11);
          if ( v11 > 0 && v39 >= v11 )
          {
            v33 = v24 - v11;
            if ( (int)(v24 - v11) <= 0 )
              v33 = 1;
            v41 -= v33;
            printf(""\\nThe %s dealt %d damage! You have %d health remaining.\\n"", v25, v33, v41);
          }
          else
          {
            printf(""Invalid input. You lose your turn.\\n"");
          }
        }
        while ( (int)v41 > 0 );
        printf(""\\nYou have been defeated!\\n"");
        goto LABEL_45;
      }
      if ( v14 != 2 )
      {
LABEL_44:
        printf(""\\nInvalid input.\\n"");
        goto LABEL_45;
      }
      printf(""\\nWelcome to the shop!\\n"");
      printf(""You can purchase a potion for 25 gold. This will restore your health to %d.\\n"", v28);
      printf(""You can also upgrade your attack for 25 gold, or your defense for 25 gold.\\n"");
      printf(""What would you like to purchase?\\n1) Potion\\n2) Attack upgrade\\n3) Defense upgrade\\n4) Leave shop\\n"");
      scanf(""%d"", &v13);
      if ( v13 == 4 )
      {
        printf(""\\nThanks for stopping by!\\n"");
        goto LABEL_45;
      }
      if ( v13 > 4 )
        goto LABEL_44;
      if ( v13 == 3 )
        break;
      if ( v13 == 1 )
      {
        if ( v38 < v27 )
          goto LABEL_36;
        v38 -= v27;
        v41 = v28;
        v35 = 1;
      }
      else
      {
        if ( v13 != 2 )
          goto LABEL_44;
        if ( v38 < v27 )
          goto LABEL_36;
        v38 -= v27;
        v40 = v30;
      }
LABEL_45:
      if ( v37 == 10 )
      {
        printf(""\\nYou have reached the end of your journey!\\n"");
        printf(""A ferocious dragon awaits you. Are you ready to take on the challenge? (y/n): "");
        scanf("" %c"", &v10);
        if ( v10 != 121 )
        {
          printf(""\\nGame over.\\n"");
          return 0;
        }
        printf(""\\nYou face the dragon...\\n"");
        do
        {
          printf(""\\nYOUR HEALTH: %d\\nENEMY HEALTH: %d\\n"", v41, v36);
          printf(""It's your turn to attack! How much damage do you want to deal? (1 - %d): "", v40);
          scanf(""%d"", &v9);
          if ( v9 > 0 && (int)v40 >= v9 )
          {
            v36 -= v9;
            printf(""\\nYou dealt %d damage! The dragon has %d health remaining.\\n"", (unsigned int)v9, v36);
          }
          else
          {
            printf(""Invalid input. You lose your turn.\\n"");
          }
          if ( (int)v36 <= 0 )
          {
            printf(""\\nCongratulations, you have defeated the dragon! You have won the game!\\n"");
            return 0;
          }
          printf(
            ""\\nIt's the dragon's turn to attack! The dragon deals %d damage. How much will you defend? (1 - %d): "",
            25i64,
            (unsigned int)v39);
          scanf(""%d"", &v8);
          if ( v8 > 0 && v39 >= v8 )
          {
            v32 = 25 - v8;
            if ( 25 - v8 <= 0 )
              v32 = 1;
            v41 -= v32;
            printf(""\\nThe dragon dealt %d damage! You have %d health remaining.\\n"", v32, v41);
          }
          else
          {
            printf(""Invalid input. You lose your turn.\\n"");
          }
        }
        while ( (int)v41 > 0 );
        printf(""\\nYou have been defeated!\\n"");
      }
    }
    if ( v38 >= v27 )
    {
      v38 -= v27;
      v39 = v29;
      goto LABEL_45;
    }
LABEL_36:
    printf(""\\nYou do not have enough gold to purchase this item.\\n"");
    goto LABEL_45;
  }
  printf(""Goodbye!\\n"");
  return 0;
}
// 140001820: conditional instruction was optimized away because %var_B4.4<3
// 140001AD6: conditional instruction was optimized away because %var_B8.4<3
// 1400017D5: variable 'v5' is possibly undefined
// 1400017D5: variable 'v6' is possibly undefined
// 140001ED0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001601: using guessed type int var_C8;

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    printf(""Welcome to the Ephemeral Adventure Game!\\n"");
    printf(""Are you ready to begin? (y/n): "");
    char answer;
    scanf("" %c"", &answer);
    if (answer == 'y') {
        printf(""Great! Let's begin...\\n"");
        int health = 100;
        int attack = 10;
        int defense = 5;
        int gold = 0;
        int level = 1;
        int max_health = 150;
        char *enemy_names[] = {""Goblin"", ""Ogre"", ""Troll"", ""Dragon""};
        int enemy_attacks[] = {8, 12, 15, 20};
        int enemy_defenses[] = {2, 4, 6, 10};
        int enemy_gold[] = {50, 75, 100, 150};
        int enemy_xp[] = {10, 20, 30, 50};
        int enemy_types[] = {1, 2, 3, 5};
        int enemy_count = 4;
        int enemy_level = 15;
        int enemy_health = 10;
        int enemy_gold_drop = 50;
        int enemy_xp_drop = 25;
        int enemy_type = 0;
        srand(time(NULL));
        while (health > 0) {
            printf(""\\nLEVEL: %d\\nHEALTH: %d\\nATTACK: %d\\nDEFENSE: %d\\nGOLD: %d\\n"", level, health, attack, defense, gold);
            printf(""\\nWhat would you like to do?\\n1) Go into the forest\\n2) Visit the shop\\n3) View inventory\\n4) Quit game\\n"");
            int choice;
            scanf(""%d"", &choice);
            switch (choice) {
                case 1:
                    printf(""\\nYou enter the forest...\\n"");
                    int enemy_index = rand() % enemy_count;
                    char *enemy_name = enemy_names[enemy_index];
                    int enemy_attack = enemy_attacks[enemy_index];
                    int enemy_defense = enemy_defenses[enemy_index];
                    int enemy_health = enemy_healths[enemy_index];
                    int enemy_gold_drop = enemy_gold_drops[enemy_index];
                    int enemy_xp_drop = enemy_xp_drops[enemy_index];
                    int enemy_type = enemy_types[enemy_index];
                    printf(""You stumble upon a %s!\\n"", enemy_name);
                    while (health > 0) {
                        printf(""\\nYOUR HEALTH: %d\\nENEMY HEALTH: %d\\n"", health, enemy_health);
                        printf(""It's your turn to attack! How much damage do you want to deal? (1 - %d): "", attack);
                        int damage;
                        scanf(""%d"", &damage);
                        if (damage < 1 || damage > attack) {
                            printf(""Invalid input. You lose your turn.\\n"");
                            continue;
                        }
                        enemy_health -= damage;
                        printf(""\\nYou dealt %d damage! The %s has %d health remaining.\\n"", damage, enemy_name, enemy_health);
                        if (enemy_health <= 0) {
                            printf(""\\nCongratulations, you have defeated the %s! You earned %d gold.\\n"", enemy_name, enemy_gold_drop);
                            gold += enemy_gold_drop;
                            level += enemy_xp_drop;
                            break;
                        }
                        printf",2
"//FormAI DATASET v1.0 Category: Stock market tracker ; Style: future-proof
#include <stdio.h>
#include <stdlib.h> // for atof function
#include <string.h>

#define MAX_LINE_LENGTH 100 // maximum length of each line in CSV file
#define MAX_LINES 1000 // maximum number of lines in CSV file

typedef struct {
    char date[11];
    float open;
    float close;
    float high;
    float low;
} StockData;

int main(int argc, char **argv) {
    if (argc != 2) {
        printf(""Usage: %s file.csv\\n"", argv[0]);
        exit(1);
    }

    StockData stocks[MAX_LINES];
    int numLines = 0;

    FILE* file = fopen(argv[1], ""r"");
    if (file == NULL) {
        printf(""Failed to open %s\\n"", argv[1]);
        exit(1);
    }
    
    // read each line of CSV file and store data in array of StockData structs
    char line[MAX_LINE_LENGTH];
    fgets(line, MAX_LINE_LENGTH, file); // discard header line
    while (fgets(line, MAX_LINE_LENGTH, file) != NULL && numLines < MAX_LINES) {
        char *token;
        int fieldCount = 0;
        for (token=strtok(line, "",\\n""); token != NULL && fieldCount < 5; token=strtok(NULL, "",\\n"")) {
            switch (fieldCount) {
                case 0:
                    strcpy(stocks[numLines].date, token);
                    break;
                case 1:
                    stocks[numLines].open = atof(token);
                    break;
                case 2:
                    stocks[numLines].close = atof(token);
                    break;
                case 3:
                    stocks[numLines].high = atof(token);
                    break;
                case 4:
                    stocks[numLines].low = atof(token);
                    break;
            }
            fieldCount++;
        }
        numLines++;
    }
    
    fclose(file);
    
    // calculate average closing price and print summary statistics
    float sum = 0.0;
    float maxDiff = 0.0;
    int maxDiffIdx = 0;
    for (int i = 0; i < numLines; i++) {
        sum += stocks[i].close;
        float diff = stocks[i].high - stocks[i].low;
        if (diff > maxDiff) {
            maxDiff = diff;
            maxDiffIdx = i;
        }
    }
    float avg = sum / numLines;
    printf(""Average closing price: $%.2f\\n"", avg);
    printf(""Maximum daily difference: $%.2f on %s\\n"", maxDiff, stocks[maxDiffIdx].date);
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// char *__cdecl strcpy(char *Destination, const char *Source);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);
// double __cdecl atof(const char *String);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  float v4; // xmm0_4
  float v5; // xmm0_4
  float v6; // xmm0_4
  char Buffer[96]; // [rsp+20h] [rbp-60h] BYREF
  _BYTE v9[28024]; // [rsp+80h] [rbp+0h] BYREF
  float v10; // [rsp+6DF8h] [rbp+6D78h]
  float v11; // [rsp+6DFCh] [rbp+6D7Ch]
  FILE *Stream; // [rsp+6E00h] [rbp+6D80h]
  int i; // [rsp+6E0Ch] [rbp+6D8Ch]
  int v14; // [rsp+6E10h] [rbp+6D90h]
  float v15; // [rsp+6E14h] [rbp+6D94h]
  float v16; // [rsp+6E18h] [rbp+6D98h]
  int v17; // [rsp+6E1Ch] [rbp+6D9Ch]
  char *Source; // [rsp+6E20h] [rbp+6DA0h]
  int v19; // [rsp+6E2Ch] [rbp+6DACh]

  _main(argc, argv, envp);
  if ( argc != 2 )
  {
    printf(""Usage: %s file.csv\\n"", *argv);
    exit(1);
  }
  v19 = 0;
  Stream = fopen(argv[1], ""r"");
  if ( !Stream )
  {
    printf(""Failed to open %s\\n"", argv[1]);
    exit(1);
  }
  fgets(Buffer, 100, Stream);
  while ( fgets(Buffer, 100, Stream) && v19 <= 999 )
  {
    v17 = 0;
    for ( Source = strtok(Buffer, "",\\n""); Source && v17 <= 4; Source = strtok(0i64, "",\\n"") )
    {
      switch ( v17 )
      {
        case 0:
          strcpy(&v9[28 * v19 + 16], Source);
          break;
        case 1:
          v3 = atof(Source);
          *(float *)&v9[28 * v19 + 28] = v3;
          break;
        case 2:
          v4 = atof(Source);
          *(float *)&v9[28 * v19 + 32] = v4;
          break;
        case 3:
          v5 = atof(Source);
          *(float *)&v9[28 * v19 + 36] = v5;
          break;
        case 4:
          v6 = atof(Source);
          *(float *)&v9[28 * v19 + 40] = v6;
          break;
        default:
          break;
      }
      ++v17;
    }
    ++v19;
  }
  fclose(Stream);
  v16 = 0.0;
  v15 = 0.0;
  v14 = 0;
  for ( i = 0; i < v19; ++i )
  {
    v16 = *(float *)&v9[28 * i + 32] + v16;
    v10 = *(float *)&v9[28 * i + 36] - *(float *)&v9[28 * i + 40];
    if ( v10 > v15 )
    {
      v15 = v10;
      v14 = i;
    }
  }
  v11 = v16 / (float)v19;
  printf(""Average closing price: $%.2f\\n"", v11);
  printf(""Maximum daily difference: $%.2f on %s\\n"", v15, &v9[28 * v14 + 16]);
  return 0;
}
// 140001AF0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ROWS 1000
#define MAX_COLS 5

typedef struct {
    char date[10];
    float open;
    float high;
    float low;
    float close;
} Stock;

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf(""Usage: %s file.csv
"", argv[0]);
        exit(1);
    }

    Stock stocks[MAX_ROWS];
    int num_stocks = 0;

    FILE *fp = fopen(argv[1], ""r"");
    if (fp == NULL) {
        printf(""Failed to open %s
"", argv[1]);
        exit(1);
    }

    char line[100];
    fgets(line, sizeof(line), fp);

    while (fgets(line, sizeof(line), fp) != NULL && num_stocks < MAX_ROWS) {
        int col = 0;
        char *token = strtok(line, "",
"");
        while (token != NULL && col < MAX_COLS) {
            switch (col) {
                case 0:
                    strcpy(stocks[num_stocks].date, token);
                    break;
                case 1:
                    stocks[num_stocks].open = atof(token);
                    break;
                case 2:
                    stocks[num_stocks].high = atof(token);
                    break;
                case 3:
                    stocks[num_stocks].low = atof(token);
                    break;
                case 4:
                    stocks[num_stocks].close = atof(token);
                    break;
            }
            col++;
            token = strtok(NULL, "",
"");
        }
        num_stocks++;
    }

    fclose(fp);

    float total_close = 0;
    float max_diff = 0;
    int max_diff_index = 0;

    for (int i = 0; i < num_stocks; i++) {
        total_close += stocks[i].close;
        float diff = stocks[i].high - stocks[i].low;
        if (diff > max_diff) {
            max_diff = diff;
            max_diff_index = i;
        }
    }

    float avg_close = total_close / num_stocks;

    printf(""Average closing price: $%.2f
"", avg_close);
    printf(""Maximum daily difference: $%.2f on %s
"", max_diff, stocks[max_diff_index].date);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Expense Tracker ; Style: Cryptic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int amount;
    char* category;
    char* date;
} Expense; // A struct to hold expense information

typedef struct {
    Expense* expenses;
    int size;
    int capacity;
} ExpenseList; // A dynamic array to hold a list of expenses

void addExpense(ExpenseList* list, Expense* expense) {
    if (list->size == list->capacity) {
        list->capacity *= 2;
        list->expenses = realloc(list->expenses, list->capacity * sizeof(Expense));
    }
    list->expenses[list->size++] = *expense;
}

int getTotalExpense(ExpenseList* list, char* category) {
    int totalExpense = 0;
    for (int i = 0; i < list->size; i++) {
        if (strcmp(list->expenses[i].category, category) == 0) {
            totalExpense += list->expenses[i].amount;
        }
    }
    return totalExpense;
}

int main() {
    ExpenseList list;
    list.size = 0;
    list.capacity = 1;
    list.expenses = malloc(sizeof(Expense));

    char option[10];
    do {
        printf(""\\n1. Add expense\\n"");
        printf(""2. Get total expense for a category\\n"");
        printf(""3. Exit\\n"");
        printf(""Enter option (1-3): "");
        scanf(""%s"", option);

        if (strcmp(option, ""1"") == 0) {
            int amount;
            char* category = malloc(20 * sizeof(char));
            char* date = malloc(20 * sizeof(char));

            printf(""Enter expense amount: "");
            scanf(""%d"", &amount);

            printf(""Enter category: "");
            scanf(""%s"", category);

            printf(""Enter date (dd-mm-yyyy): "");
            scanf(""%s"", date);

            Expense expense = { amount, category, date };
            addExpense(&list, &expense);
        }
        else if (strcmp(option, ""2"") == 0) {
            char* category = malloc(20 * sizeof(char));
            printf(""Enter category: "");
            scanf(""%s"", category);
            int total = getTotalExpense(&list, category);
            printf(""Total expense for category %s: %d\\n"", category, total);
        }
        else if (strcmp(option, ""3"") == 0) {
            printf(""Exiting...\\n"");
        }
        else {
            printf(""Invalid option!\\n"");
        }

    } while (strcmp(option, ""3"") != 0);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addExpense(_QWORD, _QWORD); // weak
__int64 __fastcall getTotalExpense(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl strcmp(const char *Str1, const char *Str2);
// void *__cdecl malloc(size_t Size);


//----- (000000014000171D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-60h] BYREF
  void *v5; // [rsp+28h] [rbp-58h]
  void *v6; // [rsp+30h] [rbp-50h]
  int v7; // [rsp+40h] [rbp-40h] BYREF
  char Str1[10]; // [rsp+46h] [rbp-3Ah] BYREF
  void *v9; // [rsp+50h] [rbp-30h] BYREF
  int v10; // [rsp+58h] [rbp-28h]
  int v11; // [rsp+5Ch] [rbp-24h]
  void *v12; // [rsp+60h] [rbp-20h]
  void *v13; // [rsp+68h] [rbp-18h]
  unsigned int TotalExpense; // [rsp+74h] [rbp-Ch]
  const char *v15; // [rsp+78h] [rbp-8h]

  _main(argc, argv, envp);
  v10 = 0;
  v11 = 1;
  v9 = malloc(0x18ui64);
  do
  {
    printf(""\\n1. Add expense\\n"");
    printf(""2. Get total expense for a category\\n"");
    printf(""3. Exit\\n"");
    printf(""Enter option (1-3): "");
    scanf(""%s"", Str1);
    if ( !strcmp(Str1, ""1"") )
    {
      v13 = malloc(0x14ui64);
      v12 = malloc(0x14ui64);
      printf(""Enter expense amount: "");
      scanf(""%d"", &v7);
      printf(""Enter category: "");
      scanf(""%s"", v13);
      printf(""Enter date (dd-mm-yyyy): "");
      scanf(""%s"", v12);
      v4 = v7;
      v5 = v13;
      v6 = v12;
      addExpense(&v9, &v4);
    }
    else if ( !strcmp(Str1, ""2"") )
    {
      v15 = (const char *)malloc(0x14ui64);
      printf(""Enter category: "");
      scanf(""%s"", v15);
      TotalExpense = getTotalExpense(&v9, v15);
      printf(""Total expense for category %s: %d\\n"", v15, TotalExpense);
    }
    else if ( !strcmp(Str1, ""3"") )
    {
      printf(""Exiting...\\n"");
    }
    else
    {
      printf(""Invalid option!\\n"");
    }
  }
  while ( strcmp(Str1, ""3"") );
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall addExpense(_QWORD, _QWORD);
// 140001691: using guessed type __int64 __fastcall getTotalExpense(_QWORD, _QWORD);
// 140001A00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000171D: using guessed type int var_40;

// nfuncs=179 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define struct for expense
typedef struct {
    int amount;
    char category[10];
    char date[11];
} Expense;

// Define struct for linked list
typedef struct Node {
    Expense expense;
    struct Node* next;
} Node;

// Function to add expense to linked list
void addExpense(Node** head, Expense expense) {
    Node* newNode = (Node*) malloc(sizeof(Node));
    newNode->expense = expense;
    newNode->next = *head;
    *head = newNode;
}

// Function to get total expense for a category
int getTotalExpense(Node** head, char* category) {
    int total = 0;
    Node* current = *head;
    while (current != NULL) {
        if (strcmp(current->expense.category, category) == 0) {
            total += current->expense.amount;
        }
        current = current->next;
    }
    return total;
}

int main() {
    // Initialize linked list
    Node* head = NULL;
    
    // Loop until user exits
    char option[10];
    int optionInt;
    do {
        // Display menu
        printf(""
1. Add expense
"");
        printf(""2. Get total expense for a category
"");
        printf(""3. Exit
"");
        printf(""Enter option (1-3): "");
        scanf(""%s"", option);
        
        // Process user option
        if (strcmp(option, ""1"") == 0) {
            // Add expense
            Expense expense;
            char* category = (char*) malloc(sizeof(char) * 10);
            char* date = (char*) malloc(sizeof(char) * 11);
            printf(""Enter expense amount: "");
            scanf(""%d"", &expense.amount);
            printf(""Enter category: "");
            scanf(""%s"", category);
            printf(""Enter date (dd-mm-yyyy): "");
            scanf(""%s"", date);
            addExpense(&head, expense);
        } else if (strcmp(option, ""2"") == 0) {
            // Get total expense for a category
            char* category = (char*) malloc(sizeof(char) * 10);
            printf(""Enter category: "");
            scanf(""%s"", category);
            int total = getTotalExpense(&head, category);
            printf(""Total expense for category %s: %d
"", category, total);
        } else if (strcmp(option, ""3"") == 0) {
            // Exit program
            printf(""Exiting...
"");
        } else {
            // Invalid option
            printf(""Invalid option!
"");
        }
    } while (strcmp(option, ""3"") != 0);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Bingo Simulator ; Style: standalone
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5
#define RANGE 75

// Function prototypes
void print_card(int card[ROWS][COLS]);
int generate_number(int used_numbers[]);
void mark_number(int card[ROWS][COLS], int number);
int check_bingo(int card[ROWS][COLS]);

int main() {
    int card[ROWS][COLS] = {0}; // Initialize card with zeros
    int used_numbers[RANGE] = {0}; // Keep track of which numbers have been called
    int num_calls = 0;
    int number = 0;
    int bingo = 0;

    // Seed the random number generator
    srand(time(NULL));

    // Generate the bingo card
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            // Generate a unique number for each square
            card[row][col] = generate_number(used_numbers);
        }
    }

    // Print the bingo card
    printf(""BINGO CARD:\\n"");
    print_card(card);

    // Play the game until someone gets bingo
    while (!bingo) {
        // Generate a number that hasn't been called yet
        number = generate_number(used_numbers);
        used_numbers[number] = 1;

        // Mark the number on the card
        mark_number(card, number);

        // Increment the number of calls made
        num_calls++;

        // Check if anyone has bingo
        bingo = check_bingo(card);

        // Print the number called and the updated card
        printf(""Number called: %d\\n"", number);
        printf(""Updated card:\\n"");
        print_card(card);
    }

    // Print the winner and the number of calls made
    printf(""BINGO! Winner after %d calls.\\n"", num_calls);

    return 0;
}

void print_card(int card[ROWS][COLS]) {
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            printf(""%2d "", card[row][col]);
        }
        printf(""\\n"");
    }
}

int generate_number(int used_numbers[]) {
    int number;
    do {
        number = rand() % RANGE + 1; // Generate a random number between 1 and RANGE (inclusive)
    } while (used_numbers[number]); // Loop until a unique number is found
    return number;
}

void mark_number(int card[ROWS][COLS], int number) {
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            if (card[row][col] == number) {
                card[row][col] = -1; // Mark the number as called
                return;
            }
        }
    }
}

int check_bingo(int card[ROWS][COLS]) {
    int bingo = 0;
    int row_sum = 0;
    int col_sum = 0;
    int diag_sum1 = 0;
    int diag_sum2 = 0;

    // Check for diagonal bingo
    for (int i = 0; i < ROWS; i++) {
        diag_sum1 += card[i][i];
        diag_sum2 += card[i][COLS-i-1];
    }
    if (diag_sum1 == -ROWS || diag_sum2 == -ROWS) {
        bingo = 1;
        return bingo;
    }

    // Check for row bingo
    for (int row = 0; row < ROWS; row++) {
        row_sum = 0;
        for (int col = 0; col < COLS; col++) {
            row_sum += card[row][col];
        }
        if (row_sum == -COLS) {
            bingo = 1;
            return bingo;
        }
    }

    // Check for column bingo
    for (int col = 0; col < COLS; col++) {
        col_sum = 0;
        for (int row = 0; row < ROWS; row++) {
            col_sum += card[row][col];
        }
        if (col_sum == -ROWS) {
            bingo = 1;
            return bingo;
        }
    }

    return bingo;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall print_card(_QWORD); // weak
__int64 __fastcall generate_number(_QWORD); // weak
__int64 __fastcall mark_number(_QWORD, _QWORD); // weak
__int64 __fastcall check_bingo(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int number; // eax
  int v6[76]; // [rsp+20h] [rbp-60h] BYREF
  int v7[27]; // [rsp+150h] [rbp+D0h] BYREF
  unsigned int v8; // [rsp+1BCh] [rbp+13Ch]
  int j; // [rsp+1C0h] [rbp+140h]
  int i; // [rsp+1C4h] [rbp+144h]
  int v11; // [rsp+1C8h] [rbp+148h]
  unsigned int v12; // [rsp+1CCh] [rbp+14Ch]

  _main(argc, argv, envp);
  memset(v7, 0, 100);
  memset(v6, 0, 300);
  v12 = 0;
  v8 = 0;
  v11 = 0;
  v3 = time(0i64);
  srand(v3);
  for ( i = 0; i <= 4; ++i )
  {
    for ( j = 0; j <= 4; ++j )
    {
      number = generate_number(v6);
      v7[5 * i + j] = number;
    }
  }
  printf(""BINGO CARD:\\n"");
  print_card(v7);
  while ( !v11 )
  {
    v8 = generate_number(v6);
    v6[v8] = 1;
    mark_number(v7, v8);
    ++v12;
    v11 = check_bingo(v7);
    printf(""Number called: %d\\n"", v8);
    printf(""Updated card:\\n"");
    print_card(v7);
  }
  printf(""BINGO! Winner after %d calls.\\n"", v12);
  return 0;
}
// 14000177C: using guessed type __int64 __fastcall print_card(_QWORD);
// 1400017FC: using guessed type __int64 __fastcall generate_number(_QWORD);
// 140001855: using guessed type __int64 __fastcall mark_number(_QWORD, _QWORD);
// 1400018E7: using guessed type __int64 __fastcall check_bingo(_QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_90[27];
// 1400015B0: using guessed type int var_1C0[76];

// nfuncs=145 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 5
#define COLS 5

void print_card(int card[ROWS][COLS]);
int generate_number(int used_numbers[ROWS * COLS]);
void mark_number(int card[ROWS][COLS], int number);
int check_bingo(int card[ROWS][COLS]);

int main() {
    int card[ROWS][COLS] = {0};
    int used_numbers[ROWS * COLS] = {0};
    int number, count = 0, bingo = 0;
    srand(time(NULL));

    // Generate random numbers for the card
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            number = generate_number(used_numbers);
            card[i][j] = number;
        }
    }

    // Print the card
    printf(""BINGO CARD:
"");
    print_card(card);

    // Play the game
    while (!bingo) {
        number = generate_number(used_numbers);
        used_numbers[number] = 1;
        mark_number(card, number);
        count++;
        bingo = check_bingo(card);
        printf(""Number called: %d
"", number);
        printf(""Updated card:
"");
        print_card(card);
    }

    printf(""BINGO! Winner after %d calls.
"", count);

    return 0;
}

void print_card(int card[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printf(""%d "", card[i][j]);
        }
        printf(""
"");
    }
}

int generate_number(int used_numbers[ROWS * COLS]) {
    int number;
    do {
        number = rand() % 15 + 1;
    } while (used_numbers[number] == 1);
    return number;
}

void mark_number(int card[ROWS][COLS], int number) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (card[i][j] == number) {
                card[i][j] = -1;
            }
        }
    }
}

int check_bingo(int card[ROWS][COLS]) {
    int row_bingo = 1;
    int col_bingo = 1;
    int diag_bingo = 1;

    // Check rows
    for (int i = 0; i < ROWS; i++) {
        row_bingo = 1;
        for (int j = 0; j < COLS; j++) {
            if (card[i][j] == 0) {
                row_bingo = 0;
                break;
            }
        }
        if (row_bingo) {
            return 1;
        }
    }

    // Check columns
    for (int i = 0; i < COLS; i++) {
        col_bingo = 1;
        for (int j = 0; j < ROWS; j++) {
            if (card[j][i] == 0) {
                col_bingo = 0;
                break;
            }
        }
        if (col_bingo) {
            return 1;
        }
    }

    // Check diagonals
    for (int i = 0; i < ROWS; i++) {
        if (card[i][i] == 0) {
            diag_bingo =",2
"//FormAI DATASET v1.0 Category: Database simulation ; Style: rigorous
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure for the database record
struct Record {
    int id;
    char name[20];
    int age;
    double salary;
};

// Declare global variables
int numRecords = 0;
struct Record *records = NULL;

// Function to add a new record to the database
void addRecord(int id, char *name, int age, double salary) {
    // Increase the size of the records array
    numRecords++;
    records = (struct Record *) realloc(records, numRecords * sizeof(struct Record));

    // Add the new record to the end of the array
    records[numRecords-1].id = id;
    strcpy(records[numRecords-1].name, name);
    records[numRecords-1].age = age;
    records[numRecords-1].salary = salary;

    printf(""Record added successfully.\\n"");
}

// Function to remove a record from the database by ID
void removeRecord(int id) {
    int i, j;

    // Find the record with the given ID
    for (i = 0; i < numRecords; i++) {
        if (records[i].id == id) {
            // Shift all the records after this one back by one
            for (j = i; j < numRecords-1; j++) {
                records[j] = records[j+1];
            }

            // Decrease the size of the records array
            numRecords--;
            records = (struct Record *) realloc(records, numRecords * sizeof(struct Record));

            printf(""Record removed successfully.\\n"");
            return;
        }
    }

    printf(""Record with ID %d not found.\\n"", id);
}

// Function to print all the records in the database
void printRecords() {
    int i;

    printf(""ID \\tName \\tAge \\tSalary\\n"");
    printf(""======================================\\n"");

    for (i = 0; i < numRecords; i++) {
        printf(""%d \\t%s \\t%d \\t%.2lf\\n"", records[i].id, records[i].name, records[i].age, records[i].salary);
    }
}

int main() {
    int choice;
    int id, age;
    char name[20];
    double salary;

    // Display the menu and prompt for user input
    do {
        printf(""\\nDatabase Menu\\n"");
        printf(""1. Add a new record\\n"");
        printf(""2. Remove a record by ID\\n"");
        printf(""3. Print all records\\n"");
        printf(""4. Quit\\n"");
        printf(""Enter your choice: "");

        scanf(""%d"", &choice);

        switch (choice) {
            case 1: // Add a new record
                printf(""Enter ID: "");
                scanf(""%d"", &id);
                printf(""Enter name: "");
                scanf(""%s"", name);
                printf(""Enter age: "");
                scanf(""%d"", &age);
                printf(""Enter salary: "");
                scanf(""%lf"", &salary);

                addRecord(id, name, age, salary);
                break;

            case 2: // Remove a record by ID
                printf(""Enter ID: "");
                scanf(""%d"", &id);

                removeRecord(id);
                break;

            case 3: // Print all records
                printRecords();
                break;

            case 4: // Quit
                break;

            default: // Invalid choice
                printf(""Invalid choice. Please try again.\\n"");
                break;
        }
    } while (choice != 4);

    // Free the memory used by the records array
    free(records);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addRecord(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall removeRecord(_QWORD); // weak
__int64 printRecords(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);

//-------------------------------------------------------------------------
// Data declarations

void *records; // idb


//----- (0000000140001937) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+28h] [rbp-28h] BYREF
  char v5[20]; // [rsp+30h] [rbp-20h] BYREF
  unsigned int v6; // [rsp+44h] [rbp-Ch] BYREF
  unsigned int v7; // [rsp+48h] [rbp-8h] BYREF
  int v8; // [rsp+4Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf(""\\nDatabase Menu\\n"");
    printf(""1. Add a new record\\n"");
    printf(""2. Remove a record by ID\\n"");
    printf(""3. Print all records\\n"");
    printf(""4. Quit\\n"");
    printf(""Enter your choice: "");
    scanf(""%d"", &v8);
    if ( v8 == 4 )
      continue;
    if ( v8 <= 4 )
    {
      switch ( v8 )
      {
        case 3:
          printRecords();
          continue;
        case 1:
          printf(""Enter ID: "");
          scanf(""%d"", &v7);
          printf(""Enter name: "");
          scanf(""%s"", v5);
          printf(""Enter age: "");
          scanf(""%d"", &v6);
          printf(""Enter salary: "");
          scanf(""%lf"", &v4);
          addRecord(v7, v5, v6);
          continue;
        case 2:
          printf(""Enter ID: "");
          scanf(""%d"", &v7);
          removeRecord(v7);
          continue;
      }
    }
    printf(""Invalid choice. Please try again.\\n"");
  }
  while ( v8 != 4 );
  free(records);
  return 0;
}
// 1400019D5: conditional instruction was optimized away because %var_4.4<3
// 1400015E2: using guessed type __int64 __fastcall addRecord(_QWORD, _QWORD, _QWORD);
// 14000170A: using guessed type __int64 __fastcall removeRecord(_QWORD);
// 14000184A: using guessed type __int64 printRecords(void);
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum number of records
#define MAX_RECORDS 100

// Define the record structure
typedef struct {
    int id;
    char name[20];
    int age;
    double salary;
} Record;

// Define the global variable to store the records
Record records[MAX_RECORDS];

// Define the function to add a new record
void addRecord(int id, char name[], int age, double salary) {
    // Check if the record already exists
    for (int i = 0; i < MAX_RECORDS; i++) {
        if (records[i].id == id) {
            printf(""Record already exists. Please try again.
"");
            return;
        }
    }
    // Add the new record
    Record newRecord;
    newRecord.id = id;
    strcpy(newRecord.name, name);
    newRecord.age = age;
    newRecord.salary = salary;
    records[MAX_RECORDS - 1] = newRecord;
    printf(""Record added successfully.
"");
}

// Define the function to remove a record by ID
void removeRecord(int id) {
    // Find the index of the record to remove
    int index = -1;
    for (int i = 0; i < MAX_RECORDS; i++) {
        if (records[i].id == id) {
            index = i;
            break;
        }
    }
    // Check if the record exists
    if (index == -1) {
        printf(""Record not found. Please try again.
"");
        return;
    }
    // Remove the record
    for (int i = index; i < MAX_RECORDS - 1; i++) {
        records[i] = records[i + 1];
    }
    printf(""Record removed successfully.
"");
}

// Define the function to print all records
void printRecords() {
    printf(""ID	Name	Age	Salary
"");
    for (int i = 0; i < MAX_RECORDS; i++) {
        if (records[i].id != 0) {
            printf(""%d	%s	%d	%.2lf
"", records[i].id, records[i].name, records[i].age, records[i].salary);
        }
    }
}

// Define the main function
int main() {
    int choice, id, age;
    char name[20];
    double salary;
    do {
        printf(""
Database Menu
"");
        printf(""1. Add a new record
"");
        printf(""2. Remove a record by ID
"");
        printf(""3. Print all records
"");
        printf(""4. Quit
"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                printf(""Enter ID: "");
                scanf(""%d"", &id);
                printf(""Enter name: "");
                scanf(""%s"", name);
                printf(""Enter age: "");
                scanf(""%d"", &age);
                printf(""Enter salary: "");
                scanf(""%lf"", &salary);
                addRecord(id, name, age, salary);
                break;
            case 2:
                printf(""Enter ID: "");
                scanf(""%d"", &id);
                removeRecord(id);
                break;
            case 3:
                printRecords();
                break;
            case 4:
                break;
            default:
                printf(""Invalid choice. Please try again.
"");
        }
    } while (choice != 4);
    free(records);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Arithmetic ; Style: lively
#include <stdio.h>

int main() {
    int num1, num2, sum, difference, product, quotient, remainder;
    
    printf(""Welcome to the magical arithmetic world!\\n"");
    printf(""Enter two numbers and watch the magic happen...\\n"");
    
    printf(""Enter the first number: "");
    scanf(""%d"", &num1);
    
    printf(""Enter the second number: "");
    scanf(""%d"", &num2);
    
    sum = num1 + num2;
    difference = num1 - num2;
    product = num1 * num2;
    quotient = num1 / num2;
    remainder = num1 % num2;
    
    printf(""\\nBehold, the magic results:\\n"");
    
    printf(""%d + %d = %d\\n"", num1, num2, sum);
    printf(""%d - %d = %d\\n"", num1, num2, difference);
    printf(""%d * %d = %d\\n"", num1, num2, product);
    
    if (num2 == 0) {
        printf(""Oops, cannot perform division. The second number is zero!\\n"");
    } else {
        quotient = num1 / num2;
        remainder = num1 % num2;
        printf(""%d / %d = %d (with a remainder of %d)\\n"", num1, num2, quotient, remainder);
    }
    
    printf(""Thank you for witnessing the magic! Goodbye!\\n"");
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+34h] [rbp-1Ch] BYREF
  int v5; // [rsp+38h] [rbp-18h] BYREF
  int v6; // [rsp+3Ch] [rbp-14h]
  int v7; // [rsp+40h] [rbp-10h]
  unsigned int v8; // [rsp+44h] [rbp-Ch]
  unsigned int v9; // [rsp+48h] [rbp-8h]
  unsigned int v10; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Welcome to the magical arithmetic world!\\n"");
  printf(""Enter two numbers and watch the magic happen...\\n"");
  printf(""Enter the first number: "");
  scanf(""%d"", &v5);
  printf(""Enter the second number: "");
  scanf(""%d"", &v4);
  v10 = v5 + v4;
  v9 = v5 - v4;
  v8 = v5 * v4;
  v7 = v5 / v4;
  v6 = v5 % v4;
  printf(""\\nBehold, the magic results:\\n"");
  printf(""%d + %d = %d\\n"", (unsigned int)v5, (unsigned int)v4, v10);
  printf(""%d - %d = %d\\n"", (unsigned int)v5, (unsigned int)v4, v9);
  printf(""%d * %d = %d\\n"", (unsigned int)v5, (unsigned int)v4, v8);
  if ( v4 )
  {
    v7 = v5 / v4;
    v6 = v5 % v4;
    printf(
      ""%d / %d = %d (with a remainder of %d)\\n"",
      (unsigned int)v5,
      (unsigned int)v4,
      (unsigned int)(v5 / v4),
      v5 % v4);
  }
  else
  {
    printf(""Oops, cannot perform division. The second number is zero!\\n"");
  }
  printf(""Thank you for witnessing the magic! Goodbye!\\n"");
  return 0;
}
// 140001830: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    int num1, num2, sum, diff, prod, quotient, remainder;
    
    printf(""Welcome to the magical arithmetic world!
"");
    printf(""Enter two numbers and watch the magic happen...
"");
    
    printf(""Enter the first number: "");
    scanf(""%d"", &num1);
    
    printf(""Enter the second number: "");
    scanf(""%d"", &num2);
    
    //perform arithmetic operations
    sum = num1 + num2;
    diff = num1 - num2;
    prod = num1 * num2;
    quotient = num1 / num2;
    remainder = num1 % num2;
    
    //display results
    printf(""
Behold, the magic results:
"");
    printf(""%d + %d = %d
"", num1, num2, sum);
    printf(""%d - %d = %d
"", num1, num2, diff);
    printf(""%d * %d = %d
"", num1, num2, prod);
    
    if (num2 == 0) {
        printf(""Oops, cannot perform division. The second number is zero!
"");
    } else {
        quotient = num1 / num2;
        remainder = num1 % num2;
        printf(""%d / %d = %d (with a remainder of %d)
"", num1, num2, quotient, remainder);
    }
    
    printf(""Thank you for witnessing the magic! Goodbye!
"");
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Queue ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#define MAX 5

struct Queue
{
     int front, rear;
     int items[MAX];
};

typedef struct Queue queue;

int isFull(queue *q)
{
     if ((q->rear + 1) % MAX == q->front)
     {
          return 1;
     }
     return 0;
}

int isEmpty(queue *q)
{
     if (q->front == q->rear)
     {
          return 1;
     }
     return 0;
}

void enqueue(queue *q, int element)
{
     if (isFull(q))
     {
          printf(""Queue is Full\\n"");
     }
     else
     {
          q->rear = (q->rear + 1) % MAX;
          q->items[q->rear] = element;
          printf(""Inserted -> %d\\n"", element);
     }
}

int dequeue(queue *q)
{
     int element;
     if (isEmpty(q))
     {
          printf(""Queue is Empty\\n"");
          return (-1);
     }
     else
     {
          element = q->items[q->front];
          printf(""Deleted element -> %d\\n"", element);
          q->front = (q->front + 1) % MAX;
          return (element);
     }
}

void display(queue *q)
{
     int i;
     if (isEmpty(q))
     {
          printf(""Queue is Empty\\n"");
     }
     else
     {
          printf(""Queue Elements are:\\n"");
          for (i = q->front; i != q->rear; i = (i + 1) % MAX)
          {
               printf(""%d "", q->items[i]);
          }
          printf(""%d "", q->items[i]);
     }
}

int main()
{
     queue *q = (queue *)malloc(sizeof(queue));
     q->front = 0;
     q->rear = 0;
     int choice, element;

     while (1)
     {
          printf(""\\n1.Enqueue\\n2.Dequeue\\n3.Display\\n4.Exit\\n"");
          printf(""Enter your Choice:"");
          scanf(""%d"", &choice);
          switch (choice)
          {
          case 1:
               printf(""Enter the element: "");
               scanf(""%d"", &element);
               enqueue(q, element);
               break;
          case 2:
               dequeue(q);
               break;
          case 3:
               display(q);
               break;
          case 4:
               exit(1);
          default:
               printf(""Invalid Choice\\n"");
               break;
          }
     }
     return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall enqueue(_QWORD, _QWORD); // weak
__int64 __fastcall dequeue(_QWORD); // weak
__int64 __fastcall display(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl __noreturn exit(int Code);


//----- (000000014000183D) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // [rsp+20h] [rbp-10h] BYREF
  int v4; // [rsp+24h] [rbp-Ch] BYREF
  _DWORD *v5; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v5 = malloc(0x1Cui64);
  *v5 = 0;
  v5[1] = 0;
  while ( 1 )
  {
    printf(""\\n1.Enqueue\\n2.Dequeue\\n3.Display\\n4.Exit\\n"");
    printf(""Enter your Choice:"");
    scanf(""%d"", &v4);
    if ( v4 == 4 )
      exit(1);
    if ( v4 > 4 )
    {
LABEL_12:
      printf(""Invalid Choice\\n"");
    }
    else
    {
      switch ( v4 )
      {
        case 3:
          display(v5);
          break;
        case 1:
          printf(""Enter the element: "");
          scanf(""%d"", &v3);
          enqueue(v5, v3);
          break;
        case 2:
          dequeue(v5);
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 1400018B6: conditional instruction was optimized away because %var_C.4<3
// 140001655: using guessed type __int64 __fastcall enqueue(_QWORD, _QWORD);
// 1400016E5: using guessed type __int64 __fastcall dequeue(_QWORD);
// 140001776: using guessed type __int64 __fastcall display(_QWORD);
// 1400019F0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include<stdio.h>
#include<stdlib.h>

struct node{
    int data;
    struct node* next;
};

void enqueue(struct node** head, int data){
    struct node* new_node = (struct node*)malloc(sizeof(struct node));
    new_node->data = data;
    new_node->next = NULL;
    if(*head == NULL){
        *head = new_node;
        return;
    }
    struct node* temp = *head;
    while(temp->next != NULL){
        temp = temp->next;
    }
    temp->next = new_node;
}

void dequeue(struct node** head){
    if(*head == NULL){
        printf(""Queue is Empty
"");
        return;
    }
    struct node* temp = *head;
    *head = (*head)->next;
    free(temp);
}

void display(struct node* head){
    if(head == NULL){
        printf(""Queue is Empty
"");
        return;
    }
    struct node* temp = head;
    while(temp != NULL){
        printf(""%d "", temp->data);
        temp = temp->next;
    }
    printf(""
"");
}

int main(){
    struct node* head = NULL;
    int choice, element;
    while(1){
        printf(""
1.Enqueue
2.Dequeue
3.Display
4.Exit
"");
        printf(""Enter your Choice:"");
        scanf(""%d"", &choice);
        switch(choice){
            case 1:
                printf(""Enter the element: "");
                scanf(""%d"", &element);
                enqueue(&head, element);
                break;
            case 2:
                dequeue(&head);
                break;
            case 3:
                display(head);
                break;
            case 4:
                exit(0);
            default:
                printf(""Invalid Choice
"");
        }
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Matrix operations ; Style: shocked
#include <stdio.h>

int main() {
  printf(""Oh my goodness! I can't believe this code is working!\\n"");
  
  int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
  };
  
  // Printing original matrix
  printf(""\\nOriginal Matrix:\\n"");
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      printf(""%d "", matrix[i][j]);
    }
    printf(""\\n"");
  }
  
  printf(""\\nI hope you're sitting down, because I'm about to transpose this matrix...\\n"");

  // Transposing the matrix
  int temp;
  for (int i = 0; i < 3; i++) {
    for (int j = i; j < 3; j++) {
      temp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = temp;
    }
  }
  
  printf(""\\nHoly smokes, it actually worked! Here's the transposed matrix:\\n"");
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      printf(""%d "", matrix[i][j]);
    }
    printf(""\\n"");
  }
  
  printf(""\\nAnd just for kicks, let's multiply each element in the matrix by 2...\\n"");

  // Multiplying each element in the matrix by 2
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      matrix[i][j] *= 2;
    }
  }
  
  printf(""\\nThis is insane... it actually worked again! Here's the final matrix:\\n"");
  for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
      printf(""%d "", matrix[i][j]);
    }
    printf(""\\n"");
  }
  
  printf(""\\nI'm not very good at expressing emotion, but that was a wild ride. Thanks for experiencing it with me!\\n"");
  
  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[9]; // [rsp+20h] [rbp-50h]
  int v5; // [rsp+44h] [rbp-2Ch]
  int nn; // [rsp+48h] [rbp-28h]
  int mm; // [rsp+4Ch] [rbp-24h]
  int kk; // [rsp+50h] [rbp-20h]
  int jj; // [rsp+54h] [rbp-1Ch]
  int ii; // [rsp+58h] [rbp-18h]
  int n; // [rsp+5Ch] [rbp-14h]
  int m; // [rsp+60h] [rbp-10h]
  int k; // [rsp+64h] [rbp-Ch]
  int j; // [rsp+68h] [rbp-8h]
  int i; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Oh my goodness! I can't believe this code is working!\\n"");
  v4[0] = 1;
  v4[1] = 2;
  v4[2] = 3;
  v4[3] = 4;
  v4[4] = 5;
  v4[5] = 6;
  v4[6] = 7;
  v4[7] = 8;
  v4[8] = 9;
  printf(""\\nOriginal Matrix:\\n"");
  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      printf(""%d "", (unsigned int)v4[3 * i + j]);
    printf(""\\n"");
  }
  printf(""\\nI hope you're sitting down, because I'm about to transpose this matrix...\\n"");
  for ( k = 0; k <= 2; ++k )
  {
    for ( m = k; m <= 2; ++m )
    {
      v5 = v4[3 * k + m];
      v4[3 * k + m] = v4[3 * m + k];
      v4[3 * m + k] = v5;
    }
  }
  printf(""\\nHoly smokes, it actually worked! Here's the transposed matrix:\\n"");
  for ( n = 0; n <= 2; ++n )
  {
    for ( ii = 0; ii <= 2; ++ii )
      printf(""%d "", (unsigned int)v4[3 * n + ii]);
    printf(""\\n"");
  }
  printf(""\\nAnd just for kicks, let's multiply each element in the matrix by 2...\\n"");
  for ( jj = 0; jj <= 2; ++jj )
  {
    for ( kk = 0; kk <= 2; ++kk )
      v4[3 * jj + kk] *= 2;
  }
  printf(""\\nThis is insane... it actually worked again! Here's the final matrix:\\n"");
  for ( mm = 0; mm <= 2; ++mm )
  {
    for ( nn = 0; nn <= 2; ++nn )
      printf(""%d "", (unsigned int)v4[3 * mm + nn]);
    printf(""\\n"");
  }
  printf(""\\nI'm not very good at expressing emotion, but that was a wild ride. Thanks for experiencing it with me!\\n"");
  return 0;
}
// 140001930: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=137 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    printf(""Oh my goodness! I can't believe this code is working!
"");

    int matrix[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    printf(""
Original Matrix:
"");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf(""%d "", matrix[i][j]);
        }
        printf(""
"");
    }

    printf(""
I hope you're sitting down, because I'm about to transpose this matrix...
"");

    for (int i = 0; i < 3; i++) {
        for (int j = i; j < 3; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    printf(""
Holy smokes, it actually worked! Here's the transposed matrix:
"");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf(""%d "", matrix[i][j]);
        }
        printf(""
"");
    }

    printf(""
And just for kicks, let's multiply each element in the matrix by 2...
"");

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            matrix[i][j] *= 2;
        }
    }

    printf(""
This is insane... it actually worked again! Here's the final matrix:
"");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf(""%d "", matrix[i][j]);
        }
        printf(""
"");
    }

    printf(""
I'm not very good at expressing emotion, but that was a wild ride. Thanks for experiencing it with me!
"");

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Image Classification system ; Style: future-proof
#include <stdio.h>
#include <stdlib.h>

// Define Constants for Image Width and Height
#define N 10
#define M 10

// Function to read the input image from a file
void read_input_image(float input_image[N][M], char *filename){
    FILE *input_file = fopen(filename, ""r"");
    if(input_file == NULL) {
        printf(""Unable to open input file\\n"");
        exit(EXIT_FAILURE);
    }
    int i, j;
    for(i = 0; i < N; i++){
        for(j = 0; j < M; j++){
            fscanf(input_file, ""%f"", &input_image[i][j]);
        }
    }
    fclose(input_file);
}

// Function to classify the image as either a circle or square
int classify_image(float input_image[N][M]){
    int i, j;
    float sum = 0;
    for(i = 0; i < N; i++){
        for(j = 0; j < M; j++){
            sum += input_image[i][j];
        }
    }
    float average = sum / (N * M);
    if(average > 0.5){
        return 0; // Circle
    }
    else{
        return 1; // Square
    }
}

// Main Function
int main(){
    float input_image[N][M];
    char *filename = ""input.txt"";
    read_input_image(input_image, filename);
    int output = classify_image(input_image);
    if(output == 0){
        printf(""The input image is a circle.\\n"");
    }
    else{
        printf(""The input image is a square.\\n"");
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall read_input_image(_QWORD, _QWORD); // weak
__int64 __fastcall classify_image(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (000000014000173B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[404]; // [rsp+20h] [rbp-60h] BYREF
  const char *v6; // [rsp+1B8h] [rbp+138h]

  _main(argc, argv, envp);
  v6 = ""input.txt"";
  read_input_image(v4, ""input.txt"");
  if ( (unsigned int)classify_image(v4) )
    printf(""The input image is a square.\\n"");
  else
    printf(""The input image is a circle.\\n"");
  return 0;
}
// 1400015D4: using guessed type __int64 __fastcall read_input_image(_QWORD, _QWORD);
// 140001694: using guessed type __int64 __fastcall classify_image(_QWORD);
// 140001870: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=180 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 100

// Function to read input image from file
void read_input_image(int image[MAX_SIZE][MAX_SIZE], char* filename) {
    FILE* fp = fopen(filename, ""r"");
    if (fp == NULL) {
        printf(""Error: Could not open file %s
"", filename);
        exit(1);
    }
    int i, j;
    for (i = 0; i < MAX_SIZE; i++) {
        for (j = 0; j < MAX_SIZE; j++) {
            fscanf(fp, ""%d"", &image[i][j]);
        }
    }
    fclose(fp);
}

// Function to classify input image
int classify_image(int image[MAX_SIZE][MAX_SIZE]) {
    int i, j, sum = 0;
    for (i = 0; i < MAX_SIZE; i++) {
        for (j = 0; j < MAX_SIZE; j++) {
            sum += image[i][j];
        }
    }
    if (sum == 0) {
        return 1; // Image is a square
    } else {
        return 0; // Image is a circle
    }
}

int main() {
    int image[MAX_SIZE][MAX_SIZE];
    char* filename = ""input.txt"";
    read_input_image(image, filename);
    if (classify_image(image)) {
        printf(""The input image is a square.
"");
    } else {
        printf(""The input image is a circle.
"");
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Chess AI ; Style: funny
#include <stdio.h>
#include <stdlib.h>

typedef struct king {
    int x;
    int y;
} King;

typedef struct chessboard {
    char board[8][8];
} Chessboard;

int main() {

    // Initialize the chessboard with pieces
    Chessboard board = {
        {""rnbqkbnr"",
         ""pppppppp"",
         ""........"",
         ""........"",
         ""........"",
         ""........"",
         ""PPPPPPPP"",
         ""RNBQKBNR""}
    };

    // Initialize the king's position
    King king = {4, 7};

    // Print out the initial state of the board
    printf(""Initial state of the board:\\n"");
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            printf(""%c "", board.board[i][j]);
        }
        printf(""\\n"");
    }
    printf(""\\n"");

    // Let's make a move!
    printf(""Making move...\\n"");

    // Randomly select a new position for the king (shhh... he doesn't know it's random)
    king.x = rand() % 8;
    king.y = rand() % 8;

    // Update the board with the new position
    board.board[king.y][king.x] = 'K';

    // Print out the updated state of the board
    printf(""Updated state of the board:\\n"");
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            printf(""%c "", board.board[i][j]);
        }
        printf(""\\n"");
    }
    printf(""\\n"");

    // Ta-da! Our Chess AI has made a move!
    printf(""I am the greatest Chess AI ever created!\\n"");

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl rand();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-58h]
  __int64 v5[8]; // [rsp+30h] [rbp-50h] BYREF
  int m; // [rsp+70h] [rbp-10h]
  int k; // [rsp+74h] [rbp-Ch]
  int j; // [rsp+78h] [rbp-8h]
  int i; // [rsp+7Ch] [rbp-4h]
  __int64 savedregs; // [rsp+80h] [rbp+0h] BYREF

  _main(argc, argv, envp);
  qmemcpy(v5, ""rnbqkbnrpppppppp................................PPPPPPPPRNBQKBNR"", sizeof(v5));
  printf(""Initial state of the board:\\n"");
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 7; ++j )
      printf(""%c "", (unsigned int)*((char *)&savedregs + 8 * i + j - 80));
    printf(""\\n"");
  }
  printf(""\\n"");
  printf(""Making move...\\n"");
  v4 = rand() % 8;
  *((_BYTE *)&savedregs + 8 * (rand() % 8) + v4 - 80) = 75;
  printf(""Updated state of the board:\\n"");
  for ( k = 0; k <= 7; ++k )
  {
    for ( m = 0; m <= 7; ++m )
      printf(""%c "", (unsigned int)*((char *)&savedregs + 8 * k + m - 80));
    printf(""\\n"");
  }
  printf(""\\n"");
  printf(""I am the greatest Chess AI ever created!\\n"");
  return 0;
}
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

int main() {
    char board[8][8] = {
        {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'},
        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
        {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
        {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
        {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
        {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'}
    };

    printf(""Initial state of the board:
"");
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            printf(""%c "", board[i][j]);
        }
        printf(""
"");
    }
    printf(""
"");

    printf(""Making move...
"");
    int row = rand() % 8;
    int col = rand() % 8;
    board[row][col] = 'X';

    printf(""Updated state of the board:
"");
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            printf(""%c "", board[i][j]);
        }
        printf(""
"");
    }
    printf(""
"");

    printf(""I am the greatest Chess AI ever created!
"");

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Airport Baggage Handling Simulation ; Style: beginner-friendly
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_PASSENGERS 50
#define NUM_BAGS 100

int main() {
    srand(time(NULL)); // Seed the random number generator

    int bag_count[NUM_PASSENGERS] = {0}; // Keep count of each passenger's bags
    int total_bags = 0; // Keep track of total number of bags

    for (int i = 0; i < NUM_BAGS; i++) {
        int passenger_num = rand() % NUM_PASSENGERS; // Randomly assign a bag to a passenger
        bag_count[passenger_num]++; // Increment the passenger's bag count
        total_bags++; // Increment the total bag count
    }

    printf(""There are %d passengers and %d bags.\\n\\n"", NUM_PASSENGERS, NUM_BAGS);

    for (int i = 0; i < NUM_PASSENGERS; i++) {
        printf(""Passenger %d has %d bags.\\n"", i+1, bag_count[i]);
    }

    printf(""\\nThere are a total of %d bags.\\n"", total_bags);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5[52]; // [rsp+20h] [rbp-60h] BYREF
  int v6; // [rsp+F0h] [rbp+70h]
  int j; // [rsp+F4h] [rbp+74h]
  int i; // [rsp+F8h] [rbp+78h]
  unsigned int v9; // [rsp+FCh] [rbp+7Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  memset(v5, 0, 0xC8ui64);
  v9 = 0;
  for ( i = 0; i <= 99; ++i )
  {
    v6 = rand() % 50;
    ++v5[v6];
    ++v9;
  }
  printf(""There are %d passengers and %d bags.\\n\\n"", 50i64, 100i64);
  for ( j = 0; j <= 49; ++j )
    printf(""Passenger %d has %d bags.\\n"", (unsigned int)(j + 1), (unsigned int)v5[j]);
  printf(""\\nThere are a total of %d bags.\\n"", v9);
  return 0;
}
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type int var_F0[52];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // Seed the random number generator
    
    int passengers = 50; // Number of passengers
    int bags = 100; // Number of bags
    
    int bag_count[passengers] = {0}; // Initialize the bag count array
    int total_bags = 0; // Initialize the total bags variable
    
    // Loop through 100 random passengers and assign them a bag
    for (int i = 0; i < bags; i++) {
        int passenger = rand() % passengers; // Generate a random passenger
        bag_count[passenger]++; // Increment the bag count for that passenger
        total_bags++; // Increment the total bags variable
    }
    
    // Print out the passenger and bag counts
    printf(""There are %d passengers and %d bags.

"", passengers, bags);
    for (int i = 0; i < passengers; i++) {
        printf(""Passenger %d has %d bags.
"", i+1, bag_count[i]);
    }
    printf(""
There are a total of %d bags.
"", total_bags);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: GPS Navigation Simulation ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define RADIUS 6371     // Earth's radius in kilometers

struct Coord {
    double lat;     // latitude in degrees
    double lon;     // longitude in degrees
} start, dest;

double toRadians(double degrees) {
    return degrees * M_PI / 180;
}

double distance(struct Coord a, struct Coord b) {
    double dLat = toRadians(b.lat - a.lat);
    double dLon = toRadians(b.lon - a.lon);
    double lat1 = toRadians(a.lat);
    double lat2 = toRadians(b.lat);

    double x = sin(dLat/2) * sin(dLat/2) + cos(lat1) * cos(lat2) * sin(dLon/2) * sin(dLon/2);
    double y = 2 * atan2(sqrt(x), sqrt(1-x));
    return RADIUS * y;
}

void navigate() {
    printf(""Enter coordinates of starting point (latitude longitude): "");
    scanf(""%lf %lf"", &start.lat, &start.lon);
    printf(""Enter coordinates of destination point (latitude longitude): "");
    scanf(""%lf %lf"", &dest.lat, &dest.lon);
    printf(""Starting point: %f %f\\n"", start.lat, start.lon);
    printf(""Destination point: %f %f\\n"", dest.lat, dest.lon);

    double dist = distance(start, dest);
    printf(""Distance: %f km\\n"", dist);

    printf(""Enter speed (km/h): "");
    double speed;
    scanf(""%lf"", &speed);

    int hours = (int)(dist / speed);        // Whole hours to travel
    double minutes = (dist / speed - hours) * 60;    // Minutes to travel remaining distance

    printf(""Estimated travel time: %d hours and %.0f minutes\\n"", hours, minutes);
}

int main() {
    navigate();
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 navigate(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019F5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _main(argc, argv, envp);
  navigate();
  return 0;
}
// 140001802: using guessed type __int64 navigate(void);
// 140001AD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define ROW 10
#define COL 10

// Define the maze
int maze[ROW][COL] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 1, 1, 1, 1, 1, 1, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
};

// Define the starting and ending points
int start_row = 1;
int start_col = 1;
int end_row = 9;
int end_col = 9;

// Define the open and closed lists
int open[ROW][COL];
int closed[ROW][COL];

// Define the parent and cost lists
int parent[ROW][COL];
int cost[ROW][COL];

// Define the path list
int path[ROW][COL];

// Define the heuristic function
int heuristic(int row, int col) {
    return abs(row - end_row) + abs(col - end_col);
}

// Define the A* algorithm
void navigate() {
    int i, j;
    int current_row, current_col;
    int min_f, min_i, min_j;
    int temp_row, temp_col;
    int temp_f;

    // Initialize the open and closed lists
    for (i = 0; i < ROW; i++) {
        for (j = 0; j < COL; j++) {
            open[i][j] = 0;
            closed[i][j] = 0;
        }
    }

    // Initialize the parent and cost lists
    for (i = 0; i < ROW; i++) {
        for (j = 0; j < COL; j++) {
            parent[i][j] = -1;
            cost[i][j] = 0;
        }
    }

    // Initialize the path list
    for (i = 0; i < ROW; i++) {
        for (j = 0; j < COL; j++) {
            path[i][j] = 0;
        }
    }

    // Initialize the current point
    current_row = start_row;
    current_col = start_col;

    // Initialize the open list
    open[current_row][current_col] = 1;

    // Initialize the cost list
    cost[current_row][current_col] = heuristic(current_row, current_col);

    // Initialize the parent list
    parent[current_row][current_col] = -1;

    // Initialize the path list
    path[current_row",0
"//FormAI DATASET v1.0 Category: Banking Record System ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a structure to hold the banking record data
typedef struct {
    int account_num;
    char name[50];
    float balance;
} Record;

int main() {
    int option;
    int num_records = 0; // keeps track of number of records
    Record *records = NULL; // points to memory for holding the records
    
    while (1) {
        printf(""\\nWelcome to the Banking Record System!\\n"");
        printf(""Please choose an option:\\n"");
        printf(""1. Add a new record\\n"");
        printf(""2. Update an existing record\\n"");
        printf(""3. Print all records\\n"");
        printf(""4. Exit\\n"");
        printf(""Option: "");
        scanf(""%d"", &option);
        
        switch(option) {
            case 1:
                // Allocate memory for a new record
                records = realloc(records, (num_records+1) * sizeof(Record));
                
                // Prompt user for account number, name, and balance
                printf(""\\nAdd a new record:\\n"");
                printf(""Account number: "");
                scanf(""%d"", &records[num_records].account_num);
                printf(""Name: "");
                scanf(""%s"", records[num_records].name);
                printf(""Balance: $"");
                scanf(""%f"", &records[num_records].balance);
                
                num_records++;
                printf(""\\nRecord added!\\n"");
                break;
                
            case 2:
                // Prompt user for account number to update
                int update_num;
                int found = 0;
                printf(""\\nEnter the account number to update: "");
                scanf(""%d"", &update_num);
                
                // Search for the record with the given account number
                for (int i = 0; i < num_records; i++) {
                    if (records[i].account_num == update_num) {
                        found = 1;
                        // Prompt user for new balance
                        printf(""Enter the new balance: $"");
                        scanf(""%f"", &records[i].balance);
                        printf(""\\nRecord updated!\\n"");
                        break;
                    }
                }
                if (!found) {
                    printf(""Record not found.\\n"");
                }
                break;
                
            case 3:
                printf(""\\nPrinting all records:\\n"");
                printf(""Account Number\\tName\\tBalance\\n"");
                for (int i = 0; i < num_records; i++) {
                    printf(""%d\\t%s\\t$%.2f\\n"", records[i].account_num, records[i].name, records[i].balance);
                }
                break;
                
            case 4:
                printf(""\\nGoodbye!\\n"");
                // Free the memory allocated for the records
                free(records);
                return 0;
                
            default:
                printf(""\\nInvalid option.\\n"");
                break;
        }
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl realloc(void *Block, size_t Size);
// void __cdecl free(void *Block);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-24h] BYREF
  int v5; // [rsp+30h] [rbp-20h] BYREF
  int i; // [rsp+34h] [rbp-1Ch]
  int j; // [rsp+38h] [rbp-18h]
  int v8; // [rsp+3Ch] [rbp-14h]
  void *Block; // [rsp+40h] [rbp-10h]
  int v10; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  v10 = 0;
  Block = 0i64;
  while ( 1 )
  {
    printf(""\\nWelcome to the Banking Record System!\\n"");
    printf(""Please choose an option:\\n"");
    printf(""1. Add a new record\\n"");
    printf(""2. Update an existing record\\n"");
    printf(""3. Print all records\\n"");
    printf(""4. Exit\\n"");
    printf(""Option: "");
    scanf(""%d"", &v5);
    if ( v5 == 4 )
      break;
    if ( v5 > 4 )
      goto LABEL_21;
    switch ( v5 )
    {
      case 3:
        printf(""\\nPrinting all records:\\n"");
        printf(""Account Number\\tName\\tBalance\\n"");
        for ( i = 0; i < v10; ++i )
          printf(
            ""%d\\t%s\\t$%.2f\\n"",
            *((unsigned int *)Block + 15 * i),
            (const char *)Block + 60 * i + 4,
            *((float *)Block + 15 * i + 14));
        break;
      case 1:
        Block = realloc(Block, 60i64 * (v10 + 1));
        printf(""\\nAdd a new record:\\n"");
        printf(""Account number: "");
        scanf(""%d"", (char *)Block + 60 * v10);
        printf(""Name: "");
        scanf(""%s"", (char *)Block + 60 * v10 + 4);
        printf(""Balance: $"");
        scanf(""%f"", (char *)Block + 60 * v10++ + 56);
        printf(""\\nRecord added!\\n"");
        break;
      case 2:
        v8 = 0;
        printf(""\\nEnter the account number to update: "");
        scanf(""%d"", &v4);
        for ( j = 0; j < v10; ++j )
        {
          if ( *((_DWORD *)Block + 15 * j) == v4 )
          {
            v8 = 1;
            printf(""Enter the new balance: $"");
            scanf(""%f"", (char *)Block + 60 * j + 56);
            printf(""\\nRecord updated!\\n"");
            break;
          }
        }
        if ( !v8 )
          printf(""Record not found.\\n"");
        break;
      default:
LABEL_21:
        printf(""\\nInvalid option.\\n"");
        break;
    }
  }
  printf(""\\nGoodbye!\\n"");
  free(Block);
  return 0;
}
// 14000169E: conditional instruction was optimized away because %var_20.4<3
// 140001A80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct BankRecord {
    int accountNumber;
    char name[50];
    float balance;
};

int main() {
    int option, numRecords = 0;
    struct BankRecord *records = NULL;

    while (1) {
        printf(""
Welcome to the Banking Record System!
"");
        printf(""Please choose an option:
"");
        printf(""1. Add a new record
"");
        printf(""2. Update an existing record
"");
        printf(""3. Print all records
"");
        printf(""4. Exit
"");
        printf(""Option: "");
        scanf(""%d"", &option);

        switch (option) {
            case 1:
                records = (struct BankRecord*) realloc(records, (numRecords + 1) * sizeof(struct BankRecord));
                printf(""
Add a new record:
"");
                printf(""Account number: "");
                scanf(""%d"", &records[numRecords].accountNumber);
                printf(""Name: "");
                scanf(""%s"", records[numRecords].name);
                printf(""Balance: $"");
                scanf(""%f"", &records[numRecords].balance);
                numRecords++;
                printf(""
Record added!
"");
                break;

            case 2:
                printf(""
Enter the account number to update: "");
                int accountNumber;
                scanf(""%d"", &accountNumber);
                int found = 0;
                for (int i = 0; i < numRecords; i++) {
                    if (records[i].accountNumber == accountNumber) {
                        found = 1;
                        printf(""Enter the new balance: $"");
                        scanf(""%f"", &records[i].balance);
                        printf(""
Record updated!
"");
                        break;
                    }
                }
                if (!found) {
                    printf(""Record not found.
"");
                }
                break;

            case 3:
                printf(""
Printing all records:
"");
                printf(""Account Number	Name	Balance
"");
                for (int i = 0; i < numRecords; i++) {
                    printf(""%d	%s	$%.2f
"", records[i].accountNumber, records[i].name, records[i].balance);
                }
                break;

            case 4:
                printf(""
Goodbye!
"");
                free(records);
                return 0;

            default:
                printf(""
Invalid option.
"");
        }
    }
}",2
"//FormAI DATASET v1.0 Category: Dice Roller ; Style: unmistakable
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// function to roll a dice with n sides
int rollDice(int n) {
    return rand() % n + 1;
}

int main() {
    // seed the random number
    srand(time(NULL));
    
    int sides, rolls, i, j, sum;
    printf(""*** Dice Roller App ***\\n\\n"");
    
    // get number of sides for the dice
    printf(""Enter the number of sides for the dice: "");
    scanf(""%d"", &sides);
    
    // get number of rolls
    printf(""Enter the number of rolls: "");
    scanf(""%d"", &rolls);
 
    printf(""\\nRolling %d %d-sided dice...\\n"", rolls, sides);
    
    // initialize sum
    sum = 0;
    
    // roll the dice and display the results
    for (i = 1; i <= rolls; i++) {
        int rollResult = rollDice(sides);
        printf(""Roll %d: %d\\n"", i, rollResult);
        
        sum += rollResult;
    }
    
    // display the sum of the rolls
    printf(""\\nSum of rolls: %d\\n"", sum);
    
    // display individual roll frequencies
    printf(""\\nIndividual roll frequencies:\\n"");
    for (j = 1; j <= sides; j++) {
        int freq = 0;
        for (i = 1; i <= rolls; i++) {
            if (rollDice(sides) == j) {
                freq++;
            }
        }
        printf(""%d: %d\\n"", j, freq);
    }
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall rollDice(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+24h] [rbp-1Ch] BYREF
  unsigned int v6; // [rsp+28h] [rbp-18h] BYREF
  unsigned int v7; // [rsp+2Ch] [rbp-14h]
  unsigned int v8; // [rsp+30h] [rbp-10h]
  unsigned int v9; // [rsp+34h] [rbp-Ch]
  unsigned int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf(""*** Dice Roller App ***\\n\\n"");
  printf(""Enter the number of sides for the dice: "");
  scanf(""%d"", &v6);
  printf(""Enter the number of rolls: "");
  scanf(""%d"", &v5);
  printf(""\\nRolling %d %d-sided dice...\\n"", (unsigned int)v5, v6);
  v9 = 0;
  for ( i = 1; i <= v5; ++i )
  {
    v7 = rollDice(v6);
    printf(""Roll %d: %d\\n"", (unsigned int)i, v7);
    v9 += v7;
  }
  printf(""\\nSum of rolls: %d\\n"", v9);
  printf(""\\nIndividual roll frequencies:\\n"");
  for ( j = 1; (int)j <= (int)v6; ++j )
  {
    v8 = 0;
    for ( i = 1; i <= v5; ++i )
    {
      if ( j == (unsigned int)rollDice(v6) )
        ++v8;
    }
    printf(""%d: %d\\n"", j, v8);
  }
  return 0;
}
// 140001601: using guessed type __int64 __fastcall rollDice(_QWORD);
// 140001840: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to roll a dice
int rollDice(int numSides) {
    return rand() % numSides + 1;
}

int main() {
    srand(time(NULL)); // Seed the random number generator
    
    int numSides, numRolls, i, j, roll, sum;
    
    printf(""*** Dice Roller App ***

"");
    
    printf(""Enter the number of sides for the dice: "");
    scanf(""%d"", &numSides);
    
    printf(""Enter the number of rolls: "");
    scanf(""%d"", &numRolls);
    
    printf(""
Rolling %d %d-sided dice...
"", numRolls, numSides);
    
    sum = 0;
    for (i = 1; i <= numRolls; i++) {
        roll = rollDice(numSides);
        printf(""Roll %d: %d
"", i, roll);
        sum += roll;
    }
    
    printf(""
Sum of rolls: %d
"", sum);
    
    printf(""
Individual roll frequencies:
"");
    for (j = 1; j <= numSides; j++) {
        int freq = 0;
        for (i = 1; i <= numRolls; i++) {
            if (rollDice(numSides) == j) {
                freq++;
            }
        }
        printf(""%d: %d
"", j, freq);
    }
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: modern Encryption ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void encrypt(char *input, char *output)
{
    // Key to perform encryption
    char key[] = ""my-secret-key"";

    int input_length = strlen(input);
    int key_length = strlen(key);

    // Allocate memory to store the output
    char *encrypted = (char *)malloc(input_length + 1);
    memset(encrypted, 0, input_length + 1);

    // Loop through the input and perform encryption
    for(int i = 0; i < input_length; i++) {
        encrypted[i] = (input[i] ^ key[i % key_length]);
    }

    // Copy the encrypted data to the output buffer
    strncpy(output, encrypted, input_length);

    // Free the memory allocated
    free(encrypted);
}

int main()
{
    char input[] = ""This is a secret message"";
    char output[strlen(input) + 1];

    encrypt(input, output);

    printf(""Original message: %s\\n"", input);
    printf(""Encrypted message: %s\\n"", output);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall encrypt(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (000000014000167A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v3; // rax
  void *v4; // rsp
  char Str[32]; // [rsp+20h] [rbp-30h] BYREF
  char *v7; // [rsp+40h] [rbp-10h]
  size_t v8; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  strcpy(Str, ""This is a secret message"");
  v3 = strlen(Str) + 1;
  v8 = v3 - 1;
  v4 = alloca(16 * ((v3 + 15) >> 4));
  v7 = Str;
  encrypt(Str, Str);
  printf(""Original message: %s\\n"", Str);
  printf(""Encrypted message: %s\\n"", v7);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall encrypt(_QWORD, _QWORD);
// 140001820: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Function to Encrypt a Message
void encrypt(char *message, char *key) {
    int i, j, k;
    char ch;
    
    // Loop through each character in the message
    for (i = 0, j = 0; message[i] != '",1
"//FormAI DATASET v1.0 Category: Procedurally Generated Maze ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define WIDTH 25
#define HEIGHT 15

void generateMaze(int maze[HEIGHT][WIDTH]) {
    srand(time(NULL));
    
    // Initialize all cells to be walls
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            maze[i][j] = 1;
        }
    }
    
    // Randomly select a starting cell
    int currentRow = rand() % HEIGHT;
    int currentCol = rand() % WIDTH;
    maze[currentRow][currentCol] = 0; // Set the starting cell to be a path
    
    // Keep track of the visited cells
    int visited[HEIGHT][WIDTH] = {0};
    visited[currentRow][currentCol] = 1;
    
    // Create a stack to keep track of the visited cells
    int stack[HEIGHT*WIDTH][2];
    int top = 0;
    stack[top][0] = currentRow;
    stack[top][1] = currentCol;
    
    // Start generating the maze
    while (top >= 0) {
        // Pop the current cell from the stack
        currentRow = stack[top][0];
        currentCol = stack[top][1];
        top--;
        
        // Check all four adjacent cells
        int neighbors[4][2] = {{currentRow-1, currentCol}, {currentRow+1, currentCol}, 
                               {currentRow, currentCol-1}, {currentRow, currentCol+1}};
        for (int i = 0; i < 4; i++) {
            int row = neighbors[i][0];
            int col = neighbors[i][1];
            
            // Check if the adjacent cell is inside the maze
            if (row < 0 || row >= HEIGHT || col < 0 || col >= WIDTH) {
                continue;
            }
            
            // Check if the adjacent cell has not been visited
            if (visited[row][col]) {
                continue;
            }
            
            // Add the current cell to the stack and remove the wall between the two cells
            top++;
            stack[top][0] = currentRow;
            stack[top][1] = currentCol;
            
            // Remove the wall between the two cells
            if (row == currentRow-1) { // Top cell
                maze[currentRow][currentCol] &= ~1; // Remove the top wall from the current cell
                maze[row][col] &= ~4; // Remove the bottom wall from the adjacent cell
            } else if (row == currentRow+1) { // Bottom cell
                maze[currentRow][currentCol] &= ~4; // Remove the bottom wall from the current cell
                maze[row][col] &= ~1; // Remove the top wall from the adjacent cell
            } else if (col == currentCol-1) { // Left cell
                maze[currentRow][currentCol] &= ~8;  // Remove the left wall from the current cell
                maze[row][col] &= ~2; // Remove the right wall from the adjacent cell
            } else if (col == currentCol+1) { // Right cell
                maze[currentRow][currentCol] &= ~2; // Remove the right wall from the current cell
                maze[row][col] &= ~8; // Remove the left wall from the adjacent cell
            }
            
            // Visit the adjacent cell and add it to the stack
            visited[row][col] = 1;
            currentRow = row;
            currentCol = col;
            maze[currentRow][currentCol] = 0; // Set the adjacent cell to be a path
            break;
        }
    }
}

int main() {
    int maze[HEIGHT][WIDTH];
    generateMaze(maze);
    
    // Print the maze
    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            if (maze[i][j] == 1) {
                printf(""#""); // Wall
            } else {
                printf("" ""); // Path
            }
        }
        printf(""\\n"");
    }
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall generateMaze(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001DBB) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4[378]; // [rsp+20h] [rbp-60h] BYREF
  int j; // [rsp+608h] [rbp+588h]
  int i; // [rsp+60Ch] [rbp+58Ch]

  _main(argc, argv, envp);
  generateMaze(v4);
  for ( i = 0; i <= 14; ++i )
  {
    for ( j = 0; j <= 24; ++j )
    {
      if ( v4[25 * i + j] == 1 )
        printf(L""# \\n"");
      else
        printf(L"" \\n"");
    }
    printf(L""\\n"");
  }
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall generateMaze(_QWORD);
// 140001F40: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001DBB: using guessed type int var_5F0[378];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 15
#define COLS 25

void generateMaze(int maze[ROWS][COLS]) {
    int i, j;
    int visited[ROWS][COLS];
    int stack[ROWS][COLS];
    int top = -1;

    // Initialize visited array to 0
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            visited[i][j] = 0;
        }
    }

    // Initialize stack
    stack[++top][0] = 0;
    stack[top][1] = 0;

    // Mark starting point as visited
    visited[0][0] = 1;

    // Generate maze
    while (top >= 0) {
        // Get current position
        int x = stack[top][0];
        int y = stack[top][1];

        // Check if we can move down
        if (y < COLS - 1 && !visited[x][y+1]) {
            visited[x][y+1] = 1;
            stack[++top][0] = x;
            stack[top][1] = y+1;
        }
        // Check if we can move up
        else if (y > 0 && !visited[x][y-1]) {
            visited[x][y-1] = 1;
            stack[++top][0] = x;
            stack[top][1] = y-1;
        }
        // Check if we can move right
        else if (x < ROWS - 1 && !visited[x+1][y]) {
            visited[x+1][y] = 1;
            stack[++top][0] = x+1;
            stack[top][1] = y;
        }
        // Check if we can move left
        else if (x > 0 && !visited[x-1][y]) {
            visited[x-1][y] = 1;
            stack[++top][0] = x-1;
            stack[top][1] = y;
        }
        // If we can't move in any direction, pop stack
        else {
            top--;
        }
    }

    // Set maze to 1 where walls are
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            if (visited[i][j] == 0) {
                maze[i][j] = 1;
            }
        }
    }
}

int main() {
    int maze[ROWS][COLS];
    generateMaze(maze);

    // Print maze
    int i, j;
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            if (maze[i][j] == 1) {
                printf(""#"");
            }
            else {
                printf("" "");
            }
        }
        printf(""
"");
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Building a CSV Reader ; Style: authentic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf(""Usage: %s <filename>\\n"", argv[0]);
        return 1;
    }

    char* filename = argv[1];
    FILE* file = fopen(filename, ""r"");

    if (!file) {
        printf(""Unable to open file: %s\\n"", filename);
        return 1;
    }

    char line[MAX_LINE_LENGTH];
    char* tokens[MAX_LINE_LENGTH];
    int lines_read = 0;

    while (fgets(line, MAX_LINE_LENGTH, file)) {
        if (strlen(line) == MAX_LINE_LENGTH - 1 && line[MAX_LINE_LENGTH - 2] != '\\n') {
            printf(""Line too long!\\n"");
            return 1;
        }
        if (line[strlen(line) - 1] == '\\n') {
            line[strlen(line) - 1] = '\\0';
        }
        char* token = strtok(line, "","");
        int i = 0;
        while (token) {
            tokens[i++] = token;
            token = strtok(NULL, "","");
        }
        lines_read++;
    }

    fclose(file);

    printf(""Read %d lines from file: %s\\n"", lines_read, filename);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strtok(char *String, const char *Delimiter);
// size_t __cdecl strlen(const char *Str);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int __cdecl fclose(FILE *Stream);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // eax
  __int64 v5[1024]; // [rsp+20h] [rbp-60h]
  char Str[1032]; // [rsp+2020h] [rbp+1FA0h] BYREF
  FILE *Stream; // [rsp+2428h] [rbp+23A8h]
  char *FileName; // [rsp+2430h] [rbp+23B0h]
  int v9; // [rsp+243Ch] [rbp+23BCh]
  char *v10; // [rsp+2440h] [rbp+23C0h]
  unsigned int v11; // [rsp+244Ch] [rbp+23CCh]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    FileName = (char *)argv[1];
    Stream = fopen(FileName, ""r"");
    if ( Stream )
    {
      v11 = 0;
      while ( fgets(Str, 1024, Stream) )
      {
        if ( strlen(Str) == 1023 && Str[1022] != 10 )
        {
          printf(""Line too long!\\n"");
          return 1;
        }
        if ( Str[strlen(Str) - 1] == 10 )
          Str[strlen(Str) - 1] = 0;
        v10 = strtok(Str, "","");
        v9 = 0;
        while ( v10 )
        {
          v4 = v9++;
          v5[v4] = (__int64)v10;
          v10 = strtok(0i64, "","");
        }
        ++v11;
      }
      fclose(Stream);
      printf(""Read %d lines from file: %s\\n"", v11, FileName);
      return 0;
    }
    else
    {
      printf(""Unable to open file: %s\\n"", FileName);
      return 1;
    }
  }
  else
  {
    printf(""Usage: %s <filename>\\n"", *argv);
    return 1;
  }
}
// 140001850: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140001591: using guessed type __int64 var_2430[1024];

// nfuncs=141 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","2 #include <stdlib.h>
        3 #include <string.h>
        4 
        5 #define MAX_LINE_LENGTH 1024
        6 
        7 int main(int argc, char *argv[]) {
        8     if (argc < 2) {
        9         printf(""Usage: %s <filename>
"", argv[0]);
        10         return 1;
        11     }
        12 
        13     char *filename = argv[1];
        14     FILE *fp = fopen(filename, ""r"");
        15     if (!fp) {
        16         printf(""Unable to open file: %s
"", filename);
        17         return 1;
        18     }
        19 
        20     char line[MAX_LINE_LENGTH];
        21     char *token;
        22     int line_count = 0;
        23 
        24     while (fgets(line, MAX_LINE_LENGTH, fp)) {
        25         if (strlen(line) == MAX_LINE_LENGTH - 1 && line[MAX_LINE_LENGTH - 2] != '
') {
        26             printf(""Line too long!
"");
        27             return 1;
        28         }
        29         if (line[strlen(line) - 1] == '
') {
        30             line[strlen(line) - 1] = '",2
"//FormAI DATASET v1.0 Category: Medical Store Management System ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Medicine {
    int id;
    char name[50];
    char manufacturer[50];
    int quantity;
    float price;
} Medicine;

void addMedicine(Medicine* medicines, int* count);
void removeMedicine(Medicine* medicines, int* count);
void searchMedicine(Medicine* medicines, int* count);
void displayList(Medicine* medicines, int* count);
void updateMedicineQuantity(Medicine* medicines, int* count);

int main() {
    int count = 0;
    Medicine* medicines = malloc(sizeof(Medicine));
    int choice;

    while(1) {
        printf(""\\n\\nMedical Store Management System"");
        printf(""\\n1.Add Medicine\\n2.Remove Medicine\\n3.Search Medicine\\n4.Display List\\n5.Update Medicine Quantity\\n6.Exit\\nEnter your choice: "");
        scanf(""%d"", &choice);

        switch(choice) {
            case 1:
                addMedicine(medicines, &count);
                break;

            case 2:
                removeMedicine(medicines, &count);
                break;

            case 3:
                searchMedicine(medicines, &count);
                break;

            case 4:
                displayList(medicines, &count);
                break;

            case 5:
                updateMedicineQuantity(medicines, &count);
                break;

            case 6:
                exit(0);

            default:
                printf(""Invalid Choice! Please Try Again."");
        }
    }
    free(medicines);
    return 0;
}

void addMedicine(Medicine* medicines, int* count) {
    printf(""\\nAdding Medicine"");
    (*count)++;
    medicines = realloc(medicines, (*count) * sizeof(Medicine));

    printf(""\\nEnter ID: "");
    scanf(""%d"", &medicines[*count - 1].id);

    printf(""\\nEnter Name: "");
    scanf("" %[^\\n]"", medicines[*count - 1].name);

    printf(""\\nEnter Manufacturer: "");
    scanf("" %[^\\n]"", medicines[*count - 1].manufacturer);

    printf(""\\nEnter Quantity: "");
    scanf(""%d"", &medicines[*count - 1].quantity);

    printf(""\\nEnter Price: "");
    scanf(""%f"", &medicines[*count - 1].price);

    printf(""\\nMedicine Added Successfully!"");
}

void removeMedicine(Medicine* medicines, int* count) {
    int id;
    int flag = 0;

    if (*count == 0) {
        printf(""\\nNo Medicines Available!"");
        return;
    }

    printf(""\\nRemoving Medicine"");
    printf(""\\nEnter ID of the Medicine to be Removed: "");
    scanf(""%d"", &id);

    for (int i=0; i<*count; i++) {
        if (medicines[i].id == id) {
            flag = 1;
            for(int j=i; j<(*count)-1; j++) {
                medicines[j] = medicines[j+1];
            }
            (*count)--;
            medicines = realloc(medicines, (*count) * sizeof(Medicine));
            printf(""\\nRemoved Successfully!"");
            break;
        }
    }

    if (flag == 0) {
        printf(""\\nMedicine Not Found!"");
    }
}

void searchMedicine(Medicine* medicines, int* count) {
    int id;
    int flag = 0;

    if (*count == 0) {
        printf(""\\nNo Medicines Available!"");
        return;
    }

    printf(""\\nSearching Medicine"");
    printf(""\\nEnter ID of the Medicine to be Searched: "");
    scanf(""%d"", &id);

    for (int i=0; i<*count; i++) {
        if (medicines[i].id == id) {
            flag = 1;
            printf(""\\nID: %d"", medicines[i].id);
            printf(""\\nName: %s"", medicines[i].name);
            printf(""\\nManufacturer: %s"", medicines[i].manufacturer);
            printf(""\\nQuantity: %d"", medicines[i].quantity);
            printf(""\\nPrice: %.2f"", medicines[i].price);
            break;
        }
    }

    if (flag == 0) {
        printf(""\\nMedicine Not Found!"");
    }
}

void displayList(Medicine* medicines, int* count) {
    if (*count == 0) {
        printf(""\\nNo Medicines Available!"");
        return;
    }
    printf(""\\nID\\t\\tName\\t\\tManufacturer\\tQuantity\\tPrice"");
    for (int i=0; i<*count; i++) {
        printf(""\\n%d\\t\\t%s\\t\\t%s\\t\\t%d\\t\\t%.2f"", medicines[i].id, medicines[i].name, medicines[i].manufacturer, medicines[i].quantity, medicines[i].price);
    }
}

void updateMedicineQuantity(Medicine* medicines, int* count) {
    int id;
    int flag = 0;

    if (*count == 0) {
        printf(""\\nNo Medicines Available!"");
        return;
    }

    printf(""\\nUpdating Medicine Quantity"");
    printf(""\\nEnter ID of the Medicine to be Updated: "");
    scanf(""%d"", &id);

    for (int i=0; i<*count; i++) {
        if (medicines[i].id == id) {
            flag = 1;
            printf(""\\nEnter New Quantity: "");
            scanf(""%d"", &medicines[i].quantity);
            printf(""\\nUpdated Successfully!"");
            break;
        }
    }

    if (flag == 0) {
        printf(""\\nMedicine Not Found!"");
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall addMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall removeMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall searchMedicine(_QWORD, _QWORD); // weak
__int64 __fastcall displayList(_QWORD, _QWORD); // weak
__int64 __fastcall updateMedicineQuantity(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  int v5; // [rsp+24h] [rbp-Ch] BYREF
  void *v6; // [rsp+28h] [rbp-8h]

  _main(argc, argv, envp);
  v5 = 0;
  v6 = malloc(0x70ui64);
  while ( 1 )
  {
    printf(""\\n\\nMedical Store Management System"");
    printf(
      ""\\n""
      ""1.Add Medicine\\n""
      ""2.Remove Medicine\\n""
      ""3.Search Medicine\\n""
      ""4.Display List\\n""
      ""5.Update Medicine Quantity\\n""
      ""6.Exit\\n""
      ""Enter your choice: "");
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        addMedicine(v6, &v5);
        break;
      case 2:
        removeMedicine(v6, &v5);
        break;
      case 3:
        searchMedicine(v6, &v5);
        break;
      case 4:
        displayList(v6, &v5);
        break;
      case 5:
        updateMedicineQuantity(v6, &v5);
        break;
      case 6:
        exit(0);
      default:
        printf(""Invalid Choice! Please Try Again."");
        break;
    }
  }
}
// 1400016DE: using guessed type __int64 __fastcall addMedicine(_QWORD, _QWORD);
// 1400018A8: using guessed type __int64 __fastcall removeMedicine(_QWORD, _QWORD);
// 140001A97: using guessed type __int64 __fastcall searchMedicine(_QWORD, _QWORD);
// 140001C84: using guessed type __int64 __fastcall displayList(_QWORD, _QWORD);
// 140001DAD: using guessed type __int64 __fastcall updateMedicineQuantity(_QWORD, _QWORD);
// 140001F90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Medicine {
    char name[50];
    int quantity;
    float price;
};

void addMedicine(struct Medicine *medicineList, int *medicineCount);
void removeMedicine(struct Medicine *medicineList, int *medicineCount);
void searchMedicine(struct Medicine *medicineList, int *medicineCount);
void displayList(struct Medicine *medicineList, int *medicineCount);
void updateMedicineQuantity(struct Medicine *medicineList, int *medicineCount);

int main() {
    int choice, medicineCount = 0;
    struct Medicine *medicineList = NULL;

    while (1) {
        printf(""\\n\\nMedical Store Management System"");
        printf(""\\n1.Add Medicine\\n2.Remove Medicine\\n3.Search Medicine\\n4.Display List\\n5.Update Medicine Quantity\\n6.Exit\\nEnter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                addMedicine(medicineList, &medicineCount);
                break;
            case 2:
                removeMedicine(medicineList, &medicineCount);
                break;
            case 3:
                searchMedicine(medicineList, &medicineCount);
                break;
            case 4:
                displayList(medicineList, &medicineCount);
                break;
            case 5:
                updateMedicineQuantity(medicineList, &medicineCount);
                break;
            case 6:
                exit(0);
            default:
                printf(""Invalid Choice! Please Try Again."");
        }
    }

    return 0;
}

void addMedicine(struct Medicine *medicineList, int *medicineCount) {
    struct Medicine *newMedicine = (struct Medicine*) malloc(sizeof(struct Medicine));
    printf(""\\nEnter Medicine Name: "");
    scanf(""%s"", newMedicine->name);
    printf(""Enter Medicine Quantity: "");
    scanf(""%d"", &newMedicine->quantity);
    printf(""Enter Medicine Price: "");
    scanf(""%f"", &newMedicine->price);

    if (*medicineCount == 0) {
        medicineList = newMedicine;
    } else {
        struct Medicine *temp = medicineList;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newMedicine;
    }
    (*medicineCount)++;
}

void removeMedicine(struct Medicine *medicineList, int *medicineCount) {
    char name[50];
    printf(""\\nEnter Medicine Name: "");
    scanf(""%s"", name);

    struct Medicine *temp = medicineList;
    struct Medicine *prev = NULL;

    while (temp != NULL) {
        if (strcmp(temp->name, name) == 0) {
            if (prev == NULL) {
                medicineList = temp->next;
            } else {
                prev->next = temp->next;
            }
            free(temp);
            (*medicineCount)--;
            printf(""\\nMedicine Removed Successfully!"");
            return;
        }
        prev = temp;
        temp = temp->next;
    }
    printf(""\\nMedicine Not Found!"");
}

void searchMedicine(struct Medicine *medicineList, int *medicineCount) {
    char name[50];
    printf(""\\nEnter Medicine Name: "");
    scanf(""%s"", name);

    struct Medicine *temp = medicineList;

    while (temp != NULL) {
        if (strcmp(temp->name, name) == 0) {
            printf(""\\nMedicine Name:",2
"//FormAI DATASET v1.0 Category: Binary Converter ; Style: genious
#include<stdio.h>
#include<stdlib.h>

int main()
{
    int num, binary[100], i=0, j;
    
    //Input number to be converted to binary
    printf(""Enter decimal number to convert to binary: "");
    scanf(""%d"", &num);
    
    //Generate binary digits in reverse order
    while(num>0)
    {
        binary[i++] = num%2;
        num /= 2;
    }
    
    //Printing the binary number in reverse order to get original binary value
    printf(""\\nBinary of the given number is: "");
    for(j=i-1; j>=0; j--)
        printf(""%d"", binary[j]);
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v5[101]; // [rsp+20h] [rbp-60h]
  int v6; // [rsp+1B4h] [rbp+134h] BYREF
  int i; // [rsp+1B8h] [rbp+138h]
  int v8; // [rsp+1BCh] [rbp+13Ch]

  _main(argc, argv, envp);
  v8 = 0;
  printf(""Enter decimal number to convert to binary: "");
  scanf(""%d"", &v6);
  while ( v6 > 0 )
  {
    v3 = v8++;
    v5[v3] = v6 % 2;
    v6 /= 2;
  }
  printf(""\\nBinary of the given number is: "");
  for ( i = v8 - 1; i >= 0; --i )
    printf(""%d"", (unsigned int)v5[i]);
  return 0;
}
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type int var_1A0[101];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    int decimal, binary[100], i = 0, j;
    printf(""Enter decimal number to convert to binary: "");
    scanf(""%d"", &decimal);
    while (decimal > 0) {
        binary[i++] = decimal % 2;
        decimal /= 2;
    }
    printf(""
Binary of the given number is: "");
    for (j = i - 1; j >= 0; j--)
        printf(""%d"", binary[j]);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>

#define WIDTH 10
#define HEIGHT 10

void display_pixel_art(unsigned char pixel_art[][WIDTH]); 

int main(void) {
    unsigned char pixel_art[HEIGHT][WIDTH] = {
        {1, 0, 1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1, 0, 1},
    };

    display_pixel_art(pixel_art);

    return EXIT_SUCCESS;
}

void display_pixel_art(unsigned char pixel_art[][WIDTH]) {
    for (int row = 0; row < HEIGHT; row++) {
        for (int col = 0; col < WIDTH; col++) {
            if (pixel_art[row][col] == 1) {
                printf(""*"");
            } else {
                printf("" "");
            }
        }
        printf(""\\n"");
    }
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall display_pixel_art(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-70h] BYREF
  __int16 v5; // [rsp+28h] [rbp-68h]
  __int64 v6; // [rsp+2Ah] [rbp-66h]
  __int16 v7; // [rsp+32h] [rbp-5Eh]
  __int64 v8; // [rsp+34h] [rbp-5Ch]
  __int16 v9; // [rsp+3Ch] [rbp-54h]
  __int64 v10; // [rsp+3Eh] [rbp-52h]
  __int16 v11; // [rsp+46h] [rbp-4Ah]
  __int64 v12; // [rsp+48h] [rbp-48h]
  __int16 v13; // [rsp+50h] [rbp-40h]
  __int64 v14; // [rsp+52h] [rbp-3Eh]
  __int16 v15; // [rsp+5Ah] [rbp-36h]
  __int64 v16; // [rsp+5Ch] [rbp-34h]
  __int16 v17; // [rsp+64h] [rbp-2Ch]
  __int64 v18; // [rsp+66h] [rbp-2Ah]
  __int16 v19; // [rsp+6Eh] [rbp-22h]
  __int64 v20; // [rsp+70h] [rbp-20h]
  __int16 v21; // [rsp+78h] [rbp-18h]
  __int64 v22; // [rsp+7Ah] [rbp-16h]
  __int16 v23; // [rsp+82h] [rbp-Eh]

  _main(argc, argv, envp);
  v4 = 0x1000100010001i64;
  v5 = 1;
  v6 = 0x100010001000100i64;
  v7 = 256;
  v8 = 0x1000100010001i64;
  v9 = 1;
  v10 = 0x100010001000100i64;
  v11 = 256;
  v12 = 0x1000100010001i64;
  v13 = 1;
  v14 = 0x100010001000100i64;
  v15 = 256;
  v16 = 0x1000100010001i64;
  v17 = 1;
  v18 = 0x100010001000100i64;
  v19 = 256;
  v20 = 0x1000100010001i64;
  v21 = 1;
  v22 = 0x100010001000100i64;
  v23 = 256;
  display_pixel_art(&v4);
  return 0;
}
// 140001633: using guessed type __int64 __fastcall display_pixel_art(_QWORD);
// 140001780: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

#define WIDTH 10
#define HEIGHT 10

typedef struct {
    int r, g, b;
} Color;

typedef struct {
    Color pixels[WIDTH][HEIGHT];
} PixelArt;

void display_pixel_art(PixelArt art);

int main() {
    PixelArt art;
    art.pixels[0][0] = (Color) {255, 0, 0};
    art.pixels[0][1] = (Color) {0, 255, 0};
    art.pixels[0][2] = (Color) {0, 0, 255};
    art.pixels[1][0] = (Color) {255, 255, 0};
    art.pixels[1][1] = (Color) {0, 0, 255};
    art.pixels[1][2] = (Color) {255, 0, 255};
    display_pixel_art(art);
    return 0;
}

void display_pixel_art(PixelArt art) {
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            Color pixel = art.pixels[x][y];
            printf(""(%d,%d,%d) "", pixel.r, pixel.g, pixel.b);
        }
        printf(""
"");
    }
}",1
"//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: retro
#include <stdio.h>
#include <string.h>

typedef struct {
    char name[20];
    int quantity;
    float price;
} Item;

void displayWarehouse(Item *items, int count);
void addItem(Item *items, int *count);
void sellItem(Item *items, int count);
float calculateRevenue(Item *items, int count);

int main() {
    Item items[100];
    int count = 0;

    while (1) {
        printf(""What would you like to do?\\n"");
        printf(""1. Display warehouse inventory\\n"");
        printf(""2. Add item to inventory\\n"");
        printf(""3. Sell item from inventory\\n"");
        printf(""4. Show total revenue\\n"");
        printf(""5. Exit\\n\\n"");

        int choice;
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                displayWarehouse(items, count);
                break;
            case 2:
                addItem(items, &count);
                break;
            case 3:
                sellItem(items, count);
                break;
            case 4:
                printf(""Total revenue: $%.2f\\n"", calculateRevenue(items, count));
                break;
            case 5:
                return 0;
            default:
                printf(""Invalid choice. Please try again.\\n"");
        }
    }
}

void displayWarehouse(Item *items, int count) {
    printf(""Name\\tQuantity\\tPrice\\n"");
    printf(""---------------------------------------------------------\\n"");
    for (int i = 0; i < count; i++) {
        printf(""%-20s%-16d$%.2f\\n"", items[i].name, items[i].quantity, items[i].price);
    }
    printf(""\\n"");
}

void addItem(Item *items, int *count) {
    printf(""Enter name of item to add:\\n"");
    scanf(""%s"", items[*count].name);
    printf(""Enter quantity to add:\\n"");
    scanf(""%d"", &items[*count].quantity);
    printf(""Enter price per item:\\n"");
    scanf(""%f"", &items[*count].price);
    (*count)++;
    printf(""\\n"");
}

void sellItem(Item *items, int count) {
    printf(""Enter name of item to sell:\\n"");
    char itemName[20];
    scanf(""%s"", itemName);

    for (int i = 0; i < count; i++) {
        if (strcmp(itemName, items[i].name) == 0) {
            int quantity;
            printf(""Enter quantity to sell:\\n"");
            scanf(""%d"", &quantity);

            if (quantity > items[i].quantity) {
                printf(""Error: insufficient quantity in inventory.\\n\\n"");
                return;
            }

            items[i].quantity -= quantity;
            printf(""Sold %d %s for $%.2f each.\\n\\n"", quantity, items[i].name, items[i].price);
            return;
        }
    }

    printf(""Error: item not found in inventory.\\n\\n"");
}

float calculateRevenue(Item *items, int count) {
    float revenue = 0;
    for (int i = 0; i < count; i++) {
        revenue += items[i].quantity * items[i].price;
    }
    return revenue;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall displayWarehouse(_QWORD, _QWORD); // weak
__int64 __fastcall addItem(_QWORD, _QWORD); // weak
__int64 __fastcall sellItem(_QWORD, _QWORD); // weak
float __fastcall calculateRevenue(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v3; // xmm0_4
  int v5; // [rsp+28h] [rbp-58h] BYREF
  unsigned int v6; // [rsp+2Ch] [rbp-54h] BYREF
  char v7[2800]; // [rsp+30h] [rbp-50h] BYREF

  _main(argc, argv, envp);
  v6 = 0;
  while ( 1 )
  {
    printf(""What would you like to do?\\n"");
    printf(""1. Display warehouse inventory\\n"");
    printf(""2. Add item to inventory\\n"");
    printf(""3. Sell item from inventory\\n"");
    printf(""4. Show total revenue\\n"");
    printf(""5. Exit\\n\\n"");
    scanf(""%d"", &v5);
    switch ( v5 )
    {
      case 1:
        displayWarehouse(v7, v6);
        break;
      case 2:
        addItem(v7, &v6);
        break;
      case 3:
        sellItem(v7, v6);
        break;
      case 4:
        v3 = calculateRevenue(v7, v6);
        printf(""Total revenue: $%.2f\\n"", v3);
        break;
      case 5:
        return 0;
      default:
        printf(""Invalid choice. Please try again.\\n"");
        break;
    }
  }
}
// 14000172C: using guessed type __int64 __fastcall displayWarehouse(_QWORD, _QWORD);
// 14000181A: using guessed type __int64 __fastcall addItem(_QWORD, _QWORD);
// 14000191D: using guessed type __int64 __fastcall sellItem(_QWORD, _QWORD);
// 140001AD9: using guessed type float __fastcall calculateRevenue(_QWORD, _QWORD);
// 140001C20: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ITEMS 100
#define MAX_NAME_LENGTH 20
#define MAX_DESCRIPTION_LENGTH 50

typedef struct {
    char name[MAX_NAME_LENGTH];
    char description[MAX_DESCRIPTION_LENGTH];
    int quantity;
    float price;
} Item;

void displayWarehouse(Item warehouse[], int numItems);
void addItem(Item warehouse[], int *numItems);
void sellItem(Item warehouse[], int numItems);
float calculateRevenue(Item warehouse[], int numItems);

int main() {
    Item warehouse[MAX_ITEMS];
    int numItems = 0;
    int choice;

    while (1) {
        printf(""What would you like to do?\\n"");
        printf(""1. Display warehouse inventory\\n"");
        printf(""2. Add item to inventory\\n"");
        printf(""3. Sell item from inventory\\n"");
        printf(""4. Show total revenue\\n"");
        printf(""5. Exit\\n\\n"");

        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                displayWarehouse(warehouse, numItems);
                break;
            case 2:
                addItem(warehouse, &numItems);
                break;
            case 3:
                sellItem(warehouse, numItems);
                break;
            case 4:
                printf(""Total revenue: $%.2f\\n"", calculateRevenue(warehouse, numItems));
                break;
            case 5:
                return 0;
            default:
                printf(""Invalid choice. Please try again.\\n"");
        }
    }

    return 0;
}

void displayWarehouse(Item warehouse[], int numItems) {
    if (numItems == 0) {
        printf(""Warehouse is empty.\\n"");
        return;
    }

    printf(""Warehouse Inventory:\\n"");
    printf(""---------------------\\n"");
    printf(""Name\\tDescription\\tQuantity\\tPrice\\n"");
    printf(""---------------------\\n"");

    for (int i = 0; i < numItems; i++) {
        printf(""%s\\t%s\\t\\t%d\\t\\t$%.2f\\n"", warehouse[i].name, warehouse[i].description, warehouse[i].quantity, warehouse[i].price);
    }
}

void addItem(Item warehouse[], int *numItems) {
    if (*numItems == MAX_ITEMS) {
        printf(""Warehouse is full.\\n"");
        return;
    }

    Item newItem;

    printf(""Enter item name: "");
    scanf(""%s"", newItem.name);

    printf(""Enter item description: "");
    scanf(""%s"", newItem.description);

    printf(""Enter item quantity: "");
    scanf(""%d"", &newItem.quantity);

    printf(""Enter item price: "");
    scanf(""%f"", &newItem.price);

    warehouse[*numItems] = newItem;
    (*numItems)++;

    printf(""Item added to warehouse.\\n"");
}

void sellItem(Item warehouse[], int numItems) {
    if (numItems == 0) {
        printf(""Warehouse is empty.\\n"");
        return;
    }

    char name[MAX_NAME_LENGTH];

    printf(""Enter item name to sell: "");
    scanf(""%s"", name);

    for (int i = 0; i < numItems; i++) {
        if (strcmp(warehouse[i].name, name) == 0) {
            if (warehouse[i].quantity ==",2
"//FormAI DATASET v1.0 Category: File system simulation ; Style: Alan Touring
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILES 10
#define FILENAME_LEN 20
#define DATA_LEN 100

typedef struct file {
    char name[FILENAME_LEN];
    char data[DATA_LEN];
} File;

int num_files = 0;
File files[MAX_FILES];

void create_file() {
    if (num_files < MAX_FILES) {
        printf(""Enter file name: "");
        scanf(""%s"", files[num_files].name);
        strcpy(files[num_files].data, """");
        num_files++;
        printf(""File created.\\n"");
    } else {
        printf(""Cannot create file. Maximum number of files reached.\\n"");
    }
}

void write_to_file() {
    char filename[FILENAME_LEN];
    printf(""Enter file name: "");
    scanf(""%s"", filename);
    int index = -1;
    for (int i = 0; i < num_files; i++) {
        if (strcmp(files[i].name, filename) == 0) {
            index = i;
            break;
        }
    }
    if (index != -1) {
        printf(""Enter data: "");
        scanf(""%s"", files[index].data);
        printf(""Data written to file.\\n"");
    } else {
        printf(""File not found.\\n"");
    }
}

void read_from_file() {
    char filename[FILENAME_LEN];
    printf(""Enter file name: "");
    scanf(""%s"", filename);
    int index = -1;
    for (int i = 0; i < num_files; i++) {
        if (strcmp(files[i].name, filename) == 0) {
            index = i;
            break;
        }
    }
    if (index != -1) {
        printf(""Data in file: %s\\n"", files[index].data);
    } else {
        printf(""File not found.\\n"");
    }
}

void delete_file() {
    char filename[FILENAME_LEN];
    printf(""Enter file name: "");
    scanf(""%s"", filename);
    int index = -1;
    for (int i = 0; i < num_files; i++) {
        if (strcmp(files[i].name, filename) == 0) {
            index = i;
            break;
        }
    }
    if (index != -1) {
        for (int i = index; i < num_files - 1; i++) {
            strcpy(files[i].name, files[i + 1].name);
            strcpy(files[i].data, files[i + 1].data);
        }
        num_files--;
        printf(""File deleted.\\n"");
    } else {
        printf(""File not found.\\n"");
    }
}

void print_menu() {
    printf(""File System Simulation Example\\n"");
    printf(""------------------------------\\n"");
    printf(""1. Create file\\n"");
    printf(""2. Write to file\\n"");
    printf(""3. Read from file\\n"");
    printf(""4. Delete file\\n"");
    printf(""5. Exit\\n"");
}

int main() {
    int choice;
    do {
        print_menu();
        printf(""Enter choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                create_file();
                break;
            case 2:
                write_to_file();
                break;
            case 3:
                read_from_file();
                break;
            case 4:
                delete_file();
                break;
            case 5:
                printf(""Exiting program.\\n"");
                break;
            default:
                printf(""Invalid choice.\\n"");
                break;
        }
    } while (choice != 5);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 create_file(void); // weak
__int64 write_to_file(void); // weak
__int64 read_from_file(void); // weak
__int64 delete_file(void); // weak
__int64 print_menu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001A67) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  do
  {
    print_menu();
    printf(""Enter choice: "");
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        create_file();
        break;
      case 2:
        write_to_file();
        break;
      case 3:
        read_from_file();
        break;
      case 4:
        delete_file();
        break;
      case 5:
        printf(""Exiting program.\\n"");
        break;
      default:
        printf(""Invalid choice.\\n"");
        break;
    }
  }
  while ( v4 != 5 );
  return 0;
}
// 1400015E2: using guessed type __int64 create_file(void);
// 14000169D: using guessed type __int64 write_to_file(void);
// 140001794: using guessed type __int64 read_from_file(void);
// 14000186D: using guessed type __int64 delete_file(void);
// 1400019EF: using guessed type __int64 print_menu(void);
// 140001BD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_FILE_NAME_LENGTH 100
#define MAX_FILE_SIZE 1000

typedef struct {
    char name[MAX_FILE_NAME_LENGTH];
    int size;
    char content[MAX_FILE_SIZE];
} File;

File files[10];
int num_files = 0;

void create_file() {
    if (num_files >= 10) {
        printf(""Maximum number of files reached.\\n"");
        return;
    }

    File new_file;
    printf(""Enter file name: "");
    scanf(""%s"", new_file.name);
    printf(""Enter file size: "");
    scanf(""%d"", &new_file.size);

    if (new_file.size > MAX_FILE_SIZE) {
        printf(""File size exceeds maximum size.\\n"");
        return;
    }

    printf(""Enter file content: "");
    scanf(""%s"", new_file.content);

    files[num_files++] = new_file;
    printf(""File created successfully.\\n"");
}

void write_to_file() {
    char file_name[MAX_FILE_NAME_LENGTH];
    printf(""Enter file name: "");
    scanf(""%s"", file_name);

    int i;
    for (i = 0; i < num_files; i++) {
        if (strcmp(files[i].name, file_name) == 0) {
            printf(""Enter content to write: "");
            scanf(""%s"", files[i].content);
            printf(""Content written successfully.\\n"");
            return;
        }
    }

    printf(""File not found.\\n"");
}

void read_from_file() {
    char file_name[MAX_FILE_NAME_LENGTH];
    printf(""Enter file name: "");
    scanf(""%s"", file_name);

    int i;
    for (i = 0; i < num_files; i++) {
        if (strcmp(files[i].name, file_name) == 0) {
            printf(""Content of file: %s\\n"", files[i].content);
            return;
        }
    }

    printf(""File not found.\\n"");
}

void delete_file() {
    char file_name[MAX_FILE_NAME_LENGTH];
    printf(""Enter file name: "");
    scanf(""%s"", file_name);

    int i;
    for (i = 0; i < num_files; i++) {
        if (strcmp(files[i].name, file_name) == 0) {
            memmove(&files[i], &files[i+1], (num_files-i-1)*sizeof(File));
            num_files--;
            printf(""File deleted successfully.\\n"");
            return;
        }
    }

    printf(""File not found.\\n"");
}

void print_menu() {
    printf(""1. Create file\\n"");
    printf(""2. Write to file\\n"");
    printf(""3. Read from file\\n"");
    printf(""4. Delete file\\n"");
    printf(""5. Exit\\n"");
}

int main() {
    int choice;

    do {
        print_menu();
        printf(""Enter choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                create_file();
                break;
            case 2:
                write_to_file();
                break;
            case 3:
                read_from_file();
                break;
            case 4:
                delete_file();
                break;
            case 5:
                printf(""Exiting program.\\n"");
                break;
            default:
                printf(""Invalid choice.\\n"");
        }
    } while (choice !=",2
"//FormAI DATASET v1.0 Category: Ebook reader ; Style: funny
#include <stdio.h>
#include <stdlib.h>

#define MAX_BOOKS 100

typedef struct {
    char title[50];
    char author[50];
    float price;
    int pages;
} Book;

typedef struct {
    Book library[MAX_BOOKS];
    int num_books;
} EbookReader;

void add_book(EbookReader *reader, Book new_book) {
    if (reader->num_books < MAX_BOOKS) {
        reader->library[reader->num_books] = new_book;
        reader->num_books++;
        printf(""You've added '%s' by %s to your Ebook Reader!\\n"", new_book.title, new_book.author);
    } else {
        printf(""Sorry, your Ebook Reader is full!\\n"");
    }
}

void print_books(EbookReader reader) {
    for (int i = 0; i < reader.num_books; i++) {
        printf(""\\nTitle: %s\\nAuthor: %s\\nPrice: %.2f\\nPages: %d\\n"", reader.library[i].title,
               reader.library[i].author, reader.library[i].price, reader.library[i].pages);
    }
}

int main() {
    EbookReader my_reader = { .num_books = 0 };

    add_book(&my_reader, (Book) {
            .title = ""The Hitchhiker's Guide to the Galaxy"",
            .author = ""Douglas Adams"",
            .price = 12.99,
            .pages = 208
    });

    add_book(&my_reader, (Book) {
            .title = ""Harry Potter and the Sorcerer's Stone"",
            .author = ""J.K. Rowling"",
            .price = 8.99,
            .pages = 309
    });

    add_book(&my_reader, (Book) {
            .title = ""The Lord of the Rings"",
            .author = ""J.R.R. Tolkien"",
            .price = 17.49,
            .pages = 1178
    });

    printf(""Your Ebook Reader contains %d books:\\n"", my_reader.num_books);
    print_books(my_reader);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall add_book(_QWORD, _QWORD); // weak
__int64 __fastcall print_books(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);


//----- (0000000140001795) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[10816]; // [rsp+20h] [rbp-60h] BYREF
  _QWORD v5[5]; // [rsp+2A60h] [rbp+29E0h] BYREF
  __int64 v6; // [rsp+2A88h] [rbp+2A08h]
  __int64 v7; // [rsp+2A90h] [rbp+2A10h]
  __int128 v8; // [rsp+2A98h] [rbp+2A18h]
  __int128 v9; // [rsp+2AA8h] [rbp+2A28h]
  __int128 v10; // [rsp+2AB8h] [rbp+2A38h]
  int v11; // [rsp+2AC8h] [rbp+2A48h]
  _WORD v12[12]; // [rsp+2AD0h] [rbp+2A50h] BYREF
  __int64 v13; // [rsp+2AE8h] [rbp+2A68h]
  __int64 v14; // [rsp+2AF0h] [rbp+2A70h]
  __int64 v15; // [rsp+2AF8h] [rbp+2A78h]
  _BYTE v16[56]; // [rsp+2B00h] [rbp+2A80h] BYREF
  int v17; // [rsp+2B38h] [rbp+2AB8h]
  _WORD v18[20]; // [rsp+2B40h] [rbp+2AC0h] BYREF
  __int64 v19; // [rsp+2B68h] [rbp+2AE8h]
  _BYTE v20[56]; // [rsp+2B70h] [rbp+2AF0h] BYREF
  int v21; // [rsp+2BA8h] [rbp+2B28h]
  _WORD v22[20]; // [rsp+2BB0h] [rbp+2B30h] BYREF
  __int64 v23; // [rsp+2BD8h] [rbp+2B58h]
  _BYTE v24[56]; // [rsp+2BE0h] [rbp+2B60h] BYREF
  int v25; // [rsp+2C18h] [rbp+2B98h]
  int Src[2704]; // [rsp+2C20h] [rbp+2BA0h] BYREF

  _main(argc, argv, envp);
  memset(Src, 0, 0x2A34ui64);
  strcpy((char *)v22, ""The Hitchhiker's Guide to the Galaxy"");
  HIBYTE(v22[18]) = 0;
  v22[19] = 0;
  v23 = 0i64;
  *(_WORD *)v24 = 0;
  *(_QWORD *)&v24[2] = 0x2073616C67756F44i64;
  *(_OWORD *)&v24[10] = 0x736D616441ui64;
  memset(&v24[26], 0, 26);
  *(_DWORD *)&v24[52] = 1095751434;
  v25 = 208;
  strcpy((char *)v5, ""The Hitchhiker's Guide to the Galaxy"");
  BYTE5(v5[4]) = 0;
  HIWORD(v5[4]) = 0;
  v6 = 0i64;
  v7 = *(_QWORD *)v24;
  v8 = *(_OWORD *)&v24[8];
  v9 = *(_OWORD *)&v24[24];
  v10 = *(_OWORD *)&v24[40];
  v11 = 208;
  add_book(Src, v5);
  strcpy((char *)v18, ""Harry Potter and the Sorcerer's Stone"");
  v18[19] = 0;
  v19 = 0i64;
  *(_WORD *)v20 = 0;
  *(_QWORD *)&v20[2] = 0x776F52202E4B2E4Ai64;
  *(_OWORD *)&v20[10] = 0x676E696Cui64;
  memset(&v20[26], 0, 26);
  *(_DWORD *)&v20[52] = 1091557130;
  v21 = 309;
  strcpy((char *)v5, ""Harry Potter and the Sorcerer's Stone"");
  HIWORD(v5[4]) = 0;
  v6 = 0i64;
  v7 = *(_QWORD *)v20;
  v8 = *(_OWORD *)&v20[8];
  v9 = *(_OWORD *)&v20[24];
  v10 = *(_OWORD *)&v20[40];
  v11 = 309;
  add_book(Src, v5);
  strcpy((char *)v12, ""The Lord of the Rings"");
  v12[11] = 0;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  *(_WORD *)v16 = 0;
  *(_QWORD *)&v16[2] = 0x54202E522E522E4Ai64;
  *(_OWORD *)&v16[10] = 0x6E65696B6C6Fui64;
  memset(&v16[26], 0, 26);
  *(_DWORD *)&v16[52] = 1099688837;
  v17 = 1178;
  strcpy((char *)v5, ""The Lord of the Rings"");
  HIWORD(v5[2]) = 0;
  v5[3] = 0i64;
  v5[4] = 0i64;
  v6 = 0i64;
  v7 = *(_QWORD *)v16;
  v8 = *(_OWORD *)&v16[8];
  v9 = *(_OWORD *)&v16[24];
  v10 = *(_OWORD *)&v16[40];
  v11 = 1178;
  add_book(Src, v5);
  printf(""Your Ebook Reader contains %d books:\\n"", (unsigned int)Src[2700]);
  memcpy(v4, Src, 0x2A34ui64);
  print_books(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall add_book(_QWORD, _QWORD);
// 140001697: using guessed type __int64 __fastcall print_books(_QWORD);
// 140001DD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=139 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BOOKS 100
#define MAX_TITLE_LENGTH 50
#define MAX_AUTHOR_LENGTH 50

typedef struct {
    char title[MAX_TITLE_LENGTH];
    char author[MAX_AUTHOR_LENGTH];
    int page_count;
} Book;

typedef struct {
    Book books[MAX_BOOKS];
    int book_count;
} EbookReader;

void add_book(EbookReader *reader, Book book) {
    reader->books[reader->book_count] = book;
    reader->book_count++;
}

void print_books(EbookReader reader) {
    for (int i = 0; i < reader.book_count; i++) {
        printf(""Title: %s
Author: %s
Page Count: %d
"", reader.books[i].title, reader.books[i].author, reader.books[i].page_count);
    }
}

int main() {
    EbookReader reader = {0};

    // Add some books to the reader
    Book book1 = {""The Hitchhiker's Guide to the Galaxy"", ""Douglas Adams"", 208};
    add_book(&reader, book1);

    Book book2 = {""Harry Potter and the Sorcerer's Stone"", ""J. K. Rowling"", 309};
    add_book(&reader, book2);

    Book book3 = {""The Lord of the Rings"", ""J. R. R. Tolkien"", 1178};
    add_book(&reader, book3);

    // Print out the books in the reader
    printf(""Your Ebook Reader contains %d books:
"", reader.book_count);
    print_books(reader);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void delay(unsigned int mseconds) {
    clock_t goal = mseconds + clock();
    while (goal > clock());
}

int main() {
    int year, month, day, hour;
    printf(""Welcome to the Alien Invasion Probability Calculator!\\n"");
    delay(2000);

    printf(""Please enter the current date and time:\\n"");
    printf(""Year (yyyy): "");
    scanf(""%d"", &year);

    printf(""Month (mm): "");
    scanf(""%d"", &month);

    printf(""Day (dd): "");
    scanf(""%d"", &day);

    printf(""Hour (00-23): "");
    scanf(""%d"", &hour);

    printf(""Calculating probability...\\n"");
    delay(3000);

    srand(time(NULL));
    int probability = rand() % 101;
    printf(""Probability of an alien invasion on %02d/%02d/%04d at %02d:00 is %d%%\\n"", month, day, year, hour, probability);
    delay(2000);

    if (probability > 75) {
        printf(""WARNING: High risk of alien invasion in your area! Please take necessary precautions.\\n"");
    } else if (probability > 50) {
        printf(""CAUTION: Moderate risk of alien invasion in your area. Please stay vigilant.\\n"");
    } else {
        printf(""No immediate danger of an alien invasion in your area. Have a nice day!\\n"");
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall delay(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (000000014000162E) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v5; // [rsp+20h] [rbp-30h]
  int v6; // [rsp+28h] [rbp-28h]
  int v7; // [rsp+3Ch] [rbp-14h] BYREF
  unsigned int v8; // [rsp+40h] [rbp-10h] BYREF
  unsigned int v9; // [rsp+44h] [rbp-Ch] BYREF
  unsigned int v10; // [rsp+48h] [rbp-8h] BYREF
  int v11; // [rsp+4Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Welcome to the Alien Invasion Probability Calculator!\\n"");
  delay(2000i64);
  printf(""Please enter the current date and time:\\n"");
  printf(""Year (yyyy): "");
  scanf(""%d"", &v10);
  printf(""Month (mm): "");
  scanf(""%d"", &v9);
  printf(""Day (dd): "");
  scanf(""%d"", &v8);
  printf(""Hour (00-23): "");
  scanf(""%d"", &v7);
  printf(""Calculating probability...\\n"");
  delay(3000i64);
  v3 = time(0i64);
  srand(v3);
  v11 = rand() % 101;
  v6 = v11;
  v5 = v7;
  printf(""Probability of an alien invasion on %02d/%02d/%04d at %02d:00 is %d%%\\n"", v9, v8, v10, v5, v6);
  delay(2000i64);
  if ( v11 <= 75 )
  {
    if ( v11 <= 50 )
      printf(""No immediate danger of an alien invasion in your area. Have a nice day!\\n"");
    else
      printf(""CAUTION: Moderate risk of alien invasion in your area. Please stay vigilant.\\n"");
  }
  else
  {
    printf(""WARNING: High risk of alien invasion in your area! Please take necessary precautions.\\n"");
  }
  return 0;
}
// 140001601: using guessed type __int64 __fastcall delay(_QWORD);
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void delay(int milliseconds) {
    clock_t start_time = clock();
    while (clock() < start_time + milliseconds);
}

int main() {
    int year, month, day, hour, probability;
    printf(""Welcome to the Alien Invasion Probability Calculator!
"");
    delay(2000); // delay for 2 seconds
    printf(""Please enter the current date and time:
"");
    printf(""Year (yyyy): "");
    scanf(""%d"", &year);
    printf(""Month (mm): "");
    scanf(""%d"", &month);
    printf(""Day (dd): "");
    scanf(""%d"", &day);
    printf(""Hour (00-23): "");
    scanf(""%d"", &hour);
    printf(""Calculating probability...
"");
    delay(3000); // delay for 3 seconds
    srand(time(NULL)); // seed random number generator with current time
    probability = rand() % 101; // generate random number between 0 and 100
    int invasion_probability = probability;
    int invasion_hour = hour;
    printf(""Probability of an alien invasion on %02d/%02d/%04d at %02d:00 is %d%%
"", month, day, year, invasion_hour, invasion_probability);
    delay(2000); // delay for 2 seconds
    if (invasion_probability > 75) {
        printf(""WARNING: High risk of alien invasion in your area! Please take necessary precautions.
"");
    } else if (invasion_probability > 50) {
        printf(""CAUTION: Moderate risk of alien invasion in your area. Please stay vigilant.
"");
    } else {
        printf(""No immediate danger of an alien invasion in your area. Have a nice day!
"");
    }
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Smart home light control ; Style: medieval
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

struct Light {
    int brightness;
    bool status;
    char color[20];
};

struct Room {
    char name[20];
    struct Light lights[5]; 
};

struct House {
    struct Room rooms[5];
};

int main() {
    struct House house;
    
    strcpy(house.rooms[0].name, ""Great Hall"");
    strcpy(house.rooms[1].name, ""Bedroom"");
    strcpy(house.rooms[2].name, ""Kitchen"");
    strcpy(house.rooms[3].name, ""Library"");
    strcpy(house.rooms[4].name, ""Dungeon"");
    
    int currentRoom = 0;
    
    printf(""Welcome to the Medieval Smart Home Light Control System!\\n"");
    
    while(1) {
        printf(""\\nYou are in the %s\\n"", house.rooms[currentRoom].name);
        printf(""What would you like to do?\\n"");
        printf(""1. Turn on/off the lights\\n"");
        printf(""2. Change the brightness level\\n"");
        printf(""3. Change the color\\n"");
        printf(""4. Move to another room\\n"");
        printf(""5. Exit the program\\n"");
        printf(""Enter your choice: "");
        
        int choice;
        scanf(""%d"", &choice);
        
        switch(choice) {
            case 1:
                for(int i=0; i<5; i++) {
                    printf(""The light %d is now %s\\n"", i+1, house.rooms[currentRoom].lights[i].status ? ""off"" : ""on"");
                    house.rooms[currentRoom].lights[i].status = !house.rooms[currentRoom].lights[i].status;
                }
                break;
                
            case 2:
                printf(""Enter the brightness level (0-100): "");
                int brightness;
                scanf(""%d"", &brightness);
                
                for(int i=0; i<5; i++) {
                    house.rooms[currentRoom].lights[i].brightness = brightness;
                    printf(""The brightness of light %d is now %d\\n"", i+1, house.rooms[currentRoom].lights[i].brightness);
                }
                break;
                
            case 3:
                printf(""Enter the color name: "");
                char color[20];
                scanf(""%s"", color);
                
                for(int i=0; i<5; i++) {
                    strcpy(house.rooms[currentRoom].lights[i].color, color);
                    printf(""The color of light %d is now %s\\n"", i+1, house.rooms[currentRoom].lights[i].color);
                }
                break;
                
            case 4:
                printf(""Which room do you want to move to? (1-5): "");
                int room;
                scanf(""%d"", &room);
                if(room<1 || room>5) {
                    printf(""Invalid room number\\n"");
                } else {
                    currentRoom = room-1;
                }
                break;
            
            case 5:
                printf(""Exiting the program..."");
                exit(0);
            
            default:
                printf(""Invalid choice\\n"");
        }
    }
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// void __cdecl __noreturn exit(int Code);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  const char *v3; // rax
  int v5; // [rsp+2Ch] [rbp-54h] BYREF
  char Source[24]; // [rsp+30h] [rbp-50h] BYREF
  int v7; // [rsp+48h] [rbp-38h] BYREF
  int v8; // [rsp+4Ch] [rbp-34h] BYREF
  char v9[48]; // [rsp+50h] [rbp-30h] BYREF
  _QWORD v10[94]; // [rsp+80h] [rbp+0h] BYREF
  int k; // [rsp+370h] [rbp+2F0h]
  int j; // [rsp+374h] [rbp+2F4h]
  int i; // [rsp+378h] [rbp+2F8h]
  int v14; // [rsp+37Ch] [rbp+2FCh]

  _main(argc, argv, envp);
  strcpy(v9, ""Great Hall"");
  v10[14] = 0x6D6F6F72646542i64;
  v10[34] = 0x6E65686374694Bi64;
  v10[54] = 0x7972617262694Ci64;
  v10[74] = 0x6E6F65676E7544i64;
  v14 = 0;
  printf(""Welcome to the Medieval Smart Home Light Control System!\\n"");
  while ( 1 )
  {
    printf(""\\nYou are in the %s\\n"", &v9[160 * v14]);
    printf(""What would you like to do?\\n"");
    printf(""1. Turn on/off the lights\\n"");
    printf(""2. Change the brightness level\\n"");
    printf(""3. Change the color\\n"");
    printf(""4. Move to another room\\n"");
    printf(""5. Exit the program\\n"");
    printf(""Enter your choice: "");
    scanf(""%d"", &v8);
    switch ( v8 )
    {
      case 1:
        for ( i = 0; i <= 4; ++i )
        {
          if ( *((_BYTE *)&v10[20 * v14 - 3] + 28 * i) )
            v3 = ""off"";
          else
            v3 = ""on"";
          printf(""The light %d is now %s\\n"", (unsigned int)(i + 1), v3);
          *((_BYTE *)&v10[20 * v14 - 3] + 28 * i) = *((_BYTE *)&v10[20 * v14 - 3] + 28 * i) == 0;
        }
        break;
      case 2:
        printf(""Enter the brightness level (0-100): "");
        scanf(""%d"", &v7);
        for ( j = 0; j <= 4; ++j )
        {
          *((_DWORD *)&v10[20 * v14 - 3] + 7 * j - 1) = v7;
          printf(
            ""The brightness of light %d is now %d\\n"",
            (unsigned int)(j + 1),
            *((unsigned int *)&v10[20 * v14 - 3] + 7 * j - 1));
        }
        break;
      case 3:
        printf(""Enter the color name: "");
        scanf(""%s"", Source);
        for ( k = 0; k <= 4; ++k )
        {
          strcpy(&v9[160 * v14 + 25 + 28 * k], Source);
          printf(""The color of light %d is now %s\\n"", (unsigned int)(k + 1), &v9[160 * v14 + 25 + 28 * k]);
        }
        break;
      case 4:
        printf(""Which room do you want to move to? (1-5): "");
        scanf(""%d"", &v5);
        if ( v5 > 0 && v5 <= 5 )
          v14 = v5 - 1;
        else
          printf(""Invalid room number\\n"");
        break;
      case 5:
        printf(""Exiting the program..."");
        exit(0);
      default:
        printf(""Invalid choice\\n"");
        break;
    }
  }
}
// 140001BE0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ROOMS 5
#define MAX_LIGHTS 5

typedef struct {
    char name[20];
    int brightness[MAX_LIGHTS];
    char color[MAX_LIGHTS][20];
    int is_on[MAX_LIGHTS];
} Room;

int main() {
    Room rooms[MAX_ROOMS];
    int current_room = 0;
    int choice;
    int brightness;
    char color[20];
    int room_num;

    strcpy(rooms[0].name, ""Great Hall"");
    rooms[0].brightness[0] = 100;
    rooms[0].brightness[1] = 100;
    rooms[0].brightness[2] = 100;
    rooms[0].brightness[3] = 100;
    rooms[0].brightness[4] = 100;
    strcpy(rooms[0].color[0], ""Blue"");
    strcpy(rooms[0].color[1], ""Green"");
    strcpy(rooms[0].color[2], ""Red"");
    strcpy(rooms[0].color[3], ""Yellow"");
    strcpy(rooms[0].color[4], ""Orange"");
    rooms[0].is_on[0] = 1;
    rooms[0].is_on[1] = 1;
    rooms[0].is_on[2] = 1;
    rooms[0].is_on[3] = 1;
    rooms[0].is_on[4] = 1;

    printf(""Welcome to the Medieval Smart Home Light Control System!\\n"");

    while (1) {
        printf(""\\nYou are in the %s\\n"", rooms[current_room].name);
        printf(""What would you like to do?\\n"");
        printf(""1. Turn on/off the lights\\n"");
        printf(""2. Change the brightness level\\n"");
        printf(""3. Change the color\\n"");
        printf(""4. Move to another room\\n"");
        printf(""5. Exit the program\\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                for (int i = 0; i < MAX_LIGHTS; i++) {
                    printf(""The light %d is now %s\\n"", i+1, rooms[current_room].is_on[i] ? ""off"" : ""on"");
                    rooms[current_room].is_on[i] = !rooms[current_room].is_on[i];
                }
                break;
            case 2:
                printf(""Enter the brightness level (0-100): "");
                scanf(""%d"", &brightness);
                for (int i = 0; i < MAX_LIGHTS; i++) {
                    rooms[current_room].brightness[i] = brightness;
                    printf(""The brightness of light %d is now %d\\n"", i+1, rooms[current_room].brightness[i]);
                }
                break;
            case 3:
                printf(""Enter the color name: "");
                scanf(""%s"", color);
                for (int i = 0; i < MAX_LIGHTS; i++) {
                    strcpy(rooms[current_room].color[i], color);
                    printf(""The color of light %d is now %s\\n"", i+1, rooms[current_room].color[i]);
                }
                break;
            case 4:
                printf(""Which room do you want to move to? (1-5): "");
                scanf(""%d"", &room_num);
                if (room_num < 1 || room_num > MAX_ROOMS) {",2
"//FormAI DATASET v1.0 Category: Word Frequency Counter ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORD_LENGTH 100

typedef struct word_node{
    char* word;
    int frequency;
    struct word_node* next;
} word_node;


void insert_word(word_node** head, char* word){
    word_node* current = *head;
    word_node* previous = NULL;
    while(current != NULL && strcmp(word, current->word) > 0){
        previous = current;
        current = current->next;
    }

    if(current == NULL || strcmp(word, current->word) != 0){
        word_node* new_node = (word_node*) malloc(sizeof(word_node));
        new_node->word = (char*) malloc(strlen(word)+1);
        strcpy(new_node->word, word);
        new_node->frequency = 1;
        new_node->next = current;

        if(previous == NULL){
            *head = new_node;
        }
        else{
            previous->next = new_node;
        }
    }
    else{
        current->frequency++;
    }
}

void print_words(word_node* head){
    while(head != NULL){
        printf(""%-20s %d\\n"", head->word, head->frequency);
        head = head->next;
    }
}

int main(int argc, char* argv[]){
    if(argc < 2){
        printf(""Usage: %s <filename>\\n"", argv[0]);
        return 1;
    }
    FILE* file = fopen(argv[1], ""r"");
    if(file == NULL){
        printf(""Error: could not open file '%s'\\n"", argv[1]);
        return 1;
    }

    char current_word[MAX_WORD_LENGTH+1];
    word_node* head = NULL;
    while(fscanf(file, ""%s"", current_word) != EOF){
        int length = strlen(current_word);
        int i;
        for(i=0; i<length; i++){
            if(!isalpha(current_word[i])){
                current_word[i] = '\\0';
                break;
            }
            else{
                current_word[i] = tolower(current_word[i]);
            }
        }

        if(i > 0){
            insert_word(&head, current_word);
        }
    }

    fclose(file);
    print_words(head);

    word_node* current = head;
    while(current != NULL){
        word_node* next = current->next;
        free(current->word);
        free(current);
        current = next;
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int fscanf(FILE *const Stream, const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall insert_word(_QWORD, _QWORD); // weak
__int64 __fastcall print_words(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);
// void __cdecl free(void *Block);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *isalpha)(int C);
// extern int (__cdecl *tolower)(int C);


//----- (000000014000172A) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v4; // [rsp+28h] [rbp-98h] BYREF
  char Str[108]; // [rsp+30h] [rbp-90h] BYREF
  int v6; // [rsp+9Ch] [rbp-24h]
  void *v7; // [rsp+A0h] [rbp-20h]
  FILE *Stream; // [rsp+A8h] [rbp-18h]
  void *Block; // [rsp+B0h] [rbp-10h]
  int i; // [rsp+BCh] [rbp-4h]

  _main(argc, argv, envp);
  if ( argc > 1 )
  {
    Stream = fopen(argv[1], ""r"");
    if ( Stream )
    {
      v4 = 0i64;
      while ( fscanf(Stream, ""%s"", Str) != -1 )
      {
        v6 = strlen(Str);
        for ( i = 0; i < v6; ++i )
        {
          if ( !isalpha(Str[i]) )
          {
            Str[i] = 0;
            break;
          }
          Str[i] = tolower(Str[i]);
        }
        if ( i > 0 )
          insert_word(&v4, Str);
      }
      fclose(Stream);
      print_words(v4);
      for ( Block = v4; Block; Block = v7 )
      {
        v7 = (void *)*((_QWORD *)Block + 2);
        free(*(void **)Block);
        free(Block);
      }
      return 0;
    }
    else
    {
      printf(""Error: could not open file '%s'\\n"", argv[1]);
      return 1;
    }
  }
  else
  {
    printf(""Usage: %s <filename>\\n"", *argv);
    return 1;
  }
}
// 1400015D4: using guessed type __int64 __fastcall insert_word(_QWORD, _QWORD);
// 1400016DE: using guessed type __int64 __fastcall print_words(_QWORD);
// 1400019B0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000172A: using guessed type char Str[108];

// nfuncs=183 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct node {
    char* word;
    struct node* next;
} Node;

void insert_word(Node** head, char* word) {
    Node* new_node = malloc(sizeof(Node));
    new_node->word = malloc(strlen(word) + 1);
    strcpy(new_node->word, word);
    new_node->next = *head;
    *head = new_node;
}

void print_words(Node* head) {
    while (head != NULL) {
        printf(""%s
"", head->word);
        head = head->next;
    }
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf(""Usage: %s <filename>
"", argv[0]);
        return 1;
    }

    FILE* file = fopen(argv[1], ""r"");
    if (file == NULL) {
        printf(""Error: could not open file '%s'
"", argv[1]);
        return 1;
    }

    char word[100];
    Node* head = NULL;
    while (fscanf(file, ""%s"", word) != EOF) {
        int len = strlen(word);
        for (int i = 0; i < len; i++) {
            if (!isalpha(word[i])) {
                word[i] = '",2
"//FormAI DATASET v1.0 Category: Genome Sequencing Simulator ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define SEQUENCE_SIZE 1000

int main(void) {
    srand(time(NULL));
    
    char nucleotides[4] = {'A', 'C', 'G', 'T'};
    char sequence[SEQUENCE_SIZE];
    
    int i;
    
    printf(""Welcome to the Genome Sequencing Simulator 2.0 - Surrealist Edition!\\n\\n"");
    printf(""Press any key to start sequencing...\\n"");
    getchar();
    
    printf(""Sequencing in progress...\\n"");
    
    for (i = 0; i < SEQUENCE_SIZE; i++) {
        
        int random_index = rand() % 4;
        sequence[i] = nucleotides[random_index];
    }
    
    printf(""\\nSequencing complete. Here is your unique genome sequence:\\n\\n"");
    
    for (i = 0; i < SEQUENCE_SIZE; i++) {
        
        printf(""%c"", sequence[i]);
        
        if (i % 10 == 9) {
            printf("" "");
        }
        if (i % 50 == 49) {
            printf(""\\n"");
        }
        if (i % 100 == 99) {
            printf(""\\n\\n"");
        }
        if (i % 200 == 199) {
            printf(""\\n"");
        }
    }

    printf(""\\n\\nThank you for using the Genome Sequencing Simulator 2.0 - Surrealist Edition.\\n"");
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();
// int __cdecl getchar();


//----- (00000001400015B0) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[1012]; // [rsp+20h] [rbp-60h]
  int v6; // [rsp+414h] [rbp+394h]
  int v7; // [rsp+418h] [rbp+398h]
  int i; // [rsp+41Ch] [rbp+39Ch]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v6 = 1413956417;
  printf(""Welcome to the Genome Sequencing Simulator 2.0 - Surrealist Edition!\\n\\n"");
  printf(""Press any key to start sequencing...\\n"");
  getchar();
  printf(""Sequencing in progress...\\n"");
  for ( i = 0; i <= 999; ++i )
  {
    v7 = rand() % 4;
    v5[i] = *((_BYTE *)&v6 + v7);
  }
  printf(""\\nSequencing complete. Here is your unique genome sequence:\\n\\n"");
  for ( i = 0; i <= 999; ++i )
  {
    printf(""%c"", (unsigned int)v5[i]);
    if ( i % 10 == 9 )
      printf("" "");
    if ( i % 50 == 49 )
      printf(""\\n"");
    if ( i % 100 == 99 )
      printf(""\\n\\n"");
    if ( i % 200 == 199 )
      printf(""\\n"");
  }
  printf(""\\n\\nThank you for using the Genome Sequencing Simulator 2.0 - Surrealist Edition.\\n"");
  return 0;
}
// 140001880: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015B0: using guessed type char var_400[1012];

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // seed the random number generator
    
    char genome[] = {'A', 'C', 'G', 'T'};
    int i, j;
    char sequence[1000];
    
    printf(""Welcome to the Genome Sequencing Simulator 2.0 - Surrealist Edition!

"");
    printf(""Press any key to start sequencing...
"");
    getchar(); // wait for user input
    
    printf(""Sequencing in progress...
"");
    
    for (i = 0; i < 1000; i++) {
        j = rand() % 4; // generate a random number between 0 and 3
        sequence[i] = genome[j]; // assign the random genome letter to the sequence
    }
    
    printf(""
Sequencing complete. Here is your unique genome sequence:

"");
    
    for (i = 0; i < 1000; i++) {
        printf(""%c"", sequence[i]); // print the sequence
        
        if (i % 10 == 9) { // add a space after every 10th character
            printf("" "");
        }
        
        if (i % 50 == 49) { // add a newline after every 50th character
            printf(""
"");
        }
        
        if (i % 100 == 99) { // add a newline after every 100th character
            printf(""

"");
        }
        
        if (i % 200 == 199) { // add a newline after every 200th character
            printf(""
"");
        }
    }
    
    printf(""

Thank you for using the Genome Sequencing Simulator 2.0 - Surrealist Edition.
"");
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Fibonacci Sequence Visualizer ; Style: complete
#include <stdio.h>

void fibonacci(int n) {
    int a = 0, b = 1, c;
    for(int i = 0; i < n; i++) {
        printf(""%d "", a);
        c = a + b;
        a = b;
        b = c;
    }
}

int main() {
    int n;
    printf(""Enter the number of terms to be printed: "");
    scanf(""%d"", &n);
    if(n <= 0) {
        printf(""Number of terms should be greater than 0.\\n"");
        return 0;
    }
    printf(""The Fibonacci sequence is: "");
    fibonacci(n);
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall fibonacci(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001643) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  printf(""Enter the number of terms to be printed: "");
  scanf(""%d"", &v4);
  if ( (int)v4 > 0 )
  {
    printf(""The Fibonacci sequence is: "");
    fibonacci(v4);
  }
  else
  {
    printf(""Number of terms should be greater than 0.\\n"");
  }
  return 0;
}
// 1400015E2: using guessed type __int64 __fastcall fibonacci(_QWORD);
// 140001770: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=177 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

void fibonacci(int n) {
    int a = 0, b = 1, c;
    printf(""%d %d "", a, b);
    for (int i = 2; i < n; i++) {
        c = a + b;
        printf(""%d "", c);
        a = b;
        b = c;
    }
}

int main() {
    int n;
    printf(""Enter the number of terms to be printed: "");
    scanf(""%d"", &n);
    if (n <= 0) {
        printf(""Number of terms should be greater than 0.
"");
        return 0;
    }
    printf(""The Fibonacci sequence is: "");
    fibonacci(n);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: recursive
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void generatePixel(int size, int row, int col) {
  if (size == 1) {
    printf(""C"");
    return;
  }

  int c = rand() % 2;
  if (c == 0) {
    generatePixel(size/2, row, col);
    generatePixel(size/2, row + size/2, col + size/2);
  }
  else {
    generatePixel(size/2, row, col + size/2);
    generatePixel(size/2, row + size/2, col);
  }
}

int main() {
  srand(time(NULL));
  
  int size, row, col;
  
  printf(""Please input the size of the pixel art (must be a power of 2): "");
  scanf(""%d"", &size);

  printf(""Please input the row and col coordinates of the top-left corner of the pixel art: "");
  scanf(""%d%d"", &row, &col);

  if (size <= 0 || row < 0 || col < 0) {
    printf(""Invalid input.\\n"");
    return 0;
  }

  for (int i = row; i < row + size; i++) {
    for (int j = col; j < col + size; j++) {
      generatePixel(size, row, col);
    }
    printf(""\\n"");
  }

  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
static time_t __cdecl time(time_t *const Time);
__int64 __fastcall generatePixel(_QWORD, _QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);


//----- (000000014000170F) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+2Ch] [rbp-14h] BYREF
  unsigned int v6; // [rsp+30h] [rbp-10h] BYREF
  unsigned int v7; // [rsp+34h] [rbp-Ch] BYREF
  int j; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  printf(""Please input the size of the pixel art (must be a power of 2): "");
  scanf(""%d"", &v7);
  printf(""Please input the row and col coordinates of the top-left corner of the pixel art: "");
  scanf(""%d%d"", &v6, &v5);
  if ( (int)v7 > 0 && (v6 & 0x80000000) == 0 && (v5 & 0x80000000) == 0 )
  {
    for ( i = v6; i < (int)(v6 + v7); ++i )
    {
      for ( j = v5; j < (int)(v5 + v7); ++j )
        generatePixel(v7, v6, v5);
      printf(""\\n"");
    }
    return 0;
  }
  else
  {
    printf(""Invalid input.\\n"");
    return 0;
  }
}
// 140001601: using guessed type __int64 __fastcall generatePixel(_QWORD, _QWORD, _QWORD);
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Function to generate a random pixel
void generatePixel(int size, int row, int col) {
    int pixel = rand() % 2;
    if (pixel == 0) {
        printf("" "");
    } else {
        printf(""#"");
    }
}

int main() {
    srand(time(NULL)); // Seed the random number generator
    
    int size, row, col;
    printf(""Please input the size of the pixel art (must be a power of 2): "");
    scanf(""%d"", &size);
    printf(""Please input the row and col coordinates of the top-left corner of the pixel art: "");
    scanf(""%d%d"", &row, &col);
    
    // Check if input is valid
    if (size <= 0 || row < 0 || col < 0 || row >= size || col >= size) {
        printf(""Invalid input.
"");
        return 0;
    }
    
    // Generate the pixel art
    for (int i = row; i < row + size; i++) {
        for (int j = col; j < col + size; j++) {
            generatePixel(size, i, j);
        }
        printf(""
"");
    }
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Tic Tac Toe AI ; Style: retro
#include <stdio.h>
#include <stdlib.h>

void display_board(char board[9]);
int winning_move(char board[9], char ch);
int check_winner(char board[9]);
int minimax(char board[9], int depth, int is_max_player, char marker);
int get_best_move(char board[9], char marker);

int main() {
    char board[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
    char player_marker, computer_marker;
    int move = 0, winner = 0;

    printf(""Welcome to Tic Tac Toe!\\n"");
    printf(""Choose your marker (X/O): "");
    scanf("" %c"", &player_marker);

    if (player_marker == 'X') {
        computer_marker = 'O';
    } else {
        computer_marker = 'X';
    }

    display_board(board);

    while (winner == 0) {
        // Player's turn
        printf(""\\nYour move (1-9): "");
        scanf(""%d"", &move);

        if (board[move - 1] == ' ') {
            board[move - 1] = player_marker;
        } else {
            printf(""That spot is already taken.\\n"");
            continue;
        }

        display_board(board);

        winner = check_winner(board);

        if (winner != 0) {
            break;
        }

        // Computer's turn
        printf(""\\nComputer's move:\\n"");

        int best_move = get_best_move(board, computer_marker);

        board[best_move] = computer_marker;

        display_board(board);

        winner = check_winner(board);
    }

    if (winner == 3) {
        printf(""\\nIt's a tie!\\n"");
    } else if (winner == 1) {
        printf(""\\nYou win!\\n"");
    } else if (winner == 2) {
        printf(""\\nThe computer wins!\\n"");
    }

    return 0;
}

void display_board(char board[9]) {
    printf(""\\n"");

    printf("" %c | %c | %c \\n"", board[0], board[1], board[2]);
    printf(""---|---|---\\n"");
    printf("" %c | %c | %c \\n"", board[3], board[4], board[5]);
    printf(""---|---|---\\n"");
    printf("" %c | %c | %c \\n"", board[6], board[7], board[8]);
}

int winning_move(char board[9], char ch) {
    if ((board[0] == ch && board[1] == ch && board[2] == ch) ||
        (board[3] == ch && board[4] == ch && board[5] == ch) ||
        (board[6] == ch && board[7] == ch && board[8] == ch) ||
        (board[0] == ch && board[3] == ch && board[6] == ch) ||
        (board[1] == ch && board[4] == ch && board[7] == ch) ||
        (board[2] == ch && board[5] == ch && board[8] == ch) ||
        (board[0] == ch && board[4] == ch && board[8] == ch) ||
        (board[2] == ch && board[4] == ch && board[6] == ch)) {
        return 1;
    }

    return 0;
}

int check_winner(char board[9]) {
    if (winning_move(board, 'X')) {
        return 1;
    }

    if (winning_move(board, 'O')) {
        return 2;
    }

    for (int i = 0; i < 9; i++) {
        if (board[i] == ' ') {
            return 0;
        }
    }

    return 3;
}

int minimax(char board[9], int depth, int is_max_player, char marker) {
    int score = check_winner(board);

    if (score == 1) {
        return 10 - depth;
    }

    if (score == 2) {
        return depth - 10;
    }

    if (score == 3) {
        return 0;
    }

    if (is_max_player) {
        int max_score = -1000;

        for (int i = 0; i < 9; i++) {
            if (board[i] == ' ') {
                board[i] = marker;

                int current_score = minimax(board, depth + 1, 0, marker);

                if (current_score > max_score) {
                    max_score = current_score;
                }

                board[i] = ' ';
            }
        }

        return max_score;
    } else {
        int min_score = 1000;

        for (int i = 0; i < 9; i++) {
            if (board[i] == ' ') {
                board[i] = (marker == 'X') ? 'O' : 'X';

                int current_score = minimax(board, depth + 1, 1, marker);

                if (current_score < min_score) {
                    min_score = current_score;
                }

                board[i] = ' ';
            }
        }

        return min_score;
    }
}

int get_best_move(char board[9], char marker) {
    int best_move = -1;
    int max_score = -1000;

    for (int i = 0; i < 9; i++) {
        if (board[i] == ' ') {
            board[i] = marker;

            int current_score = minimax(board, 0, 0, marker);

            if (current_score > max_score) {
                max_score = current_score;
                best_move = i;
            }

            board[i] = ' ';
        }
    }

    return best_move;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall display_board(_QWORD); // weak
__int64 __fastcall check_winner(_QWORD); // weak
__int64 __fastcall get_best_move(_QWORD, _QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-1Ch] BYREF
  char v5; // [rsp+2Ah] [rbp-16h] BYREF
  _BYTE v6[9]; // [rsp+2Bh] [rbp-15h] BYREF
  int best_move; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  char v9; // [rsp+3Fh] [rbp-1h]

  _main(argc, argv, envp);
  memset(v6, 32, sizeof(v6));
  v4 = 0;
  v8 = 0;
  printf(""Welcome to Tic Tac Toe!\\n"");
  printf(""Choose your marker (X/O): "");
  scanf("" %c"", &v5);
  if ( v5 == 88 )
    v9 = 79;
  else
    v9 = 88;
  display_board(v6);
  while ( !v8 )
  {
    printf(""\\nYour move (1-9): "");
    scanf(""%d"", &v4);
    if ( v6[v4 - 1] == 32 )
    {
      v6[v4 - 1] = v5;
      display_board(v6);
      v8 = check_winner(v6);
      if ( v8 )
        break;
      printf(""\\nComputer's move:\\n"");
      best_move = get_best_move(v6, (unsigned int)v9);
      v6[best_move] = v9;
      display_board(v6);
      v8 = check_winner(v6);
    }
    else
    {
      printf(""That spot is already taken.\\n"");
    }
  }
  switch ( v8 )
  {
    case 3:
      printf(""\\nIt's a tie!\\n"");
      break;
    case 1:
      printf(""\\nYou win!\\n"");
      break;
    case 2:
      printf(""\\nThe computer wins!\\n"");
      break;
  }
  return 0;
}
// 140001782: using guessed type __int64 __fastcall display_board(_QWORD);
// 140001A24: using guessed type __int64 __fastcall check_winner(_QWORD);
// 140001C1D: using guessed type __int64 __fastcall get_best_move(_QWORD, _QWORD);
// 140001D80: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type int var_1C;

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define BOARD_SIZE 3

void display_board(char board[BOARD_SIZE][BOARD_SIZE]);
bool check_winner(char board[BOARD_SIZE][BOARD_SIZE]);
int get_best_move(char board[BOARD_SIZE][BOARD_SIZE], char marker);

int main() {
    char board[BOARD_SIZE][BOARD_SIZE] = { {' ', ' ', ' '},
                                            {' ', ' ', ' '},
                                            {' ', ' ', ' '} };
    char marker;
    int move = 0;
    bool game_over = false;

    printf(""Welcome to Tic Tac Toe!\\n"");
    printf(""Choose your marker (X/O): "");
    scanf("" %c"", &marker);

    if (marker == 'X') {
        marker = 'O';
    } else {
        marker = 'X';
    }

    display_board(board);

    while (!game_over) {
        printf(""\\nYour move (1-9): "");
        scanf(""%d"", &move);

        if (board[move-1][0] == ' ') {
            board[move-1][0] = marker;
            display_board(board);
            game_over = check_winner(board);

            if (!game_over) {
                printf(""\\nComputer's move:\\n"");
                int best_move = get_best_move(board, marker);
                board[best_move][0] = marker;
                display_board(board);
                game_over = check_winner(board);
            }
        } else {
            printf(""That spot is already taken.\\n"");
        }
    }

    if (game_over == 1) {
        printf(""\\nYou win!\\n"");
    } else if (game_over == 2) {
        printf(""\\nThe computer wins!\\n"");
    } else {
        printf(""\\nIt's a tie!\\n"");
    }

    return 0;
}

void display_board(char board[BOARD_SIZE][BOARD_SIZE]) {
    printf(""\\n"");
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            printf(""%c "", board[i][j]);
        }
        printf(""\\n"");
    }
}

bool check_winner(char board[BOARD_SIZE][BOARD_SIZE]) {
    bool winner = false;

    // Check rows
    for (int i = 0; i < BOARD_SIZE; i++) {
        if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != ' ') {
            winner = true;
        }
    }

    // Check columns
    for (int i = 0; i < BOARD_SIZE; i++) {
        if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != ' ') {
            winner = true;
        }
    }

    // Check diagonals
    if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != ' ') {
        winner = true;
    }

    if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != ' ') {
        winner = true;
    }

    return winner;
}

int get_best_move(char board[BOARD_SIZE][BOARD_SIZE], char marker) {
    int best_move = 0;
    int score = -10",2
"//FormAI DATASET v1.0 Category: Expense Tracker ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float expenses[31]; // Array to hold expenses for each day of the month
    float total = 0; // Variable to hold the total expenses for the month

    // Loop to input expenses for each day of the month
    for(int i = 0; i < 31; i++)
    {
        printf(""Enter expenses for day %d: "", i+1);
        scanf(""%f"", &expenses[i]);

        total += expenses[i]; // Add the expense to the total
    }

    printf(""\\nTotal expenses for the month: $%.2f\\n"", total);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  float v4[34]; // [rsp+20h] [rbp-90h] BYREF
  int i; // [rsp+A8h] [rbp-8h]
  float v6; // [rsp+ACh] [rbp-4h]

  _main(argc, argv, envp);
  v6 = 0.0;
  for ( i = 0; i <= 30; ++i )
  {
    printf(""Enter expenses for day %d: "", (unsigned int)(i + 1));
    scanf(""%f"", &v4[i]);
    v6 = v4[i] + v6;
  }
  printf(""\\nTotal expenses for the month: $%.2f\\n"", v6);
  return 0;
}
// 140001750: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type float var_90[34];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    float expenses[31];
    float total = 0;
    int i;

    for (i = 0; i < 31; i++) {
        printf(""Enter expenses for day %d: "", i+1);
        scanf(""%f"", &expenses[i]);
        total += expenses[i];
    }

    printf(""
Total expenses for the month: $%.2f
"", total);

    return 0;
}
// Code executed as C


// The C Programming Language
// Chapter 3. Expressions and Assignments
// Example 3.1

#include <stdio.h>

int main() {
    float expenses[31];
    float total = 0;
    int i;

    for (i = 0; i < 31; i++) {
        printf(""Enter expenses for day %d: "", i+1);
        scanf(""%f"", &expenses[i]);
        total += expenses[i];
    }

    printf(""
Total expenses for the month: $%.2f
"", total);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Online Examination System ; Style: configurable
#include<stdio.h>   // includes standard input and output functions
#include<stdlib.h>  // includes functions for dynamic memory allocation
#include<string.h>  // includes functions for string operations

// defining a structure for storing student record
struct student{
    char name[50];
    int rollno;
    int marks;
    char grade;
}stud[100];     // creating array of structure

int main(){
    int choice, n, i, j, roll, found, hmarks, lmarks, total, avgmarks;
    char ch, grade;

    do{
        printf(""\\n\\t\\t ONLINE EXAMINATION SYSTEM"");
        printf(""\\n\\t\\t -------------------------"");
        printf(""\\n\\n\\t 1. CREATE DATABASE OF STUDENTS"");
        printf(""\\n\\t 2. DISPLAY DATABASE"");
        printf(""\\n\\t 3. FIND STUDENT RECORD BY ROLL NUMBER"");
        printf(""\\n\\t 4. FIND HIGHEST AND LOWEST MARKS"");
        printf(""\\n\\t 5. FIND CLASS AVERAGE"");
        printf(""\\n\\t 6. EXIT FROM PROGRAM"");
        printf(""\\n\\n\\t Enter your choice: "");
        scanf(""%d"", &choice);

        switch(choice){
            case 1:         // to create database of students
                    printf(""\\n\\n\\t ENTER THE NUMBER OF STUDENTS: "");
                    scanf(""%d"", &n);

                    // input student details
                    for(i=0; i<n; i++){
                        printf(""\\n\\t ENTER THE DETAILS OF STUDENT %d:"", i+1);
                        printf(""\\n\\t NAME: "");
                        scanf(""%s"", stud[i].name);
                        printf(""\\n\\t ROLL NUMBER: "");
                        scanf(""%d"", &stud[i].rollno);
                        printf(""\\n\\t MARKS (out of 100): "");
                        scanf(""%d"", &stud[i].marks);
                        total += stud[i].marks;     // calculating total marks
                    }

                    avgmarks = total/n;     // calculating average marks
                    printf(""\\n\\n\\t DATABASE CREATED SUCCESSFULLY!"");
                    printf(""\\n\\t TOTAL STUDENTS: %d"", n);
                    printf(""\\n\\t TOTAL MARKS: %d"", total);
                    printf(""\\n\\t AVERAGE MARKS: %d"", avgmarks);
                    break;

            case 2:         // to display database of students
                    printf(""\\n\\n\\t STUDENT DATABASE"");
                    printf(""\\n\\t ----------------"");
                    printf(""\\n\\t NAME\\t\\tROLL NO\\tMARKS\\tGRADE"");
                    printf(""\\n\\t ----\\t\\t-------\\t-----\\t-----"");

                    // displaying student details
                    for(i=0; i<n; i++){
                        if(stud[i].marks >= 80)
                            grade = 'A';
                        else if(stud[i].marks >= 60)
                            grade = 'B';
                        else if(stud[i].marks >= 40)
                            grade = 'C';
                        else
                            grade = 'F';

                        printf(""\\n\\t %s\\t%d\\t%d\\t%c"", stud[i].name, stud[i].rollno, stud[i].marks, grade);
                    }
                    break;

            case 3:         // to search student record by roll number
                    printf(""\\n\\n\\t ENTER THE ROLL NUMBER TO SEARCH FOR: "");
                    scanf(""%d"", &roll);

                    // searching for student record
                    found = 0;
                    for(i=0; i<n; i++){
                        if(stud[i].rollno == roll){
                            printf(""\\n\\n\\t STUDENT RECORD FOUND!"");
                            printf(""\\n\\t NAME: %s"", stud[i].name);
                            printf(""\\n\\t ROLL NUMBER: %d"", stud[i].rollno);
                            printf(""\\n\\t MARKS: %d"", stud[i].marks);
                            found = 1;
                            break;
                        }
                    }

                    if(!found)
                        printf(""\\n\\n\\t STUDENT RECORD NOT FOUND!"");
                    break;

            case 4:         // to find highest and lowest marks
                    hmarks = stud[0].marks;
                    lmarks = stud[0].marks;
                    for(i=1; i<n; i++){
                        if(stud[i].marks > hmarks)
                            hmarks = stud[i].marks;     // new highest marks
                        if(stud[i].marks < lmarks)
                            lmarks = stud[i].marks;     // new lowest marks
                    }

                    printf(""\\n\\n\\t HIGHEST MARKS: %d"", hmarks);
                    printf(""\\n\\t LOWEST MARKS: %d"", lmarks);
                    break;

            case 5:         // to find class average
                    printf(""\\n\\n\\t CLASS AVERAGE: %d"", avgmarks);
                    break;

            case 6:         // to exit the program
                    printf(""\\n\\n\\t PRESS 'Y' TO CONFIRM EXIT: "");
                    scanf("" %c"", &ch);
                    if(ch == 'y' || ch == 'Y'){
                        printf(""\\n\\n\\t THANK YOU FOR USING ONLINE EXAMINATION SYSTEM!"");
                        exit(0);   // exit from program
                    }
                    break;

            default:        // to handle invalid input
                    printf(""\\n\\n\\t INVALID CHOICE! PLEASE CHOOSE AGAIN."");
        }
    }while(1);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN stud; // weak
_UNKNOWN unk_140019074; // weak
int dword_140019078[1586]; // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-40h]
  char v5; // [rsp+37h] [rbp-29h] BYREF
  int v6; // [rsp+38h] [rbp-28h] BYREF
  int v7; // [rsp+3Ch] [rbp-24h] BYREF
  int v8; // [rsp+40h] [rbp-20h] BYREF
  char v9; // [rsp+47h] [rbp-19h]
  unsigned int v10; // [rsp+48h] [rbp-18h]
  unsigned int v11; // [rsp+4Ch] [rbp-14h]
  unsigned int v12; // [rsp+50h] [rbp-10h]
  unsigned int v13; // [rsp+54h] [rbp-Ch]
  int v14; // [rsp+58h] [rbp-8h]
  int i; // [rsp+5Ch] [rbp-4h]

  _main(argc, argv, envp);
  while ( 1 )
  {
    printf(""\\n\\t\\t ONLINE EXAMINATION SYSTEM"");
    printf(""\\n\\t\\t -------------------------"");
    printf(""\\n\\n\\t 1. CREATE DATABASE OF STUDENTS"");
    printf(""\\n\\t 2. DISPLAY DATABASE"");
    printf(""\\n\\t 3. FIND STUDENT RECORD BY ROLL NUMBER"");
    printf(""\\n\\t 4. FIND HIGHEST AND LOWEST MARKS"");
    printf(""\\n\\t 5. FIND CLASS AVERAGE"");
    printf(""\\n\\t 6. EXIT FROM PROGRAM"");
    printf(""\\n\\n\\t Enter your choice: "");
    scanf(""%d"", &v8);
    switch ( v8 )
    {
      case 1:
        printf(""\\n\\n\\t ENTER THE NUMBER OF STUDENTS: "");
        scanf(""%d"", &v7);
        for ( i = 0; i < v7; ++i )
        {
          printf(""\\n\\t ENTER THE DETAILS OF STUDENT %d:"", (unsigned int)(i + 1));
          printf(""\\n\\t NAME: "");
          scanf(""%s"", (char *)&stud + 64 * (__int64)i);
          printf(""\\n\\t ROLL NUMBER: "");
          scanf(""%d"", (char *)&stud + 64 * (__int64)i + 52);
          printf(""\\n\\t MARKS (out of 100): "");
          scanf(""%d"", (char *)&stud + 64 * (__int64)i + 56);
          v11 += dword_140019078[16 * (__int64)i];
        }
        v10 = (int)v11 / v7;
        printf(""\\n\\n\\t DATABASE CREATED SUCCESSFULLY!"");
        printf(""\\n\\t TOTAL STUDENTS: %d"", (unsigned int)v7);
        printf(""\\n\\t TOTAL MARKS: %d"", v11);
        printf(""\\n\\t AVERAGE MARKS: %d"", v10);
        continue;
      case 2:
        printf(""\\n\\n\\t STUDENT DATABASE"");
        printf(""\\n\\t ----------------"");
        printf(""\\n\\t NAME\\t\\tROLL NO\\tMARKS\\tGRADE"");
        printf(""\\n\\t ----\\t\\t-------\\t-----\\t-----"");
        for ( i = 0; i < v7; ++i )
        {
          if ( dword_140019078[16 * (__int64)i] <= 79 )
          {
            if ( dword_140019078[16 * (__int64)i] <= 59 )
            {
              if ( dword_140019078[16 * (__int64)i] <= 39 )
                v9 = 70;
              else
                v9 = 67;
            }
            else
            {
              v9 = 66;
            }
          }
          else
          {
            v9 = 65;
          }
          LODWORD(v4) = v9;
          printf(
            ""\\n\\t %s\\t%d\\t%d\\t%c"",
            (const char *)&stud + 64 * (__int64)i,
            *((unsigned int *)&unk_140019074 + 16 * (__int64)i),
            (unsigned int)dword_140019078[16 * (__int64)i],
            v4);
        }
        continue;
      case 3:
        printf(""\\n\\n\\t ENTER THE ROLL NUMBER TO SEARCH FOR: "");
        scanf(""%d"", &v6);
        v14 = 0;
        i = 0;
        break;
      case 4:
        v13 = dword_140019078[0];
        v12 = dword_140019078[0];
        for ( i = 1; i < v7; ++i )
        {
          if ( (int)v13 < dword_140019078[16 * (__int64)i] )
            v13 = dword_140019078[16 * (__int64)i];
          if ( (int)v12 > dword_140019078[16 * (__int64)i] )
            v12 = dword_140019078[16 * (__int64)i];
        }
        printf(""\\n\\n\\t HIGHEST MARKS: %d"", v13);
        printf(""\\n\\t LOWEST MARKS: %d"", v12);
        continue;
      case 5:
        printf(""\\n\\n\\t CLASS AVERAGE: %d"", v10);
        continue;
      case 6:
        printf(""\\n\\n\\t PRESS 'Y' TO CONFIRM EXIT: "");
        scanf("" %c"", &v5);
        if ( v5 == 121 || v5 == 89 )
        {
          printf(""\\n\\n\\t THANK YOU FOR USING ONLINE EXAMINATION SYSTEM!"");
          exit(0);
        }
        continue;
      default:
        printf(""\\n\\n\\t INVALID CHOICE! PLEASE CHOOSE AGAIN."");
        continue;
    }
    while ( 1 )
    {
      if ( i >= v7 )
        goto LABEL_23;
      if ( *((_DWORD *)&unk_140019074 + 16 * (__int64)i) == v6 )
        break;
      ++i;
    }
    printf(""\\n\\n\\t STUDENT RECORD FOUND!"");
    printf(""\\n\\t NAME: %s"", (const char *)&stud + 64 * (__int64)i);
    printf(""\\n\\t ROLL NUMBER: %d"", *((unsigned int *)&unk_140019074 + 16 * (__int64)i));
    printf(""\\n\\t MARKS: %d"", (unsigned int)dword_140019078[16 * (__int64)i]);
    v14 = 1;
LABEL_23:
    if ( !v14 )
      printf(""\\n\\n\\t STUDENT RECORD NOT FOUND!"");
  }
}
// 140001943: variable 'v4' is possibly undefined
// 140001C60: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 140019078: using guessed type int dword_140019078[1586];
// 1400015E2: using guessed type int var_20;

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include<stdio.h>
#include<stdlib.h>
#include<string.h>

struct student{
    char name[50];
    int roll_no;
    int marks;
};

int main(){
    int choice, i, n, j, sum=0, average;
    char grade;
    struct student stud[100];
    
    while(1){
        printf(""\\n\\t\\t ONLINE EXAMINATION SYSTEM"");
        printf(""\\n\\t\\t -------------------------"");
        printf(""\\n\\n\\t 1. CREATE DATABASE OF STUDENTS"");
        printf(""\\n\\t 2. DISPLAY DATABASE"");
        printf(""\\n\\t 3. FIND STUDENT RECORD BY ROLL NUMBER"");
        printf(""\\n\\t 4. FIND HIGHEST AND LOWEST MARKS"");
        printf(""\\n\\t 5. FIND CLASS AVERAGE"");
        printf(""\\n\\t 6. EXIT FROM PROGRAM"");
        printf(""\\n\\n\\t Enter your choice: "");
        scanf(""%d"", &choice);
        
        switch(choice){
            case 1:
                printf(""\\n\\n\\t ENTER THE NUMBER OF STUDENTS: "");
                scanf(""%d"", &n);
                
                for(i=0; i<n; i++){
                    printf(""\\n\\t ENTER THE DETAILS OF STUDENT %d:"", i+1);
                    printf(""\\n\\t NAME: "");
                    scanf(""%s"", stud[i].name);
                    printf(""\\n\\t ROLL NUMBER: "");
                    scanf(""%d"", &stud[i].roll_no);
                    printf(""\\n\\t MARKS (out of 100): "");
                    scanf(""%d"", &stud[i].marks);
                    sum += stud[i].marks;
                }
                
                average = sum/n;
                
                printf(""\\n\\n\\t DATABASE CREATED SUCCESSFULLY!"");
                printf(""\\n\\t TOTAL STUDENTS: %d"", n);
                printf(""\\n\\t TOTAL MARKS: %d"", sum);
                printf(""\\n\\t AVERAGE MARKS: %d"", average);
                break;
            
            case 2:
                printf(""\\n\\n\\t STUDENT DATABASE"");
                printf(""\\n\\t ----------------"");
                printf(""\\n\\t NAME\\t\\tROLL NO\\tMARKS\\tGRADE"");
                printf(""\\n\\t ----\\t\\t-------\\t-----\\t-----"");
                
                for(i=0; i<n; i++){
                    if(stud[i].marks >= 80){
                        grade = 'A';
                    }
                    else if(stud[i].marks >= 60){
                        grade = 'B';
                    }
                    else if(stud[i].marks >= 50){
                        grade = 'C';
                    }
                    else if(stud[i].marks >= 40){
                        grade = 'D';
                    }
                    else{
                        grade = 'F';
                    }
                    
                    printf(""\\n\\t %s\\t%d\\t%d\\t%c"", stud[i].name, stud[i].roll_no, stud[i].marks, grade);
                }
                break;
            
            case 3:
                printf(""\\n\\n\\t ENTER THE ROLL NUMBER TO SEARCH FOR: "");
                scanf(""%d"", &j);
                
                int found = 0;
                
                for(i=0; i<n; i++){
                    if(stud[i].roll_no == j){
                        printf(""\\n\\n\\t STUDENT RECORD FOUND!"");
                        printf(""\\n\\t NAME: %s"", stud[i].name);",2
"//FormAI DATASET v1.0 Category: Image compression ; Style: active
#include <stdio.h>
#include <stdlib.h>

// Global variables
int width, height, bpp, compression_ratio;

// Function to calculate the compression ratio
void calculate_compression_ratio(int original_size, int compressed_size) {
    float ratio = ((float)compressed_size / (float)original_size) * 100;
    compression_ratio = 100 - (int)ratio;
}

int main() {

    // Read the input image file
    FILE *input_file = fopen(""input_image.raw"", ""rb"");
    if (input_file == NULL) {
        printf(""Error: Could not open input file!\\n"");
        return 0;
    }

    // Read the header information from the image file
    fread(&width, sizeof(int), 1, input_file);
    fread(&height, sizeof(int), 1, input_file);
    fread(&bpp, sizeof(int), 1, input_file);

    // Calculate the size of the image data
    int image_data_size = width * height * bpp;

    // Allocate memory to store the uncompressed image data
    unsigned char *image_data = (unsigned char*)malloc(image_data_size);

    // Read the uncompressed image data from the file
    fread(image_data, sizeof(unsigned char), image_data_size, input_file);

    // Calculate the original size of the image
    int original_size = ftell(input_file);

    // Close the input file
    fclose(input_file);

    // Perform image compression using any compression algorithm of your choice here

    // ...

    // Calculate the compressed size of the image data
    int compressed_size = image_data_size / 2;

    // Calculate the compression ratio
    calculate_compression_ratio(original_size, compressed_size);

    // Write the compressed image data to a new file
    FILE *output_file = fopen(""compressed_image.raw"", ""wb"");
    if (output_file == NULL) {
        printf(""Error: Could not create output file!\\n"");
        return 0;
    }

    // Write the header information to the output file
    fwrite(&width, sizeof(int), 1, output_file);
    fwrite(&height, sizeof(int), 1, output_file);
    fwrite(&bpp, sizeof(int), 1, output_file);

    // Write the compressed image data to the file
    fwrite(image_data, sizeof(unsigned char), compressed_size, output_file);

    // Close the output file
    fclose(output_file);

    // Free the memory allocated for the uncompressed image data
    free(image_data);

    // Print the compression ratio
    printf(""Image compression completed successfully!\\n"");
    printf(""Compression ratio: %d%%\\n"", compression_ratio);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
__int64 __fastcall calculate_compression_ratio(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void *__cdecl malloc(size_t Size);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// int __cdecl ftell(FILE *Stream);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);

//-------------------------------------------------------------------------
// Data declarations

int width; // weak
int height; // weak
int bpp; // weak
int compression_ratio; // weak


//----- (00000001400015E6) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  FILE *v4; // [rsp+28h] [rbp-28h]
  unsigned int v5; // [rsp+34h] [rbp-1Ch]
  void *Buffer; // [rsp+38h] [rbp-18h]
  int v7; // [rsp+44h] [rbp-Ch]
  FILE *Stream; // [rsp+48h] [rbp-8h]

  _main(argc, argv, envp);
  Stream = fopen(""input_image.raw"", ""rb"");
  if ( Stream )
  {
    fread(&width, 4ui64, 1ui64, Stream);
    fread(&height, 4ui64, 1ui64, Stream);
    fread(&bpp, 4ui64, 1ui64, Stream);
    v7 = height * width * bpp;
    Buffer = malloc(v7);
    fread(Buffer, 1ui64, v7, Stream);
    v5 = ftell(Stream);
    fclose(Stream);
    calculate_compression_ratio(v5, (unsigned int)(v7 / 2));
    v4 = fopen(""compressed_image.raw"", ""wb"");
    if ( v4 )
    {
      fwrite(&width, 4ui64, 1ui64, v4);
      fwrite(&height, 4ui64, 1ui64, v4);
      fwrite(&bpp, 4ui64, 1ui64, v4);
      fwrite(Buffer, 1ui64, v7 / 2, v4);
      fclose(v4);
      free(Buffer);
      printf(""Image compression completed successfully!\\n"");
      printf(""Compression ratio: %d%%\\n"", (unsigned int)compression_ratio);
    }
    else
    {
      printf(""Error: Could not create output file!\\n"");
    }
    return 0;
  }
  else
  {
    printf(""Error: Could not open input file!\\n"");
    return 0;
  }
}
// 140001591: using guessed type __int64 __fastcall calculate_compression_ratio(_QWORD, _QWORD);
// 1400018E0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 14000F040: using guessed type int width;
// 14000F044: using guessed type int height;
// 14000F048: using guessed type int bpp;
// 14000F04C: using guessed type int compression_ratio;

// nfuncs=142 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>

int width, height, bpp;
int compression_ratio;

void calculate_compression_ratio(int original_size, int compressed_size) {
    compression_ratio = (int)((float)original_size / compressed_size * 100);
}

int main() {
    FILE *input_file, *output_file;
    int original_size, compressed_size;
    unsigned char *image_data;

    // Open input file
    input_file = fopen(""input_image.raw"", ""rb"");
    if (input_file == NULL) {
        printf(""Error: Could not open input file!
"");
        return 0;
    }

    // Read image dimensions
    fread(&width, sizeof(int), 1, input_file);
    fread(&height, sizeof(int), 1, input_file);
    fread(&bpp, sizeof(int), 1, input_file);

    // Calculate original size
    original_size = width * height * bpp;

    // Allocate memory for image data
    image_data = (unsigned char*)malloc(original_size);

    // Read image data
    fread(image_data, sizeof(unsigned char), original_size, input_file);

    // Calculate compressed size
    compressed_size = ftell(input_file);

    // Close input file
    fclose(input_file);

    // Calculate compression ratio
    calculate_compression_ratio(original_size, compressed_size);

    // Open output file
    output_file = fopen(""compressed_image.raw"", ""wb"");
    if (output_file == NULL) {
        printf(""Error: Could not create output file!
"");
        return 0;
    }

    // Write image dimensions
    fwrite(&width, sizeof(int), 1, output_file);
    fwrite(&height, sizeof(int), 1, output_file);
    fwrite(&bpp, sizeof(int), 1, output_file);

    // Write compressed image data
    fwrite(image_data, sizeof(unsigned char), original_size / 2, output_file);

    // Close output file
    fclose(output_file);

    // Free memory
    free(image_data);

    printf(""Image compression completed successfully!
"");
    printf(""Compression ratio: %d%%
"", compression_ratio);

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Music Library Management System ; Style: innovative
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

typedef struct Song {
    char title[50];
    char artist[50];
    char album[50];
    int year;
} Song;

typedef struct Node {
    Song data;
    struct Node *next;
} Node;

Node *head = NULL;

void add_song() {
    Song song;
    printf(""\\nEnter details of the song\\n\\n"");
    printf(""Title: "");
    scanf(""%s"", song.title);
    printf(""Artist: "");
    scanf(""%s"", song.artist);
    printf(""Album: "");
    scanf(""%s"", song.album);
    printf(""Year: "");
    scanf(""%d"", &song.year);

    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->data = song;
    new_node->next = NULL;

    if (head == NULL) {
        head = new_node;
    } else {
        Node *current = head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = new_node;
    }

    printf(""\\nSong added successfully!\\n"");
}

void search_song() {
    char title[50];
    printf(""\\nEnter the title of the song: "");
    scanf(""%s"", title);

    Node *current = head;
    int found = 0;
    while (current != NULL) {
        if (strcmp(current->data.title, title) == 0) {
            found = 1;
            printf(""\\nFound the following song:\\n\\n"");
            printf(""Title: %s\\n"", current->data.title);
            printf(""Artist: %s\\n"", current->data.artist);
            printf(""Album: %s\\n"", current->data.album);
            printf(""Year: %d\\n"", current->data.year);
        }
        current = current->next;
    }

    if (!found) {
        printf(""\\nSong not found!\\n"");
    }
}

void display_songs() {
    if (head == NULL) {
        printf(""\\nNo songs in the library!\\n"");
    } else {
        Node *current = head;
        printf(""\\nSongs in the library:\\n\\n"");
        while (current != NULL) {
            printf(""Title: %s\\n"", current->data.title);
            printf(""Artist: %s\\n"", current->data.artist);
            printf(""Album: %s\\n"", current->data.album);
            printf(""Year: %d\\n\\n"", current->data.year);
            current = current->next;
        }
    }
}

void delete_song() {
    if (head == NULL) {
        printf(""\\nNo songs in the library!\\n"");
        return;
    }

    char title[50];
    printf(""\\nEnter the title of the song to be deleted: "");
    scanf(""%s"", title);

    Node *current = head;
    Node *prev = NULL;
    int found = 0;
    while (current != NULL) {
        if (strcmp(current->data.title, title) == 0) {
            found = 1;
            if (current == head) {
                head = head->next;
            } else {
                prev->next = current->next;
            }
            free(current);
            printf(""\\nSong deleted successfully!\\n"");
            break;
        }
        prev = current;
        current = current->next;
    }

    if (!found) {
        printf(""\\nSong not found!\\n"");
    }
}

void menu() {
    printf(""\\nMusic Library Management System\\n"");
    printf(""------------------------------\\n"");
    printf(""1. Add song\\n"");
    printf(""2. Search song\\n"");
    printf(""3. Display songs\\n"");
    printf(""4. Delete song\\n"");
    printf(""5. Exit\\n"");
    printf(""------------------------------\\n"");
    printf(""Enter your choice: "");
}

int main() {
    int choice;
    do {
        menu();
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                add_song();
                break;
            case 2:
                search_song();
                break;
            case 3:
                display_songs();
                break;
            case 4:
                delete_song();
                break;
            case 5:
                printf(""\\nExiting program. Goodbye!\\n"");
                exit(0);
            default:
                printf(""\\nEnter a valid choice!\\n"");
        }
    } while (1);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 add_song(void); // weak
__int64 search_song(void); // weak
__int64 display_songs(void); // weak
__int64 delete_song(void); // weak
__int64 menu(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B7B) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+2Ch] [rbp-4h] BYREF

  _main(argc, argv, envp);
  while ( 1 )
  {
    menu();
    scanf(""%d"", &v4);
    switch ( v4 )
    {
      case 1:
        add_song();
        break;
      case 2:
        search_song();
        break;
      case 3:
        display_songs();
        break;
      case 4:
        delete_song();
        break;
      case 5:
        printf(""\\nExiting program. Goodbye!\\n"");
        exit(0);
      default:
        printf(""\\nEnter a valid choice!\\n"");
        break;
    }
  }
}
// 1400015E2: using guessed type __int64 add_song(void);
// 1400017FA: using guessed type __int64 search_song(void);
// 140001903: using guessed type __int64 display_songs(void);
// 1400019C9: using guessed type __int64 delete_song(void);
// 140001AE5: using guessed type __int64 menu(void);
// 140001CD0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum number of songs in the library
#define MAX_SONGS 100

// Define the maximum length of the song title
#define MAX_TITLE_LENGTH 50

// Define the maximum length of the artist name
#define MAX_ARTIST_LENGTH 30

// Define the maximum length of the album name
#define MAX_ALBUM_LENGTH 20

// Define the maximum length of the genre
#define MAX_GENRE_LENGTH 15

// Define the maximum length of the year
#define MAX_YEAR_LENGTH 4

// Define the maximum length of the comment
#define MAX_COMMENT_LENGTH 100

// Define the structure for a song
typedef struct {
    char title[MAX_TITLE_LENGTH];
    char artist[MAX_ARTIST_LENGTH];
    char album[MAX_ALBUM_LENGTH];
    char genre[MAX_GENRE_LENGTH];
    int year;
    char comment[MAX_COMMENT_LENGTH];
} Song;

// Define the structure for the library
typedef struct {
    Song songs[MAX_SONGS];
    int num_songs;
} Library;

// Function to add a song to the library
void add_song() {
    Library *library = (Library *) malloc(sizeof(Library));
    if (library == NULL) {
        printf(""
Error: Memory allocation failed!
"");
        return;
    }
    
    // Check if the library is empty
    if (library->num_songs == 0) {
        // Initialize the library
        library->num_songs = 1;
        strcpy(library->songs[0].title, """");
        strcpy(library->songs[0].artist, """");
        strcpy(library->songs[0].album, """");
        strcpy(library->songs[0].genre, """");
        library->songs[0].year = 0;
        strcpy(library->songs[0].comment, """");
    } else {
        // Check if the library is full
        if (library->num_songs == MAX_SONGS) {
            printf(""
Error: Library is full!
"");
            return;
        }
        
        // Increment the number of songs in the library
        library->num_songs++;
    }
    
    // Get the song details from the user
    printf(""
Enter the song title: "");
    scanf(""%s"", library->songs[library->num_songs-1].title);
    printf(""Enter the artist name: "");
    scanf(""%s"", library->songs[library->num_songs-1].artist);
    printf(""Enter the album name: "");
    scanf(""%s"", library->songs[library->num_songs-1].album);
    printf(""Enter the genre: "");
    scanf(""%s"", library->songs[library->num_songs-1].genre);
    printf(""Enter the year: "");
    scanf(""%d"", &library->songs[library->num_songs-1].year);
    printf(""Enter a comment: "");
    scanf(""%s"", library->songs[library->num_songs-1].comment);
    
    // Display the song details
    printf(""
Song added successfully!
"");
    printf(""Title: %s
"", library->songs[library->num_songs-1].title);
    printf(""Artist: %s
"", library->songs[library->num_songs-1].artist);
    printf(""Album: %s
"", library->songs[library->num_songs-1].album);
    printf(""Genre: %s
"", library->songs[library->num_songs-1].genre);",1
"//FormAI DATASET v1.0 Category: Cat Language Translator ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char input[100], output[1000] = """";

    printf(""Welcome to the C Cat Language Translator! Meow!\\n"");
    printf(""Please input your sentence: "");
    scanf(""%[^\\n]"", input);

    strcat(output, ""Meow! "");

    for(int i=0; i<strlen(input); i++)
    {
        switch(input[i])
        {
            case ' ': strcat(output, "" Meow!""); break;
            case 'a': strcat(output, "" meow""); break;
            case 'b': strcat(output, "" meooow""); break;
            case 'c': strcat(output, "" meoooww""); break;
            // more cases for the rest of the alphabet
            default: strcat(output, "" meoooooooow""); break;
        }
    }

    strcat(output, "" Meow!"");

    printf(""%s\\n"", output);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// size_t __cdecl strlen(const char *Str);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char Str[1008]; // [rsp+20h] [rbp-60h] BYREF
  char v6[108]; // [rsp+410h] [rbp+390h] BYREF
  int i; // [rsp+47Ch] [rbp+3FCh]

  _main(argc, argv, envp);
  memset(Str, 0, 1000);
  printf(""Welcome to the C Cat Language Translator! Meow!\\n"");
  printf(""Please input your sentence: "");
  scanf(""%[^\\n]"", v6);
  strcat(Str, ""Meow! "");
  for ( i = 0; i < strlen(v6); ++i )
  {
    v3 = v6[i];
    if ( v3 == 99 )
    {
      strcat(Str, "" meoooww"");
    }
    else
    {
      if ( v3 <= 99 )
      {
        switch ( v3 )
        {
          case 'b':
            *(_QWORD *)&Str[strlen(Str)] = 0x776F6F6F656D20i64;
            continue;
          case ' ':
            strcat(Str, "" Meow!"");
            continue;
          case 'a':
            strcat(Str, "" meow"");
            continue;
        }
      }
      strcat(Str, "" meoooooooow"");
    }
  }
  strcat(Str, "" Meow!"");
  printf(""%s\\n"", Str);
  return 0;
}
// 1400016B6: conditional instruction was optimized away because eax.4 is in (<62u|>=FFFFFF80u)
// 1400018C0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);
// 1400015E2: using guessed type char var_80[108];

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <string.h>

int main() {
    char input[100];
    char output[1000] = """";
    
    printf(""Welcome to the C Cat Language Translator! Meow!
"");
    printf(""Please input your sentence: "");
    scanf(""%[^
]"", input);
    
    strcat(output, ""Meow! "");
    
    for (int i = 0; i < strlen(input); i++) {
        switch (input[i]) {
            case 'a':
                strcat(output, "" meow"");
                break;
            case 'b':
                strcat(output, "" meoooww"");
                break;
            case 'c':
                strcat(output, "" meooooooow"");
                break;
            case ' ':
                strcat(output, "" Meow!"");
                break;
            default:
                strcat(output, "" meooooooow"");
                break;
        }
    }
    
    strcat(output, "" Meow!"");
    
    printf(""%s
"", output);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Product Inventory System ; Style: dynamic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Struct to hold product information
typedef struct product {
    char name[50];
    int quantity;
    double price;
} product;

// Function to add new product to inventory
void add_product(product** inventory, int* num_products) {
    // Reallocate memory for new product
    *inventory = realloc(*inventory, (*num_products + 1) * sizeof(product));
    printf(""\\nEnter the product name: "");
    scanf(""%s"", (*inventory + *num_products)->name);
    printf(""\\nEnter the product quantity: "");
    scanf(""%d"", &((*inventory + *num_products)->quantity));
    printf(""\\nEnter the product price: "");
    scanf(""%lf"", &((*inventory + *num_products)->price));
    // Increase number of products by 1
    *num_products += 1;
}

// Function to remove a product from inventory
void remove_product(product** inventory, int* num_products) {
    char product_name[50];
    int found = 0;
    printf(""\\nEnter the name of the product to remove: "");
    scanf(""%s"", product_name);
    for (int i = 0; i < *num_products; i++) {
        if (strcmp(((*inventory) + i)->name, product_name) == 0) {
            // Shift memory to remove product
            memmove((*inventory) + i, (*inventory) + i + 1, (*num_products - i - 1) * sizeof(product));
            found = 1;
            // Decrease number of products by 1
            *num_products -= 1;
            // Reallocate memory for new size
            *inventory = realloc(*inventory, *num_products * sizeof(product));
            printf(""\\nProduct removed successfully!\\n"");
            break;
        }
    }
    if (!found) {
        printf(""\\nProduct not found.\\n"");
    }
}

// Function to display current inventory
void display_inventory(product* inventory, int num_products) {
    printf(""\\n%-20s %-15s %-10s\\n"", ""Product Name"", ""Quantity"", ""Price"");
    for (int i = 0; i < num_products; i++) {
        printf(""%-20s %-15d $%.2lf\\n"", (inventory + i)->name, (inventory + i)->quantity, (inventory + i)->price);
    }
}

int main() {
    product* inventory = NULL;
    int num_products = 0;
    int choice;

    do {
        printf(""\\n===== Product Inventory System =====\\n"");
        printf(""1. Add Product\\n"");
        printf(""2. Remove Product\\n"");
        printf(""3. Display Inventory\\n"");
        printf(""4. Exit\\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                add_product(&inventory, &num_products);
                break;
            case 2:
                remove_product(&inventory, &num_products);
                break;
            case 3:
                display_inventory(inventory, num_products);
                break;
            case 4:
                printf(""\\nGoodbye!\\n"");
                break;
            default:
                printf(""\\nInvalid choice.\\n"");
                break;
        }
    } while (choice != 4);

    // Free allocated memory
    free(inventory);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall add_product(_QWORD, _QWORD); // weak
__int64 __fastcall remove_product(_QWORD, _QWORD); // weak
__int64 __fastcall display_inventory(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl free(void *Block);


//----- (00000001400018D4) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+20h] [rbp-10h] BYREF
  unsigned int v5; // [rsp+24h] [rbp-Ch] BYREF
  void *Block; // [rsp+28h] [rbp-8h] BYREF

  _main(argc, argv, envp);
  Block = 0i64;
  v5 = 0;
  do
  {
    printf(""\\n===== Product Inventory System =====\\n"");
    printf(""1. Add Product\\n"");
    printf(""2. Remove Product\\n"");
    printf(""3. Display Inventory\\n"");
    printf(""4. Exit\\n"");
    printf(""Enter your choice: "");
    scanf(""%d"", &v4);
    if ( v4 == 4 )
    {
      printf(""\\nGoodbye!\\n"");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            display_inventory(Block, v5);
            continue;
          case 1:
            add_product(&Block, &v5);
            continue;
          case 2:
            remove_product(&Block, &v5);
            continue;
        }
      }
      printf(""\\nInvalid choice.\\n"");
    }
  }
  while ( v4 != 4 );
  free(Block);
  return 0;
}
// 140001975: conditional instruction was optimized away because %var_10.4<3
// 1400015E2: using guessed type __int64 __fastcall add_product(_QWORD, _QWORD);
// 1400016DD: using guessed type __int64 __fastcall remove_product(_QWORD, _QWORD);
// 140001814: using guessed type __int64 __fastcall display_inventory(_QWORD, _QWORD);
// 140001AB0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum number of products
#define MAX_PRODUCTS 100

// Define the maximum length of product name
#define MAX_NAME_LENGTH 50

// Define the product structure
typedef struct {
    char name[MAX_NAME_LENGTH];
    int quantity;
} Product;

// Function to add a product to the inventory
void add_product(Product **inventory, int *num_products) {
    // Check if the inventory is full
    if (*num_products == MAX_PRODUCTS) {
        printf(""
Inventory is full.
"");
        return;
    }

    // Get the product name from the user
    printf(""
Enter product name: "");
    char name[MAX_NAME_LENGTH];
    scanf(""%s"", name);

    // Get the product quantity from the user
    printf(""Enter product quantity: "");
    int quantity;
    scanf(""%d"", &quantity);

    // Create a new product and add it to the inventory
    Product *new_product = (Product*) malloc(sizeof(Product));
    strcpy(new_product->name, name);
    new_product->quantity = quantity;
    inventory[*num_products] = new_product;
    (*num_products)++;

    printf(""
Product added to inventory.
"");
}

// Function to remove a product from the inventory
void remove_product(Product **inventory, int *num_products) {
    // Check if the inventory is empty
    if (*num_products == 0) {
        printf(""
Inventory is empty.
"");
        return;
    }

    // Get the product name from the user
    printf(""
Enter product name: "");
    char name[MAX_NAME_LENGTH];
    scanf(""%s"", name);

    // Find the product in the inventory
    int i;
    for (i = 0; i < *num_products; i++) {
        if (strcmp(inventory[i]->name, name) == 0) {
            break;
        }
    }

    // Check if the product was found
    if (i == *num_products) {
        printf(""
Product not found.
"");
        return;
    }

    // Remove the product from the inventory
    for (int j = i; j < *num_products - 1; j++) {
        inventory[j] = inventory[j+1];
    }
    (*num_products)--;

    printf(""
Product removed from inventory.
"");
}

// Function to display the inventory
void display_inventory(Product **inventory, int num_products) {
    // Check if the inventory is empty
    if (num_products == 0) {
        printf(""
Inventory is empty.
"");
        return;
    }

    // Display the inventory
    printf(""
Inventory:
"");
    for (int i = 0; i < num_products; i++) {
        printf(""%s - %d
"", inventory[i]->name, inventory[i]->quantity);
    }
}

int main() {
    // Initialize the inventory
    Product *inventory[MAX_PRODUCTS] = {NULL};
    int num_products = 0;

    // Loop until the user chooses to exit
    int choice;
    do {
        printf(""
===== Product Inventory System =====
"");
        printf(""1. Add Product
"");
        printf(""2. Remove Product
"");
        printf(""3. Display Inventory
"");
        printf(""4. Exit
"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                add_product(&inventory,",2
"//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: light-weight
#include <stdio.h>
#include <string.h>

/* Define the maximum storage capacity of the warehouse */
#define MAX_CAPACITY 100

/* Define the data structure for each item in the warehouse */
typedef struct {
    char name[20];
    int quantity;
} Item;

/* Define the array to store the items in the warehouse */
Item items[MAX_CAPACITY];

/* Define the number of items currently stored in the warehouse */
int numItems = 0;

/* Define a function to add an item to the warehouse */
void addItem(char* name, int quantity) {
    /* Check if the warehouse is already at maximum capacity */
    if (numItems >= MAX_CAPACITY) {
        printf(""Warehouse is already at maximum capacity.\\n"");
        return;
    }

    /* Check if the item already exists in the warehouse */
    for (int i = 0; i < numItems; i++) {
        if (strcmp(name, items[i].name) == 0) {
            items[i].quantity += quantity;
            printf(""%d units of %s added to warehouse.\\n"", quantity, name);
            return;
        }
    }

    /* Add the new item to the warehouse */
    strcpy(items[numItems].name, name);
    items[numItems].quantity = quantity;
    numItems++;
    printf(""%d units of %s added to warehouse.\\n"", quantity, name);
}

/* Define a function to remove an item from the warehouse */
void removeItem(char* name, int quantity) {
    /* Check if the item exists in the warehouse */
    for (int i = 0; i < numItems; i++) {
        if (strcmp(name, items[i].name) == 0) {
            /* Check if there is enough quantity to remove */
            if (items[i].quantity >= quantity) {
                items[i].quantity -= quantity;
                printf(""%d units of %s removed from warehouse.\\n"", quantity, name);
                return;
            } else {
                printf(""Not enough %s in warehouse to remove %d units.\\n"", name, quantity);
                return;
            }
        }
    }

    /* If item is not found in the warehouse */
    printf(""%s is not found in warehouse.\\n"", name);
}

/* Define a function to display the current status of the warehouse */
void displayStatus() {
    printf(""Warehouse Status:\\n"");
    printf(""------------------\\n"");

    /* Display item name and quantity for each item in warehouse */
    for (int i = 0; i < numItems; i++) {
        printf(""%s: %d\\n"", items[i].name, items[i].quantity);
    }

    /* If warehouse is empty */
    if (numItems == 0) {
        printf(""Empty.\\n"");
    }

    printf(""------------------\\n"");
}

int main() {
    /* Menu-driven interface for warehouse management */
    char itemName[20];
    int itemQuantity;
    int choice;

    do {
        printf(""Warehouse Management System\\n"");
        printf(""---------------------------\\n"");
        printf(""1. Add item\\n"");
        printf(""2. Remove item\\n"");
        printf(""3. Display status\\n"");
        printf(""4. Exit\\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                printf(""Enter item name: "");
                scanf(""%s"", itemName);
                printf(""Enter quantity: "");
                scanf(""%d"", &itemQuantity);
                addItem(itemName, itemQuantity);
                break;
            case 2:
                printf(""Enter item name: "");
                scanf(""%s"", itemName);
                printf(""Enter quantity: "");
                scanf(""%d"", &itemQuantity);
                removeItem(itemName, itemQuantity);
                break;
            case 3:
                displayStatus();
                break;
            case 4:
                printf(""Exiting. Thank you!\\n"");
                break;
            default:
                printf(""Invalid choice. Try again.\\n"");
        }

        printf(""\\n"");
    } while (choice != 4);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall addItem(_QWORD, _QWORD); // weak
__int64 __fastcall removeItem(_QWORD, _QWORD); // weak
__int64 displayStatus(void); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (0000000140001916) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+28h] [rbp-28h] BYREF
  unsigned int v5; // [rsp+2Ch] [rbp-24h] BYREF
  char v6[32]; // [rsp+30h] [rbp-20h] BYREF

  _main(argc, argv, envp);
  do
  {
    printf(""Warehouse Management System\\n"");
    printf(""---------------------------\\n"");
    printf(""1. Add item\\n"");
    printf(""2. Remove item\\n"");
    printf(""3. Display status\\n"");
    printf(""4. Exit\\n"");
    printf(""Enter your choice: "");
    scanf(""%d"", &v4);
    if ( v4 == 4 )
    {
      printf(""Exiting. Thank you!\\n"");
    }
    else
    {
      if ( v4 <= 4 )
      {
        switch ( v4 )
        {
          case 3:
            displayStatus();
            goto LABEL_13;
          case 1:
            printf(""Enter item name: "");
            scanf(""%s"", v6);
            printf(""Enter quantity: "");
            scanf(""%d"", &v5);
            addItem(v6, v5);
            goto LABEL_13;
          case 2:
            printf(""Enter item name: "");
            scanf(""%s"", v6);
            printf(""Enter quantity: "");
            scanf(""%d"", &v5);
            removeItem(v6, v5);
            goto LABEL_13;
        }
      }
      printf(""Invalid choice. Try again.\\n"");
    }
LABEL_13:
    printf(""\\n"");
  }
  while ( v4 != 4 );
  return 0;
}
// 1400019C3: conditional instruction was optimized away because %var_28.4<3
// 1400015E2: using guessed type __int64 __fastcall addItem(_QWORD, _QWORD);
// 14000173F: using guessed type __int64 __fastcall removeItem(_QWORD, _QWORD);
// 140001857: using guessed type __int64 displayStatus(void);
// 140001B90: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=181 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_ITEMS 100

typedef struct {
    char name[20];
    int quantity;
} Item;

Item inventory[MAX_ITEMS];
int numItems = 0;

void addItem(char name[], int quantity) {
    if (numItems == MAX_ITEMS) {
        printf(""Sorry, inventory is full.
"");
        return;
    }
    Item newItem;
    strcpy(newItem.name, name);
    newItem.quantity = quantity;
    inventory[numItems++] = newItem;
    printf(""Item added to inventory.
"");
}

void removeItem(char name[], int quantity) {
    int i;
    for (i = 0; i < numItems; i++) {
        if (strcmp(inventory[i].name, name) == 0) {
            if (inventory[i].quantity < quantity) {
                printf(""Sorry, not enough items in inventory.
"");
                return;
            }
            inventory[i].quantity -= quantity;
            if (inventory[i].quantity == 0) {
                for (int j = i; j < numItems - 1; j++) {
                    inventory[j] = inventory[j+1];
                }
                numItems--;
            }
            printf(""Item removed from inventory.
"");
            return;
        }
    }
    printf(""Item not found in inventory.
"");
}

void displayStatus() {
    printf(""Inventory Status:
"");
    for (int i = 0; i < numItems; i++) {
        printf(""%s: %d
"", inventory[i].name, inventory[i].quantity);
    }
}

int main() {
    int choice;
    char name[20];
    int quantity;
    do {
        printf(""Warehouse Management System
"");
        printf(""---------------------------
"");
        printf(""1. Add item
"");
        printf(""2. Remove item
"");
        printf(""3. Display status
"");
        printf(""4. Exit
"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch (choice) {
            case 1:
                printf(""Enter item name: "");
                scanf(""%s"", name);
                printf(""Enter quantity: "");
                scanf(""%d"", &quantity);
                addItem(name, quantity);
                break;
            case 2:
                printf(""Enter item name: "");
                scanf(""%s"", name);
                printf(""Enter quantity: "");
                scanf(""%d"", &quantity);
                removeItem(name, quantity);
                break;
            case 3:
                displayStatus();
                break;
            case 4:
                printf(""Exiting. Thank you!
"");
                break;
            default:
                printf(""Invalid choice. Try again.
"");
        }
        printf(""
"");
    } while (choice != 4);
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: decentralized
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

// Structure to hold the details of the items ordered
typedef struct{
    char name[50];
    int price;
    int quantity;
}Item;

// Structure to hold the details of a customer
typedef struct{
    char name[50];
    Item order[10];
    int no_of_items;
    int total_price;
}Customer;

// Function to initialize a menu with some items
void initialize_menu(Item *menu){
    strcpy(menu[0].name, ""Coffee"");
    menu[0].price = 50;
    menu[0].quantity = 10;

    strcpy(menu[1].name, ""Tea"");
    menu[1].price = 30;
    menu[1].quantity = 20;

    strcpy(menu[2].name, ""Sandwich"");
    menu[2].price = 80;
    menu[2].quantity = 5;

    strcpy(menu[3].name, ""Burger"");
    menu[3].price = 120;
    menu[3].quantity = 8;
}

// Function to display the menu
void display_menu(Item *menu){
    printf(""\\nMenu:"");
    printf(""\\n------------------------------"");
    printf(""\\n| %-10s | %-10s | %-10s |"", ""Item"", ""Price"", ""Quantity"");
    printf(""\\n------------------------------"");
    for(int i=0; i<4; i++){
        printf(""\\n| %-10s | %-10d | %-10d |"", menu[i].name, menu[i].price, menu[i].quantity);
    }
    printf(""\\n------------------------------\\n"");
}

// Function to take the order of a customer and update the menu and total price of the customer
void take_order(Customer *customer, Item *menu){
    printf(""\\nEnter your name: "");
    scanf(""%s"", customer->name);

    char item[50];
    int found;
    do{
        found = 0;
        printf(""\\nEnter the name of the item you want to order (-1 to exit): "");
        scanf(""%s"", item);
        if(strcmp(item, ""-1"") != 0){
            for(int i=0; i<4; i++){
                if(strcmp(menu[i].name, item) == 0){
                    found = 1;
                    if(menu[i].quantity > 0){
                        strcpy(customer->order[customer->no_of_items].name, item);
                        customer->order[customer->no_of_items].price = menu[i].price;
                        customer->order[customer->no_of_items].quantity = 1;
                        customer->no_of_items++;
                        menu[i].quantity--;
                        customer->total_price += menu[i].price;
                        printf(""\\n%s added to your order!\\n"", item);
                    }
                    else{
                        printf(""\\nSorry, %s not available!\\n"", item);
                    }
                }
            }
            if(found == 0){
                printf(""\\nInvalid item name!\\n"");
            }
        }
    }while(strcmp(item, ""-1"") != 0);
}

// Function to display the order of a customer
void display_order(Customer *customer){
    printf(""\\nOrder details:"");
    printf(""\\nCustomer name: %s"", customer->name);
    printf(""\\n------------------------------"");
    printf(""\\n| %-10s | %-10s | %-10s |"", ""Item"", ""Price"", ""Quantity"");
    printf(""\\n------------------------------"");
    for(int i=0; i<customer->no_of_items; i++){
        printf(""\\n| %-10s | %-10d | %-10d |"", customer->order[i].name, customer->order[i].price, customer->order[i].quantity);
    }
    printf(""\\n------------------------------"");
    printf(""\\nTotal price: %d\\n"", customer->total_price);
}

int main(){
    Item menu[4];
    initialize_menu(menu);

    int choice;
    do{
        printf(""\\n1. Display Menu"");
        printf(""\\n2. Take Order"");
        printf(""\\n3. Display Order"");
        printf(""\\n4. Exit"");
        printf(""\\nEnter your choice: "");
        scanf(""%d"", &choice);

        switch(choice){
            case 1:
                display_menu(menu);
                break;

            case 2:
                Customer customer;
                take_order(&customer, menu);
                break;

            case 3:
                display_order(&customer);
                break;

            case 4:
                printf(""\\nThank you for visiting!"");
                exit(0);
                break;

            default:
                printf(""\\nInvalid choice!\\n"");
                break;
        }
    }while(1);

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
__int64 __fastcall initialize_menu(_QWORD); // weak
__int64 __fastcall display_menu(_QWORD); // weak
__int64 __fastcall take_order(_QWORD, _QWORD); // weak
__int64 __fastcall display_order(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001B86) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3[668]; // [rsp+20h] [rbp-60h] BYREF
  int v4; // [rsp+2BCh] [rbp+23Ch] BYREF
  char v5[240]; // [rsp+2C0h] [rbp+240h] BYREF

  _main(argc, argv, envp);
  initialize_menu(v5);
  while ( 1 )
  {
    printf(""\\n1. Display Menu"");
    printf(""\\n2. Take Order"");
    printf(""\\n3. Display Order"");
    printf(""\\n4. Exit"");
    printf(""\\nEnter your choice: "");
    scanf(""%d"", &v4);
    if ( v4 == 4 )
    {
      printf(""\\nThank you for visiting!"");
      exit(0);
    }
    if ( v4 > 4 )
    {
LABEL_12:
      printf(""\\nInvalid choice!\\n"");
    }
    else
    {
      switch ( v4 )
      {
        case 3:
          display_order(v3);
          break;
        case 1:
          display_menu(v5);
          break;
        case 2:
          take_order(v3, v5);
          break;
        default:
          goto LABEL_12;
      }
    }
  }
}
// 140001C26: conditional instruction was optimized away because %var_F4.4<3
// 1400015E2: using guessed type __int64 __fastcall initialize_menu(_QWORD);
// 1400016B6: using guessed type __int64 __fastcall display_menu(_QWORD);
// 1400017BC: using guessed type __int64 __fastcall take_order(_QWORD, _QWORD);
// 140001A3E: using guessed type __int64 __fastcall display_order(_QWORD);
// 140001D50: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=182 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
"," C Program to simulate a Cafe Menu

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the maximum number of items in the menu
#define MAX_ITEMS 10

// Define the maximum length of the item name
#define MAX_NAME_LENGTH 20

// Define the maximum length of the item description
#define MAX_DESCRIPTION_LENGTH 50

// Define the maximum length of the item price
#define MAX_PRICE_LENGTH 10

// Define the maximum length of the item quantity
#define MAX_QUANTITY_LENGTH 5

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item type
#define MAX_TYPE_LENGTH 10

// Define the maximum length of the item category
#define MAX_CATEGORY_LENGTH 10

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define MAX_TOTAL_LENGTH 15

// Define the maximum length of the item discount
#define MAX_DISCOUNT_LENGTH 10

// Define the maximum length of the item tax
#define MAX_TAX_LENGTH 10

// Define the maximum length of the item subtotal
#define MAX_SUBTOTAL_LENGTH 15

// Define the maximum length of the item total
#define",0
"//FormAI DATASET v1.0 Category: Color Code Converter ; Style: shocked
#include <stdio.h>

int main() {
  printf(""Welcome to the Color Code Converter program!\\n"");

  // Read in RGB values
  int r, g, b;
  printf(""Enter the red RGB value (0-255): "");
  scanf(""%d"", &r);
  printf(""Enter the green RGB value (0-255): "");
  scanf(""%d"", &g);
  printf(""Enter the blue RGB value (0-255): "");
  scanf(""%d"", &b);

  // Convert to HEX
  int hex_r = r / 16;
  int hex_r_mod = r % 16;
  int hex_g = g / 16;
  int hex_g_mod = g % 16;
  int hex_b = b / 16;
  int hex_b_mod = b % 16;

  printf(""\\n"");
  printf(""Your RGB values: (%d, %d, %d)\\n"", r, g, b);
  printf(""Your HEX values: #%X%X%X%X%X%X\\n"", hex_r, hex_r_mod, hex_g, hex_g_mod, hex_b, hex_b_mod);

  printf(""\\nThanks for using the Color Code Converter program!\\n"");

  return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+4Ch] [rbp-24h] BYREF
  int v5; // [rsp+50h] [rbp-20h] BYREF
  int v6; // [rsp+54h] [rbp-1Ch] BYREF
  int v7; // [rsp+58h] [rbp-18h]
  int v8; // [rsp+5Ch] [rbp-14h]
  int v9; // [rsp+60h] [rbp-10h]
  unsigned int v10; // [rsp+64h] [rbp-Ch]
  unsigned int v11; // [rsp+68h] [rbp-8h]
  unsigned int v12; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  printf(""Welcome to the Color Code Converter program!\\n"");
  printf(""Enter the red RGB value (0-255): "");
  scanf(""%d"", &v6);
  printf(""Enter the green RGB value (0-255): "");
  scanf(""%d"", &v5);
  printf(""Enter the blue RGB value (0-255): "");
  scanf(""%d"", &v4);
  v12 = v6 / 16;
  v11 = v6 % 16;
  v10 = v5 / 16;
  v9 = v5 % 16;
  v8 = v4 / 16;
  v7 = v4 % 16;
  printf(""\\n"");
  printf(""Your RGB values: (%d, %d, %d)\\n"", (unsigned int)v6, (unsigned int)v5, (unsigned int)v4);
  printf(""Your HEX values: #%X%X%X%X%X%X\\n"", v12, v11, v10, v9, v8, v7);
  printf(""\\nThanks for using the Color Code Converter program!\\n"");
  return 0;
}
// 140001810: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=176 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    int red, green, blue;
    int red_hex, green_hex, blue_hex;
    int red_dec, green_dec, blue_dec;

    printf(""Welcome to the Color Code Converter program!
"");

    printf(""Enter the red RGB value (0-255): "");
    scanf(""%d"", &red);

    printf(""Enter the green RGB value (0-255): "");
    scanf(""%d"", &green);

    printf(""Enter the blue RGB value (0-255): "");
    scanf(""%d"", &blue);

    // Convert RGB to HEX
    red_hex = red / 16;
    red_dec = red % 16;
    green_hex = green / 16;
    green_dec = green % 16;
    blue_hex = blue / 16;
    blue_dec = blue % 16;

    // Print the results
    printf(""
"");
    printf(""Your RGB values: (%d, %d, %d)
"", red, green, blue);
    printf(""Your HEX values: #%X%X%X%X%X%X
"", red_hex, red_dec, green_hex, green_dec, blue_hex, blue_dec);

    printf(""
Thanks for using the Color Code Converter program!
"");

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Text Summarizer ; Style: inquisitive
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXSUMMARY 100

void text_summarizer(char *text) {
    // Declarations
    int i, j, k, count;
    int len = strlen(text);
    int sentence_count = 0;
    int sentence_start[MAXSUMMARY], sentence_end[MAXSUMMARY];
    int score[MAXSUMMARY];
    char sentence[MAXSUMMARY][MAXSUMMARY];
    char summary[MAXSUMMARY];
    
    // Initialize
    memset(sentence_start, 0, sizeof(sentence_start));
    memset(sentence_end, 0, sizeof(sentence_end));
    memset(score, 0, sizeof(score));
    memset(sentence, 0, sizeof(sentence));
    memset(summary, 0, sizeof(summary));
    
    // Find sentence boundaries
    for (i = 0; i < len; i++) {
        if (text[i] == '.' || text[i] == '?' || text[i] == '!') {
            sentence_end[sentence_count] = i;
            sentence_count++;
        }
    }
    
    // Extract sentences
    for (i = 0; i < sentence_count; i++) {
        int start = sentence_start[i];
        int end = sentence_end[i];
        int sentence_len = end - start + 1;
        strncpy(sentence[i], &text[start], sentence_len);
        sentence[i][sentence_len] = '\\0';
    }
    
    // Compute sentence scores
    for (i = 0; i < sentence_count; i++) {
        for (j = 0; j < sentence[i][j]; j++) {
            if (sentence[i][j] == ' ') {
                score[i]++;
            }
        }
    }
    
    // Find top-scoring sentences
    for (i = 0; i < MAXSUMMARY; i++) {
        int max_score = 0;
        int max_index = 0;
        for (j = 0; j < sentence_count; j++) {
            if (score[j] > max_score) {
                max_score = score[j];
                max_index = j;
            }
        }
        if (max_score == 0) {
            break;
        }
        score[max_index] = 0;
        strcat(summary, sentence[max_index]);
        strcat(summary, "" "");
    }
    
    // Output summary
    printf(""Text Summary:\\n%s"", summary);
}

int main() {
    // Input text
    char text[] = ""In the year 2021, computer programming continues to be an essential skill in the workforce. However, with the vast amount of information and resources available online, it can be overwhelming for beginners to know where to start. This C Text Summarizer program is designed to help simplify the process of extracting the most important information from a lengthy text. Users can simply input their desired text and the program will output a summarized version of the text, providing the essential information without the excess fluff. Give it a try and see how it can help enhance your productivity!"";
    
    // Call text_summarizer function
    text_summarizer(text);
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall text_summarizer(_QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak


//----- (00000001400019D7) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[624]; // [rsp+20h] [rbp-60h] BYREF

  _main(argc, argv, envp);
  strcpy(
    v4,
    ""In the year 2021, computer programming continues to be an essential skill in the workforce. However, with the vast a""
    ""mount of information and resources available online, it can be overwhelming for beginners to know where to start. Th""
    ""is C Text Summarizer program is designed to help simplify the process of extracting the most important information f""
    ""rom a lengthy text. Users can simply input their desired text and the program will output a summarized version of th""
    ""e text, providing the essential information without the excess fluff. Give it a try and see how it can help enhance ""
    ""your productivity!"");
  text_summarizer(v4);
  return 0;
}
// 140001591: using guessed type __int64 __fastcall text_summarizer(_QWORD);
// 140001B00: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=140 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <string.h>

// Function to summarize the text
void text_summarizer(char text[]) {
    // Initialize variables
    int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, count = 0;
    char summary[1000] = """";
    
    // Loop through each word in the text
    for (i = 0; i < strlen(text); i++) {
        // Check if the current character is a space
        if (text[i] == ' ') {
            // Check if the previous word is a stop word
            if (text[i-1] == '.' || text[i-1] == ',' || text[i-1] == ';' || text[i-1] == ':' || text[i-1] == '!' || text[i-1] == '?' || text[i-1] == '(' || text[i-1] == ')' || text[i-1] == '[' || text[i-1] == ']' || text[i-1] == '{' || text[i-1] == '}' || text[i-1] == '""' || text[i-1] == ''' || text[i-1] == '`' || text[i-1] == '\\' || text[i-1] == '/' || text[i-1] == '=' || text[i-1] == '+' || text[i-1] == '-' || text[i-1] == '*' || text[i-1] == '%' || text[i-1] == '&' || text[i-1] == '|' || text[i-1] == '<' || text[i-1] == '>' || text[i-1] == '^' || text[i-1] == '~' || text[i-1] == '`') {
                // Add the previous word to the summary
                strcat(summary, "" "");
                strcat(summary, text[i-1]);
            }
            else {
                // Add the previous word to the summary
                strcat(summary, "" "");
                strcat(summary, text[i-1]);
                // Increment the count of the number of words in the summary
                count++;
            }
        }
        else {
            // Add the current character to the summary
            strcat(summary, text[i]);
        }
    }
    
    // Print the summary
    printf(""Summary: %s
"", summary);
}

int main() {
    // Initialize variables
    char text[] = ""In the year 2021, computer programming continues to be an essential skill in the workforce. However, with the vast amount of information and resources available online, it can be overwhelming for beginners to know where to start. This C Text Summarizer program is designed to help simplify the process of extracting the most important information from a lengthy text. Users can simply input their desired text and the program will output a summarized version of the text, providing the essential information without the excess fluff. Give it a try and see how it can help enhance your productivity!"";
    
    // Call the text summarizer function
    text_summarizer(text);
    
    return 0;
}",2
"//FormAI DATASET v1.0 Category: Traffic Flow Simulation ; Style: detailed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROAD_LENGTH 10
#define TRAFFIC_DENSITY 0.3
#define MAX_SPEED 3
#define MIN_DISTANCE 1

typedef struct Car {
    int pos;
    int speed;
    int size;
    char symbol;
} Car;

void display(Car road[], int size) {
    for(int i = 0; i < size; i++) {
        printf(""%c"", road[i].symbol);
    }
    printf(""\\n"");
}

void simulate(Car road[], int size) {
    for(int i = size - 1; i >= 1; i--) {
        if(road[i].speed == MAX_SPEED) {
            continue;
        }
        int distance = size;
        for(int j = i + 1; j <= i + road[i].speed; j++) {
            if(j >= size) {
                break;
            }
            if(road[j].symbol != '-') {
                distance = j - i - road[j].size - 1;
                break;
            }
        }
        if(distance > road[i].speed) {
            distance = road[i].speed;
        }
        if(distance < MIN_DISTANCE) {
            road[i].speed = distance - 1;
        } else {
            road[i].speed = MAX_SPEED;
        }
    }
    for(int i = size - 1; i >= 1; i--) {
        road[i].pos = road[i-1].pos;
    }
    for(int i = 1; i < size; i++) {
        if(road[i].speed == 0) {
            continue;
        }
        road[i].pos += road[i].speed;
        if(road[i].pos >= (ROAD_LENGTH)) {
            road[i].pos -= (ROAD_LENGTH);
        }
    }
    for(int i = 0; i < size; i++) {
        for(int j = 0; j < road[i].pos; j++) {
            printf("" "");
        }
        printf(""%c"", road[i].symbol);
    }
    printf(""\\n"");
}

int main() {
    srand(time(NULL));
    Car road[ROAD_LENGTH];
    int size = ROAD_LENGTH;
    int num_cars = (int)(TRAFFIC_DENSITY * ROAD_LENGTH);
    for(int i = 0; i < size; i++) {
        road[i].symbol = '-';
    }
    for(int i = 0; i < num_cars; i++) {
        int pos = rand() % (size - 2);
        if(road[pos].symbol != '-' || road[pos+1].symbol != '-') {
            i--;
            continue;
        }
        road[pos].symbol = '>';
        road[pos+1].symbol = '<';
        road[pos].size = 1;
        road[pos+1].size = 1;
        road[pos].speed = rand() % (MAX_SPEED+1);
    }
    display(road, size);
    for(int i = 0; i < 20; i++) {
        simulate(road, size);
    }
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

static time_t __cdecl time(time_t *const Time);
__int64 __fastcall display(_QWORD, _QWORD); // weak
__int64 __fastcall simulate(_QWORD, _QWORD); // weak
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// void __cdecl srand(unsigned int Seed);
// int __cdecl rand();


//----- (00000001400018E9) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char v5[168]; // [rsp+20h] [rbp-C0h] BYREF
  int v6; // [rsp+C8h] [rbp-18h]
  int v7; // [rsp+CCh] [rbp-14h]
  unsigned int v8; // [rsp+D0h] [rbp-10h]
  int k; // [rsp+D4h] [rbp-Ch]
  int j; // [rsp+D8h] [rbp-8h]
  int i; // [rsp+DCh] [rbp-4h]

  _main(argc, argv, envp);
  v3 = time(0i64);
  srand(v3);
  v8 = 10;
  v7 = 3;
  for ( i = 0; i < (int)v8; ++i )
    v5[16 * i + 12] = 45;
  for ( j = 0; j < v7; ++j )
  {
    v6 = rand() % (int)(v8 - 2);
    if ( v5[16 * v6 + 12] == 45 && v5[16 * v6 + 28] == 45 )
    {
      v5[16 * v6 + 12] = 62;
      v5[16 * v6 + 28] = 60;
      *(_DWORD *)&v5[16 * v6 + 8] = 1;
      *(_DWORD *)&v5[16 * v6 + 24] = 1;
      *(_DWORD *)&v5[16 * v6 + 4] = rand() % 4;
    }
    else
    {
      --j;
    }
  }
  display(v5, v8);
  for ( k = 0; k <= 19; ++k )
    simulate(v5, v8);
  return 0;
}
// 1400015B0: using guessed type __int64 __fastcall display(_QWORD, _QWORD);
// 140001615: using guessed type __int64 __fastcall simulate(_QWORD, _QWORD);
// 140001B30: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=143 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Define the size of the board
#define BOARD_SIZE 10

// Define the maximum number of moves
#define MAX_MOVES 20

// Define the direction of the snake
#define UP 1
#define DOWN 2
#define LEFT 3
#define RIGHT 4

// Define the positions of the ladders and snakes
#define LADDER_1 3
#define LADDER_2 7
#define SNAKE_1 4
#define SNAKE_2 6

// Define the structure of the board
typedef struct {
    int position;
    int moves;
    int direction;
    int roll;
} Board;

// Function to display the board
void display(Board board[], int size) {
    printf(""   "");
    for (int i = 0; i < size; i++) {
        printf(""%d "", i+1);
    }
    printf(""
"");
    for (int i = 0; i < size; i++) {
        printf(""%d "", i+1);
        for (int j = 0; j < size; j++) {
            if (board[i].position == j) {
                printf(""O "");
            } else if (board[i].position == j+1) {
                printf(""- "");
            } else if (board[i].position == j-1) {
                printf(""+ "");
            } else {
                printf(""  "");
            }
        }
        printf(""
"");
    }
}

// Function to simulate the game
void simulate(Board board[], int size) {
    int current_position = board[0].position;
    int current_moves = board[0].moves;
    int current_direction = board[0].direction;
    int current_roll = board[0].roll;
    int new_position, new_moves, new_direction, new_roll;
    
    // Check if the game is over
    if (current_position == size) {
        printf(""Congratulations! You have won the game!
"");
        return;
    }
    
    // Check if the player has reached the maximum number of moves
    if (current_moves >= MAX_MOVES) {
        printf(""Sorry, you have reached the maximum number of moves.
"");
        return;
    }
    
    // Check if the player has reached a ladder
    if (current_position == LADDER_1) {
        new_position = LADDER_2;
        new_moves = current_moves + 1;
        new_direction = current_direction;
        new_roll = current_roll;
        printf(""Congratulations! You have reached a ladder!
"");
    } else if (current_position == LADDER_2) {
        new_position = LADDER_1;
        new_moves = current_moves + 1;
        new_direction = current_direction;
        new_roll = current_roll;
        printf(""Congratulations! You have reached a ladder!
"");
    } else if (current_position == SNAKE_1) {
        new_position = SNAKE_2;
        new_moves = current_moves + 1;
        new_direction = current_direction;
        new_roll = current_roll;
        printf(""Sorry, you have reached a snake!
"");
    } else if (current_position == SNAKE_2) {
        new_position = SNAKE_1;
        new_moves = current_moves + 1;
        new_direction = current_direction;
        new_roll = current_roll;
        printf(""Sorry, you have reached a snake!
"");
    } else {
        // Calculate the new position
        if (current_direction == UP",0
"//FormAI DATASET v1.0 Category: Password management ; Style: Ada Lovelace
#include <stdio.h>
#include <string.h>

#define MAX_USERS 10
#define MAX_PASSWORD_LENGTH 20

struct user {
   char username[MAX_PASSWORD_LENGTH];
   char password[MAX_PASSWORD_LENGTH];
};

int main() {
   struct user users[MAX_USERS];
   char entered_username[MAX_PASSWORD_LENGTH];
   char entered_password[MAX_PASSWORD_LENGTH];
   int i, user_exists, attempts;

   // Fill in some users for demo purposes
   strcpy(users[0].username, ""ada_lovelace"");
   strcpy(users[0].password, ""computing"");
   strcpy(users[1].username, ""grace_hopper"");
   strcpy(users[1].password, ""programming"");
   strcpy(users[2].username, ""alan_turing"");
   strcpy(users[2].password, ""enigma"");

   // Welcome message
   printf(""Welcome to the Password Management System!\\n"");
   printf(""Please enter your username and password to access your account.\\n"");

   // Loop until user enters correct credentials or exceeds maximum attempts
   attempts = 0;
   do {
      // Ask user for username and password
      printf(""Enter your username: "");
      scanf(""%s"", entered_username);
      printf(""Enter your password: "");
      scanf(""%s"", entered_password);

      // Check if entered credentials match any existing user
      user_exists = 0;
      for (i = 0; i < MAX_USERS; i++) {
         if (strcmp(entered_username, users[i].username) == 0 && strcmp(entered_password, users[i].password) == 0) {
            user_exists = 1;
            break;
         }
      }

      // If the user exists, show welcome message
      if (user_exists) {
         printf(""\\nWelcome, %s!\\n"", entered_username);
         printf(""You have successfully logged in.\\n"");

         // Ask user if they want to change password
         char change_password;
         printf(""Would you like to change your password? (Y/N) "");
         scanf("" %c"", &change_password);

         // If the user wants to change password, prompt for new one and store it
         if (change_password == 'Y' || change_password == 'y') {
            char new_password[MAX_PASSWORD_LENGTH];
            printf(""Enter new password (up to %d characters): "", MAX_PASSWORD_LENGTH - 1);
            scanf(""%s"", new_password);
            strcpy(users[i].password, new_password);
            printf(""Password successfully changed.\\n"");
         }

         // Exit program
         return 0;
      }
      // If the user does not exist, show error message and increment attempt counter
      else {
         printf(""\\nIncorrect username or password. Please try again.\\n"");
         attempts++;
      }
   } while (attempts < 3);

   // If the maximum number of attempts is reached, show error message and exit program
   printf(""\\nMaximum number of attempts exceeded. Account locked.\\n"");
   return 1;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strcpy(char *Destination, const char *Source);
// int __cdecl strcmp(const char *Str1, const char *Str2);


//----- (00000001400015E2) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char Source[31]; // [rsp+20h] [rbp-60h] BYREF
  char v5; // [rsp+3Fh] [rbp-41h] BYREF
  char v6[32]; // [rsp+40h] [rbp-40h] BYREF
  char Str1[32]; // [rsp+60h] [rbp-20h] BYREF
  _QWORD v8[2]; // [rsp+80h] [rbp+0h] BYREF
  char v9[16]; // [rsp+94h] [rbp+14h] BYREF
  char v10[16]; // [rsp+A8h] [rbp+28h] BYREF
  char v11[16]; // [rsp+BCh] [rbp+3Ch] BYREF
  char v12[16]; // [rsp+D0h] [rbp+50h] BYREF
  char v13[8]; // [rsp+E4h] [rbp+64h] BYREF
  int v14; // [rsp+214h] [rbp+194h]
  int v15; // [rsp+218h] [rbp+198h]
  int i; // [rsp+21Ch] [rbp+19Ch]

  _main(argc, argv, envp);
  strcpy((char *)v8, ""ada_lovelace"");
  strcpy(v9, ""computing"");
  strcpy(v10, ""grace_hopper"");
  strcpy(v11, ""programming"");
  strcpy(v12, ""alan_turing"");
  strcpy(v13, ""enigma"");
  printf(""Welcome to the Password Management System!\\n"");
  printf(""Please enter your username and password to access your account.\\n"");
  v14 = 0;
  while ( 1 )
  {
    printf(""Enter your username: "");
    scanf(""%s"", Str1);
    printf(""Enter your password: "");
    scanf(""%s"", v6);
    v15 = 0;
    for ( i = 0; i <= 9; ++i )
    {
      if ( !strcmp(Str1, (const char *)&v8[5 * i]) && !strcmp(v6, (const char *)&v8[5 * i + 2] + 4) )
      {
        v15 = 1;
        break;
      }
    }
    if ( v15 )
      break;
    printf(""\\nIncorrect username or password. Please try again.\\n"");
    if ( ++v14 > 2 )
    {
      printf(""\\nMaximum number of attempts exceeded. Account locked.\\n"");
      return 1;
    }
  }
  printf(""\\nWelcome, %s!\\n"", Str1);
  printf(""You have successfully logged in.\\n"");
  printf(""Would you like to change your password? (Y/N) "");
  scanf("" %c"", &v5);
  if ( v5 == 89 || v5 == 121 )
  {
    printf(""Enter new password (up to %d characters): "", 19i64);
    scanf(""%s"", Source);
    strcpy((char *)&v8[5 * i + 2] + 4, Source);
    printf(""Password successfully changed.\\n"");
  }
  return 0;
}
// 140001970: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=178 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_USERNAME_LENGTH 15
#define MAX_PASSWORD_LENGTH 20
#define MAX_ATTEMPTS 3

typedef struct {
    char username[MAX_USERNAME_LENGTH];
    char password[MAX_PASSWORD_LENGTH];
} User;

int main() {
    User users[10];
    strcpy(users[0].username, ""ada_lovelace"");
    strcpy(users[0].password, ""computing"");
    strcpy(users[1].username, ""grace_hopper"");
    strcpy(users[1].password, ""programming"");
    strcpy(users[2].username, ""alan_turing"");
    strcpy(users[2].password, ""enigma"");

    printf(""Welcome to the Password Management System!
"");
    printf(""Please enter your username and password to access your account.
"");

    char username[MAX_USERNAME_LENGTH];
    char password[MAX_PASSWORD_LENGTH];
    int attempts = 0;

    while (1) {
        printf(""Enter your username: "");
        scanf(""%s"", username);
        printf(""Enter your password: "");
        scanf(""%s"", password);

        int valid = 0;
        for (int i = 0; i < 10; i++) {
            if (strcmp(username, users[i].username) == 0 && strcmp(password, users[i].password + 4) == 0) {
                valid = 1;
                break;
            }
        }

        if (valid) {
            printf(""
Welcome, %s!
"", username);
            printf(""You have successfully logged in.
"");
            break;
        } else {
            printf(""
Incorrect username or password. Please try again.
"");
            attempts++;
            if (attempts > MAX_ATTEMPTS) {
                printf(""
Maximum number of attempts exceeded. Account locked.
"");
                return 1;
            }
        }
    }

    printf(""Would you like to change your password? (Y/N) "");
    char choice;
    scanf("" %c"", &choice);

    if (choice == 'Y' || choice == 'y') {
        printf(""Enter new password (up to %d characters): "", MAX_PASSWORD_LENGTH - 4);
        char new_password[MAX_PASSWORD_LENGTH - 4];
        scanf(""%s"", new_password);
        strcpy(users[i].password, new_password);
        printf(""Password successfully changed.
"");
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Natural Language Date Converter ; Style: surprised
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

// function declarations
void print_greeting();
void print_farewell();
void convert_date(char input[]);

// main function
int main()
{
    print_greeting();
    
    char input[100];
    do {
        printf(""Enter a date in natural language (e.g. 'today', 'next Friday', 'October 31st'): "");
        scanf(""%[^\\n]"", input);
        getchar();
        convert_date(input);
        printf(""Enter another date? (y/n): "");
        char response = getchar();
        if (tolower(response) == 'n') {
            break;
        }
        getchar();
    } while (1);
    
    print_farewell();
    return 0;
}

// function definitions
void print_greeting() {
    printf(""Welcome to the Natural Language Date Converter!\\n"");
    printf(""I can convert dates like 'today' or 'next Wednesday' to a numerical date.\\n"");
    printf(""But keep an eye out for surprises along the way!\\n"");
}

void print_farewell() {
    printf(""Thank you for using the Natural Language Date Converter. Have a great day!\\n"");
}

void convert_date(char input[]) {
    // check for special dates
    if (strcmp(input, ""pi day"") == 0) {
        printf(""Wow, it's Pi Day! March 14th.\\n"");
        return;
    }
    
    // get current time
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    
    // add the requested amount of days
    if (strcmp(input, ""yesterday"") == 0) {
        t -= 86400;
    } else if (strcmp(input, ""today"") != 0) {
        // calculate the number of days to add
        int day_of_week = tm->tm_wday;
        int days_to_add;
        if (day_of_week == 5) {
            days_to_add = 2;
        } else if (day_of_week == 6) {
            days_to_add = 1;
        } else {
            days_to_add = 1 + (7 + (input[0] - 'a' + 7 - day_of_week) % 7) % 7;
        }
        // add the days to the current time
        t += 86400 * days_to_add;
    }
    
    // convert to struct tm and print the date
    tm = localtime(&t);
    printf(""The date on %s is %02d/%02d/%04d.\\n"", input, tm->tm_mon + 1, tm->tm_mday, tm->tm_year + 1900);
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int scanf(const char *const Format, ...);
int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 print_greeting(void); // weak
__int64 print_farewell(void); // weak
__int64 __fastcall convert_date(_QWORD); // weak
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();

//-------------------------------------------------------------------------
// Data declarations

// extern int (__cdecl *tolower)(int C);


//----- (0000000140001620) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[111]; // [rsp+20h] [rbp-70h] BYREF
  char v5; // [rsp+8Fh] [rbp-1h]

  _main(argc, argv, envp);
  print_greeting();
  while ( 1 )
  {
    printf(""Enter a date in natural language (e.g. 'today', 'next Friday', 'October 31st'): "");
    scanf(""%[^\\n]"", v4);
    getchar();
    convert_date(v4);
    printf(""Enter another date? (y/n): "");
    v5 = getchar();
    if ( tolower(v5) == 110 )
      break;
    getchar();
  }
  print_farewell();
  return 0;
}
// 1400016B1: using guessed type __int64 print_greeting(void);
// 1400016ED: using guessed type __int64 print_farewell(void);
// 14000170B: using guessed type __int64 __fastcall convert_date(_QWORD);
// 140001950: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=185 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

void print_greeting();
void print_farewell();
void convert_date(char *date);

int main() {
    char input[100];
    char choice;

    print_greeting();

    while (1) {
        printf(""Enter a date in natural language (e.g. 'today', 'next Friday', 'October 31st'): "");
        scanf(""%[^\\n]"", input);
        getchar(); // consume newline character

        convert_date(input);

        printf(""Enter another date? (y/n): "");
        choice = getchar();
        if (tolower(choice) == 'n') {
            break;
        }
        getchar(); // consume newline character
    }

    print_farewell();

    return 0;
}

void print_greeting() {
    printf(""Welcome to the Date Converter!\\n"");
}

void print_farewell() {
    printf(""Thank you for using the Date Converter!\\n"");
}

void convert_date(char *date) {
    char *months[] = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
    char *days[] = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
    char *today = ""today"";
    char *tomorrow = ""tomorrow"";
    char *yesterday = ""yesterday"";
    char *next_week = ""next week"";
    char *last_week = ""last week"";
    char *next_month = ""next month"";
    char *last_month = ""last month"";
    char *next_year = ""next year"";
    char *last_year = ""last year"";
    char *invalid_date = ""Invalid date"";

    char *month_name;
    int month_number;
    char *day_name;
    int day_number;
    int year;
    int month;
    int day;
    int weekday;
    int week;
    int day_of_month;
    int days_in_month;
    int days_in_year;
    int days_in_week;
    int days_in_last_week;
    int days_in_next_week;
    int days_in_last_month;
    int days_in_next_month;
    int days_in_last_year;
    int days_in_next_year;

    if (strcmp(date, today) == 0) {
        printf(""Today is "");
        time_t now = time(NULL);
        struct tm *tm = localtime(&now);
        printf(""%d %s %d\\n"", tm->tm_mday, months[tm->tm_mon], tm->tm_year + 1900);
    } else if (strcmp(date, tomorrow) == 0) {
        printf(""Tomorrow is "");
        time_t now = time(NULL);
        struct tm *tm = localtime(&now);
        tm->tm_mday += 1;
        printf(""%d %s %d\\n"", tm->tm_mday, months[tm->tm_mon], tm->tm_year + 1900);
    } else if (strcmp(date, yesterday) == 0) {
        printf(""Yesterday was "");
        time_t now = time(NULL);
        struct tm *tm = localtime(&now);
        tm->tm_mday -= 1;
        printf(""%d %s %d\\n"", tm->tm_mday, months[tm->tm_mon], tm->tm_year + 1900);
    } else if (strstr(date, next_week) != NULL) {
       ",2
"//FormAI DATASET v1.0 Category: Antivirus scanner ; Style: medieval
/* Medieval Antivirus Scanner */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char virus_one[] = ""plague""; // first virus name
    char virus_two[] = ""black death""; // second virus name
    char virus_three[] = ""smallpox""; // third virus name
    char *filename = ""suspicious_file.exe""; // the name of the suspicious file
    char *file_content; // the content of the suspicious file
    int file_size; // the size of the suspicious file

    // Read the suspicious file
    FILE *fp = fopen(filename, ""rb"");
    if(!fp) {
        printf(""File cannot be opened."");
        exit(0);
    }

    // Get the size of the file
    fseek(fp, 0L, SEEK_END);
    file_size = ftell(fp);
    rewind(fp);

    // Allocate memory for the file content
    file_content = (char *) malloc (file_size);

    // Read the file content
    fread(file_content, sizeof(char), file_size, fp);

    // Close the file
    fclose(fp);

    // Scan for viruses
    int virus_found = 0;
    if(strstr(file_content, virus_one)) {
        virus_found = 1;
    }
    if(strstr(file_content, virus_two)) {
        virus_found = 1;
    }
    if(strstr(file_content, virus_three)) {
        virus_found = 1;
    }

    // Remove the file content from memory
    free(file_content);

    // Display the result
    if(virus_found) {
        printf(""Warning: Virus detected in the file!"");
    } else {
        printf(""The file is clean."");
    }

    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// char *__cdecl strstr(const char *Str, const char *SubStr);
// void __cdecl rewind(FILE *Stream);
// void *__cdecl malloc(size_t Size);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl free(void *Block);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fclose(FILE *Stream);
// void __cdecl __noreturn exit(int Code);


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char v4[21]; // [rsp+2Ch] [rbp-44h] BYREF
  char v5[19]; // [rsp+41h] [rbp-2Fh] BYREF
  int v6; // [rsp+54h] [rbp-1Ch]
  FILE *Stream; // [rsp+58h] [rbp-18h]
  char *FileName; // [rsp+60h] [rbp-10h]
  BOOL v9; // [rsp+6Ch] [rbp-4h]

  _main(argc, argv, envp);
  strcpy(v5, ""plague"");
  strcpy(&v4[9], ""black death"");
  strcpy(v4, ""smallpox"");
  FileName = ""suspicious_file.exe"";
  Stream = fopen(""suspicious_file.exe"", ""rb"");
  if ( !Stream )
  {
    printf(""File cannot be opened."");
    exit(0);
  }
  fseek(Stream, 0, 2);
  v6 = ftell(Stream);
  rewind(Stream);
  *(_QWORD *)&v5[7] = malloc(v6);
  fread(*(void **)&v5[7], 1ui64, v6, Stream);
  fclose(Stream);
  v9 = strstr(*(const char **)&v5[7], v5) != 0i64;
  if ( strstr(*(const char **)&v5[7], &v4[9]) )
    v9 = 1;
  if ( strstr(*(const char **)&v5[7], v4) )
    v9 = 1;
  free(*(void **)&v5[7]);
  if ( v9 )
    printf(""Warning: Virus detected in the file!"");
  else
    printf(""The file is clean."");
  return 0;
}
// 1400017D0: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=144 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char virus_signature[] = ""plague"";
    char virus_signature2[] = ""black death"";
    char virus_signature3[] = ""smallpox"";
    char* file_name = ""suspicious_file.exe"";
    FILE* file_ptr;
    int file_size;
    char* file_data;
    int i;
    int virus_found = 0;

    // Open the file
    file_ptr = fopen(file_name, ""rb"");
    if (file_ptr == NULL) {
        printf(""File cannot be opened."");
        exit(0);
    }

    // Get the file size
    fseek(file_ptr, 0, SEEK_END);
    file_size = ftell(file_ptr);
    rewind(file_ptr);

    // Allocate memory for the file data
    file_data = (char*) malloc(file_size);

    // Read the file data
    fread(file_data, sizeof(char), file_size, file_ptr);

    // Close the file
    fclose(file_ptr);

    // Check for virus signature
    if (strstr(file_data, virus_signature) != NULL) {
        virus_found = 1;
    }

    // Check for virus signature 2
    if (strstr(file_data, virus_signature2) != NULL) {
        virus_found = 1;
    }

    // Check for virus signature 3
    if (strstr(file_data, virus_signature3) != NULL) {
        virus_found = 1;
    }

    // Free the memory allocated for the file data
    free(file_data);

    // Print the result
    if (virus_found) {
        printf(""Warning: Virus detected in the file!"");
    } else {
        printf(""The file is clean."");
    }

    return 0;
}",2
"//FormAI DATASET v1.0 Category: Robot movement control ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Initialize variables
    int x = 0, y = 0, z = 0;
    char direction = 'N';
    
    // Cyberpunk style console output
    printf(""Initializing robotic movement control...\\n"");
    printf(""System online. Ready for input.\\n"");
    printf(""Enter directional commands: F (forward), B (backward), L (left), R (right), U (up), D (down)\\n"");
    printf(""Enter Q to quit\\n"");
    
    // Main loop for receiving input commands
    while (1) {
        printf(""Current position: (%d, %d, %d), Facing: %c\\n"", x, y, z, direction);
        char command = getchar();
        
        if (command == 'Q') {
            // Quit program
            printf(""Exiting program...\\n"");
            break;
        } else if (command == '\\n') {
            // Ignore newline characters
            continue;
        } else if (command == 'F') {
            // Move forward
            if (direction == 'N') {
                y++;
            } else if (direction == 'S') {
                y--;
            } else if (direction == 'E') {
                x++;
            } else if (direction == 'W') {
                x--;
            } else if (direction == 'U') {
                z++;
            } else if (direction == 'D') {
                z--;
            }
        } else if (command == 'B') {
            // Move backward
            if (direction == 'N') {
                y--;
            } else if (direction == 'S') {
                y++;
            } else if (direction == 'E') {
                x--;
            } else if (direction == 'W') {
                x++;
            } else if (direction == 'U') {
                z--;
            } else if (direction == 'D') {
                z++;
            }
        } else if (command == 'L') {
            // Turn left
            if (direction == 'N') {
                direction = 'W';
            } else if (direction == 'S') {
                direction = 'E';
            } else if (direction == 'E') {
                direction = 'N';
            } else if (direction == 'W') {
                direction = 'S';
            } else {
                // Cannot turn left while moving up or down
                printf(""Cannot turn left while moving up or down\\n"");
            }
        } else if (command == 'R') {
            // Turn right
            if (direction == 'N') {
                direction = 'E';
            } else if (direction == 'S') {
                direction = 'W';
            } else if (direction == 'E') {
                direction = 'S';
            } else if (direction == 'W') {
                direction = 'N';
            } else {
                // Cannot turn right while moving up or down
                printf(""Cannot turn right while moving up or down\\n"");
            }
        } else if (command == 'U') {
            // Move up
            if (direction == 'U') {
                z++;
            } else if (direction == 'D') {
                z--;
            } else {
                // Cannot move up if not facing up or down
                printf(""Cannot move up if not facing up or down\\n"");
            }
        } else if (command == 'D') {
            // Move down
            if (direction == 'U') {
                z--;
            } else if (direction == 'D') {
                z++;
            } else {
                // Cannot move down if not facing up or down
                printf(""Cannot move down if not facing up or down\\n"");
            }
        } else {
            // Invalid command
            printf(""Invalid command\\n"");
        }
        
        // Clear input buffer
        while (getchar() != '\\n');
    }
    
    return 0;
}","/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int printf(const char *const Format, ...);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall _main(_QWORD, _QWORD, _QWORD); // weak
// int __cdecl getchar();


//----- (0000000140001591) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+20h] [rbp-20h]
  char v5; // [rsp+32h] [rbp-Eh]
  char v6; // [rsp+33h] [rbp-Dh]
  unsigned int v7; // [rsp+38h] [rbp-8h]
  unsigned int v8; // [rsp+3Ch] [rbp-4h]

  _main(argc, argv, envp);
  v8 = 0;
  v7 = 0;
  v6 = 78;
  printf(""Initializing robotic movement control...\\n"");
  printf(""System online. Ready for input.\\n"");
  printf(""Enter directional commands: F (forward), B (backward), L (left), R (right), U (up), D (down)\\n"");
  printf(""Enter Q to quit\\n"");
  while ( 1 )
  {
    LODWORD(v4) = v6;
    printf(""Current position: (%d, %d, %d), Facing: %c\\n"", v8, v7, 0i64, v4);
    v5 = getchar();
    if ( v5 == 81 )
      break;
    if ( v5 != 10 )
    {
      switch ( v5 )
      {
        case 'F':
          switch ( v6 )
          {
            case 'N':
              ++v7;
              break;
            case 'S':
              --v7;
              break;
            case 'E':
              ++v8;
              break;
            default:
              --v8;
              break;
          }
          break;
        case 'B':
          switch ( v6 )
          {
            case 'N':
              --v7;
              break;
            case 'S':
              ++v7;
              break;
            case 'E':
              --v8;
              break;
            default:
              ++v8;
              break;
          }
          break;
        case 'L':
          switch ( v6 )
          {
            case 'N':
              v6 = 87;
              break;
            case 'S':
              v6 = 69;
              break;
            case 'E':
              v6 = 78;
              break;
            default:
              v6 = 83;
              break;
          }
          break;
        case 'R':
          switch ( v6 )
          {
            case 'N':
              v6 = 69;
              break;
            case 'S':
              v6 = 87;
              break;
            case 'E':
              v6 = 83;
              break;
            default:
              v6 = 78;
              break;
          }
          break;
        case 'U':
          printf(""Cannot move up if not facing up or down\\n"");
          break;
        case 'D':
          printf(""Cannot move down if not facing up or down\\n"");
          break;
        default:
          printf(""Invalid command\\n"");
          break;
      }
      while ( getchar() != 10 )
        ;
    }
  }
  printf(""Exiting program...\\n"");
  return 0;
}
// 14000167F: conditional instruction was optimized away because %var_D.1==57
// 1400016E3: conditional instruction was optimized away because %var_D.1==57
// 140001747: conditional instruction was optimized away because %var_D.1==57
// 14000179D: conditional instruction was optimized away because %var_D.1==57
// 1400017C0: conditional instruction was optimized away because %var_D.1 is in (==45|==4E|==53|==57)
// 1400017CC: conditional instruction was optimized away because %var_D.1 is in (==45|==4E|==53|==57)
// 1400017EF: conditional instruction was optimized away because %var_D.1 is in (==45|==4E|==53|==57)
// 1400017FB: conditional instruction was optimized away because %var_D.1 is in (==45|==4E|==53|==57)
// 140001617: variable 'v4' is possibly undefined
// 140001900: using guessed type __int64 __fastcall _main(_QWORD, _QWORD, _QWORD);

// nfuncs=138 queued=1 decompiled=1 lumina nreq=0 worse=0 better=0
// ALL OK, 1 function(s) have been successfully decompiled
","#include <stdio.h>

int main() {
    int x = 0, y = 0, z = 0;
    char direction = 'N';
    
    printf(""Initializing robotic movement control...
"");
    printf(""System online. Ready for input.
"");
    printf(""Enter directional commands: F (forward), B (backward), L (left), R (right), U (up), D (down)
"");
    printf(""Enter Q to quit
"");
    
    while (1) {
        printf(""Current position: (%d, %d, %d), Facing: %c
"", x, y, z, direction);
        
        char input = getchar();
        
        if (input == 'Q') {
            printf(""Exiting program...
"");
            break;
        }
        
        if (input == '
') {
            continue;
        }
        
        switch (input) {
            case 'F':
                if (direction == 'N') {
                    y++;
                } else if (direction == 'S') {
                    y--;
                } else if (direction == 'E') {
                    x++;
                } else {
                    x--;
                }
                break;
            case 'B':
                if (direction == 'N') {
                    y--;
                } else if (direction == 'S') {
                    y++;
                } else if (direction == 'E') {
                    x--;
                } else {
                    x++;
                }
                break;
            case 'L':
                if (direction == 'N') {
                    direction = 'W';
                } else if (direction == 'S') {
                    direction = 'E';
                } else if (direction == 'E') {
                    direction = 'N';
                } else {
                    direction = 'S';
                }
                break;
            case 'R':
                if (direction == 'N') {
                    direction = 'E';
                } else if (direction == 'S') {
                    direction = 'W';
                } else if (direction == 'E') {
                    direction = 'S';
                } else {
                    direction = 'N';
                }
                break;
            case 'U':
                printf(""Cannot move up if not facing up or down
"");
                break;
            case 'D':
                printf(""Cannot move down if not facing up or down
"");
                break;
            default:
                printf(""Invalid command
"");
                break;
        }
        
        // Clear input buffer
        while (getchar() != '
');
    }
    
    return 0;
}",2
