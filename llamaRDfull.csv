trg,RD,out,sub_eval
"//FormAI DATASET v1.0 Category: HTML beautifier ; Style: Ken Thompson
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX_LINE_LENGTH 1000

void beautify(char* line);

int main(int argc, char** argv) {
    FILE* input_file;
    FILE* output_file;
    char line[MAX_LINE_LENGTH];

    if (argc != 3) {
        fprintf(stderr, ""Usage: %s [input file] [output file]\n"", argv[0]);
        exit(1);
    }

    input_file = fopen(argv[1], ""r"");

    if (!input_file) {
        fprintf(stderr, ""Failed to open input file '%s'\n"", argv[1]);
        exit(1);
    }

    output_file = fopen(argv[2], ""w"");

    if (!output_file) {
        fprintf(stderr, ""Failed to open output file '%s'\n"", argv[2]);
        exit(1);
    }

    while (fgets(line, MAX_LINE_LENGTH, input_file)) {
        beautify(line);
        fprintf(output_file, ""%s"", line);
    }

    fclose(input_file);
    fclose(output_file);

    return 0;
}

void beautify(char* line) {
    char beautified[MAX_LINE_LENGTH];
    char* p_beautified = beautified;
    char* p_line = line;
    bool in_tag = false;

    while (*p_line != '\0') {
        if (*p_line == '<') {
            in_tag = true;
        }

        if (in_tag) {
            *p_beautified = *p_line;
            p_beautified++;
        }
        else {
            if (isalpha(*p_line)) {
                *p_beautified = toupper(*p_line);
                p_beautified++;
            }
            else if (isspace(*p_line)) {
                // ignore consecutive spaces
                if (*(p_line + 1) != ' ') {
                    *p_beautified = ' ';
                    p_beautified++;
                }
            }
            else {
                *p_beautified = *p_line;
                p_beautified++;
            }
        }

        if (*p_line == '>') {
            in_tag = false;
        }

        p_line++;
    }

    *p_beautified = '\0';
    sprintf(line, ""%s"", beautified);
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t beautify(int64_t * str);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10d0(int64_t * d);
int32_t function_10e0(int32_t c);
int32_t function_10f0(struct _IO_FILE * stream);
void function_1100(void);
int32_t function_1110(char * s, struct _IO_FILE * stream);
char * function_1120(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1130(struct _IO_FILE * stream, char * format, ...);
struct _IO_FILE * function_1140(char * filename, char * modes);
int32_t function_1150(char * s, char * format, ...);
void function_1160(int32_t status);
int16_t ** function_1170(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x20001; // 0x2000
int32_t g2 = 0; // 0x3e8
int32_t g3 = 0; // 0x400
struct _IO_FILE * g4 = NULL; // 0x4020
char g5 = 0; // 0x4028
int32_t g6;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g6;
    }
    // 0x1016
    return result;
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int64_t * d) {
    // 0x10d0
    __cxa_finalize(d);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(int32_t c) {
    // 0x10e0
    return toupper(c);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(struct _IO_FILE * stream) {
    // 0x10f0
    return fclose(stream);
}

// Address range: 0x1100 - 0x110b
void function_1100(void) {
    // 0x1100
    __stack_chk_fail();
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s, struct _IO_FILE * stream) {
    // 0x1110
    return fputs(s, stream);
}

// Address range: 0x1120 - 0x112b
char * function_1120(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1120
    return fgets(s, n, stream);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(struct _IO_FILE * stream, char * format, ...) {
    // 0x1130
    return fprintf(stream, format);
}

// Address range: 0x1140 - 0x114b
struct _IO_FILE * function_1140(char * filename, char * modes) {
    // 0x1140
    return fopen(filename, modes);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * s, char * format, ...) {
    // 0x1150
    return sprintf(s, format);
}

// Address range: 0x1160 - 0x116b
void function_1160(int32_t status) {
    // 0x1160
    exit(status);
}

// Address range: 0x1170 - 0x117b
int16_t ** function_1170(void) {
    // 0x1170
    return __ctype_b_loc();
}

// Address range: 0x1180 - 0x11a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1180
    int64_t v1; // 0x1180
    __libc_start_main(0x1269, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x11b0 - 0x11d9
int64_t deregister_tm_clones(void) {
    // 0x11b0
    return 0x4010;
}

// Address range: 0x11e0 - 0x1219
int64_t register_tm_clones(void) {
    // 0x11e0
    return 0;
}

// Address range: 0x1220 - 0x1259
int64_t __do_global_dtors_aux(void) {
    // 0x1220
    if (g5 != 0) {
        // 0x1258
        int64_t result; // 0x1220
        return result;
    }
    // 0x122d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x123b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1247
    g5 = 1;
    return result2;
}

// Address range: 0x1260 - 0x1269
int64_t frame_dummy(void) {
    // 0x1260
    return register_tm_clones();
}

// Address range: 0x1269 - 0x141e
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1285
    if ((int32_t)argc != 3) {
        // 0x129d
        fprintf(g4, ""Usage: %s [input file] [output file]\n"", argv);
        exit(1);
        // UNREACHABLE
    }
    int64_t v2 = (int64_t)argv; // 0x12cf
    int64_t * file_path = (int64_t *)(v2 + 8); // 0x12da
    struct _IO_FILE * file = fopen((char *)*file_path, ""r""); // 0x12ea
    if (file == NULL) {
        // 0x1300
        fprintf(g4, ""Failed to open input file '%s'\n"", (char *)*file_path);
        exit(1);
        // UNREACHABLE
    }
    int64_t * file_path2 = (int64_t *)(v2 + 16); // 0x1341
    struct _IO_FILE * file2 = fopen((char *)*file_path2, ""w""); // 0x1351
    if (file2 == NULL) {
        // 0x1367
        fprintf(g4, ""Failed to open output file '%s'\n"", (char *)*file_path2);
        exit(1);
        // UNREACHABLE
    }
    // 0x13c5
    int64_t str; // bp-1016, 0x1269
    if (fgets((char *)&str, (int32_t)&g2, file) != NULL) {
        beautify(&str);
        fputs((char *)&str, file2);
        while (fgets((char *)&str, (int32_t)&g2, file) != NULL) {
            // 0x139d
            beautify(&str);
            fputs((char *)&str, file2);
        }
    }
    // 0x13e5
    fclose(file);
    fclose(file2);
    int64_t result = 0; // 0x1415
    if (v1 != __readfsqword(40)) {
        // 0x1417
        __stack_chk_fail();
        result = &g6;
    }
    // 0x141c
    return result;
}

// Address range: 0x141e - 0x15de
int64_t beautify(int64_t * str) {
    int64_t v1 = __readfsqword(40); // 0x1434
    char v2 = *(char *)str; // 0x158d
    int64_t v3; // bp-1016, 0x141e
    char * v4 = (char *)&v3; // 0x1592
    if (v2 != 0) {
        char * v5 = (char *)&v3;
        int64_t v6 = (int64_t)str;
        char * v7 = (char *)str;
        char v8 = v2 != 60 ? 0 : 1;
        char * v9; // 0x141e
        char v10; // 0x150c
        uint16_t v11; // 0x1519
        int16_t * v12; // 0x14ae
        char c; // 0x14b8
        uint16_t v13; // 0x14c5
        int16_t * v14; // 0x1502
        if (v8 == 0) {
            // 0x14a9
            v12 = *__ctype_b_loc();
            c = *v7;
            v13 = *(int16_t *)(2 * (int64_t)c + (int64_t)v12);
            if (((int32_t)v13 & (int32_t)&g3) == 0) {
                // 0x14fd
                v14 = *__ctype_b_loc();
                v10 = *v7;
                v11 = *(int16_t *)(2 * (int64_t)v10 + (int64_t)v14);
                if (((int32_t)v11 & (int32_t)&g1) == 0) {
                    // 0x154e
                    *v5 = v10;
                    v9 = (char *)((int64_t)v5 + 1);
                } else {
                    // 0x1528
                    v9 = v5;
                    if (*(char *)(v6 + 1) != 32) {
                        // 0x153a
                        *v5 = 32;
                        v9 = (char *)((int64_t)v5 + 1);
                    }
                }
            } else {
                // 0x14d4
                *v5 = (char)toupper((int32_t)c);
                v9 = (char *)((int64_t)v5 + 1);
            }
        } else {
            // 0x1489
            *v5 = v2;
            v9 = (char *)((int64_t)v5 + 1);
        }
        char * v15 = v9;
        int64_t v16 = v6 + 1; // 0x157e
        char * v17 = (char *)v16; // 0x158d
        char v18 = *v17; // 0x158d
        char v19 = *v7 != 62 ? v8 : 0; // 0x1592
        v4 = v15;
        while (v18 != 0) {
            // 0x146b
            v5 = v15;
            v6 = v16;
            v7 = v17;
            char v20 = v18;
            v8 = v20 != 60 ? v19 : 1;
            if (v8 == 0) {
                // 0x14a9
                v12 = *__ctype_b_loc();
                c = *v7;
                v13 = *(int16_t *)(2 * (int64_t)c + (int64_t)v12);
                if (((int32_t)v13 & (int32_t)&g3) == 0) {
                    // 0x14fd
                    v14 = *__ctype_b_loc();
                    v10 = *v7;
                    v11 = *(int16_t *)(2 * (int64_t)v10 + (int64_t)v14);
                    if (((int32_t)v11 & (int32_t)&g1) == 0) {
                        // 0x154e
                        *v5 = v10;
                        v9 = (char *)((int64_t)v5 + 1);
                    } else {
                        // 0x1528
                        v9 = v5;
                        if (*(char *)(v6 + 1) != 32) {
                            // 0x153a
                            *v5 = 32;
                            v9 = (char *)((int64_t)v5 + 1);
                        }
                    }
                } else {
                    // 0x14d4
                    *v5 = (char)toupper((int32_t)c);
                    v9 = (char *)((int64_t)v5 + 1);
                }
            } else {
                // 0x1489
                *v5 = v20;
                v9 = (char *)((int64_t)v5 + 1);
            }
            // 0x1569
            v15 = v9;
            v16 = v6 + 1;
            v17 = (char *)v16;
            v18 = *v17;
            v19 = *v7 != 62 ? v8 : 0;
            v4 = v15;
        }
    }
    // 0x1598
    *v4 = 0;
    sprintf((char *)str, ""%s"", &v3);
    int64_t result = 0; // 0x15d5
    if (v1 != __readfsqword(40)) {
        // 0x15d7
        __stack_chk_fail();
        result = &g6;
    }
    // 0x15dc
    return result;
}

// Address range: 0x15e0 - 0x15ed
int64_t _fini(void) {
    // 0x15e0
    int64_t result; // 0x15e0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","      #include <stdio.h>
        #include <stdlib.h>
        #include <ctype.h>

        int main(int argc, char ** argv) {
            if (argc != 3) {
                fprintf(stderr, ""Usage: %s [input file] [output file]\n"", argv[0]);
                exit(1);
            }
            char * file_path = argv[1];
            char * file_path2 = argv[2];
            FILE * file = fopen(file_path, ""r"");
            if (file == NULL) {
                fprintf(stderr, ""Failed to open input file '%s'\n"", file_path);
                exit(1);
            }
            FILE * file2 = fopen(file_path2, ""w"");
            if (file2 == NULL) {
                fprintf(stderr, ""Failed to open output file '%s'\n"", file_path2);
                exit(1);
            }
            int64_t str;
            if (fgets((char *)&str, 1024, file) != NULL) {
                beautify(&str);
                fputs((char *)&str, file2);
                while (fgets((char *)&str, 1024, file) != NULL) {
                    beautify(&str);
                    fputs((char *)&str, file2);
                }
            }
            fclose(file);
            fclose(file2);
            return 0;
        }

        int beautify(int64_t * str) {
            char * v5 = (char *)str;
            int64_t v6 = (int64_t)str;
            char * v7 = (char *)str;
            char v8 = *v7;
            char v9 = *v7 != 60 ? 0 : 1;
            char * v10 = v5;
            char v11 = *v7;
            char v12 = *v7 != 60 ? v9 : 0;
            if (v12 == 0) {
                int16_t * v13 = *__ctype_b_loc();
                char c = *v7;
                int16_t v14 = *(int16_t *)(2 * (int64_t)c + (int64_t)v13);
                if (((int32_t)v14 & (int32_t)&g3) == 0) {
                    int16_t * v15 = *__ctype_b_loc();
                    char v16 = *v7;
                    int16_t v17 = *(int16_t *)(2 * (int64_t)v16 + (int64_t)v15);
                    if (((int32_t)v17 & (int32_t)&g1) == 0) {
                        *v5 = v16;
                        v10 = (char *)((int64_t)v5 + 1);
                    } else {
                        v10 = v5;
                        if (*(char *)(v6 + 1) != 32) {
                            *v5 = 32;
                            v10 = (char *)((int64_t)v5 + 1);
                        }
                    }
                } else {
                    *v5 = (char)toupper((int32_t)c);
                    v10 = (char *)((int64_t)v5 + 1);
                }
            } else {
                *v5 = v8;
                v10 = (char *)((int64_t)v5 + 1);
            }
            char * v18 = v10;
            int64_t v19 = v6 + 1;
            char * v20 = (char *)v19;
            char v21 = *v20;
            char v22 = *v7 != 62 ? v12 : 0;
            v5 = v18;
            while (v21 != 0) {
                v6 = v19;
                v7 = v20;
                char v23 = v21;
                v8 = v23 != 60 ? v22 : 0;
                if (v8 == 0) {
                    int16_t * v24 = *__ctype_b_loc();
                    char c = *v7;
                    int16_t v25 = *(int16_t *)(2 * (int64_t)c + (int64_t)v24);
                    if (((int32_t)v25 & (int32_t)&g3) == 0) {
                        int16_t * v26 = *__ctype_b_loc();
                        char v27 = *v7;
                        int16_t v28 = *(int16_t *)(2 * (int64_t)v27 + (int64_t)v26);
                        if (((int32_t)v28 & (int32_t)&g1) == 0) {
                            *v5 = v27;
                            v10 = (char *)((int64_t)v5 + 1);
                        } else {
                            v10 = v5;
                            if (*(char *)(v6 + 1) != 32) {
                                *v5 = 32;
                                v10 = (char *)((int64_t)v5 + 1);
                            }
                        }
                    } else {
                        *v5 = (char)toupper((int32_t)c);
                        v10 = (char *)((int64_t)v5 + 1);
                    }
                } else {
                    *v5 = v23;
                    v10 = (char *)((int64_t)v5 + 1);
                }
                v18 = v10;
                v19 = v6 + 1;
                v20 = (char *)v19;
                v21 = *v20;
                v22 = *v7 != 62 ? v8 : 0;
                v5 = v18;
            }
            *v5 = 0;
            sprintf((char *)str, ""%s"", v5);
            return 0;
        }


",1
"//FormAI DATASET v1.0 Category: Building a FTP Client ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define SERVER ""127.0.0.1""
#define PORT 21

void cyberpunk_authenticate(int sock_fd, char *username, char *password) {
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    recv(sock_fd, buffer, 1024, 0);
    printf(""FTP Server Response: %s\n"", buffer);
    char* user_command = malloc(strlen(username) + 6);
    sprintf(user_command, ""USER %s\r\n"", username);
    printf(""Client Request: %s"", user_command);
    send(sock_fd, user_command, strlen(user_command), 0);
    memset(buffer, 0, sizeof(buffer));
    recv(sock_fd, buffer, 1024, 0);
    printf(""FTP Server Response: %s\n"", buffer);
    char* pass_command = malloc(strlen(password) + 6);
    sprintf(pass_command, ""PASS %s\r\n"", password);
    printf(""Client Request: %s"", pass_command);
    send(sock_fd, pass_command, strlen(pass_command), 0);
    memset(buffer, 0, sizeof(buffer));
    recv(sock_fd, buffer, 1024, 0);
    printf(""FTP Server Response: %s\n"", buffer);
    free(user_command);
    free(pass_command);
}

void cyberpunk_download(int sock_fd, char *filename) {
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    char* retr_command = malloc(strlen(filename) + 6);
    sprintf(retr_command, ""RETR %s\r\n"", filename);
    printf(""Client Request: %s"", retr_command);
    send(sock_fd, retr_command, strlen(retr_command), 0);
    recv(sock_fd, buffer, 1024, 0);
    printf(""FTP Server Response: %s\n"", buffer);
    FILE *file = fopen(filename, ""w"");
    while(recv(sock_fd, buffer, 1024, 0) > 0) {
        fprintf(file, ""%s"", buffer);
        memset(buffer, 0, sizeof(buffer));
    }
    fclose(file);
    free(retr_command);
}

void cyberpunk_upload(int sock_fd, char *filename) {
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    char* stor_command = malloc(strlen(filename) + 6);
    sprintf(stor_command, ""STOR %s\r\n"", filename);
    printf(""Client Request: %s"", stor_command);
    send(sock_fd, stor_command, strlen(stor_command), 0);
    FILE *file = fopen(filename, ""r"");
    while(fgets(buffer, 1024, file) != NULL) {
        send(sock_fd, buffer, strlen(buffer), 0);
        memset(buffer, 0, sizeof(buffer));
    }
    fclose(file);
    recv(sock_fd, buffer, 1024, 0);
    printf(""FTP Server Response: %s\n"", buffer);
    free(stor_command);
}

void cyberpunk_disconnect(int sock_fd) {
    char* quit_command = ""QUIT\r\n"";
    printf(""Client Request: %s"", quit_command);
    send(sock_fd, quit_command, strlen(quit_command), 0);
    close(sock_fd);
}

int main() {
    int sock_fd;
    struct sockaddr_in server_addr;
    sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    inet_pton(AF_INET, SERVER, &server_addr.sin_addr);
    connect(sock_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));
    char username[256];
    char password[256];
    printf(""Enter FTP Username: "");
    scanf(""%s"", username);
    printf(""Enter FTP Password: "");
    scanf(""%s"", password);
    cyberpunk_authenticate(sock_fd, username, password);
    char filename[256];
    printf(""Enter filename to download/upload: "");
    scanf(""%s"", filename);
    char download_or_upload;
    printf(""Do you want to download or upload? (d/u): "");
    scanf("" %c"", &download_or_upload);
    if(download_or_upload == 'd') {
        cyberpunk_download(sock_fd, filename);
    } else if (download_or_upload == 'u') {
        cyberpunk_upload(sock_fd, filename);
    } else {
        printf(""Invalid Input!"");
    }
    cyberpunk_disconnect(sock_fd);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t cyberpunk_authenticate(int64_t a1, int64_t * str, int64_t * str2);
int64_t cyberpunk_disconnect(int64_t a1);
int64_t cyberpunk_download(int64_t a1, int64_t * str);
int64_t cyberpunk_upload(int64_t a1, int64_t * str);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1160(int64_t * d);
void function_1170(int64_t * ptr);
int32_t function_1180(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_1190(struct _IO_FILE * stream);
int32_t function_11a0(char * s);
void function_11b0(void);
int16_t function_11c0(int16_t hostshort);
int32_t function_11d0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11e0(char * format, ...);
int32_t function_11f0(char * s, struct _IO_FILE * stream);
int64_t * function_1200(int64_t * s, int32_t c, int32_t n);
int32_t function_1210(int32_t fd);
char * function_1220(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1230(int32_t af, char * cp, int64_t * buf);
int64_t * function_1240(int32_t size);
struct _IO_FILE * function_1250(char * filename, char * modes);
int32_t function_1260(char * format, ...);
int32_t function_1270(char * s, char * format, ...);
int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1290(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1160 - 0x116b
void function_1160(int64_t * d) {
    // 0x1160
    __cxa_finalize(d);
}

// Address range: 0x1170 - 0x117b
void function_1170(int64_t * ptr) {
    // 0x1170
    free(ptr);
}

// Address range: 0x1180 - 0x118b
int32_t function_1180(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1180
    return recv(fd, buf, n, flags);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(struct _IO_FILE * stream) {
    // 0x1190
    return fclose(stream);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(char * s) {
    // 0x11a0
    return strlen(s);
}

// Address range: 0x11b0 - 0x11bb
void function_11b0(void) {
    // 0x11b0
    __stack_chk_fail();
}

// Address range: 0x11c0 - 0x11cb
int16_t function_11c0(int16_t hostshort) {
    // 0x11c0
    return htons(hostshort);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x11d0
    return send(fd, buf, n, flags);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(char * format, ...) {
    // 0x11e0
    return printf(format);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(char * s, struct _IO_FILE * stream) {
    // 0x11f0
    return fputs(s, stream);
}

// Address range: 0x1200 - 0x120b
int64_t * function_1200(int64_t * s, int32_t c, int32_t n) {
    // 0x1200
    return memset(s, c, n);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int32_t fd) {
    // 0x1210
    return close(fd);
}

// Address range: 0x1220 - 0x122b
char * function_1220(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1220
    return fgets(s, n, stream);
}

// Address range: 0x1230 - 0x123b
int32_t function_1230(int32_t af, char * cp, int64_t * buf) {
    // 0x1230
    return inet_pton(af, cp, buf);
}

// Address range: 0x1240 - 0x124b
int64_t * function_1240(int32_t size) {
    // 0x1240
    return malloc(size);
}

// Address range: 0x1250 - 0x125b
struct _IO_FILE * function_1250(char * filename, char * modes) {
    // 0x1250
    return fopen(filename, modes);
}

// Address range: 0x1260 - 0x126b
int32_t function_1260(char * format, ...) {
    // 0x1260
    return scanf(format);
}

// Address range: 0x1270 - 0x127b
int32_t function_1270(char * s, char * format, ...) {
    // 0x1270
    return sprintf(s, format);
}

// Address range: 0x1280 - 0x128b
int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1280
    return connect(fd, addr, len);
}

// Address range: 0x1290 - 0x129b
int32_t function_1290(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1290
    return socket(domain, type, protocol);
}

// Address range: 0x12a0 - 0x12c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x12a0
    int64_t v1; // 0x12a0
    __libc_start_main(0x19fa, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x12d0 - 0x12f9
int64_t deregister_tm_clones(void) {
    // 0x12d0
    return &g2;
}

// Address range: 0x1300 - 0x1339
int64_t register_tm_clones(void) {
    // 0x1300
    return 0;
}

// Address range: 0x1340 - 0x1379
int64_t __do_global_dtors_aux(void) {
    // 0x1340
    if (*(char *)&g2 != 0) {
        // 0x1378
        int64_t result; // 0x1340
        return result;
    }
    // 0x134d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x135b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1367
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1380 - 0x1389
int64_t frame_dummy(void) {
    // 0x1380
    return register_tm_clones();
}

// Address range: 0x1389 - 0x160f
int64_t cyberpunk_authenticate(int64_t a1, int64_t * str, int64_t * str2) {
    int32_t sock = a1; // 0x1398
    int64_t v1 = __readfsqword(40); // 0x13ac
    int64_t buf; // bp-1048, 0x1389
    memset(&buf, 0, (int32_t)&g1);
    recv(sock, &buf, (int32_t)&g1, 0);
    printf(""FTP Server Response: %s\n"", &buf);
    int64_t * mem = malloc(strlen((char *)str) + 6); // 0x1426
    sprintf((char *)mem, ""USER %s\r\n"", str);
    printf(""Client Request: %s"", mem);
    send(sock, mem, strlen((char *)mem), 0);
    memset(&buf, 0, (int32_t)&g1);
    recv(sock, &buf, (int32_t)&g1, 0);
    printf(""FTP Server Response: %s\n"", &buf);
    int64_t * mem2 = malloc(strlen((char *)str2) + 6); // 0x150b
    sprintf((char *)mem2, ""PASS %s\r\n"", str2);
    printf(""Client Request: %s"", mem2);
    send(sock, mem2, strlen((char *)mem2), 0);
    memset(&buf, 0, (int32_t)&g1);
    recv(sock, &buf, (int32_t)&g1, 0);
    printf(""FTP Server Response: %s\n"", &buf);
    free(mem);
    free(mem2);
    int64_t result = 0; // 0x1606
    if (v1 != __readfsqword(40)) {
        // 0x1608
        __stack_chk_fail();
        result = &g3;
    }
    // 0x160d
    return result;
}

// Address range: 0x160f - 0x17cb
int64_t cyberpunk_download(int64_t a1, int64_t * str) {
    int32_t sock = a1; // 0x161e
    int64_t v1 = __readfsqword(40); // 0x162b
    int64_t buf; // bp-1048, 0x160f
    memset(&buf, 0, (int32_t)&g1);
    int64_t * mem = malloc(strlen((char *)str) + 6); // 0x1669
    sprintf((char *)mem, ""RETR %s\r\n"", str);
    printf(""Client Request: %s"", mem);
    send(sock, mem, strlen((char *)mem), 0);
    recv(sock, &buf, (int32_t)&g1, 0);
    printf(""FTP Server Response: %s\n"", &buf);
    struct _IO_FILE * file = fopen((char *)str, ""w""); // 0x1733
    int32_t v2 = recv(sock, &buf, (int32_t)&g1, 0); // 0x178c
    if (v2 >= 0 == (v2 != 0)) {
        fputs((char *)&buf, file);
        memset(&buf, 0, (int32_t)&g1);
        int32_t v3 = recv(sock, &buf, (int32_t)&g1, 0); // 0x178c
        while (v3 >= 0 == (v3 != 0)) {
            // 0x1741
            fputs((char *)&buf, file);
            memset(&buf, 0, (int32_t)&g1);
            v3 = recv(sock, &buf, (int32_t)&g1, 0);
        }
    }
    // 0x1796
    fclose(file);
    free(mem);
    int64_t result = 0; // 0x17c2
    if (v1 != __readfsqword(40)) {
        // 0x17c4
        __stack_chk_fail();
        result = &g3;
    }
    // 0x17c9
    return result;
}

// Address range: 0x17cb - 0x1996
int64_t cyberpunk_upload(int64_t a1, int64_t * str) {
    int32_t sock = a1; // 0x17da
    int64_t v1 = __readfsqword(40); // 0x17e7
    int64_t str2; // bp-1048, 0x17cb
    memset(&str2, 0, (int32_t)&g1);
    int64_t * mem = malloc(strlen((char *)str) + 6); // 0x1825
    sprintf((char *)mem, ""STOR %s\r\n"", str);
    printf(""Client Request: %s"", mem);
    send(sock, mem, strlen((char *)mem), 0);
    struct _IO_FILE * file = fopen((char *)str, ""r""); // 0x18b3
    if (fgets((char *)&str2, (int32_t)&g1, file) != NULL) {
        send(sock, &str2, strlen((char *)&str2), 0);
        memset(&str2, 0, (int32_t)&g1);
        while (fgets((char *)&str2, (int32_t)&g1, file) != NULL) {
            // 0x18c1
            send(sock, &str2, strlen((char *)&str2), 0);
            memset(&str2, 0, (int32_t)&g1);
        }
    }
    // 0x1925
    fclose(file);
    recv(sock, &str2, (int32_t)&g1, 0);
    printf(""FTP Server Response: %s\n"", &str2);
    free(mem);
    int64_t result = 0; // 0x198d
    if (v1 != __readfsqword(40)) {
        // 0x198f
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1994
    return result;
}

// Address range: 0x1996 - 0x19fa
int64_t cyberpunk_disconnect(int64_t a1) {
    int32_t sock = a1; // 0x19a2
    printf(""Client Request: %s"", ""QUIT\r\n"");
    send(sock, (int64_t *)""QUIT\r\n"", strlen(""QUIT\r\n""), 0);
    return close(sock);
}

// Address range: 0x19fa - 0x1c0d
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1a09
    uint32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1a27
    int64_t addr; // bp-808, 0x19fa
    memset(&addr, 0, 16);
    addr = 2;
    htons(21);
    int64_t address; // bp-804, 0x19fa
    inet_pton(AF_INET, ""127.0.0.1"", &address);
    connect(sock_fd, (struct sockaddr *)&addr, 16);
    printf(""Enter FTP Username: "");
    int64_t v2; // bp-792, 0x19fa
    scanf(""%s"", &v2);
    printf(""Enter FTP Password: "");
    int64_t v3; // bp-536, 0x19fa
    scanf(""%s"", &v3);
    int64_t v4 = sock_fd; // 0x1b1e
    cyberpunk_authenticate(v4, &v2, &v3);
    printf(""Enter filename to download/upload: "");
    int64_t v5; // bp-280, 0x19fa
    scanf(""%s"", &v5);
    printf(""Do you want to download or upload? (d/u): "");
    char v6; // bp-813, 0x19fa
    scanf("" %c"", &v6);
    if (v6 != 100) {
        if (v6 != 117) {
            // 0x1bd1
            printf(""Invalid Input!"");
        } else {
            // 0x1bb8
            cyberpunk_upload(v4, &v5);
        }
    } else {
        // 0x1b94
        cyberpunk_download(v4, &v5);
    }
    // 0x1be5
    cyberpunk_disconnect(v4);
    int64_t result = 0; // 0x1c04
    if (v1 != __readfsqword(40)) {
        // 0x1c06
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1c0b
    return result;
}

// Address range: 0x1c10 - 0x1c1d
int64_t _fini(void) {
    // 0x1c10
    int64_t result; // 0x1c10
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 32

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <arpa/inet.h>
        #include <netinet/in.h>
        #include <sys/socket.h>
        #include <unistd.h>

        int main(int argc, char ** argv) {
            int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            struct sockaddr_in addr;
            memset(&addr, 0, sizeof(addr));
            addr.sin_family = AF_INET;
            addr.sin_port = htons(21);
            inet_pton(AF_INET, ""127.0.0.1"", &addr.sin_addr);
            connect(sock_fd, (struct sockaddr *)&addr, sizeof(addr));
            char username[100];
            char password[100];
            printf(""Enter FTP Username: "");
            scanf(""%s"", username);
            printf(""Enter FTP Password: "");
            scanf(""%s"", password);
            char filename[100];
            printf(""Enter filename to download/upload: "");
            scanf(""%s"", filename);
            char choice;
            printf(""Do you want to download or upload? (d/u): "");
            scanf("" %c"", &choice);
            if (choice == 'd') {
                download(sock_fd, filename);
            } else if (choice == 'u') {
                upload(sock_fd, filename);
            } else {
                printf(""Invalid Input!"");
            }
            close(sock_fd);
            return 0;
        }

        void download(int sock_fd, char * filename) {
            char buf[1024];
            memset(buf, 0, sizeof(buf));
            recv(sock_fd, buf, sizeof(buf), 0);
            printf(""FTP Server Response: %s\n"", buf);
            char * mem = malloc(strlen(filename) + 6);
            sprintf(mem, ""USER %s\r\n"", filename);
            printf(""Client Request: %s"", mem);
            send(sock_fd, mem, strlen(mem), 0);
            memset(buf, 0, sizeof(buf));
            recv(sock_fd, buf, sizeof(buf), 0);
            printf(""FTP Server Response: %s\n"", buf);
            char * mem2 = malloc(strlen(filename) + 6);
            sprintf(mem2, ""PASS %s\r\n"", filename);
            printf(""Client Request: %s"", mem2);
            send(sock_fd, mem2, strlen(mem2), 0);
            memset(buf, 0, sizeof(buf));
            recv(sock_fd, buf, sizeof(buf), 0);
            printf(""FTP Server Response: %s\n"", buf);
            FILE * file = fopen(filename, ""w"");
            int len = recv(sock_fd, buf, sizeof(buf), 0);
            if (len >= 0 == (len != 0)) {
                fputs(buf, file);
                memset(buf, 0, sizeof(buf));
                int len2 = recv(sock_fd, buf, sizeof(buf), 0);
                while (len2 >= 0 == (len2 != 0)) {
                    fputs(buf, file);
                    memset(buf, 0, sizeof(buf));
                    len2 = recv(sock_fd, buf, sizeof(buf), 0);
                }
            }
            fclose(file);
            free(mem);
            free(mem2);
        }

        void upload(int sock_fd, char * filename) {
            char buf[1024];
            memset(buf, 0, sizeof(buf));
            recv(sock_fd, buf, sizeof(buf), 0);
            printf(""FTP Server Response: %s\n"", buf);
            char * mem = malloc(strlen(filename) + 6);
            sprintf(mem, ""RETR %s\r\n"", filename);
            printf(""Client Request: %s"", mem);
            send(sock_fd, mem, strlen(mem), 0);
            memset(buf, 0, sizeof(buf));
            recv(sock_fd, buf, sizeof(buf), 0);
            printf(""FTP Server Response: %s\n"", buf);
            FILE * file = fopen(filename, ""r"");
            if (fgets(buf, sizeof(buf), file) != NULL) {
                send(sock_fd, buf, strlen(buf), 0);
                memset(buf, 0, sizeof(buf));
                while (fgets(buf, sizeof(buf), file) != NULL) {
                    send(sock_fd, buf, strlen(buf), 0);
                    memset(buf, 0, sizeof(buf));
                }
            }
            fclose(file);
            recv(sock_fd, buf, sizeof(buf), 0);
            printf(""FTP Server Response: %s\n"", buf);
            free(mem);
        }


",2
"//FormAI DATASET v1.0 Category: Log analysis ; Style: scalable
#include <stdio.h>
#include <stdlib.h>

#define MAX_LOG_ENTRIES 10000 // Maximum number of log entries to read
#define MAX_LOG_LINE_LENGTH 200 // Maximum length of log line

// Struct to hold a log entry
typedef struct {
    long timestamp; // Unix timestamp of log entry
    char *message; // Log message
} log_entry;

// Helper function to parse log line into a log entry
log_entry parse_log_line(char *line) {
    char *timestamp_str = strtok(line, "" ""); // Get timestamp string
    long timestamp = atol(timestamp_str); // Convert string to long integer
    char *message = strtok(NULL, """"); // Get log message
    log_entry entry = {timestamp, message}; // Create log entry struct
    return entry;
}

int main(int argc, char **argv) {
    if (argc != 2) { // Check for correct number of arguments
        printf(""Usage: log_analysis <log_file>\n"");
        exit(1);
    }

    char *log_file = argv[1];
    FILE *file = fopen(log_file, ""r"");
    char line[MAX_LOG_LINE_LENGTH]; // Buffer for reading log lines
    int num_entries = 0; // Counter for number of log entries read
    log_entry entries[MAX_LOG_ENTRIES];

    if (file) { // File opened successfully
        while (fgets(line, MAX_LOG_LINE_LENGTH, file) != NULL && num_entries < MAX_LOG_ENTRIES) {
            entries[num_entries] = parse_log_line(line); // Parse log line and store in array
            num_entries++;
        }
        fclose(file); // Close file
    }

    // Print out log entries
    for (int i = 0; i < num_entries; i++) {
        printf(""%ld: %s"", entries[i].timestamp, entries[i].message);
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
int32_t function_10d0(char * s);
int32_t function_10e0(struct _IO_FILE * stream);
void function_10f0(void);
int32_t function_1100(char * format, ...);
char * function_1110(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1120(char * nptr);
struct _IO_FILE * function_1130(char * filename, char * modes);
char * function_1140(char * s, char * delim);
void function_1150(int32_t status);
int64_t parse_log_line(int64_t * str);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x200a
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(struct _IO_FILE * stream) {
    // 0x10e0
    return fclose(stream);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(void) {
    // 0x10f0
    __stack_chk_fail();
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return printf(format);
}

// Address range: 0x1110 - 0x111b
char * function_1110(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1110
    return fgets(s, n, stream);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * nptr) {
    // 0x1120
    return atol(nptr);
}

// Address range: 0x1130 - 0x113b
struct _IO_FILE * function_1130(char * filename, char * modes) {
    // 0x1130
    return fopen(filename, modes);
}

// Address range: 0x1140 - 0x114b
char * function_1140(char * s, char * delim) {
    // 0x1140
    return strtok(s, delim);
}

// Address range: 0x1150 - 0x115b
void function_1150(int32_t status) {
    // 0x1150
    exit(status);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x12c3, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g2;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g2 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x12c3
int64_t parse_log_line(int64_t * str) {
    int32_t str_as_l = atol(strtok((char *)str, "" "")); // 0x1281
    strtok(NULL, (char *)&g1);
    return str_as_l;
}

// Address range: 0x12c3 - 0x1473
int main(int argc, char ** argv) {
    // 0x12c3
    int64_t v1; // bp-16, 0x12c3
    int64_t v2 = &v1; // 0x12cc
    int64_t v3; // bp-159760, 0x12c3
    while (v2 - 0x1000 != (int64_t)&v3) {
        // 0x12d4
        v2 -= 0x1000;
    }
    int64_t v4 = __readfsqword(40); // 0x12f9
    if ((int32_t)argc != 2) {
        // 0x1311
        puts(""Usage: log_analysis <log_file>"");
        exit(1);
        // UNREACHABLE
    }
    struct _IO_FILE * file = fopen((char *)*(int64_t *)((int64_t)argv + 8), ""r""); // 0x1350
    if (file != NULL) {
        // 0x13a9
        int64_t str2; // bp-232, 0x12c3
        if (fgets((char *)&str2, 200, file) == NULL) {
            // 0x13e4
            fclose(file);
        } else {
            // 0x1372
            int64_t v5; // bp-8, 0x12c3
            int64_t v6 = (int64_t)&v5 - 16; // 0x137e
            int64_t v7 = 0; // 0x12c3
            int64_t v8 = 16 * v7 + v6; // 0x1382
            *(int64_t *)(v8 - 0x271d0) = parse_log_line(&str2);
            *(int64_t *)(v8 - 0x271c8) = (int64_t)file;
            int64_t v9 = v7 + 1;
            char * str = fgets((char *)&str2, 200, file); // 0x13bf
            v7 = v9;
            while (v9 < 0x2710 == (str != NULL)) {
                // 0x1372
                v8 = 16 * v7 + v6;
                *(int64_t *)(v8 - 0x271d0) = parse_log_line(&str2);
                *(int64_t *)(v8 - 0x271c8) = (int64_t)file;
                v9 = v7 + 1;
                str = fgets((char *)&str2, 200, file);
                v7 = v9;
            }
            // 0x13f0
            fclose(file);
            int64_t v10 = 0;
            int64_t v11 = 16 * v10 + v6; // 0x1400
            int64_t v12 = *(int64_t *)(v11 - 0x271d0); // 0x1425
            printf(""%ld: %s"", (int32_t)v12, (char *)*(int64_t *)(v11 - 0x271c8));
            v10++;
            while (v10 != (v9 & 0xffffffff)) {
                // 0x13f0
                v11 = 16 * v10 + v6;
                v12 = *(int64_t *)(v11 - 0x271d0);
                printf(""%ld: %s"", (int32_t)v12, (char *)*(int64_t *)(v11 - 0x271c8));
                v10++;
            }
        }
    }
    int64_t result = 0; // 0x1466
    if (v4 != __readfsqword(40)) {
        // 0x1468
        __stack_chk_fail();
        result = &g3;
    }
    // 0x146d
    return result;
}

// Address range: 0x1474 - 0x1481
int64_t _fini(void) {
    // 0x1474
    int64_t result; // 0x1474
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 19

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            if (argc != 2) {
                puts(""Usage: log_analysis <log_file>"");
                exit(1);
            }
            FILE * file = fopen(argv[1], ""r"");
            if (file == NULL) {
                puts(""Error opening file"");
                exit(1);
            }
            char str[200];
            if (fgets(str, 200, file) == NULL) {
                puts(""Error reading file"");
                exit(1);
            }
            int i = 0;
            while (fgets(str, 200, file) != NULL) {
                int line = atol(strtok(str, "" ""));
                strtok(NULL, "" "");
                printf(""%d: %s"", line, str);
                i++;
            }
            fclose(file);
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Searching algorithm ; Style: surrealist
#include <stdio.h>
#include <stdlib.h>

int surrealSearch(int* array, int size, int element) {
   int startPosition = 0;
   int endPosition = size - 1;

   while (startPosition <= endPosition) {
       int midpoint = (startPosition + endPosition) / 2;

       if (array[midpoint] == element) {
           return midpoint;
       }

       if (array[startPosition] <= array[midpoint]) {
           if (array[startPosition] <= element && element < array[midpoint]) {
               endPosition = midpoint - 1;
           } else {
               startPosition = midpoint + 1;
           }
       } else {
           if (array[midpoint] < element && element <= array[endPosition]) {
               startPosition = midpoint + 1;
           } else {
               endPosition = midpoint - 1;
           }
       }
   }

   return -1;
}

int main() {
   int surrealArray[] = { 4, 5, 6, 7, 8, 9, 1, 2, 3 };
   int surrealSize = sizeof(surrealArray) / sizeof(surrealArray[0]);
   int surrealElement = 5;

   int surrealResult = surrealSearch(surrealArray, surrealSize, surrealElement);

   if (surrealResult == -1) {
       printf(""Element not found in surreal array."");
   } else {
       printf(""Element found at surreal index %d"", surrealResult);
   }

   return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1050(int64_t * d);
void function_1060(void);
int32_t function_1070(char * format, ...);
int64_t register_tm_clones(void);
int64_t surrealSearch(int32_t * a1, int64_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1050 - 0x105b
void function_1050(int64_t * d) {
    // 0x1050
    __cxa_finalize(d);
}

// Address range: 0x1060 - 0x106b
void function_1060(void) {
    // 0x1060
    __stack_chk_fail();
}

// Address range: 0x1070 - 0x107b
int32_t function_1070(char * format, ...) {
    // 0x1070
    return printf(format);
}

// Address range: 0x1080 - 0x10a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1080
    int64_t v1; // 0x1080
    __libc_start_main(0x12a0, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10b0 - 0x10d9
int64_t deregister_tm_clones(void) {
    // 0x10b0
    return &g1;
}

// Address range: 0x10e0 - 0x1119
int64_t register_tm_clones(void) {
    // 0x10e0
    return 0;
}

// Address range: 0x1120 - 0x1159
int64_t __do_global_dtors_aux(void) {
    // 0x1120
    if (*(char *)&g1 != 0) {
        // 0x1158
        int64_t result; // 0x1120
        return result;
    }
    // 0x112d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x113b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1147
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1160 - 0x1169
int64_t frame_dummy(void) {
    // 0x1160
    return register_tm_clones();
}

// Address range: 0x1169 - 0x12a0
int64_t surrealSearch(int32_t * a1, int64_t a2, int32_t a3) {
    int32_t v1 = (int32_t)a2 - 1; // 0x1185
    if (v1 < 0) {
        // 0x129e
        return 0xffffffff;
    }
    int64_t v2 = (int64_t)a1; // 0x11b1
    int64_t v3 = a3;
    int32_t v4 = v1;
    int32_t v5 = 0;
    int32_t v6 = v4 + v5; // 0x1196
    uint32_t v7 = v6 + (int32_t)(v6 < 0) >> 1; // 0x119f
    uint32_t v8 = *(int32_t *)(4 * (int64_t)v7 + v2); // 0x11b8
    if (v8 == a3) {
        // break (via goto) -> 0x11bf
        goto lab_0x11bf;
    }
    uint32_t v9 = *(int32_t *)(4 * (int64_t)v5 + v2); // 0x11db
    uint32_t v10; // 0x1272
    if (v9 > v8) {
        if (v3 > (int64_t)v8) {
            // 0x125e
            v10 = *(int32_t *)(4 * (int64_t)v4 + v2);
            if (v3 <= (int64_t)v10) {
                // break -> 0x128d
                break;
            }
        }
    } else {
        if (v3 < (int64_t)v8 != v3 >= (int64_t)v9) {
            // break -> 0x128d
            break;
        }
    }
    // 0x128d
    while (v5 < v7) {
        // 0x1190
        v4 = v7 - 1;
        v6 = v4 + v5;
        v7 = v6 + (int32_t)(v6 < 0) >> 1;
        v8 = *(int32_t *)(4 * (int64_t)v7 + v2);
        if (v8 == a3) {
            // break (via goto) -> 0x11bf
            goto lab_0x11bf;
        }
        // 0x11c7
        v9 = *(int32_t *)(4 * (int64_t)v5 + v2);
        if (v9 > v8) {
            if (v3 > (int64_t)v8) {
                // 0x125e
                v10 = *(int32_t *)(4 * (int64_t)v4 + v2);
                if (v3 <= (int64_t)v10) {
                    // break -> 0x128d
                    break;
                }
            }
        } else {
            if (v3 < (int64_t)v8 != v3 >= (int64_t)v9) {
                // break -> 0x128d
                break;
            }
        }
    }
    // 0x129e
    return 0xffffffff;
}

// Address range: 0x12a0 - 0x136f
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x12ac
    int32_t v2 = 4; // bp-56, 0x12bb
    int64_t v3 = surrealSearch(&v2, 9, 5); // 0x1317
    if ((int32_t)v3 != -1) {
        // 0x133b
        printf(""Element found at surreal index %d"", v3 & 0xffffffff);
    } else {
        // 0x1325
        printf(""Element not found in surreal array."");
    }
    int64_t result = 0; // 0x1366
    if (v1 != __readfsqword(40)) {
        // 0x1368
        __stack_chk_fail();
        result = &g2;
    }
    // 0x136d
    return result;
}

// Address range: 0x1370 - 0x137d
int64_t _fini(void) {
    // 0x1370
    int64_t result; // 0x1370
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 12

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            int64_t v1 = __readfsqword(40);
            int32_t v2 = 4;
            int64_t v3 = surrealSearch(&v2, 9, 5);
            if ((int32_t)v3 != -1) {
                printf(""Element found at surreal index %d"", v3 & 0xffffffff);
            } else {
                printf(""Element not found in surreal array."");
            }
            if (v1 != __readfsqword(40)) {
                __stack_chk_fail();
            }
            return 0;
        }

        int64_t surrealSearch(int32_t * a1, int64_t a2, int32_t a3) {
            int32_t v1 = (int32_t)a2 - 1;
            if (v1 < 0) {
                return 0xffffffff;
            }
            int64_t v2 = (int64_t)a1;
            int64_t v3 = a3;
            int32_t v4 = v1;
            int32_t v5 = 0;
            int32_t v6 = v4 + v5;
            uint32_t v7 = v6 + (int32_t)(v6 < 0) >> 1;
            uint32_t v8 = *(int32_t *)(4 * (int64_t)v7 + v2);
            if (v8 == a3) {
                return v7;
            }
            uint32_t v9 = *(int32_t *)(4 * (int64_t)v5 + v2);
            uint32_t v10;
            if (v9 > v8) {
                if (v3 > (int64_t)v8) {
                    v10 = *(int32_t *)(4 * (int64_t)v4 + v2);
                    if (v3 <= (int64_t)v10) {
                        break;
                    }
                }
            } else {
                if (v3 < (int64_t)v8 != v3 >= (int64_t)v9) {
                    break;
                }
            }
            while (v5 < v7) {
                v4 = v7 - 1;
                v6 = v4 + v5;
                v7 = v6 + (int32_t)(v6 < 0) >> 1;
                v8 = *(int32_t *)(4 * (int64_t)v7 + v2);
                if (v8 == a3) {
                    break;
                }
                v9 = *(int32_t *)(4 * (int64_t)v5 + v2);
                if (v9 > v8) {
                    if (v3 > (int64_t)v8) {
                        v10 = *(int32_t *)(4 * (int64_t)v4 + v2);
                        if (v3 <= (int64_t)v10) {
                            break;
                        }
                    }
                } else {
                    if (v3 < (int64_t)v8 != v3 >= (int64_t)v9) {
                        break;
                    }
                }
            }
            return 0xffffffff;
        }


",1
"//FormAI DATASET v1.0 Category: Ebook reader ; Style: romantic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BOOKS 100
#define MAX_PAGES 5000

typedef struct book {
    char title[100];
    char author[100];
    int num_pages;
    char pages[MAX_PAGES][1000];
} Book;

Book library[MAX_BOOKS]; // Global variable to hold books

int num_books = 0; // Global variable to hold number of books in library

void load_book(Book *book, char *filename) {
    FILE *file = fopen(filename, ""r"");
    char buffer[1000];
    int page_num = 0;
    while (fgets(buffer, 1000, file)) {
        if (strlen(buffer) > 1) { // Skip blank lines
            strcpy(book->pages[page_num], buffer);
            page_num++;
        }
    }
    fclose(file);
}

void add_book(char *title, char *author, char *filename) {
    if (num_books >= MAX_BOOKS) {
        printf(""Sorry, the library is full!\n"");
        return;
    }
    Book *book = &library[num_books];
    strcpy(book->title, title);
    strcpy(book->author, author);
    load_book(book, filename);
    book->num_pages = num_books;
    num_books++;
    printf(""Book added to library.\n"");
}

void print_page(Book *book, int page_num) {
    printf(""%s - %s\n\n"", book->title, book->author);
    printf(""%s\n"", book->pages[page_num]);
}

int main() {
    add_book(""Pride and Prejudice"", ""Jane Austen"", ""pride_and_prejudice.txt"");
    add_book(""Wuthering Heights"", ""Emily Bronte"", ""wuthering_heights.txt"");
    add_book(""Jane Eyre"", ""Charlotte Bronte"", ""jane_eyre.txt"");

    int book_num = 0;
    int page_num = 0;
    char input[10];
    while (1) {
        print_page(&library[book_num], page_num);
        printf(""Enter 'n' for next page, 'p' for previous page, 'q' to quit:"");
        fgets(input, 10, stdin);
        if (strcmp(input, ""n\n"") == 0) {
            if (page_num < library[book_num].num_pages - 1) {
                page_num++;
            }
        } else if (strcmp(input, ""p\n"") == 0) {
            if (page_num > 0) {
                page_num--;
            }
        } else if (strcmp(input, ""q\n"") == 0) {
            break;
        } else {
            printf(""Invalid input! Please enter 'n', 'p', or 'q'.\n"");
        }
    }
    printf(""Goodbye!\n"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t add_book(int64_t str2, int64_t str3, int64_t a3);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
char * function_10d0(char * dest, char * src);
int32_t function_10e0(char * s);
int32_t function_10f0(struct _IO_FILE * stream);
int32_t function_1100(char * s);
void function_1110(void);
int32_t function_1120(char * format, ...);
char * function_1130(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1140(char * s1, char * s2);
struct _IO_FILE * function_1150(char * filename, char * modes);
int64_t load_book(int64_t a1, int64_t file_path);
int64_t print_page(int64_t a1, int64_t a2);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int128_t g1; // 0x1dcdf4f0
int32_t g2 = 0; // 0x1dcdf4f1
int32_t g3 = 0; // 0x3e8
struct _IO_FILE * g4 = NULL; // 0x4020
char g5 = 0; // 0x4028
char * g6; // 0x4040
int64_t g7 = 0; // 0x4108
int128_t g8; // 0x4c4c0c
int32_t g9;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g9;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
char * function_10d0(char * dest, char * src) {
    // 0x10d0
    return strcpy(dest, src);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * s) {
    // 0x10e0
    return puts(s);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(struct _IO_FILE * stream) {
    // 0x10f0
    return fclose(stream);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * s) {
    // 0x1100
    return strlen(s);
}

// Address range: 0x1110 - 0x111b
void function_1110(void) {
    // 0x1110
    __stack_chk_fail();
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * format, ...) {
    // 0x1120
    return printf(format);
}

// Address range: 0x1130 - 0x113b
char * function_1130(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1130
    return fgets(s, n, stream);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * s1, char * s2) {
    // 0x1140
    return strcmp(s1, s2);
}

// Address range: 0x1150 - 0x115b
struct _IO_FILE * function_1150(char * filename, char * modes) {
    // 0x1150
    return fopen(filename, modes);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x1459, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return 0x4010;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (g5 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    g5 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x1339
int64_t load_book(int64_t a1, int64_t file_path) {
    int64_t v1 = __readfsqword(40); // 0x1266
    struct _IO_FILE * file = fopen((char *)file_path, ""r""); // 0x1289
    int64_t v2 = a1 + 204;
    int32_t v3 = 0; // 0x129f
    int64_t v4 = 0; // 0x129f
    while (true) {
        int64_t str; // bp-1016, 0x1249
        if (fgets((char *)&str, (int32_t)&g3, file) == NULL) {
            // break (via goto) -> 0x1313
            goto lab_0x1313;
        }
        // 0x12f3
        while (strlen((char *)&str) < 2) {
            // 0x12f3
            if (fgets((char *)&str, (int32_t)&g3, file) == NULL) {
                // break (via goto) -> 0x1313
                goto lab_0x1313;
            }
        }
        // 0x12b6
        strcpy((char *)(v2 + v4 * (int64_t)&g3), (char *)&str);
        v3++;
        v4 = v3;
    }
  lab_0x1313:
    // 0x1313
    fclose(file);
    int64_t result = 0; // 0x1330
    if (v1 != __readfsqword(40)) {
        // 0x1332
        __stack_chk_fail();
        result = &g9;
    }
    // 0x1337
    return result;
}

// Address range: 0x1339 - 0x13fa
int64_t add_book(int64_t str2, int64_t str3, int64_t a3) {
    int32_t v1 = *(int32_t *)&g1; // 0x1351
    int32_t puts_rc; // 0x1339
    if (v1 < 100) {
        int64_t v2 = (int64_t)v1 * (int64_t)&g8; // 0x1378
        int64_t str = v2 + (int64_t)&g6; // 0x1386
        strcpy((char *)str, (char *)str2);
        strcpy((char *)(v2 + (int64_t)&g6 + 100), (char *)str3);
        load_book(str, a3);
        int32_t v3 = *(int32_t *)&g1; // 0x13ca
        *(int32_t *)(v2 + (int64_t)&g6 + 200) = v3;
        *(int32_t *)&g1 = (int32_t)&g2;
        puts_rc = puts(""Book added to library."");
    } else {
        // 0x135c
        puts_rc = puts(""Sorry, the library is full!"");
    }
    // 0x13f8
    return puts_rc;
}

// Address range: 0x13fa - 0x1459
int64_t print_page(int64_t a1, int64_t a2) {
    // 0x13fa
    printf(""%s - %s\n\n"", (char *)a1, (char *)(a1 + 100));
    int32_t puts_rc = puts((char *)(a1 + 204 + (0x100000000 * a2 >> 32) * (int64_t)&g3)); // 0x1451
    return puts_rc;
}

// Address range: 0x1459 - 0x1605
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1465
    add_book((int64_t)""Pride and Prejudice"", (int64_t)""Jane Austen"", (int64_t)""pride_and_prejudice.txt"");
    add_book((int64_t)""Wuthering Heights"", (int64_t)""Emily Bronte"", (int64_t)""wuthering_heights.txt"");
    add_book((int64_t)""Jane Eyre"", (int64_t)""Charlotte Bronte"", (int64_t)""jane_eyre.txt"");
    int32_t v2 = 0; // 0x14e4
    while (true) {
        int32_t v3 = v2;
        int64_t v4 = v3; // 0x1504
        print_page((int64_t)&g6, v4);
        printf(""Enter 'n' for next page, 'p' for previous page, 'q' to quit:"");
        int64_t str; // bp-26, 0x1459
        fgets((char *)&str, 10, g4);
        int32_t v5; // 0x1459
        if (strcmp((char *)&str, ""n\n"") != 0) {
            while (strcmp((char *)&str, ""p\n"") != 0) {
                // 0x15ac
                if (strcmp((char *)&str, ""q\n"") == 0) {
                    // break (via goto) -> 0x15da
                    goto lab_0x15da;
                }
                // 0x15c6
                puts(""Invalid input! Please enter 'n', 'p', or 'q'."");
                print_page((int64_t)&g6, v4);
                printf(""Enter 'n' for next page, 'p' for previous page, 'q' to quit:"");
                fgets((char *)&str, 10, g4);
                if (strcmp((char *)&str, ""n\n"") == 0) {
                    goto lab_0x1554;
                }
            }
            // 0x1599
            v5 = v3 > 0;
        } else {
          lab_0x1554:;
            int32_t v6 = *(int32_t *)&g7; // 0x1567
            v5 = (int64_t)v3 < (int64_t)(v6 - 1);
        }
        // 0x14eb
        v2 = v5 + v3;
    }
  lab_0x15da:
    // 0x15da
    puts(""Goodbye!"");
    int64_t result = 0; // 0x15fc
    if (v1 != __readfsqword(40)) {
        // 0x15fe
        __stack_chk_fail();
        result = &g9;
    }
    // 0x1603
    return result;
}

// Address range: 0x1608 - 0x1615
int64_t _fini(void) {
    // 0x1608
    int64_t result; // 0x1608
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            int i = 0;
            char * str = malloc(100);
            char * str2 = malloc(100);
            char * str3 = malloc(100);
            char * str4 = malloc(100);
            char * str5 = malloc(100);
            char * str6 = malloc(100);
            char * str7 = malloc(100);
            char * str8 = malloc(100);
            char * str9 = malloc(100);
            char * str10 = malloc(100);
            char * str11 = malloc(100);
            char * str12 = malloc(100);
            char * str13 = malloc(100);
            char * str14 = malloc(100);
            char * str15 = malloc(100);
            char * str16 = malloc(100);
            char * str17 = malloc(100);
            char * str18 = malloc(100);
            char * str19 = malloc(100);
            char * str20 = malloc(100);
            char * str21 = malloc(100);
            char * str22 = malloc(100);
            char * str23 = malloc(100);
            char * str24 = malloc(100);
            char * str25 = malloc(100);
            char * str26 = malloc(100);
            char * str27 = malloc(100);
            char * str28 = malloc(100);
            char * str29 = malloc(100);
            char * str30 = malloc(100);
            char * str31 = malloc(100);
            char * str32 = malloc(100);
            char * str33 = malloc(100);
            char * str34 = malloc(100);
            char * str35 = malloc(100);
            char * str36 = malloc(100);
            char * str37 = malloc(100);
            char * str38 = malloc(100);
            char * str39 = malloc(100);
            char * str40 = malloc(100);
            char * str41 = malloc(100);
            char * str42 = malloc(100);
            char * str43 = malloc(100);
            char * str44 = malloc(100);
            char * str45 = malloc(100);
            char * str46 = malloc(100);
            char * str47 = malloc(100);
            char * str48 = malloc(100);
            char * str49 = malloc(100);
            char * str50 = malloc(100);
            char * str51 = malloc(100);
            char * str52 = malloc(100);
            char * str53 = malloc(100);
            char * str54 = malloc(100);
            char * str55 = malloc(100);
            char * str56 = malloc(100);
            char * str57 = malloc(100);
            char * str58 = malloc(100);
            char * str59 = malloc(100);
            char * str60 = malloc(100);
            char * str61 = malloc(100);
            char * str62 = malloc(100);
            char * str63 = malloc(100);
            char * str64 = malloc(100);
            char * str65 = malloc(100);
            char * str66 = malloc(100);
            char * str67 = malloc(100);
            char * str68 = malloc(100);
            char * str69 = malloc(100);
            char * str70 = malloc(100);
            char * str71 = malloc(100);
            char * str72 = malloc(100);
            char * str73 = malloc(100);
            char * str74 = malloc(100);
            char * str75 = malloc(100);
            char * str76 = malloc(100);
            char * str77 = malloc(100);
            char * str78 = malloc(100);
            char * str79 = malloc(100);
            char * str80 = malloc(100);
            char * str81 = malloc(100);
            char * str82 = malloc(100);
            char * str83 = malloc(100);
            char * str84 = malloc(100);
            char * str85 = malloc(100);
            char * str86 = malloc(100);
            char * str87 = malloc(100);
            char * str88 = malloc(100);
            char * str89 = malloc(100);
            char * str90 = malloc(100);
            char * str91 = malloc(100);
            char * str92 = malloc(100);
            char * str93 = malloc(100);
            char * str94 = malloc(100);
            char * str95 = malloc(100);
            char * str96 = malloc(100);
            char * str97 = malloc(100);
            char * str98 = malloc(100);
            char * str99 = malloc(100);
            char * str100 = malloc(100);
            char * str101 = malloc(100);
            char * str102 = malloc(100);
            char * str103 = malloc(100);
            char * str104 = malloc(100);
            char * str105 = malloc(100);
            char * str106 = malloc(100);
            char * str107 = malloc(100);
            char * str108 = malloc(100);
            char * str109 = malloc(100);
            char * str110 = malloc(100);
            char * str111 = malloc(100);
            char * str112 = malloc(100);
            char * str113 = malloc(100);
            char * str114 = malloc(100);
            char * str115 = malloc(100);
            char * str116 = malloc(100);
            char * str117 = malloc(100);
            char * str118 = malloc(100);
            char * str119 = malloc(100);
            char * str120 = malloc(100);
            char * str121 = malloc(100);
            char * str122 = malloc(100);
            char * str123 = malloc(100);
            char * str124 = malloc(100);
            char * str125 = malloc(100);
            char * str126 = malloc(100);
            char * str127 = malloc(100);
            char * str128 = malloc(100);
            char * str129 = malloc(100);
            char * str130 = malloc(100);
            char * str131 = malloc(100);
            char * str132 = malloc(100);
            char * str133 = malloc(100);
            char * str134 = malloc(100);
            char * str135 = malloc(100);
            char * str136 = malloc(100);
            char * str137 = malloc(100);
         ",0
"//FormAI DATASET v1.0 Category: Drone Remote Control ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x;
    int y;
} Coordinates;

void flyTo(Coordinates coords) {
    printf(""Drone is flying to coordinates: (%d, %d)\n"", coords.x, coords.y);
}

void hover() {
    printf(""Drone is hovering\n"");
}

void land() {
    printf(""Drone is landing\n"");
}

void takeOff() {
    printf(""Drone is taking off\n"");
}

int main() {
    int choice;
    Coordinates destination;

    printf(""Welcome to the drone remote control program!\n"");
    printf(""1. Take off\n"");
    printf(""2. Fly to a location\n"");
    printf(""3. Hover in place\n"");
    printf(""4. Land\n"");
    printf(""5. Quit\n"");

    while (1) {
        printf(""Enter your choice (1-5): "");
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                takeOff();
                break;
            case 2:
                printf(""Enter the x-coordinate: "");
                scanf(""%d"", &destination.x);
                printf(""Enter the y-coordinate: "");
                scanf(""%d"", &destination.y);
                flyTo(destination);
                break;
            case 3:
                hover();
                break;
            case 4:
                land();
                break;
            case 5:
                printf(""Exiting program\n"");
                exit(0);
            default:
                printf(""Invalid choice, please try again\n"");
                break;
        }

        printf(""\n"");
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t flyTo(int64_t a1);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(int32_t c);
int32_t function_10a0(char * s);
int32_t function_10b0(char * format, ...);
int32_t function_10c0(char * format, ...);
void function_10d0(int32_t status);
int64_t hover(void);
int64_t land(void);
int64_t register_tm_clones(void);
int64_t takeOff(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xe4a00000d9b; // 0x2164
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(int32_t c) {
    // 0x1090
    return putchar(c);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return printf(format);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return scanf(format);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int32_t status) {
    // 0x10d0
    exit(status);
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x1246, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g2;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g2 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x11f8
int64_t flyTo(int64_t a1) {
    // 0x11c9
    int32_t v1; // 0x11c9
    return printf(""Drone is flying to coordinates: (%d, %d)\n"", a1 & 0xffffffff, (int64_t)(uint32_t)v1);
}

// Address range: 0x11f8 - 0x1212
int64_t hover(void) {
    // 0x11f8
    return puts(""Drone is hovering"");
}

// Address range: 0x1212 - 0x122c
int64_t land(void) {
    // 0x1212
    return puts(""Drone is landing"");
}

// Address range: 0x122c - 0x1246
int64_t takeOff(void) {
    // 0x122c
    return puts(""Drone is taking off"");
}

// Address range: 0x1246 - 0x13e8
int main(int argc, char ** argv) {
    // 0x1246
    __readfsqword(40);
    puts(""Welcome to the drone remote control program!"");
    puts(""1. Take off"");
    puts(""2. Fly to a location"");
    puts(""3. Hover in place"");
    puts(""4. Land"");
    puts(""5. Quit"");
    printf(""Enter your choice (1-5): "");
    int64_t v1; // bp-28, 0x1246
    scanf(""%d"", &v1);
    uint32_t v2; // 0x1307
    if ((int32_t)v1 < 6) {
        // 0x12f6
        v2 = *(int32_t *)((4 * v1 & 0x3fffffffc) + (int64_t)&g1);
        return (int64_t)v2 + (int64_t)&g1;
    }
    puts(""Invalid choice, please try again"");
    putchar(10);
    printf(""Enter your choice (1-5): "");
    scanf(""%d"", &v1);
    while ((int32_t)v1 >= 6) {
        // 0x13c9
        puts(""Invalid choice, please try again"");
        putchar(10);
        printf(""Enter your choice (1-5): "");
        scanf(""%d"", &v1);
    }
    // 0x12f6
    v2 = *(int32_t *)((4 * v1 & 0x3fffffffc) + (int64_t)&g1);
    return (int64_t)v2 + (int64_t)&g1;
}

// Address range: 0x13e8 - 0x13f5
int64_t _fini(void) {
    // 0x13e8
    int64_t result; // 0x13e8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to the drone remote control program!"");
            puts(""1. Take off"");
            puts(""2. Fly to a location"");
            puts(""3. Hover in place"");
            puts(""4. Land"");
            puts(""5. Quit"");
            printf(""Enter your choice (1-5): "");
            int choice;
            scanf(""%d"", &choice);
            uint32_t result;
            if ((int32_t)choice < 6) {
                result = *(int32_t *)((4 * choice & 0x3fffffffc) + (int64_t)&g1);
                return (int64_t)result + (int64_t)&g1;
            }
            puts(""Invalid choice, please try again"");
            putchar(10);
            printf(""Enter your choice (1-5): "");
            scanf(""%d"", &choice);
            while ((int32_t)choice >= 6) {
                puts(""Invalid choice, please try again"");
                putchar(10);
                printf(""Enter your choice (1-5): "");
                scanf(""%d"", &choice);
            }
            result = *(int32_t *)((4 * choice & 0x3fffffffc) + (int64_t)&g1);
            return (int64_t)result + (int64_t)&g1;
        }

        int32_t takeOff(void) {
            return puts(""Drone is taking off"");
        }

        int32_t flyTo(int32_t a1) {
            return printf(""Drone is flying to coordinates: (%d, %d)\n"", a1 & 0xffffffff, (int64_t)(uint32_t)a1);
        }

        int32_t hover(void) {
            return puts(""Drone is hovering"");
        }

        int32_t land(void) {
            return puts(""Drone is landing"");
        }

        int32_t function_1090(int32_t c) {
            return putchar(c);
        }

        int32_t function_10a0(char * s) {
            return puts(s);
        }

        int32_t function_10b0(char * format, ...) {
            return printf(format);
        }

        int32_t function_10c0(char * format, ...) {
            return scanf(format);
        }

        void function_10d0(int32_t status) {
            exit(status);
        }

        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            __libc_start_main(0x1246, (int32_t)a6, (char **)&a1, NULL, NULL, (void (*)())a3);
            __asm_hlt();
            return 0;
        }

        int64_t _init(void) {
            int64_t result;
            if (*(int64_t *)0x3fe8 != 0) {
                __gmon_start__();
                result = &g3;
            }
            return result;
        }

        void __cxa_finalize(int64_t * a1) {
            return;
        }

        void __gmon_start__(void) {
            return;
        }

        int64_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)()) {
            return 0;
        }

        int64_t deregister_tm_clones(void) {
            return &g2;
        }

        int64_t register_tm_clones(void) {
            return 0;
        }

        int64_t __do_global_dtors_aux(void) {
            if (*(char *)&g2 != 0) {
                __cxa_finalize((int64_t *)*(int64_t *)0x4008);
            }
            int64_t result;
            result = deregister_tm_clones();
            *(char *)&g2 = 1;
            return result;
        }

        int64_t frame_dummy(void) {
            return register_tm_clones();
        }

        int64_t _fini(void) {
            return 0;
        }


",1
"//FormAI DATASET v1.0 Category: Searching algorithm ; Style: high level of detail
#include <stdio.h> 

int interpolationSearch(int arr[], int low, int high, int x) 
{ 
    int pos; 
    if (low <= high && x >= arr[low] && x <= arr[high]) { 
        pos = low + ((x - arr[low]) * (high - low) / (arr[high] - arr[low])); 

        if (arr[pos] == x) 
            return pos; 
        
        if (arr[pos] < x) 
            return interpolationSearch(arr, pos + 1, high, x); 

        if (arr[pos] > x) 
            return interpolationSearch(arr, low, pos - 1, x); 
    } 
    
    return -1; 
} 

int main() 
{ 
    int arr[] = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 }; 
    int n = sizeof(arr) / sizeof(arr[0]); 
    int x = 12; 
    int index = interpolationSearch(arr, 0, n - 1, x); 
    
    if (index != -1) 
        printf(""Element found at index %d"", index); 
    else
        printf(""Element not found""); 
    
    return 0; 
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1050(int64_t * d);
void function_1060(void);
int32_t function_1070(char * format, ...);
int64_t interpolationSearch(int64_t a1, int64_t a2, int32_t a3, int32_t a4);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1050 - 0x105b
void function_1050(int64_t * d) {
    // 0x1050
    __cxa_finalize(d);
}

// Address range: 0x1060 - 0x106b
void function_1060(void) {
    // 0x1060
    __stack_chk_fail();
}

// Address range: 0x1070 - 0x107b
int32_t function_1070(char * format, ...) {
    // 0x1070
    return printf(format);
}

// Address range: 0x1080 - 0x10a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1080
    int64_t v1; // 0x1080
    __libc_start_main(0x12c6, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10b0 - 0x10d9
int64_t deregister_tm_clones(void) {
    // 0x10b0
    return &g1;
}

// Address range: 0x10e0 - 0x1119
int64_t register_tm_clones(void) {
    // 0x10e0
    return 0;
}

// Address range: 0x1120 - 0x1159
int64_t __do_global_dtors_aux(void) {
    // 0x1120
    if (*(char *)&g1 != 0) {
        // 0x1158
        int64_t result; // 0x1120
        return result;
    }
    // 0x112d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x113b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1147
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1160 - 0x1169
int64_t frame_dummy(void) {
    // 0x1160
    return register_tm_clones();
}

// Address range: 0x1169 - 0x12c6
int64_t interpolationSearch(int64_t a1, int64_t a2, int32_t a3, int32_t a4) {
    // 0x1169
    if ((int32_t)a2 > a3) {
        // 0x12c4
        return 0xffffffff;
    }
    int64_t v1 = 0x100000000 * a2;
    uint32_t v2 = *(int32_t *)((v1 >> 30) + a1); // 0x11a2
    int64_t v3 = a4; // 0x11a7
    if (v3 < (int64_t)v2) {
        // 0x12c4
        return 0xffffffff;
    }
    uint32_t v4 = *(int32_t *)(4 * (int64_t)a3 + a1); // 0x11c1
    if (v3 > (int64_t)v4) {
        // 0x12c4
        return 0xffffffff;
    }
    int64_t v5 = v1 >> 32; // 0x1179
    int32_t v6 = v5; // 0x11ec
    int32_t v7 = (a4 - v2) * (a3 - v6); // 0x11ef
    int32_t result = (int32_t)((0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) / (int64_t)(v4 - v2)) + v6; // 0x122c
    uint32_t v8 = *(int32_t *)(4 * (int64_t)result + a1); // 0x1245
    if (v8 == a4) {
        // 0x12c4
        return result;
    }
    int64_t v9 = v8; // 0x1265
    if (v3 > v9) {
        // 0x12c4
        return interpolationSearch(a1, (int64_t)(result + 1), a3, a4);
    }
    int64_t result2 = 0xffffffff; // 0x129f
    if (v3 < v9) {
        // 0x12a1
        result2 = interpolationSearch(a1, v5 & 0xffffffff, result - 1, a4);
    }
    // 0x12c4
    return result2;
}

// Address range: 0x12c6 - 0x13a6
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x12d2
    int32_t v2 = 2; // bp-56, 0x12e1
    int64_t v3 = interpolationSearch((int64_t)&v2, 0, 9, 12); // 0x134e
    if ((int32_t)v3 == -1) {
        // 0x1377
        printf(""Element not found"");
    } else {
        // 0x135c
        printf(""Element found at index %d"", v3 & 0xffffffff);
    }
    int64_t result = 0; // 0x139d
    if (v1 != __readfsqword(40)) {
        // 0x139f
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13a4
    return result;
}

// Address range: 0x13a8 - 0x13b5
int64_t _fini(void) {
    // 0x13a8
    int64_t result; // 0x13a8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 12

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            int64_t v1 = __readfsqword(40);
            int32_t v2 = 2;
            int64_t v3 = interpolationSearch((int64_t)&v2, 0, 9, 12);
            if ((int32_t)v3 == -1) {
                printf(""Element not found"");
            } else {
                printf(""Element found at index %d"", v3 & 0xffffffff);
            }
            int64_t result = 0;
            if (v1 != __readfsqword(40)) {
                __stack_chk_fail();
                result = &g2;
            }
            return result;
        }

        int64_t interpolationSearch(int64_t a1, int64_t a2, int32_t a3, int32_t a4) {
            if ((int32_t)a2 > a3) {
                return 0xffffffff;
            }
            int64_t v1 = 0x100000000 * a2;
            uint32_t v2 = *(int32_t *)((v1 >> 30) + a1);
            int64_t v3 = a4;
            if (v3 < (int64_t)v2) {
                return 0xffffffff;
            }
            uint32_t v4 = *(int32_t *)(4 * (int64_t)a3 + a1);
            if (v3 > (int64_t)v4) {
                return 0xffffffff;
            }
            int64_t v5 = v1 >> 32;
            int32_t v6 = v5;
            int32_t v7 = (a4 - v2) * (a3 - v6);
            int32_t result = (int32_t)((0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) / (int64_t)(v4 - v2)) + v6;
            uint32_t v8 = *(int32_t *)(4 * (int64_t)result + a1);
            if (v8 == a4) {
                return result;
            }
            int64_t v9 = v8;
            if (v3 > v9) {
                return interpolationSearch(a1, (int64_t)(result + 1), a3, a4);
            }
            int64_t result2 = 0xffffffff;
            if (v3 < v9) {
                result2 = interpolationSearch(a1, v5 & 0xffffffff, result - 1, a4);
            }
            return result2;
        }


",0
"//FormAI DATASET v1.0 Category: Data recovery tool ; Style: portable
#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE 512

int main(int argc, char *argv[]) {
    char *filename = argv[1];
    char buffer[BUFFER_SIZE];

    FILE *fp = NULL;
    fp = fopen(filename, ""rb"");

    if (fp == NULL) {
        printf(""Failed to open file\n"");
        return 1;
    }

    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    unsigned char *raw_data = (unsigned char *)malloc(file_size);
    int read_count = fread(raw_data, 1, file_size, fp);

    if (read_count != file_size) {
        printf(""Failed to read file\n"");
        return 1;
    }

    fclose(fp);

    // Perform data recovery algorithm

    unsigned char *recovered_data = (unsigned char *)malloc(file_size);
    int recovered_count = 0;

    for (int i = 0; i < file_size; i++) {
        if (i % 2 == 0) {
            recovered_data[recovered_count] = raw_data[i];
            recovered_count++;
        }
    }

    // Write recovered data to file

    char *recovery_filename = ""recovered_data.bin"";
    FILE *recovery_fp = NULL;
    recovery_fp = fopen(recovery_filename, ""wb"");

    if (recovery_fp == NULL) {
        printf(""Failed to create recovery file\n"");
        return 1;
    }

    int write_count = fwrite(recovered_data, 1, recovered_count, recovery_fp);

    if (write_count != recovered_count) {
        printf(""Failed to write recovery file\n"");
        return 1;
    }

    fclose(recovery_fp);

    printf(""Data recovery successful: %d bytes recovered\n"", recovered_count);

    free(raw_data);
    free(recovered_data);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10e0(int64_t * d);
void function_10f0(int64_t * ptr);
int32_t function_1100(char * s);
int32_t function_1110(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_1120(struct _IO_FILE * stream);
void function_1130(void);
int32_t function_1140(char * format, ...);
int32_t function_1150(struct _IO_FILE * stream);
int64_t * function_1160(int32_t size);
int32_t function_1170(struct _IO_FILE * stream, int32_t off, int32_t whence);
struct _IO_FILE * function_1180(char * filename, char * modes);
int32_t function_1190(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int64_t * d) {
    // 0x10e0
    __cxa_finalize(d);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(int64_t * ptr) {
    // 0x10f0
    free(ptr);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * s) {
    // 0x1100
    return puts(s);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x1110
    return fread(ptr, size, n, stream);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(struct _IO_FILE * stream) {
    // 0x1120
    return fclose(stream);
}

// Address range: 0x1130 - 0x113b
void function_1130(void) {
    // 0x1130
    __stack_chk_fail();
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return printf(format);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(struct _IO_FILE * stream) {
    // 0x1150
    return ftell(stream);
}

// Address range: 0x1160 - 0x116b
int64_t * function_1160(int32_t size) {
    // 0x1160
    return malloc(size);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(struct _IO_FILE * stream, int32_t off, int32_t whence) {
    // 0x1170
    return fseek(stream, off, whence);
}

// Address range: 0x1180 - 0x118b
struct _IO_FILE * function_1180(char * filename, char * modes) {
    // 0x1180
    return fopen(filename, modes);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x1190
    return fwrite(ptr, size, n, s);
}

// Address range: 0x11a0 - 0x11c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x11a0
    int64_t v1; // 0x11a0
    __libc_start_main(0x1289, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x11d0 - 0x11f9
int64_t deregister_tm_clones(void) {
    // 0x11d0
    return &g1;
}

// Address range: 0x1200 - 0x1239
int64_t register_tm_clones(void) {
    // 0x1200
    return 0;
}

// Address range: 0x1240 - 0x1279
int64_t __do_global_dtors_aux(void) {
    // 0x1240
    if (*(char *)&g1 != 0) {
        // 0x1278
        int64_t result; // 0x1240
        return result;
    }
    // 0x124d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x125b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1267
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1280 - 0x1289
int64_t frame_dummy(void) {
    // 0x1280
    return register_tm_clones();
}

// Address range: 0x1289 - 0x1564
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x12a5
    struct _IO_FILE * file = fopen((char *)*(int64_t *)((int64_t)argv + 8), ""rb""); // 0x12e5
    int64_t v2; // 0x1289
    if (file != NULL) {
        // 0x1314
        fseek(file, 0, SEEK_END);
        int32_t curr_file_offset = ftell(file); // 0x1337
        fseek(file, 0, SEEK_SET);
        int64_t * mem = malloc(curr_file_offset); // 0x1366
        if (curr_file_offset == fread(mem, 1, curr_file_offset, file)) {
            // 0x13c4
            fclose(file);
            int64_t * mem2 = malloc(curr_file_offset); // 0x13dd
            int32_t v3 = 0; // 0x1454
            if (curr_file_offset > 0) {
                int32_t v4 = 0;
                uint64_t v5 = 0;
                int32_t v6 = v4; // 0x140a
                char v7; // 0x1432
                if (v5 % 2 == 0) {
                    // 0x140c
                    v7 = *(char *)(v5 + (int64_t)mem);
                    *(char *)((int64_t)v4 + (int64_t)mem2) = v7;
                    v6 = v4 + 1;
                }
                int32_t v8 = v6;
                int64_t v9 = v5 + 1;
                v3 = v8;
                while (v9 != (int64_t)curr_file_offset) {
                    // 0x13ff
                    v4 = v8;
                    v5 = v9;
                    v6 = v4;
                    if (v5 % 2 == 0) {
                        // 0x140c
                        v7 = *(char *)(v5 + (int64_t)mem);
                        *(char *)((int64_t)v4 + (int64_t)mem2) = v7;
                        v6 = v4 + 1;
                    }
                    // 0x143e
                    v8 = v6;
                    v9 = v5 + 1;
                    v3 = v8;
                }
            }
            struct _IO_FILE * file2 = fopen(""recovered_data.bin"", ""wb""); // 0x1483
            if (file2 != NULL) {
                uint32_t nmemb = v3;
                if (fwrite(mem2, 1, nmemb, file2) == nmemb) {
                    // 0x1500
                    fclose(file2);
                    printf(""Data recovery successful: %d bytes recovered\n"", (int64_t)nmemb);
                    free(mem);
                    free(mem2);
                    v2 = 0;
                } else {
                    // 0x14ea
                    puts(""Failed to write recovery file"");
                    v2 = 1;
                }
            } else {
                // 0x1499
                puts(""Failed to create recovery file"");
                v2 = 1;
            }
        } else {
            // 0x13ab
            puts(""Failed to read file"");
            v2 = 1;
        }
    } else {
        // 0x12fb
        puts(""Failed to open file"");
        v2 = 1;
    }
    int64_t result = v2; // 0x155b
    if (v1 != __readfsqword(40)) {
        // 0x155d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1562
    return result;
}

// Address range: 0x1564 - 0x1571
int64_t _fini(void) {
    // 0x1564
    int64_t result; // 0x1564
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <stdint.h>
        #include <stdbool.h>
        #include <assert.h>
        #include <ctype.h>
        #include <errno.h>
        #include <limits.h>
        #include <math.h>
        #include <setjmp.h>
        #include <signal.h>
        #include <stdarg.h>
        #include <stddef.h>
        #include <stdint.h>
        #include <time.h>
        #include <unistd.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/mman.h>
        #include <sys/time.h>
        #include <sys/resource.h>
        #include <sys/wait.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <fcntl.h>
        #include <poll.h>
        #include <pthread.h>
        #include <sched.h>
        #include <sys/syscall.h>
        #include <sys/uio.h>
        #include <sys/un.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/xattr.h>
        #include <linux/falloc.h>
        #include <linux/filter.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/perf_event.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.h>
        #include <linux/sockios.h>
        #include <linux/types.h>
        #include <linux/videodev2.h>
        #include <linux/vm_sockets.h>
        #include <linux/xattr.h>
        #include <linux/netlink.h>
        #include <linux/if_packet.h>
        #include <linux/if_tun.h>
        #include <linux/netlink.h>
        #include <linux/reboot.h>
        #include <linux/rtnetlink.h>
        #include <linux/sched.h>
        #include <linux/seccomp.",0
"//FormAI DATASET v1.0 Category: Cafe Billing System ; Style: single-threaded
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

// define a structure for a customer's order
struct order {
    char item[20];
    float price;
};

// define a function to calculate the total bill of the customer
float calc_bill(struct order o[], int n) {
    float total = 0.0;
    for(int i=0; i<n; i++) {
        total += o[i].price;
    }
    return total;
}

int main() {
    int n; // number of items in the order
    printf(""Enter the number of items in the order: "");
    scanf(""%d"", &n);
    
    struct order *o = (struct order*) malloc(n * sizeof(struct order)); // allocate memory for the order
    
    // get input for each item in the order
    for(int i=0; i<n; i++) {
        printf(""Enter the name of item %d: "", i+1);
        scanf(""%s"", o[i].item);
        printf(""Enter the price of item %d: "", i+1);
        scanf(""%f"", &o[i].price);
    }
    
    // print the order
    printf(""\nOrder Summary:\n"");
    for(int i=0; i<n; i++) {
        printf(""%s %.2f\n"", o[i].item, o[i].price);
    }
    
    // calculate the total bill
    float total = calc_bill(o, n);
    printf(""\nTotal Bill: %.2f\n"", total);
    
    free(o); // free the memory
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int128_t calc_bill(int64_t a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
void function_10a0(int64_t * ptr);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
int64_t * function_10e0(int32_t size);
int32_t function_10f0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * ptr) {
    // 0x10a0
    free(ptr);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
int64_t * function_10e0(int32_t size) {
    // 0x10e0
    return malloc(size);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return scanf(format);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x124d, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g1;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g1 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x124d
int128_t calc_bill(int64_t a1, int64_t a2) {
    // 0x11e9
    int128_t v1; // 0x11e9
    int128_t v2 = v1;
    int32_t v3 = __asm_movss(__asm_pxor(v2, v2));
    if ((int32_t)a2 <= 0) {
        // 0x1246
        return __asm_movss_1(v3);
    }
    int64_t v4 = 0;
    int32_t v5 = *(int32_t *)(a1 + 20 + 24 * v4); // 0x1227
    int128_t v6 = __asm_addss(__asm_movss_1(v5), __asm_movss_1(v3)); // 0x1231
    v4++;
    int32_t v7 = __asm_movss(v6);
    int32_t v8 = v7; // 0x1244
    while (v4 != (a2 & 0xffffffff)) {
        // 0x120a
        v5 = *(int32_t *)(a1 + 20 + 24 * v4);
        v6 = __asm_addss(__asm_movss_1(v5), __asm_movss_1(v7));
        v4++;
        v7 = __asm_movss(v6);
        v8 = v7;
    }
    // 0x1246
    return __asm_movss_1(v8);
}

// Address range: 0x124d - 0x1468
int main(int argc, char ** argv) {
    // 0x124d
    int128_t v1; // 0x124d
    int128_t v2 = v1;
    int64_t v3 = __readfsqword(40); // 0x1259
    printf(""Enter the number of items in the order: "");
    int64_t v4; // bp-40, 0x124d
    scanf(""%d"", &v4);
    int64_t * mem = malloc(24 * (int32_t)v4); // 0x12ad
    int64_t v5 = (int64_t)mem; // 0x12ad
    int32_t v6 = 0; // 0x1370
    if ((v4 & 0xffffffff) != 0) {
        v6++;
        int64_t v7 = v6; // 0x12c8
        printf(""Enter the name of item %d: "", v7);
        int64_t v8 = v5; // 0x12f8
        scanf(""%s"", (char **)v8);
        printf(""Enter the price of item %d: "", v7);
        scanf(""%f"", (float64_t *)(v8 + 20));
        int64_t v9 = v6; // 0x1370
        while ((v4 & 0xffffffff) > v9) {
            // 0x12c2
            v6++;
            v7 = v6;
            printf(""Enter the name of item %d: "", v7);
            v8 = 24 * v9 + v5;
            scanf(""%s"", (char **)v8);
            printf(""Enter the price of item %d: "", v7);
            scanf(""%f"", (float64_t *)(v8 + 20));
            v9 = v6;
        }
    }
    // 0x1376
    puts(""\nOrder Summary:"");
    int32_t v10 = 0; // 0x1400
    int64_t v11 = 0; // 0x1400
    if ((v4 & 0xffffffff) != 0) {
        int128_t v12; // 0x124d
        int128_t v13 = v12;
        int64_t v14 = v5; // 0x13a8
        int128_t v15 = __asm_movss_1(*(int32_t *)(v14 + 20)); // 0x13ab
        __asm_pxor(v13, v13);
        int128_t v16 = __asm_cvtss2sd_3(v15); // 0x13b4
        int64_t v17 = __asm_movq(v16); // 0x13b8
        printf(""%s %.2f\n"", (char *)v14, (float64_t)(int64_t)__asm_movq_2(v17));
        v10++;
        int64_t v18 = v4 & 0xffffffff; // 0x13fa
        int64_t v19 = v10; // 0x1400
        v11 = v18;
        while (v18 > v19) {
            // 0x138e
            v13 = v16;
            v14 = 24 * v19 + v5;
            v15 = __asm_movss_1(*(int32_t *)(v14 + 20));
            __asm_pxor(v13, v13);
            v16 = __asm_cvtss2sd_3(v15);
            v17 = __asm_movq(v16);
            printf(""%s %.2f\n"", (char *)v14, (float64_t)(int64_t)__asm_movq_2(v17));
            v10++;
            v18 = v4 & 0xffffffff;
            v19 = v10;
            v11 = v18;
        }
    }
    int32_t v20 = __asm_movd(calc_bill(v5, v11)); // 0x1413
    __asm_pxor(v2, v2);
    int64_t v21 = __asm_movq(__asm_cvtss2sd(v20)); // 0x1423
    printf(""\nTotal Bill: %.2f\n"", (float64_t)(int64_t)__asm_movq_2(v21));
    free(mem);
    int64_t result = 0; // 0x145f
    if (v3 != __readfsqword(40)) {
        // 0x1461
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1466
    return result;
}

// Address range: 0x1468 - 0x1475
int64_t _fini(void) {
    // 0x1468
    int64_t result; // 0x1468
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","nclude <stdio.h>

int main(int argc, char ** argv) {
    int n;
    scanf(""%d"", &n);
    float * mem = malloc(sizeof(float) * n);
    for (int i = 0; i < n; i++) {
        scanf(""%s"", (char *)(mem + i));
        scanf(""%f"", (float *)(mem + i + n));
    }
    puts(""\nOrder Summary:"");
    for (int i = 0; i < n; i++) {
        printf(""%s %.2f\n"", (char *)(mem + i), *(float *)(mem + i + n));
    }
    float sum = 0;
    for (int i = 0; i < n; i++) {
        sum += *(float *)(mem + i + n);
    }
    printf(""\nTotal Bill: %.2f\n"", sum);
    free(mem);
    return 0;
}

",1
"//FormAI DATASET v1.0 Category: Benchmarking ; Style: systematic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_SIZE 100000

void insertionSort(int arr[], int n){
    int i, key, j;
    for (i = 1; i < n; i++){
        key = arr[i];
        j = i - 1;

        while (j >= 0 && arr[j] > key){
            arr[j + 1] = arr[j];
            j = j - 1;
        }

        arr[j + 1] = key;
    }
}

void merge(int arr[], int l, int m, int r){
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2){
        if (L[i] <= R[j]){
            arr[k] = L[i];
            i++;
        }
        else{
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1){
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2){
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r){
    if (l < r){
        int m = l + (r - l) / 2;

        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}

int main(){
    int arr[MAX_SIZE];
    int n, i;

    srand(time(0)); // seeding the random function with current time

    printf(""Enter the number of elements:\n"");
    scanf(""%d"", &n);

    printf(""Randomly generated array:\n"");

    for (i = 0; i < n; i++){
        arr[i] = rand() % 1000;
        printf(""%d "", arr[i]);
    }

    printf(""\n"");

    clock_t t;
    t = clock(); // starting the clock for insertion sort
    insertionSort(arr, n);
    t = clock() - t; // stopping the clock and calculating the time taken

    printf(""Array sorted using Insertion Sort:\n"");
    for (i = 0; i < n; i++)
        printf(""%d "", arr[i]);

    printf(""\nTime taken by Insertion Sort: %lf seconds\n"", ((double)t) / CLOCKS_PER_SEC);

    t = clock(); // starting the clock for merge sort
    mergeSort(arr, 0, n - 1);
    t = clock() - t; // stopping the clock and calculating the time taken

    printf(""Array sorted using Merge Sort:\n"");
    for (i = 0; i < n; i++)
        printf(""%d "", arr[i]);

    printf(""\nTime taken by Merge Sort: %lf seconds\n"", ((double)t) / CLOCKS_PER_SEC);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
int32_t function_10d0(int32_t c);
int32_t function_10e0(char * s);
int32_t function_10f0(void);
void function_1100(void);
int32_t function_1110(char * format, ...);
void function_1120(int32_t seed);
int32_t function_1130(int32_t * timer);
int32_t function_1140(char * format, ...);
int32_t function_1150(void);
int64_t insertionSort(int64_t * a1, int64_t a2);
int64_t merge(int64_t a1, int32_t a2, int32_t a3, int64_t a4);
int64_t mergeSort(int64_t a1, int64_t a2, uint32_t a3);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x3e8
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(int32_t c) {
    // 0x10d0
    return putchar(c);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * s) {
    // 0x10e0
    return puts(s);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(void) {
    // 0x10f0
    return clock();
}

// Address range: 0x1100 - 0x110b
void function_1100(void) {
    // 0x1100
    __stack_chk_fail();
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return printf(format);
}

// Address range: 0x1120 - 0x112b
void function_1120(int32_t seed) {
    // 0x1120
    srand(seed);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(int32_t * timer) {
    // 0x1130
    return time(timer);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return scanf(format);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(void) {
    // 0x1150
    return rand();
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x16e3, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g2;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g2 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x130f
int64_t insertionSort(int64_t * a1, int64_t a2) {
    // 0x1249
    if ((int32_t)a2 <= 1) {
        // 0x130b
        return 1;
    }
    int64_t v1 = (int64_t)a1;
    int64_t v2 = v1 + 4;
    int64_t result = a2 & 0xffffffff;
    int64_t v3 = 1;
    int64_t v4; // 0x1249
    int32_t v5; // 0x1278
    while (true) {
      lab_0x12c3:
        // 0x12c3
        v5 = *(int32_t *)(4 * v3 + v1);
        int32_t v6 = (int32_t)v3 - 1;
        int64_t v7 = 4 * (int64_t)v6;
        uint32_t v8 = *(int32_t *)(v7 + v1); // 0x12d7
        v4 = v7;
        while ((int64_t)v5 < (int64_t)v8) {
            // 0x1288
            *(int32_t *)(v7 + v2) = v8;
            int32_t v9 = v6 - 1;
            int32_t v10 = v9; // 0x12c1
            if (v9 < 0) {
                // 0x1288
                v4 = 4 * (int64_t)v9;
                goto lab_0x12de;
            }
            v6 = v10;
            v7 = 4 * (int64_t)v6;
            v8 = *(int32_t *)(v7 + v1);
            v4 = v7;
        }
        goto lab_0x12de;
    }
    // 0x130b
    return result;
  lab_0x12de:
    // 0x12de
    *(int32_t *)(v4 + v2) = v5;
    v3++;
    if (v3 == result) {
        return result;
    }
    goto lab_0x12c3;
}

// Address range: 0x130f - 0x1669
int64_t merge(int64_t a1, int32_t a2, int32_t a3, int64_t a4) {
    int64_t v1 = __readfsqword(40); // 0x1330
    int32_t v2 = a3 - a2 + 1; // 0x134b
    int64_t v3 = v2;
    int64_t v4 = 16 * (4 * v3 + 15) / 16;
    int64_t v5; // bp-136, 0x130f
    int64_t v6 = (int64_t)&v5 - (v4 & -0x1000) - (v4 & 4080); // 0x13d7
    if (v2 > 0) {
        int64_t v7 = 0;
        int32_t v8 = *(int32_t *)(4 * (int64_t)((int32_t)v7 + a2) + a1); // 0x14de
        *(int32_t *)(4 * v7 + v6) = v8;
        v7++;
        while (v7 != (int64_t)v2) {
            // 0x14c5
            v8 = *(int32_t *)(4 * (int64_t)((int32_t)v7 + a2) + a1);
            *(int32_t *)(4 * v7 + v6) = v8;
            v7++;
        }
    }
    int32_t v9 = (int32_t)a4 - a3; // 0x1354
    int64_t v10 = v9;
    int64_t v11 = 16 * (4 * v10 + 15) / 16;
    int64_t v12 = 3 - (v11 & 4080) - (v11 & -0x1000) + v6 & -8; // 0x14b0
    int32_t v13 = 0; // 0x1537
    int32_t v14 = 0; // 0x1537
    int32_t v15 = a2; // 0x1537
    if (v9 > 0) {
        int64_t v16 = 0;
        int64_t v17 = v16 + 1;
        int32_t v18 = *(int32_t *)(4 * (int64_t)((int32_t)v17 + a3) + a1); // 0x151e
        *(int32_t *)(4 * v16 + v12) = v18;
        while (v17 != (int64_t)v9) {
            // 0x1502
            v16 = v17;
            v17 = v16 + 1;
            v18 = *(int32_t *)(4 * (int64_t)((int32_t)v17 + a3) + a1);
            *(int32_t *)(4 * v16 + v12) = v18;
        }
        // 0x15c3
        v13 = 0;
        v14 = 0;
        v15 = a2;
        if (v2 > 0) {
            int32_t v19 = 0;
            int32_t v20 = 0;
            uint32_t v21 = *(int32_t *)(4 * (int64_t)v19 + v6); // 0x1559
            uint32_t v22 = *(int32_t *)(4 * (int64_t)v20 + v12); // 0x1566
            int32_t * v23 = (int32_t *)(4 * (int64_t)a2 + a1);
            int32_t v24; // 0x130f
            int32_t v25; // 0x130f
            if (v21 > v22) {
                // 0x1597
                *v23 = v22;
                v24 = v19;
                v25 = v20 + 1;
            } else {
                // 0x156d
                *v23 = v21;
                v24 = v19 + 1;
                v25 = v20;
            }
            int32_t v26 = a2 + 1; // 0x15bf
            int32_t v27 = v26; // 0x15c9
            v13 = v24;
            v14 = v25;
            v15 = v26;
            while (v24 < v2 == v25 < v9) {
                // 0x154f
                v19 = v24;
                v20 = v25;
                v21 = *(int32_t *)(4 * (int64_t)v19 + v6);
                v22 = *(int32_t *)(4 * (int64_t)v20 + v12);
                v23 = (int32_t *)(4 * (int64_t)v27 + a1);
                if (v21 > v22) {
                    // 0x1597
                    *v23 = v22;
                    v24 = v19;
                    v25 = v20 + 1;
                } else {
                    // 0x156d
                    *v23 = v21;
                    v24 = v19 + 1;
                    v25 = v20;
                }
                // 0x15bf
                v26 = v27 + 1;
                v27 = v26;
                v13 = v24;
                v14 = v25;
                v15 = v26;
            }
        }
    }
    int32_t v28 = v15; // 0x160b
    if (v13 < v2) {
        int64_t v29 = v13;
        int32_t v30 = v15; // 0x1601
        int32_t v31 = *(int32_t *)(4 * v29 + v6); // 0x15f8
        *(int32_t *)(4 * (int64_t)v30 + a1) = v31;
        v29++;
        v30++;
        v28 = v30;
        while (v29 != v3) {
            // 0x15d9
            v31 = *(int32_t *)(4 * v29 + v6);
            *(int32_t *)(4 * (int64_t)v30 + a1) = v31;
            v29++;
            v30++;
            v28 = v30;
        }
    }
    if (v14 < v9) {
        int64_t v32 = v14;
        int32_t v33 = v28; // 0x130f
        int32_t v34 = *(int32_t *)(4 * v32 + v12); // 0x162e
        *(int32_t *)(4 * (int64_t)v33 + a1) = v34;
        v32++;
        v33++;
        while (v32 != v10) {
            // 0x160f
            v34 = *(int32_t *)(4 * v32 + v12);
            *(int32_t *)(4 * (int64_t)v33 + a1) = v34;
            v32++;
            v33++;
        }
    }
    int64_t result = 0; // 0x1654
    if (v1 != __readfsqword(40)) {
        // 0x1656
        __stack_chk_fail();
        result = &g3;
    }
    // 0x165b
    return result;
}

// Address range: 0x1669 - 0x16e3
int64_t mergeSort(int64_t a1, int64_t a2, uint32_t a3) {
    int64_t result = a2 & 0xffffffff; // 0x1685
    if ((int32_t)a2 < a3) {
        int64_t v1 = 0x100000000 * a2 >> 32; // 0x1679
        int32_t v2 = v1; // 0x168a
        int32_t v3 = a3 - v2; // 0x168a
        int32_t v4 = (v3 + (int32_t)(v3 < 0) >> 1) + v2; // 0x169b
        mergeSort(a1, v1 & 0xffffffff, v4);
        mergeSort(a1, (int64_t)(v4 + 1), a3);
        result = merge(a1, v2, v4, (int64_t)a3);
    }
    // 0x16e0
    return result;
}

// Address range: 0x16e3 - 0x1992
int main(int argc, char ** argv) {
    // 0x16e3
    int128_t v1; // 0x16e3
    int128_t v2 = v1;
    int64_t v3; // bp-8, 0x16e3
    int64_t v4 = &v3; // 0x16e7
    int64_t v5 = v4; // 0x16eb
    int64_t v6; // bp-397320, 0x16e3
    while (v5 - 0x1000 != (int64_t)&v6) {
        // 0x16f3
        v5 -= 0x1000;
    }
    int64_t v7 = __readfsqword(40); // 0x170b
    srand(time(NULL));
    puts(""Enter the number of elements:"");
    int64_t v8; // bp-400040, 0x16e3
    scanf(""%d"", &v8);
    puts(""Randomly generated array:"");
    if ((v8 & 0xffffffff) != 0) {
        int32_t v9 = 0; // 0x17ce
        int32_t v10 = rand(); // 0x1773
        uint32_t v11 = v10 - v10 / 1000 * (int32_t)&g1; // 0x1796
        *(int32_t *)(v4 - 0x61a90) = v11;
        printf(""%d "", (int64_t)v11);
        v9++;
        int64_t v12 = v9; // 0x17e1
        while ((v8 & 0xffffffff) > v12) {
            // 0x1773
            v10 = rand();
            v11 = v10 - v10 / 1000 * (int32_t)&g1;
            *(int32_t *)(v4 - 0x61a90 + 4 * v12) = v11;
            printf(""%d "", (int64_t)v11);
            v9++;
            v12 = v9;
        }
    }
    // 0x17e3
    putchar(10);
    int32_t proc_time = clock(); // 0x17ed
    int64_t v13; // bp-400024, 0x16e3
    insertionSort(&v13, v8 & 0xffffffff);
    int32_t proc_time2 = clock(); // 0x1810
    puts(""Array sorted using Insertion Sort:"");
    if ((v8 & 0xffffffff) != 0) {
        int32_t v14 = 0; // 0x1863
        printf(""%d "", (int64_t)*(int32_t *)(v4 - 0x61a90));
        v14++;
        int64_t v15 = v14; // 0x1876
        while ((v8 & 0xffffffff) > v15) {
            // 0x183e
            printf(""%d "", (int64_t)*(int32_t *)(v4 - 0x61a90 + 4 * v15));
            v14++;
            v15 = v14;
        }
    }
    // 0x1878
    __asm_pxor(v2, v2);
    int128_t v16 = __asm_cvtsi2sd((int64_t)proc_time2 - (int64_t)proc_time); // 0x187c
    int128_t v17 = __asm_movq_1(__asm_movq(__asm_divsd(v16, __asm_movsd(0x412e848000000000)))); // 0x1896
    printf(""\nTime taken by Insertion Sort: %lf seconds\n"", (float64_t)(int64_t)v17);
    int32_t proc_time3 = clock(); // 0x18af
    mergeSort((int64_t)&v13, 0, (int32_t)v8 - 1);
    int32_t proc_time4 = clock(); // 0x18d8
    puts(""Array sorted using Merge Sort:"");
    if ((v8 & 0xffffffff) != 0) {
        int32_t v18 = 0; // 0x192b
        printf(""%d "", (int64_t)*(int32_t *)(v4 - 0x61a90));
        v18++;
        int64_t v19 = v18; // 0x193e
        while ((v8 & 0xffffffff) > v19) {
            // 0x1906
            printf(""%d "", (int64_t)*(int32_t *)(v4 - 0x61a90 + 4 * v19));
            v18++;
            v19 = v18;
        }
    }
    // 0x1940
    __asm_pxor(v17, v17);
    int128_t v20 = __asm_cvtsi2sd((int64_t)proc_time4 - (int64_t)proc_time3); // 0x1944
    int64_t v21 = __asm_movq(__asm_divsd(v20, __asm_movsd(0x412e848000000000))); // 0x1959
    printf(""\nTime taken by Merge Sort: %lf seconds\n"", (float64_t)(int64_t)__asm_movq_1(v21));
    int64_t result = 0; // 0x1989
    if (v7 != __readfsqword(40)) {
        // 0x198b
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1990
    return result;
}

// Address range: 0x1994 - 0x19a1
int64_t _fini(void) {
    // 0x1994
    int64_t result; // 0x1994
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            int n;
            int i;
            int j;
            int temp;
            int * arr;

            srand(time(NULL));
            puts(""Enter the number of elements:"");
            scanf(""%d"", &n);
            puts(""Randomly generated array:"");
            arr = (int *)malloc(n * sizeof(int));
            for (i = 0; i < n; i++) {
                arr[i] = rand();
                printf(""%d "", arr[i]);
            }
            puts("""");
            int proc_time = clock();
            for (i = 0; i < n - 1; i++) {
                for (j = 0; j < n - i - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                    }
                }
            }
            int proc_time2 = clock();
            puts(""Array sorted using Insertion Sort:"");
            for (i = 0; i < n; i++) {
                printf(""%d "", arr[i]);
            }
            puts("""");
            int proc_time3 = clock();
            mergeSort(arr, 0, n - 1);
            int proc_time4 = clock();
            puts(""Array sorted using Merge Sort:"");
            for (i = 0; i < n; i++) {
                printf(""%d "", arr[i]);
            }
            puts("""");
            int proc_time5 = clock();
            printf(""\nTime taken by Insertion Sort: %d seconds\n"", proc_time2 - proc_time);
            printf(""\nTime taken by Merge Sort: %d seconds\n"", proc_time4 - proc_time3);
            free(arr);
            return 0;
        }

        int mergeSort(int arr[], int l, int r) {
            if (l < r) {
                int m = l + (r - l) / 2;
                mergeSort(arr, l, m);
                mergeSort(arr, m + 1, r);
                merge(arr, l, m, r);
            }
        }

        void merge(int arr[], int l, int m, int r) {
            int i, j, k;
            int n1 = m - l + 1;
            int n2 = r - m;
            int L[n1], R[n2];
            for (i = 0; i < n1; i++)
                L[i] = arr[l + i];
            for (j = 0; j < n2; j++)
                R[j] = arr[m + 1 + j];
            i = 0;
            j = 0;
            k = l;
            while (i < n1 && j < n2) {
                if (L[i] <= R[j]) {
                    arr[k] = L[i];
                    i++;
                } else {
                    arr[k] = R[j];
                    j++;
                }
                k++;
            }
            while (i < n1) {
                arr[k] = L[i];
                i++;
                k++;
            }
            while (j < n2) {
                arr[k] = R[j];
                j++;
                k++;
            }
        }


",2
"//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: grateful
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <sys/stat.h>

// Function to calculate the total size of a directory
long int calculate_directory_size(char *path) {
    DIR *dir;
    struct dirent *entry;
    struct stat file_info;
    long int total_size = 0;

    dir = opendir(path);
    if (dir == NULL) {
        printf(""Error: cannot open directory %s\n"", path);
        exit(1);
    }

    while ((entry = readdir(dir)) != NULL) {
        // Ignore hidden files and directories
        if (entry->d_name[0] == '.') {
            continue;
        }

        // Construct the full path to the file
        char file_path[1024];
        sprintf(file_path, ""%s/%s"", path, entry->d_name);

        // Get the file info
        stat(file_path, &file_info);
        if (S_ISDIR(file_info.st_mode)) {
            // Recursively calculate the size of subdirectories
            total_size += calculate_directory_size(file_path);
        } else {
            // Add the size of the file to the total size
            total_size += file_info.st_size;
        }
    }

    closedir(dir);
    return total_size;
}

int main() {
    char path[1024];
    printf(""Enter the path to the directory: "");
    scanf(""%s"", path);

    long int total_size = calculate_directory_size(path);
    printf(""Total size of files in %s: %ld bytes\n"", path, total_size);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <dirent.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

// ------------------------ Structures ------------------------

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t calculate_directory_size(int64_t * name);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
struct __dirstream * function_10d0(char * name);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
int32_t function_1100(struct __dirstream * dirp);
int32_t function_1110(char * file, struct stat * buf);
struct dirent * function_1120(struct __dirstream * dirp);
int32_t function_1130(char * format, ...);
int32_t function_1140(char * s, char * format, ...);
void function_1150(int32_t status);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
struct __dirstream * function_10d0(char * name) {
    // 0x10d0
    return opendir(name);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(struct __dirstream * dirp) {
    // 0x1100
    return closedir(dirp);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * file, struct stat * buf) {
    // 0x1110
    return stat(file, buf);
}

// Address range: 0x1120 - 0x112b
struct dirent * function_1120(struct __dirstream * dirp) {
    // 0x1120
    return readdir(dirp);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * format, ...) {
    // 0x1130
    return scanf(format);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * s, char * format, ...) {
    // 0x1140
    return sprintf(s, format);
}

// Address range: 0x1150 - 0x115b
void function_1150(int32_t status) {
    // 0x1150
    exit(status);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x13a4, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g1;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g1 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x13a4
int64_t calculate_directory_size(int64_t * name) {
    int64_t v1 = __readfsqword(40); // 0x125f
    struct __dirstream * dirp = opendir((char *)name); // 0x1283
    if (dirp == NULL) {
        // 0x129d
        printf(""Error: cannot open directory %s\n"", name);
        exit(1);
        // UNREACHABLE
    }
    int64_t v2 = 0; // 0x1249
    int64_t v3; // 0x1249
    while (true) {
        // 0x1354
        v3 = v2;
        struct dirent * v4 = readdir(dirp); // 0x135e
        if (v4 == NULL) {
            // break (via goto) -> 0x1378
            goto lab_0x1378;
        }
        char * v5 = (char *)((int64_t)v4 + 19);
        while (*v5 == 46) {
            // 0x1354
            v4 = readdir(dirp);
            if (v4 == NULL) {
                // break (via goto) -> 0x1378
                goto lab_0x1378;
            }
            // 0x12c5
            v5 = (char *)((int64_t)v4 + 19);
        }
        // 0x12d6
        int64_t str; // bp-1048, 0x1249
        sprintf((char *)&str, ""%s/%s"", name, v5);
        int64_t buf; // bp-1192, 0x1249
        stat((char *)&str, (struct stat *)&buf);
        int32_t v6; // 0x1249
        if ((v6 & 0xf000) != 0x4000) {
            // 0x1346
            int64_t v7; // 0x1249
            v2 = v3 + v7;
        } else {
            // 0x132e
            v2 = calculate_directory_size(&str) + v3;
        }
    }
  lab_0x1378:
    // 0x1378
    closedir(dirp);
    int64_t result = v3; // 0x139b
    if (v1 != __readfsqword(40)) {
        // 0x139d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13a2
    return result;
}

// Address range: 0x13a4 - 0x144a
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x13b3
    printf(""Enter the path to the directory: "");
    int64_t v2; // bp-1048, 0x13a4
    scanf(""%s"", &v2);
    int64_t v3 = calculate_directory_size(&v2); // 0x13fe
    printf(""Total size of files in %s: %ld bytes\n"", &v2, (int32_t)v3);
    int64_t result = 0; // 0x1441
    if (v1 != __readfsqword(40)) {
        // 0x1443
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1448
    return result;
}

// Address range: 0x144c - 0x1459
int64_t _fini(void) {
    // 0x144c
    int64_t result; // 0x144c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 19

","nclude <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

int main(int argc, char ** argv) {
    if (argc != 2) {
        printf(""Usage: %s <directory>\n"", argv[0]);
        exit(1);
    }
    DIR * dirp = opendir(argv[1]);
    if (dirp == NULL) {
        printf(""Error: cannot open directory %s\n"", argv[1]);
        exit(1);
    }
    int64_t total_size = 0;
    struct dirent * direntp;
    while ((direntp = readdir(dirp)) != NULL) {
        char * filename = (char *)((int64_t)direntp + 19);
        while (*filename == '.') {
            filename++;
        }
        if (*filename == '\0') {
            continue;
        }
        char * filepath = (char *)malloc(strlen(argv[1]) + strlen(filename) + 2);
        sprintf(filepath, ""%s/%s"", argv[1], filename);
        struct stat buf;
        stat(filepath, &buf);
        if ((buf.st_mode & S_IFMT) != S_IFDIR) {
            total_size += buf.st_size;
        } else {
            total_size += calculate_directory_size(filepath);
        }
        free(filepath);
    }
    closedir(dirp);
    printf(""Total size of files in %s: %ld bytes\n"", argv[1], (int32_t)total_size);
    return 0;
}

int64_t calculate_directory_size(char * name) {
    DIR * dirp = opendir(name);
    if (dirp == NULL) {
        printf(""Error: cannot open directory %s\n"", name);
        exit(1);
    }
    int64_t total_size = 0;
    struct dirent * direntp;
    while ((direntp = readdir(dirp)) != NULL) {
        char * filename = (char *)((int64_t)direntp + 19);
        while (*filename == '.') {
            filename++;
        }
        if (*filename == '\0') {
            continue;
        }
        char * filepath = (char *)malloc(strlen(name) + strlen(filename) + 2);
        sprintf(filepath, ""%s/%s"", name, filename);
        struct stat buf;
        stat(filepath, &buf);
        if ((buf.st_mode & S_IFMT) != S_IFDIR) {
            total_size += buf.st_size;
        } else {
            total_size += calculate_directory_size(filepath);
        }
        free(filepath);
    }
    closedir(dirp);
    return total_size;
}


",2
"//FormAI DATASET v1.0 Category: Sudoku solver ; Style: careful
#include <stdio.h>

// Define the size of the Sudoku board
#define SIZE 9

// Function to check if a particular number is valid for a given position on the board
int is_valid(int board[SIZE][SIZE], int row, int col, int num) {
    // Check the row for conflicts
    for (int i = 0; i < SIZE; i++) {
        if (board[row][i] == num) {
            return 0;
        }
    }
    // Check the column for conflicts
    for (int i = 0; i < SIZE; i++) {
        if (board[i][col] == num) {
            return 0;
        }
    }
    // Check the 3x3 sub-grid for conflicts
    int sub_row = (row / 3) * 3;
    int sub_col = (col / 3) * 3;
    for (int i = sub_row; i < sub_row + 3; i++) {
        for (int j = sub_col; j < sub_col + 3; j++) {
            if (board[i][j] == num) {
                return 0;
            }
        }
    }
    // If there are no conflicts, the number is valid for the position
    return 1;
}

// Function to recursively solve the Sudoku board
int solve_board(int board[SIZE][SIZE], int row, int col) {
    // If we have reached the end of the board, the Sudoku is solved
    if (row == SIZE) {
        return 1;
    }
    // If we have reached the end of the row, move to the next row
    if (col == SIZE) {
        return solve_board(board, row + 1, 0);
    }
    // If the current position is already filled in, move to the next position
    if (board[row][col] != 0) {
        return solve_board(board, row, col + 1);
    }
    // Try numbers 1-9 in the current position and recursively solve the new board
    for (int num = 1; num <= 9; num++) {
        if (is_valid(board, row, col, num)) {
            board[row][col] = num;
            if (solve_board(board, row, col + 1)) {
                return 1;
            }
            board[row][col] = 0; // backtrack
        }
    }
    // If no number is valid for the current position, the Sudoku is unsolvable
    return 0;
}

// Function to print the Sudoku board to the screen
void print_board(int board[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf(""%2d "", board[i][j]);
        }
        printf(""\n"");
    }
}

int main() {
    // Define the Sudoku board
    int board[SIZE][SIZE] = {
        {0, 0, 0, 7, 0, 0, 0, 0, 9},
        {0, 0, 5, 0, 3, 0, 0, 0, 0},
        {0, 2, 0, 0, 0, 6, 0, 0, 0},
        {0, 0, 4, 0, 0, 0, 0, 2, 0},
        {5, 0, 0, 0, 0, 0, 7, 0, 0},
        {0, 0, 0, 4, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 2, 0, 0, 3},
        {0, 4, 0, 0, 0, 0, 5, 1, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 4}
    };
    // Print the unsolved Sudoku board
    printf(""Unsolved Sudoku:\n"");
    print_board(board);
    // Solve the Sudoku board
    if (solve_board(board, 0, 0)) {
        // Print the solved Sudoku board
        printf(""\nSolved Sudoku:\n"");
        print_board(board);
    } else {
        printf(""\nUnsolvable Sudoku!\n"");
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
int32_t function_1090(char * s);
void function_10a0(void);
int32_t function_10b0(char * format, ...);
int64_t is_valid(int64_t a1, int32_t a2, int64_t a3, int32_t a4);
int64_t print_board(int64_t * a1);
int64_t register_tm_clones(void);
int64_t solve_board(int64_t a1, int64_t a2, int64_t a3);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(void) {
    // 0x10a0
    __stack_chk_fail();
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return printf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x14b3, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x12f3
int64_t is_valid(int64_t a1, int32_t a2, int64_t a3, int32_t a4) {
    int64_t v1 = 0x100000000 * a3;
    int32_t v2 = 0; // 0x11fc
    int64_t result = 0; // 0x11f0
    int32_t v3; // 0x11a9
    while (*(int32_t *)(36 * (int64_t)a2 + a1 + 4 * (int64_t)v2) != a4) {
        // 0x1200
        v2++;
        if (v2 >= 9) {
            // 0x1248
            v3 = 0;
            goto lab_0x120f;
        }
        result = 0;
    }
    // 0x12f1
    return result;
  lab_0x120f:
    // 0x120f
    result = 0;
    int64_t v4; // 0x11a9
    int32_t v5; // 0x11a9
    int32_t v6; // 0x1287
    int64_t v7; // 0x12d5
    int64_t v8; // 0x12db
    int64_t v9; // 0x12e4
    if (*(int32_t *)((v1 >> 30) + a1 + 36 * (int64_t)v3) != a4) {
        int32_t v10 = v3 + 1; // 0x1244
        v3 = v10;
        if (v10 < 9) {
            goto lab_0x120f;
        } else {
            int32_t v11 = a2 - a2 % 3; // 0x1268
            v9 = v11 + 2;
            int64_t v12 = v11; // 0x12ea
            result = 1;
            if (v12 > v9) {
                return result;
            } else {
                // 0x12d2
                v6 = 3 * ((int32_t)(0x55555556 * (v1 >> 32) / 0x100000000) - ((int32_t)a3 >> 31));
                v7 = v6 + 2;
                v8 = v6;
                v4 = v12;
                v5 = v11;
                goto lab_0x12d2_2;
            }
        }
    } else {
        return result;
    }
  lab_0x12d2_2:;
    // 0x12d2
    int64_t v13; // 0x11a9
    int32_t v14; // 0x11a9
    if (v8 > v7) {
        goto lab_0x12dd;
    } else {
        // 0x129c
        v13 = v8;
        v14 = v6;
        goto lab_0x129c_2;
    }
  lab_0x12dd:;
    int32_t v15 = v5 + 1; // 0x12dd
    int64_t v16 = v15; // 0x12ea
    v4 = v16;
    v5 = v15;
    result = 1;
    if (v16 > v9) {
        return result;
    } else {
        goto lab_0x12d2_2;
    }
  lab_0x129c_2:
    // 0x129c
    result = 0;
    if (*(int32_t *)(36 * v4 + a1 + 4 * v13) != a4) {
        int32_t v17 = v14 + 1; // 0x12ce
        int64_t v18 = v17; // 0x12db
        v13 = v18;
        v14 = v17;
        if (v18 > v7) {
            goto lab_0x12dd;
        } else {
            goto lab_0x129c_2;
        }
    } else {
        return result;
    }
}

// Address range: 0x12f3 - 0x1433
int64_t solve_board(int64_t a1, int64_t a2, int64_t a3) {
    // 0x12f3
    if ((int32_t)a2 == 9) {
        // 0x1431
        return 1;
    }
    int64_t v1 = 0x100000000 * a2;
    int64_t v2 = v1 >> 32; // 0x1303
    int64_t v3 = 0x100000000 * a3;
    int64_t v4 = v3 >> 32; // 0x1306
    if ((int32_t)v4 == 9) {
        // 0x1431
        return solve_board(a1, v2 + 1 & 0xffffffff, 0);
    }
    int32_t * v5 = (int32_t *)((v3 >> 30) + a1 + 4 * ((v1 >> 29) + v2)); // 0x1360
    if (*v5 != 0) {
        // 0x1431
        return solve_board(a1, v2 & 0xffffffff, v4 + 1 & 0xffffffff);
    }
    int32_t v6 = 1;
    if ((int32_t)is_valid(a1, (int32_t)v2, v4 & 0xffffffff, v6) != 0) {
        // 0x13a8
        *v5 = v6;
        if ((int32_t)solve_board(a1, v2 & 0xffffffff, v4 + 1 & 0xffffffff) != 0) {
            // break -> 0x1431
            break;
        }
        // 0x13f4
        *v5 = 0;
    }
    int32_t v7 = v6 + 1; // 0x141e
    int64_t result = 0; // 0x1426
    while (v7 < 10) {
        // 0x138f
        v6 = v7;
        if ((int32_t)is_valid(a1, (int32_t)v2, v4 & 0xffffffff, v6) != 0) {
            // 0x13a8
            *v5 = v6;
            result = 1;
            if ((int32_t)solve_board(a1, v2 & 0xffffffff, v4 + 1 & 0xffffffff) != 0) {
                // break -> 0x1431
                break;
            }
            // 0x13f4
            *v5 = 0;
        }
        // 0x141e
        v7 = v6 + 1;
        result = 0;
    }
    // 0x1431
    return result;
}

// Address range: 0x1433 - 0x14b3
int64_t print_board(int64_t * a1) {
    int32_t putchar_rc; // 0x14a0
    for (int64_t i = 0; i < 9; i++) {
        int64_t v1 = 36 * i + (int64_t)a1; // 0x1470
        for (int64_t j = 0; j < 9; j++) {
            // 0x1455
            printf(""%2d "", (int64_t)*(int32_t *)(v1 + 4 * j));
        }
        // 0x149b
        putchar_rc = putchar(10);
    }
    // 0x14af
    return putchar_rc;
}

// Address range: 0x14b3 - 0x160e
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x14c2
    int64_t v2; // bp-344, 0x14b3
    int64_t v3 = &v2; // 0x14e2
    __asm_rep_stosq_memset((char *)&v2, 0, 40);
    bool v4; // 0x14b3
    *(int32_t *)((v4 ? -320 : 320) + v3) = 0;
    puts(""Unsolved Sudoku:"");
    print_board(&v2);
    if ((int32_t)solve_board(v3, 0, 0) == 0) {
        // 0x15e4
        puts(""\nUnsolvable Sudoku!"");
    } else {
        // 0x15c4
        puts(""\nSolved Sudoku:"");
        print_board(&v2);
    }
    int64_t result = 0; // 0x1605
    if (v1 != __readfsqword(40)) {
        // 0x1607
        __stack_chk_fail();
        result = &g2;
    }
    // 0x160c
    return result;
}

// Address range: 0x1610 - 0x161d
int64_t _fini(void) {
    // 0x1610
    int64_t result; // 0x1610
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdbool.h>

        bool is_valid(int a1, int a2, int a3, int a4) {
            int v1 = 0x100000000 * a3;
            int v2 = 0;
            while (*(int *)(36 * (int)a2 + a1 + 4 * (int)v2) != a4) {
                v2++;
                if (v2 >= 9) {
                    return false;
                }
            }
            int v3 = 0;
            while (*(int *)((v1 >> 30) + a1 + 36 * (int)v3) != a4) {
                v3++;
                if (v3 >= 9) {
                    return false;
                }
            }
            return true;
        }

        int solve_board(int a1, int a2, int a3) {
            if ((int)a2 == 9) {
                return 1;
            }
            int v1 = 0x100000000 * a2;
            int v2 = v1 >> 32;
            int v3 = 0x100000000 * a3;
            int v4 = v3 >> 32;
            if ((int)v4 == 9) {
                return solve_board(a1, v2 + 1 & 0xffffffff, 0);
            }
            int * v5 = (int *)((v3 >> 30) + a1 + 4 * ((v1 >> 29) + v2));
            if (*v5 != 0) {
                return solve_board(a1, v2 & 0xffffffff, v4 + 1 & 0xffffffff);
            }
            int v6 = 1;
            if ((int)is_valid(a1, (int)v2, v4 & 0xffffffff, v6) != 0) {
                *v5 = v6;
                if ((int)solve_board(a1, v2 & 0xffffffff, v4 + 1 & 0xffffffff) != 0) {
                    break;
                }
                *v5 = 0;
            }
            int v7 = v6 + 1;
            while (v7 < 10) {
                v6 = v7;
                if ((int)is_valid(a1, (int)v2, v4 & 0xffffffff, v6) != 0) {
                    *v5 = v6;
                    if ((int)solve_board(a1, v2 & 0xffffffff, v4 + 1 & 0xffffffff) != 0) {
                        break;
                    }
                    *v5 = 0;
                }
                v7 = v6 + 1;
            }
            return 0;
        }

        void print_board(int * a1) {
            for (int i = 0; i < 9; i++) {
                int v1 = 36 * i + (int)a1;
                for (int j = 0; j < 9; j++) {
                    printf(""%2d "", *(int *)(v1 + 4 * j));
                }
                putchar(10);
            }
        }

        int main(int argc, char ** argv) {
            int v1 = __readfsqword(40);
            int v2;
            int * v3 = &v2;
            __stosq((char *)&v2, 0, 40);
            bool v4;
            *(int *)((v4 ? -320 : 320) + v3) = 0;
            puts(""Unsolved Sudoku:"");
            print_board(&v2);
            if ((int)solve_board(v3, 0, 0) == 0) {
                puts(""\nUnsolvable Sudoku!"");
            } else {
                puts(""\nSolved Sudoku:"");
                print_board(&v2);
            }
            int result = 0;
            if (v1 != __readfsqword(40)) {
                __stack_chk_fail();
                result = 1;
            }
            return result;
        }


",1
"//FormAI DATASET v1.0 Category: Building a XML Parser ; Style: modular
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_TAG_LENGTH 100
#define MAX_ATTRIBUTE_LENGTH 100
#define MAX_VALUE_LENGTH 500

typedef struct {
    char tag[MAX_TAG_LENGTH];
    char attribute[MAX_ATTRIBUTE_LENGTH];
    char value[MAX_VALUE_LENGTH];
} XMLTag;

typedef struct {
    int size;
    int capacity;
    XMLTag* tags;
} XMLTagList;

void initTagList(XMLTagList* list) {
    list->size = 0;
    list->capacity = 10;
    list->tags = (XMLTag*)malloc(sizeof(XMLTag) * list->capacity);
}

void pushTag(XMLTagList* list, XMLTag tag) {
    if (list->size == list->capacity) {
        list->capacity *= 2;
        list->tags = (XMLTag*)realloc(list->tags, sizeof(XMLTag) * list->capacity);
    }
    list->tags[list->size++] = tag;
}

void printTag(XMLTag tag) {
    printf(""<%s %s=\""%s\"" />\n"", tag.tag, tag.attribute, tag.value);
}

void printTagList(XMLTagList* list) {
    for (int i = 0; i < list->size; i++) {
        printTag(list->tags[i]);
    }
}

XMLTag parseTag(char* tagString) {
    XMLTag tag;
    tag.attribute[0] = '\0';
    tag.value[0] = '\0';

    // Find tag name
    int i;
    for (i = 0; i < strlen(tagString); i++) {
        if (isspace(tagString[i])) break;
        tag.tag[i] = tagString[i];
    }
    tag.tag[i] = '\0';

    // Find attributes
    int attributeStart = i;
    while (i < strlen(tagString)) {
        char c = tagString[i];
        if (c == '=') {
            int j;
            for (j = i+1; j < strlen(tagString); j++) {
                if (tagString[j] == '\""') break;
                tag.attribute[j-i-1] = tagString[j];
            }
            tag.attribute[j-i-1] = '\0';
        }
        else if (c == '\""') {
            int j;
            for (j = i+1; j < strlen(tagString); j++) {
                if (tagString[j] == '\""') break;
                tag.value[j-i-1] = tagString[j];
            }
            tag.value[j-i-1] = '\0';
        }
        i++;
    }

    return tag;
}

XMLTagList parseXML(char* xmlString) {
    XMLTagList list;
    initTagList(&list);

    // Find and parse each tag
    int i = 0;
    while (i < strlen(xmlString)) {
        char c = xmlString[i];
        if (c == '<') {
            int tagStart = i+1;
            while (xmlString[i] != '>') i++;
            int tagEnd = i;
            XMLTag tag = parseTag(xmlString + tagStart);
            pushTag(&list, tag);
        }
        i++;
    }

    return list;
}

int main() {
    char* xml = ""<note title=\""My Note\"" body=\""This is a note.\"" /><book title=\""My Book\"" author=\""John Doe\"" publisher=\""Penguin\"" />"";
    XMLTagList tags = parseXML(xml);
    printTagList(&tags);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
int64_t * function_10d0(int32_t size);
int64_t * function_10e0(int64_t * ptr, int32_t size);
int16_t ** function_10f0(void);
int64_t initTagList(int64_t * a1);
int64_t parseTag(int64_t * a1, int64_t a2);
int64_t parseXML(int64_t a1);
int64_t printTag(void);
int64_t printTagList(int64_t * a1);
int64_t pushTag(int64_t * a1, int64_t a2);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x20001; // 0x2000
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return strlen(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
int64_t * function_10d0(int32_t size) {
    // 0x10d0
    return malloc(size);
}

// Address range: 0x10e0 - 0x10eb
int64_t * function_10e0(int64_t * ptr, int32_t size) {
    // 0x10e0
    return realloc(ptr, size);
}

// Address range: 0x10f0 - 0x10fb
int16_t ** function_10f0(void) {
    // 0x10f0
    return __ctype_b_loc();
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x1807, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g2;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g2 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x1234
int64_t initTagList(int64_t * a1) {
    int64_t result = (int64_t)a1;
    *(int32_t *)a1 = 0;
    *(int32_t *)(result + 4) = 10;
    *(int64_t *)(result + 8) = (int64_t)malloc(0x1b58);
    return result;
}

// Address range: 0x1234 - 0x1306
int64_t pushTag(int64_t * a1, int64_t a2) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = a2;
    int64_t v3; // 0x1234
    int32_t v4 = v3;
    int32_t * v5 = (int32_t *)(v1 + 4); // 0x124e
    int32_t v6 = *v5; // 0x124e
    int64_t v7; // 0x1234
    int64_t v8; // 0x1234
    int32_t v9; // 0x1234
    if (v6 != v4) {
        // 0x1234
        v7 = *(int64_t *)(v1 + 8);
        v8 = a2;
        v9 = v4;
    } else {
        // 0x1255
        *v5 = 2 * v6;
        int64_t * v10 = (int64_t *)(v1 + 8);
        int64_t mem = (int64_t)realloc((int64_t *)*v10, 1400 * v6); // 0x1284
        *v10 = mem;
        v7 = mem;
        v8 = v2;
        int64_t v11; // 0x1234
        v9 = *(int32_t *)&v11;
    }
    // 0x1291
    *(int32_t *)a1 = v9 + 1;
    int64_t v12 = 700 * (int64_t)v9 + v7; // 0x12b1
    *(int64_t *)v12 = v8;
    int64_t v13 = v12 + 8 & -8; // 0x12e4
    int64_t v14 = v12 - v13; // 0x12e8
    int64_t result = (int64_t)&v2 - v14; // 0x12eb
    __asm_rep_movsq_memcpy((char *)v13, (char *)result, (v14 + 700) / 8 % 0x20000000);
    return result;
}

// Address range: 0x1306 - 0x133a
int64_t printTag(void) {
    // 0x1306
    int64_t v1; // bp+108, 0x1306
    int64_t v2; // bp+208, 0x1306
    int64_t v3; // 0x1306
    return printf(""<%s %s=\""%s\"" />\n"", &v3, &v1, &v2);
}

// Address range: 0x133a - 0x13ab
int64_t printTagList(int64_t * a1) {
    // 0x133a
    int64_t v1; // 0x133a
    uint64_t result = v1 & 0xffffffff;
    if ((int32_t)v1 == 0) {
        // 0x13a7
        return result;
    }
    // 0x1353
    int64_t v2; // bp-40, 0x133a
    char * v3 = (char *)((int64_t)&v2 - 704); // 0x137f
    int32_t v4 = 0; // 0x1398
    int64_t v5 = *(int64_t *)((int64_t)a1 + 8); // 0x1357
    __asm_rep_movsq_memcpy(v3, (char *)v5, 87);
    printTag();
    v4++;
    int64_t v6 = v4;
    while (result > v6) {
        // 0x1353
        v5 = *(int64_t *)((int64_t)a1 + 8);
        __asm_rep_movsq_memcpy(v3, (char *)(v5 + 700 * v6), 87);
        printTag();
        v4++;
        v6 = v4;
    }
    // 0x13a7
    return result;
}

// Address range: 0x13ab - 0x16a5
int64_t parseTag(int64_t * a1, int64_t a2) {
    // 0x13ab
    int64_t v1; // bp-8, 0x13ab
    int64_t v2 = &v1; // 0x13b0
    int64_t v3 = __readfsqword(40); // 0x13c9
    char * str = (char *)a2; // 0x1468
    int64_t v4 = v2 - 736;
    int32_t v5 = 0; // 0x1470
    int32_t v6 = 0; // 0x1470
    if (strlen(str) != 0) {
        int16_t * v7 = *__ctype_b_loc(); // 0x13f7
        int64_t v8 = v5; // 0x1400
        char v9 = *(char *)(v8 + a2); // 0x140d
        uint16_t v10 = *(int16_t *)(2 * (int64_t)v9 + (int64_t)v7); // 0x141a
        v6 = v5;
        while (((int32_t)v10 & (int32_t)&g1) == 0) {
            // 0x1429
            *(char *)(v4 + v8) = v9;
            v5++;
            v6 = v5;
            if (v5 >= strlen(str)) {
                // break -> 0x1475
                break;
            }
            v7 = *__ctype_b_loc();
            v8 = v5;
            v9 = *(char *)(v8 + a2);
            v10 = *(int16_t *)(2 * (int64_t)v9 + (int64_t)v7);
            v6 = v5;
        }
    }
    // 0x1475
    *(char *)(v4 + (int64_t)v6) = 0;
    if (v6 < strlen(str)) {
        int64_t v11 = v2 - 636;
        int64_t v12 = v2 - 536;
        char v13 = *(char *)((int64_t)v6 + a2); // 0x14a9
        int32_t v14; // 0x13ab
        int32_t v15; // 0x13ab
        int32_t v16; // 0x13ab
        int32_t v17; // 0x13ab
        int32_t v18; // 0x13ab
        int32_t v19; // 0x13ab
        int32_t v20; // 0x13ab
        int32_t v21; // 0x13ab
        int32_t v22; // 0x13ab
        int32_t v23; // 0x13ab
        int32_t v24; // 0x13ab
        int32_t v25; // 0x13ab
        int32_t v26; // 0x13ab
        int32_t v27; // 0x13ab
        int32_t v28; // 0x13ab
        char v29; // 0x14e3
        char v30; // 0x158e
        if (v13 != 61) {
            // 0x155d
            v14 = v6 + 1;
            v15 = v14;
            if (v13 == 34) {
                // 0x15ca
                v18 = v14;
                v22 = v6;
                if (v14 < strlen(str)) {
                    v21 = v6;
                    v19 = v18;
                    v30 = *(char *)((int64_t)v19 + a2);
                    v22 = v21;
                    while (v30 != 34) {
                        // 0x1595
                        *(char *)(v12 + (int64_t)(v21 - v6)) = v30;
                        v17 = v19 + 1;
                        v18 = v17;
                        v20 = v19;
                        v22 = v19;
                        if (v17 >= strlen(str)) {
                            // break -> 0x15ea
                            break;
                        }
                        v21 = v20;
                        v19 = v18;
                        v30 = *(char *)((int64_t)v19 + a2);
                        v22 = v21;
                    }
                }
                // 0x15ea
                *(char *)(v12 + (int64_t)(v22 - v6)) = 0;
                v15 = v14;
            }
        } else {
            // 0x151f
            v23 = v6 + 1;
            v24 = v23;
            v28 = v6;
            if (v23 < strlen(str)) {
                v27 = v6;
                v25 = v24;
                v29 = *(char *)((int64_t)v25 + a2);
                v28 = v27;
                while (v29 != 34) {
                    // 0x14ea
                    *(char *)(v11 + (int64_t)(v27 - v6)) = v29;
                    v16 = v25 + 1;
                    v24 = v16;
                    v26 = v25;
                    v28 = v25;
                    if (v16 >= strlen(str)) {
                        // break -> 0x153f
                        break;
                    }
                    v27 = v26;
                    v25 = v24;
                    v29 = *(char *)((int64_t)v25 + a2);
                    v28 = v27;
                }
            }
            // 0x153f
            *(char *)(v11 + (int64_t)(v28 - v6)) = 0;
            v15 = v23;
        }
        int32_t v31 = v15;
        while (v31 < strlen(str)) {
            int32_t v32 = v31;
            v13 = *(char *)((int64_t)v32 + a2);
            if (v13 != 61) {
                // 0x155d
                v14 = v32 + 1;
                v15 = v14;
                if (v13 == 34) {
                    // 0x15ca
                    v18 = v14;
                    v20 = v32;
                    v22 = v32;
                    if (v14 < strlen(str)) {
                        v21 = v20;
                        v19 = v18;
                        v30 = *(char *)((int64_t)v19 + a2);
                        v22 = v21;
                        while (v30 != 34) {
                            // 0x1595
                            *(char *)(v12 + (int64_t)(v21 - v32)) = v30;
                            v17 = v19 + 1;
                            v18 = v17;
                            v20 = v19;
                            v22 = v19;
                            if (v17 >= strlen(str)) {
                                // break -> 0x15ea
                                break;
                            }
                            v21 = v20;
                            v19 = v18;
                            v30 = *(char *)((int64_t)v19 + a2);
                            v22 = v21;
                        }
                    }
                    // 0x15ea
                    *(char *)(v12 + (int64_t)(v22 - v32)) = 0;
                    v15 = v14;
                }
            } else {
                // 0x151f
                v23 = v32 + 1;
                v24 = v23;
                v26 = v32;
                v28 = v32;
                if (v23 < strlen(str)) {
                    v27 = v26;
                    v25 = v24;
                    v29 = *(char *)((int64_t)v25 + a2);
                    v28 = v27;
                    while (v29 != 34) {
                        // 0x14ea
                        *(char *)(v11 + (int64_t)(v27 - v32)) = v29;
                        v16 = v25 + 1;
                        v24 = v16;
                        v26 = v25;
                        v28 = v25;
                        if (v16 >= strlen(str)) {
                            // break -> 0x153f
                            break;
                        }
                        v27 = v26;
                        v25 = v24;
                        v29 = *(char *)((int64_t)v25 + a2);
                        v28 = v27;
                    }
                }
                // 0x153f
                *(char *)(v11 + (int64_t)(v28 - v32)) = 0;
                v15 = v23;
            }
            // 0x1603
            v31 = v15;
        }
    }
    int64_t result = (int64_t)a1;
    int64_t v33; // bp-744, 0x13ab
    *a1 = v33;
    int64_t v34 = result + 8 & -8; // 0x1665
    int64_t v35 = result - v34; // 0x1669
    __asm_rep_movsq_memcpy((char *)v34, (char *)((int64_t)&v33 - v35), (v35 + 700) / 8 % 0x20000000);
    if (v3 != __readfsqword(40)) {
        // 0x1693
        __stack_chk_fail();
    }
    // 0x1698
    return result;
}

// Address range: 0x16a5 - 0x1807
int64_t parseXML(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x16bc
    int64_t v2; // bp-760, 0x16a5
    initTagList(&v2);
    char * str = (char *)a1; // 0x17d1
    if (strlen(str) != 0) {
        // 0x16e9
        int64_t v3; // bp-792, 0x16a5
        char * v4 = (char *)((int64_t)&v3 - 704);
        int32_t v5 = 0;
        int32_t v6 = v5; // 0x170c
        int32_t v7; // 0x16a5
        int64_t v8; // bp-744, 0x16a5
        int32_t v9; // 0x16a5
        int32_t v10; // 0x16a5
        if (*(char *)((int64_t)v5 + a1) != 60) {
            // 0x16e9
            v7 = v5 + 1;
        } else {
            v9 = v6;
            v10 = v9 + 1;
            while (*(char *)((int64_t)v9 + a1) != 62) {
                // 0x172a
                v9 = v10;
                v10 = v9 + 1;
            }
            // 0x1744
            parseTag(&v8, (int64_t)(v5 + 1) + a1);
            __asm_rep_movsq_memcpy(v4, (char *)&v8, 87);
            pushTag(&v2, (int64_t)&g3);
            v7 = v10;
        }
        int32_t v11 = v7;
        while (v11 < strlen(str)) {
            // 0x16e9
            v5 = v11;
            v6 = v5;
            if (*(char *)((int64_t)v5 + a1) != 60) {
                // 0x16e9
                v7 = v5 + 1;
            } else {
                v9 = v6;
                v10 = v9 + 1;
                while (*(char *)((int64_t)v9 + a1) != 62) {
                    // 0x172a
                    v9 = v10;
                    v10 = v9 + 1;
                }
                // 0x1744
                parseTag(&v8, (int64_t)(v5 + 1) + a1);
                __asm_rep_movsq_memcpy(v4, (char *)&v8, 87);
                pushTag(&v2, (int64_t)&g3);
                v7 = v10;
            }
            // 0x17b7
            v11 = v7;
        }
    }
    int64_t result = v2; // 0x17fa
    if (v1 != __readfsqword(40)) {
        // 0x17fc
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1801
    return result;
}

// Address range: 0x1807 - 0x1868
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1813
    char * v2 = (char *)parseXML((int64_t)""<note title=\""My Note\"" body=\""This is a note.\"" /><book title=\""My Book\"" author=\""John Doe\"" publisher=\""Penguin\"" />""); // bp-40, 0x1839
    printTagList((int64_t *)&v2);
    int64_t result = 0; // 0x185f
    if (v1 != __readfsqword(40)) {
        // 0x1861
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1866
    return result;
}

// Address range: 0x1868 - 0x1875
int64_t _fini(void) {
    // 0x1868
    int64_t result; // 0x1868
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","nclude <stdio.h>

int main(int argc, char ** argv) {
    printf(""Hello, world!\n"");
    return 0;
}

",0
"//FormAI DATASET v1.0 Category: Hotel Management System ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>

// Define the maximum number of rooms available
#define MAX_ROOMS 50

// Room structure to hold room number and availability status
typedef struct {
    int roomNo;
    int isAvailable;
} Room;

// Function to generate the initial list of rooms
void generateRooms(Room* rooms) {
    for(int i = 0; i < MAX_ROOMS; i++) {
        rooms[i].roomNo = i+1;
        rooms[i].isAvailable = 1; // 1 for available, 0 for booked
    }
}

// Function to display the list of available rooms
void displayAvailableRooms(Room* rooms) {
    printf(""\nAvailable Rooms:\n"");
    printf(""Room No.\tStatus\n"");
    for(int i = 0; i < MAX_ROOMS; i++) {
        if(rooms[i].isAvailable) {
            printf(""%d\t\tAvailable\n"", rooms[i].roomNo);
        }
    }
}

// Function to book a room
void bookRoom(Room* rooms, int roomNo) {
    if(rooms[roomNo-1].isAvailable) {
        rooms[roomNo-1].isAvailable = 0;
        printf(""\nRoom %d has been booked successfully!\n"", roomNo);
    } else {
        printf(""\nSorry, Room %d is not available.\n"", roomNo);
    }
}

// Function to check out of a room
void checkOut(Room* rooms, int roomNo) {
    if(!rooms[roomNo-1].isAvailable) {
        rooms[roomNo-1].isAvailable = 1;
        printf(""\nThank you for staying with us in Room %d. Hope you had a pleasant stay!\n"", roomNo);
    } else {
        printf(""\nSorry, Room %d is already available.\n"", roomNo);
    }
}

int main() {
    Room rooms[MAX_ROOMS];
    generateRooms(rooms);

    int choice;
    int roomNo;

    // Display the main menu
    printf(""Welcome to C Hotel Management System!\n"");
    do {
        printf(""\n1. Display available rooms\n2. Book a room\n3. Check out of a room\n4. Exit\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch(choice) {
            case 1:
                displayAvailableRooms(rooms);
                break;
            case 2:
                printf(""\nEnter the room number you want to book: "");
                scanf(""%d"", &roomNo);
                bookRoom(rooms, roomNo);
                break;
            case 3:
                printf(""\nEnter the room number you want to check out of: "");
                scanf(""%d"", &roomNo);
                checkOut(rooms, roomNo);
                break;
            case 4:
                printf(""\nThank you for using C Hotel Management System! Have a nice day!\n"");
                break;
            default:
                printf(""\nInvalid choice! Please try again.\n"");
        }
    } while(choice != 4);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t bookRoom(int64_t * a1, int64_t a2);
int64_t checkOut(int64_t * a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t displayAvailableRooms(int64_t * a1);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t generateRooms(int64_t * a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x138f, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1203
int64_t generateRooms(int64_t * a1) {
    int64_t v1 = 0;
    int64_t result = 8 * v1 + (int64_t)a1; // 0x11cf
    v1++;
    *(int32_t *)result = (int32_t)v1;
    *(int32_t *)(result + 4) = 1;
    while (v1 != 50) {
        // 0x11be
        result = 8 * v1 + (int64_t)a1;
        v1++;
        *(int32_t *)result = (int32_t)v1;
        *(int32_t *)(result + 4) = 1;
    }
    // 0x11ff
    return result;
}

// Address range: 0x1203 - 0x128f
int64_t displayAvailableRooms(int64_t * a1) {
    // 0x1203
    puts(""\nAvailable Rooms:"");
    puts(""Room No.\tStatus"");
    int64_t chars_printed; // 0x1203
    for (int64_t i = 0; i < 50; i++) {
        int64_t v1 = 8 * i + (int64_t)a1; // 0x124b
        chars_printed = 0;
        if (*(int32_t *)(v1 + 4) != 0) {
            // 0x1255
            chars_printed = printf(""%d\t\tAvailable\n"", (int64_t)*(int32_t *)v1);
        }
    }
    // 0x128b
    return chars_printed;
}

// Address range: 0x128f - 0x130f
int64_t bookRoom(int64_t * a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2;
    int64_t v2 = v1 >> 32; // 0x129f
    int32_t * v3 = (int32_t *)((int64_t)a1 - 4 + (v1 >> 29)); // 0x12b6
    int32_t chars_printed; // 0x128f
    if (*v3 == 0) {
        // 0x12f3
        chars_printed = printf(""\nSorry, Room %d is not available.\n"", v2 & 0xffffffff);
    } else {
        // 0x12bd
        *v3 = 0;
        chars_printed = printf(""\nRoom %d has been booked successfully!\n"", v2 & 0xffffffff);
    }
    // 0x130c
    return chars_printed;
}

// Address range: 0x130f - 0x138f
int64_t checkOut(int64_t * a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2;
    int64_t v2 = v1 >> 32; // 0x131f
    int32_t * v3 = (int32_t *)((int64_t)a1 - 4 + (v1 >> 29)); // 0x1336
    int32_t chars_printed; // 0x130f
    if (*v3 != 0) {
        // 0x1373
        chars_printed = printf(""\nSorry, Room %d is already available.\n"", v2 & 0xffffffff);
    } else {
        // 0x133d
        *v3 = 1;
        chars_printed = printf(""\nThank you for staying with us in Room %d. Hope you had a pleasant stay!\n"", v2 & 0xffffffff);
    }
    // 0x138c
    return chars_printed;
}

// Address range: 0x138f - 0x1535
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x139e
    int64_t v2; // bp-424, 0x138f
    generateRooms(&v2);
    puts(""Welcome to C Hotel Management System!"");
    int64_t v3; // bp-432, 0x138f
    while (true) {
      lab_0x13cb:
        // 0x13cb
        puts(""\n1. Display available rooms\n2. Book a room\n3. Check out of a room\n4. Exit"");
        printf(""Enter your choice: "");
        scanf(""%d"", &v3);
        int32_t v4 = v3; // 0x1412
        if (v4 == 4) {
            // 0x14eb
            puts(""\nThank you for using C Hotel Management System! Have a nice day!"");
            goto lab_0x150b;
        } else {
            if (v4 > 4) {
                // 0x14fc
                puts(""\nInvalid choice! Please try again."");
                goto lab_0x150b;
            } else {
                int64_t v5; // bp-428, 0x138f
                switch (v4) {
                    case 3: {
                        // 0x14a0
                        printf(""\nEnter the room number you want to check out of: "");
                        scanf(""%d"", &v5);
                        checkOut(&v2, v5 & 0xffffffff);
                        goto lab_0x150b;
                    }
                    case 1: {
                        // 0x1441
                        displayAvailableRooms(&v2);
                        goto lab_0x150b;
                    }
                    case 2: {
                        // 0x1455
                        printf(""\nEnter the room number you want to book: "");
                        scanf(""%d"", &v5);
                        bookRoom(&v2, v5 & 0xffffffff);
                        goto lab_0x150b;
                    }
                    default: {
                        // 0x14fc
                        puts(""\nInvalid choice! Please try again."");
                        goto lab_0x150b;
                    }
                }
            }
        }
    }
  lab_0x151a:;
    int64_t result = 0; // 0x152c
    if (v1 != __readfsqword(40)) {
        // 0x152e
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1533
    return result;
  lab_0x150b:
    // 0x150b
    if ((int32_t)v3 == 4) {
        // break -> 0x151a
        goto lab_0x151a;
    }
    goto lab_0x13cb;
}

// Address range: 0x1538 - 0x1545
int64_t _fini(void) {
    // 0x1538
    int64_t result; // 0x1538
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","nclude <stdio.h>
#include <stdlib.h>

int main(int argc, char ** argv) {
    puts(""Welcome to C Hotel Management System!"");
    int room_no;
    while (true) {
        puts(""\n1. Display available rooms\n2. Book a room\n3. Check out of a room\n4. Exit"");
        printf(""Enter your choice: "");
        scanf(""%d"", &room_no);
        int choice = room_no;
        if (choice == 4) {
            puts(""\nThank you for using C Hotel Management System! Have a nice day!"");
            break;
        } else {
            if (choice > 4) {
                puts(""\nInvalid choice! Please try again."");
                continue;
            } else {
                switch (choice) {
                    case 3: {
                        printf(""\nEnter the room number you want to check out of: "");
                        scanf(""%d"", &room_no);
                        printf(""\nRoom %d has been booked successfully!\n"", room_no);
                        break;
                    }
                    case 1: {
                        puts(""\nAvailable Rooms:"");
                        puts(""Room No.\tStatus"");
                        for (int i = 0; i < 50; i++) {
                            int v1 = i;
                            if (v1 < 50) {
                                int v2 = v1;
                                if (v2 < 50) {
                                    int v3 = v2;
                                    if (v3 < 50) {
                                        int v4 = v3;
                                        if (v4 < 50) {
                                            int v5 = v4;
                                            if (v5 < 50) {
                                                int v6 = v5;
                                                if (v6 < 50) {
                                                    int v7 = v6;
                                                    if (v7 < 50) {
                                                        int v8 = v7;
                                                        if (v8 < 50) {
                                                            int v9 = v8;
                                                            if (v9 < 50) {
                                                                int v10 = v9;
                                                                if (v10 < 50) {
                                                                    int v11 = v10;
                                                                    if (v11 < 50) {
                                                                        int v12 = v11;
                                                                        if (v12 < 50) {
                                                                            int v13 = v12;
                                                                            if (v13 < 50) {
                                                                                int v14 = v13;
                                                                                if (v14 < 50) {
                                                                                    int v15 = v14;
                                                                                    if (v15 < 50) {
                                                                                        int v16 = v15;
                                                                                        if (v16 < 50) {
                                                                                            int v17 = v16;
                                                                                            if (v17 < 50) {
                                                                                                int v18 = v17;
                                                                                                if (v18 < 50) {
                                                                                                    int v19 = v18;
                                                                                                    if (v19 < 50) {
                                                                                                        int v20 = v19;
                                                                                                        if (v20 < 50) {
                                                                                                            int v21 = v20;
                                                                                                            if (v21 < 50) {
                                                                                                                int v22 = v21;
                                                                                                                if (v22 < 50) {
                                                                                                                    int v23 = v22;
                                                                                                                    if (v23 < 50) {
                                                                                                                        int v24 = v23;
                                                                                                                        if (v24 < 50) {
                                                                                                                            int v25 = v24;
                                                                                                                            if (v25 < 50) {
                                                                                                                                int v26 = v25;
                                                                                                                                if (v26 < 50) {
                                                                                                                                    int v27 = v26;
                                                                                                                                    if (v27 < 50) {
                                                                                                                                        int v28 = v27;
                                                                                                                                        if (v28 < 50) {
                                                                                                                                            int v29 = v28;
                                                                                                                                            if (v29 < 50) {
                                                                                                                                                int v30 = v29;
                                                                                                                                                if (v30 < 50) {
                                                                                                                                                    int v31 = v30;
                                                                                                                                                    if (v31 < 50) {
                                                                                                                                                        int v32 = v31;
                                                                                                                                                        if (v32 < 50) {
                                                                                                                                                            int v33 = v32;
                                                                                                                                                            if (v33 < 50) {
                                                                                                                                                                int v34 = v33;
                                                                                                                                                                if (v34 < 50) {
                                                                                                                                                                    int v35 = v34;
                                                                                                                                                                    if (v35 < 50) {
                                                                                                                                                                        int v36 = v35;
                                                                                                                                                                        if (v36 < 50) {
                                                                                                                                                                            int v37 = v36;
                                                                                                                                                                            if (v37 < 50) {
                                                                                                                                                                                int v38 = v37;
                                                                                                                                                                                if (v38 < 50) {
                                                                                                                                                                                    int v39 = v38;
                                                                                                                                                                                    if (v39 < 50) {
                                                                                                                                                                                        int v40 = v39;
                                                                                                                                                                                        if (v40 < 50) {
                                                                                                                                                                                            int v41 = v40;
                                                                                                                                                                                            if (v41 < 50) {
                                                                                                                                                                                                int v42 = v41;
                                                                                                                                                                                                if (v42 < 50) {
                                                                                                                                                                                                    int v43 = v42;
                                                                                                                                                                                                    if (v43 < 50) {
                                                                                                                                                                                                        int v44 = v43;
                                                                                                                                                                                                        if (v44 < 50) {
                                                                                                                                                                                                            int v45 = v44;
                                                                                                                                                                                                            if (v45 < 50) {
                                                                                                                                                                                                                int v46 = v45;
                                                                                                                                                                                              ",1
"//FormAI DATASET v1.0 Category: Spell checking ; Style: puzzling
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

int main()
{
    printf(""Welcome to the Spell Checker!\n"");
    printf(""Enter a word to check: "");

    char word[50];
    scanf(""%s"", word);

    int len = strlen(word);

    for(int i = 0; i < len; i++){
        if(isdigit(word[i]))
        {
            printf(""ERROR: The word contains numbers!\n"");
            return 0;
        }
    }

    char dictionary[1000][50];
    FILE *fp;
    fp = fopen(""dictionary.txt"", ""r"");
    if(fp == NULL)
    {
        printf(""ERROR: Could not open dictionary file.\n"");
        return 0;
    }

    int dictSize = 0;
    while(fscanf(fp, ""%s"", dictionary[dictSize++]) != EOF);

    fclose(fp);

    int found = 0;
    for(int i = 0; i < dictSize; i++)
    {
        if(strcmp(word, dictionary[i]) == 0){
            printf(""The word is spelled correctly!\n"");
            found = 1;
            break;
        }
    }

    if(!found)
        printf(""The word is spelled incorrectly!\n"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10d0(int64_t * d);
int32_t function_10e0(struct _IO_FILE * stream, char * format, ...);
int32_t function_10f0(char * s);
int32_t function_1100(struct _IO_FILE * stream);
int32_t function_1110(char * s);
void function_1120(void);
int32_t function_1130(char * format, ...);
int32_t function_1140(char * s1, char * s2);
struct _IO_FILE * function_1150(char * filename, char * modes);
int32_t function_1160(char * format, ...);
int16_t ** function_1170(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2 = 0; // 0x800
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int64_t * d) {
    // 0x10d0
    __cxa_finalize(d);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(struct _IO_FILE * stream, char * format, ...) {
    // 0x10e0
    return fscanf(stream, format);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * s) {
    // 0x10f0
    return puts(s);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(struct _IO_FILE * stream) {
    // 0x1100
    return fclose(stream);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s) {
    // 0x1110
    return strlen(s);
}

// Address range: 0x1120 - 0x112b
void function_1120(void) {
    // 0x1120
    __stack_chk_fail();
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * format, ...) {
    // 0x1130
    return printf(format);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * s1, char * s2) {
    // 0x1140
    return strcmp(s1, s2);
}

// Address range: 0x1150 - 0x115b
struct _IO_FILE * function_1150(char * filename, char * modes) {
    // 0x1150
    return fopen(filename, modes);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(char * format, ...) {
    // 0x1160
    return scanf(format);
}

// Address range: 0x1170 - 0x117b
int16_t ** function_1170(void) {
    // 0x1170
    return __ctype_b_loc();
}

// Address range: 0x1180 - 0x11a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1180
    int64_t v1; // 0x1180
    __libc_start_main(0x1269, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x11b0 - 0x11d9
int64_t deregister_tm_clones(void) {
    // 0x11b0
    return &g1;
}

// Address range: 0x11e0 - 0x1219
int64_t register_tm_clones(void) {
    // 0x11e0
    return 0;
}

// Address range: 0x1220 - 0x1259
int64_t __do_global_dtors_aux(void) {
    // 0x1220
    if (*(char *)&g1 != 0) {
        // 0x1258
        int64_t result; // 0x1220
        return result;
    }
    // 0x122d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x123b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1247
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1260 - 0x1269
int64_t frame_dummy(void) {
    // 0x1260
    return register_tm_clones();
}

// Address range: 0x1269 - 0x14c5
int main(int argc, char ** argv) {
    // 0x1269
    int64_t v1; // bp-8, 0x1269
    int64_t v2 = &v1; // 0x126d
    int64_t v3 = v2; // 0x1271
    int64_t v4; // bp-49160, 0x1269
    while (v3 - 0x1000 != (int64_t)&v4) {
        // 0x1279
        v3 -= 0x1000;
    }
    int64_t v5 = __readfsqword(40); // 0x1291
    puts(""Welcome to the Spell Checker!"");
    printf(""Enter a word to check: "");
    int64_t str; // bp-72, 0x1269
    scanf(""%s"", &str);
    int32_t len = strlen((char *)&str); // 0x12e5
    if (len > 0) {
        int32_t v6 = 0; // 0x1343
        int16_t * v7 = *__ctype_b_loc(); // 0x1301
        char v8 = *(char *)(v2 - 64 + (int64_t)v6); // 0x130c
        uint16_t v9 = *(int16_t *)(2 * (int64_t)v8 + (int64_t)v7); // 0x131b
        while (((int32_t)v9 & (int32_t)&g2) == 0) {
            // 0x134a
            v6++;
            if (v6 >= len) {
                goto lab_0x1358;
            }
            v7 = *__ctype_b_loc();
            v8 = *(char *)(v2 - 64 + (int64_t)v6);
            v9 = *(int16_t *)(2 * (int64_t)v8 + (int64_t)v7);
        }
        // 0x132a
        puts(""ERROR: The word contains numbers!"");
    } else {
      lab_0x1358:;
        struct _IO_FILE * file = fopen(""dictionary.txt"", ""r""); // 0x136c
        if (file != NULL) {
            // 0x13a6
            int64_t v10; // bp-50072, 0x1269
            int64_t v11 = &v10;
            int32_t v12 = 0;
            int32_t v13 = v12 + 1; // 0x13ac
            int32_t v14 = v13; // 0x13fc
            while (fscanf(file, ""%s"", (char **)(50 * (int64_t)v12 + v11)) != -1) {
                // 0x13a6
                v12 = v14;
                v13 = v12 + 1;
                v14 = v13;
            }
            // 0x13fe
            fclose(file);
            if (v13 > 0) {
                int64_t v15 = 0;
                while (strcmp((char *)&str, (char *)(50 * v15 + v11)) != 0) {
                    // 0x1484
                    v15++;
                    if (v15 >= (int64_t)v13) {
                        goto lab_0x149b;
                    }
                }
                // 0x1462
                puts(""The word is spelled correctly!"");
            } else {
              lab_0x149b:
                // 0x149b
                puts(""The word is spelled incorrectly!"");
            }
        } else {
            // 0x1382
            puts(""ERROR: Could not open dictionary file."");
        }
    }
    int64_t result = 0; // 0x14bc
    if (v5 != __readfsqword(40)) {
        // 0x14be
        __stack_chk_fail();
        result = &g3;
    }
    // 0x14c3
    return result;
}

// Address range: 0x14c8 - 0x14d5
int64_t _fini(void) {
    // 0x14c8
    int64_t result; // 0x14c8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 19

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to the Spell Checker!"");
            printf(""Enter a word to check: "");
            char str[100];
            scanf(""%s"", str);
            int len = strlen(str);
            if (len > 0) {
                int i = 0;
                while (str[i] != '\0') {
                    if (isdigit(str[i])) {
                        puts(""ERROR: The word contains numbers!"");
                        return 0;
                    }
                    i++;
                }
                puts(""The word is spelled correctly!"");
            } else {
                puts(""ERROR: The word is empty!"");
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Sudoku solver ; Style: immersive
#include <stdio.h>
#include <stdbool.h>

#define GRID_SIZE 9

int grid[GRID_SIZE][GRID_SIZE];

bool findUnassignedLocation(int *row, int *col) {
    for (*row = 0; *row < GRID_SIZE; (*row)++) {
        for (*col = 0; *col < GRID_SIZE; (*col)++) {
            if (grid[*row][*col] == 0) {
                return true;
            }
        }
    }
    return false;
}

bool usedInRow(int row, int num) {
    for (int col = 0; col < GRID_SIZE; col++) {
        if (grid[row][col] == num) {
            return true;
        }
    }
    return false;
}

bool usedInColumn(int col, int num) {
    for (int row = 0; row < GRID_SIZE; row++) {
        if (grid[row][col] == num) {
            return true;
        }
    }
    return false;
}

bool usedInBox(int boxStartRow, int boxStartCol, int num) {
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            if (grid[row+boxStartRow][col+boxStartCol] == num) {
                return true;
            }
        }
    }
    return false;
}

bool isSafe(int row, int col, int num) {
    return !usedInRow(row, num) &&
           !usedInColumn(col, num) &&
           !usedInBox(row - row % 3, col - col % 3, num) &&
           grid[row][col] == 0;
}

bool solveSudoku() {
    int row, col;

    if (!findUnassignedLocation(&row, &col)) {
        return true;
    }

    for (int num = 1; num <= 9; num++) {
        if (isSafe(row, col, num)) {
            grid[row][col] = num;

            if (solveSudoku()) {
                return true;
            }

            grid[row][col] = 0;
        }
    }

    return false;
}

void printGrid() {
    for (int row = 0; row < GRID_SIZE; row++) {
        for (int col = 0; col < GRID_SIZE; col++) {
            printf(""%d "", grid[row][col]);
        }
        printf(""\n"");
    }
}

int main() {
    // Sample inputs
    for (int row = 0; row < GRID_SIZE; row++) {
        for (int col = 0; col < GRID_SIZE; col++) {
            scanf(""%d"", &grid[row][col]);
        }
    }

    if (solveSudoku()) {
        printGrid();
    } else {
        printf(""No solution found\n"");
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t findUnassignedLocation(int64_t * a1, int64_t * a2);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(int32_t c);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
int32_t function_10d0(char * format, ...);
int64_t isSafe(int64_t a1, int64_t a2, uint32_t a3);
int64_t printGrid(void);
int64_t register_tm_clones(void);
int64_t solveSudoku(void);
int64_t usedInBox(int64_t a1, int64_t a2, int64_t a3);
int64_t usedInColumn(int64_t a1, int64_t a2);
int64_t usedInRow(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

char g1 = 0; // 0x4020
int64_t g2 = 0; // 0x4040
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(int32_t c) {
    // 0x1090
    return putchar(c);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return scanf(format);
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x1612, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return 0x4010;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (g1 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x1268
int64_t findUnassignedLocation(int64_t * a1, int64_t * a2) {
    // 0x11c9
    *(int32_t *)a1 = 0;
    int64_t v1; // 0x11c9
    uint32_t v2 = (int32_t)v1;
    if (v2 >= 9) {
        // 0x1266
        return 0;
    }
    uint32_t v3 = (int32_t)v1;
    *(int32_t *)a2 = 0;
    if (v3 >= 9) {
        // 0x1247
        while (true) {
            // 0x1247
            *(int32_t *)a1 = v2 + 1;
            *(int32_t *)a2 = 0;
        }
    }
    // 0x11f1
    if (*(int32_t *)(4 * (9 * (0x100000000 * v1 >> 32) + (0x100000000 * v1 >> 32)) + (int64_t)&g2) == 0) {
        // 0x1266
        return 1;
    }
    int32_t * v4 = (int32_t *)(4 * (9 * (0x100000000 * v1 >> 32) + (0x100000000 * v1 >> 32)) + (int64_t)&g2); // 0x121f
    *(int32_t *)a2 = v3 + 1;
    // 0x123c
    while (*v4 != 0) {
        // 0x123c
        *(int32_t *)a2 = v3 + 1;
    }
    // 0x1266
    return 1;
}

// Address range: 0x1268 - 0x12c7
int64_t usedInRow(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a1;
    int64_t v2 = (v1 >> 29) + (v1 >> 32); // 0x1292
    int32_t v3 = 0; // 0x12b6
    int32_t v4 = *(int32_t *)(4 * (v2 + (int64_t)v3) + (int64_t)&g2); // 0x12a7
    int64_t result = 1; // 0x12ad
    while (v4 != (int32_t)a2) {
        // 0x12ba
        v3++;
        result = 0;
        if (v3 >= 9) {
            // break -> 0x12c5
            break;
        }
        v4 = *(int32_t *)(4 * (v2 + (int64_t)v3) + (int64_t)&g2);
        result = 1;
    }
    // 0x12c5
    return result;
}

// Address range: 0x12c7 - 0x1326
int64_t usedInColumn(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a1 >> 32;
    int32_t v2 = 0; // 0x1315
    int32_t v3 = *(int32_t *)(4 * (9 * (int64_t)v2 + v1) + (int64_t)&g2); // 0x1306
    int64_t result = 1; // 0x130c
    while (v3 != (int32_t)a2) {
        // 0x1319
        v2++;
        result = 0;
        if (v2 >= 9) {
            // break -> 0x1324
            break;
        }
        v3 = *(int32_t *)(4 * (9 * (int64_t)v2 + v1) + (int64_t)&g2);
        result = 1;
    }
    // 0x1324
    return result;
}

// Address range: 0x1326 - 0x13a5
int64_t usedInBox(int64_t a1, int64_t a2, int64_t a3) {
    int64_t v1 = 0;
    int64_t v2 = 9 * (0x100000000 * (v1 + a1) >> 32); // 0x1366
    int64_t result; // 0x1326
    int32_t v3; // 0x137b
    for (int64_t i = 0; i < 3; i++) {
        // 0x1349
        v3 = *(int32_t *)(4 * ((0x100000000 * (i + a2) >> 32) + v2) + (int64_t)&g2);
        result = 1;
        if (v3 == (int32_t)a3) {
            return result;
        }
    }
    // 0x1394
    v1++;
    result = 0;
    while (v1 < 3) {
        // 0x138e
        v2 = 9 * (0x100000000 * (v1 + a1) >> 32);
        for (int64_t i = 0; i < 3; i++) {
            // 0x1349
            v3 = *(int32_t *)(4 * ((0x100000000 * (i + a2) >> 32) + v2) + (int64_t)&g2);
            result = 1;
            if (v3 == (int32_t)a3) {
                return result;
            }
        }
        // 0x1394
        v1++;
        result = 0;
    }
  lab_0x13a3:
    // 0x13a3
    return result;
}

// Address range: 0x13a5 - 0x1495
int64_t isSafe(int64_t a1, int64_t a2, uint32_t a3) {
    int64_t v1 = a3; // 0x13c0
    if ((char)usedInRow(a1 & 0xffffffff, v1) == 1) {
        // 0x1490
        return 0;
    }
    int64_t v2 = 0x100000000 * a2 >> 32; // 0x13b4
    if ((char)usedInColumn(v2 & 0xffffffff, v1) == 1) {
        // 0x1490
        return 0;
    }
    int64_t v3 = 0x100000000 * a1;
    int64_t v4 = v3 >> 32; // 0x141c
    if ((char)usedInBox((int64_t)(3 * ((int32_t)(0x55555556 * v4 / 0x100000000) - ((int32_t)a1 >> 31))), (int64_t)(3 * ((int32_t)(0x55555556 * v2 / 0x100000000) - ((int32_t)v2 >> 31))), v1) == 1) {
        // 0x1490
        return 0;
    }
    int32_t v5 = *(int32_t *)(4 * ((v3 >> 29) + v4 + v2) + (int64_t)&g2); // 0x147d
    if (v5 == 0) {
        // 0x1490
        return 1;
    }
    // 0x1490
    return 0;
}

// Address range: 0x1495 - 0x1591
int64_t solveSudoku(void) {
    int64_t v1 = __readfsqword(40); // 0x14a1
    int32_t v2; // bp-24, 0x1495
    int32_t v3; // bp-28, 0x1495
    int64_t v4 = findUnassignedLocation((int64_t *)&v3, (int64_t *)&v2); // 0x14be
    int64_t v5 = 1; // 0x14c8
    if ((char)v4 == 1) {
        int32_t v6 = 1;
        if ((char)isSafe((int64_t)v3, (int64_t)v2, v6) != 0) {
            // 0x14f6
            *(int32_t *)(4 * (9 * (int64_t)v3 + (int64_t)v2) + (int64_t)&g2) = v6;
            if ((char)solveSudoku() != 0) {
                // break -> 0x157b
                break;
            }
            // 0x1539
            *(int32_t *)(4 * (9 * (int64_t)v3 + (int64_t)v2) + (int64_t)&g2) = 0;
        }
        int32_t v7 = v6 + 1; // 0x1568
        v5 = 0;
        while (v7 < 10) {
            // 0x14e0
            v6 = v7;
            if ((char)isSafe((int64_t)v3, (int64_t)v2, v6) != 0) {
                // 0x14f6
                *(int32_t *)(4 * (9 * (int64_t)v3 + (int64_t)v2) + (int64_t)&g2) = v6;
                v5 = 1;
                if ((char)solveSudoku() != 0) {
                    // break -> 0x157b
                    break;
                }
                // 0x1539
                *(int32_t *)(4 * (9 * (int64_t)v3 + (int64_t)v2) + (int64_t)&g2) = 0;
            }
            // 0x1568
            v7 = v6 + 1;
            v5 = 0;
        }
    }
    int64_t result = v5; // 0x1588
    if (v1 != __readfsqword(40)) {
        // 0x158a
        __stack_chk_fail();
        result = &g3;
    }
    // 0x158f
    return result;
}

// Address range: 0x1591 - 0x1612
int64_t printGrid(void) {
    int32_t putchar_rc; // 0x15ff
    for (int64_t i = 0; i < 9; i++) {
        int64_t v1 = 9 * i; // 0x15c2
        for (int64_t j = 0; j < 9; j++) {
            uint32_t v2 = *(int32_t *)(4 * (j + v1) + (int64_t)&g2); // 0x15d7
            printf(""%d "", (int64_t)v2);
        }
        // 0x15fa
        putchar_rc = putchar(10);
    }
    // 0x160e
    return putchar_rc;
}

// Address range: 0x1612 - 0x16b6
int main(int argc, char ** argv) {
    for (int64_t i = 0; i < 9; i++) {
        int64_t v1 = 9 * i; // 0x1643
        for (int64_t j = 0; j < 9; j++) {
            // 0x1630
            scanf(""%d"", (int64_t *)(4 * (j + v1) + (int64_t)&g2));
        }
    }
    // 0x1686
    if ((char)solveSudoku() == 0) {
        // 0x16a0
        puts(""No solution found"");
    } else {
        // 0x1694
        printGrid();
    }
    // 0x16af
    return 0;
}

// Address range: 0x16b8 - 0x16c5
int64_t _fini(void) {
    // 0x16b8
    int64_t result; // 0x16b8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdbool.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    scanf(""%d"", &g2[i][j]);
                }
            }
            if (!solveSudoku()) {
                printf(""No solution found"");
            } else {
                printGrid();
            }
            return 0;
        }

        bool isSafe(int row, int col, int num) {
            for (int i = 0; i < 9; i++) {
                if (g2[i][col] == num) return false;
            }
            for (int i = 0; i < 9; i++) {
                if (g2[row][i] == num) return false;
            }
            int box_row = row - row % 3;
            int box_col = col - col % 3;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (g2[box_row + i][box_col + j] == num) return false;
                }
            }
            return true;
        }

        bool solveSudoku() {
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    if (g2[i][j] == 0) {
                        for (int k = 1; k <= 9; k++) {
                            if (isSafe(i, j, k)) {
                                g2[i][j] = k;
                                if (solveSudoku()) return true;
                                g2[i][j] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        void printGrid() {
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                    printf(""%d "", g2[i][j]);
                }
                printf(""\n"");
            }
        }


",1
"//FormAI DATASET v1.0 Category: Educational ; Style: surprised
#include<stdio.h>

int main()
{
    printf(""Oh boy, am I surprised to be running on this computer!\n"");
    printf(""I can't believe it, but I'm actually executing code!\n"");
    printf(""Let me show you what I can do...\n\n"");

    int num1, num2, result;
    char operator;

    printf(""Please enter two numbers:\n"");
    scanf(""%d %d"", &num1, &num2);

    printf(""\nNow enter an operator (+, -, *, /):\n"");
    scanf("" %c"", &operator);

    switch(operator)
    {
        case '+':
            result = num1 + num2;
            printf(""\n%d + %d = %d\n"", num1, num2, result);
            break;

        case '-':
            result = num1 - num2;
            printf(""\n%d - %d = %d\n"", num1, num2, result);
            break;

        case '*':
            result = num1 * num2;
            printf(""\n%d * %d = %d\n"", num1, num2, result);
            break;

        case '/':
            if(num2 == 0)
            {
                printf(""\n\nError: Cannot divide by zero. Let's try that again.\n"");
                main();
            }
            else
            {
                result = num1 / num2;
                printf(""\n%d / %d = %d\n"", num1, num2, result);
            }
            break;

        default:
            printf(""\n\nOperator not recognized. Please try again.\n"");
            main();
    }

    printf(""\nWow, that was a rush! Hope you enjoyed watching me perform my calculations.\n"");
    printf(""Until next time, goodbye!"");
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x13af
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    puts(""Oh boy, am I surprised to be running on this computer!"");
    puts(""I can't believe it, but I'm actually executing code!"");
    puts(""Let me show you what I can do...\n"");
    puts(""Please enter two numbers:"");
    int64_t v2; // bp-24, 0x11a9
    int64_t v3; // bp-28, 0x11a9
    scanf(""%d %d"", &v3, &v2);
    puts(""\nNow enter an operator (+, -, *, /):"");
    int32_t v4; // bp-29, 0x11a9
    scanf("" %c"", &v4);
    int32_t v5 = 0x100000000000000 * (int64_t)v4 >> 56; // 0x1250
    if (v5 == 47) {
        // 0x1309
        if ((int32_t)v2 != 0) {
            int64_t v6 = v3 & 0xffffffff; // 0x1332
            int64_t v7 = v2 & 0xffffffff; // 0x1332
            printf(""\n%d / %d = %d\n"", v6, v7, (0x100000000 * (int64_t)((int32_t)v3 >> 31) | v6) / v7 & 0xffffffff);
        } else {
            // 0x1310
            puts(""\n\nError: Cannot divide by zero. Let's try that again."");
            main((int64_t)""\n\nError: Cannot divide by zero. Let's try that again."", (char **)&v4);
        }
        goto lab_0x1371;
    } else {
        if (v5 > 47) {
            // 0x1358
            puts(""\n\nOperator not recognized. Please try again."");
            main((int64_t)""\n\nOperator not recognized. Please try again."", (char **)&v4);
            goto lab_0x1371;
        } else {
            if (v5 == 45) {
                int64_t v8 = v3;
                int64_t v9 = v2;
                printf(""\n%d - %d = %d\n"", v8 & 0xffffffff, v9 & 0xffffffff, v8 - v9 & 0xffffffff);
                goto lab_0x1371;
            } else {
                if (v5 > 45) {
                    // 0x1358
                    puts(""\n\nOperator not recognized. Please try again."");
                    main((int64_t)""\n\nOperator not recognized. Please try again."", (char **)&v4);
                    goto lab_0x1371;
                } else {
                    if (v5 == 42) {
                        int64_t v10 = v3; // 0x12dc
                        int64_t v11 = v2;
                        printf(""\n%d * %d = %d\n"", v10 & 0xffffffff, v11 & 0xffffffff, (0x100000000 * v11 >> 32) * (0x100000000 * v10 >> 32) & 0xffffffff);
                        goto lab_0x1371;
                    } else {
                        if (v5 != 43) {
                            // 0x1358
                            puts(""\n\nOperator not recognized. Please try again."");
                            main((int64_t)""\n\nOperator not recognized. Please try again."", (char **)&v4);
                            goto lab_0x1371;
                        } else {
                            int64_t v12 = v3;
                            int64_t v13 = v2;
                            printf(""\n%d + %d = %d\n"", v12 & 0xffffffff, v13 & 0xffffffff, v13 + v12 & 0xffffffff);
                            goto lab_0x1371;
                        }
                    }
                }
            }
        }
    }
  lab_0x1371:
    // 0x1371
    puts(""\nWow, that was a rush! Hope you enjoyed watching me perform my calculations."");
    printf(""Until next time, goodbye!"");
    int64_t result = 0; // 0x13a6
    if (v1 != __readfsqword(40)) {
        // 0x13a8
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13ad
    return result;
}

// Address range: 0x13b0 - 0x13bd
int64_t _fini(void) {
    // 0x13b0
    int64_t result; // 0x13b0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            puts(""Oh boy, am I surprised to be running on this computer!"");
            puts(""I can't believe it, but I'm actually executing code!"");
            puts(""Let me show you what I can do...\n"");
            puts(""Please enter two numbers:"");
            int v2;
            int v3;
            scanf(""%d %d"", &v3, &v2);
            puts(""\nNow enter an operator (+, -, *, /):"");
            char v4;
            scanf("" %c"", &v4);
            int v5 = 0x100000000000000 * (int64_t)v4 >> 56;
            if (v5 == 47) {
                if ((int32_t)v2 != 0) {
                    int64_t v6 = v3 & 0xffffffff;
                    int64_t v7 = v2 & 0xffffffff;
                    printf(""\n%d / %d = %d\n"", v6, v7, (0x100000000 * (int64_t)((int32_t)v3 >> 31) | v6) / v7 & 0xffffffff);
                } else {
                    puts(""\n\nError: Cannot divide by zero. Let's try that again."");
                    main((int64_t)""\n\nError: Cannot divide by zero. Let's try that again."", (char **)&v4);
                }
            } else {
                if (v5 > 47) {
                    puts(""\n\nOperator not recognized. Please try again."");
                    main((int64_t)""\n\nOperator not recognized. Please try again."", (char **)&v4);
                } else {
                    if (v5 == 45) {
                        int64_t v8 = v3;
                        int64_t v9 = v2;
                        printf(""\n%d - %d = %d\n"", v8 & 0xffffffff, v9 & 0xffffffff, v8 - v9 & 0xffffffff);
                    } else {
                        if (v5 > 45) {
                            puts(""\n\nOperator not recognized. Please try again."");
                            main((int64_t)""\n\nOperator not recognized. Please try again."", (char **)&v4);
                        } else {
                            if (v5 == 42) {
                                int64_t v10 = v3;
                                int64_t v11 = v2;
                                printf(""\n%d * %d = %d\n"", v10 & 0xffffffff, v11 & 0xffffffff, (0x100000000 * v11 >> 32) * (0x100000000 * v10 >> 32) & 0xffffffff);
                            } else {
                                if (v5 != 43) {
                                    puts(""\n\nOperator not recognized. Please try again."");
                                    main((int64_t)""\n\nOperator not recognized. Please try again."", (char **)&v4);
                                } else {
                                    int64_t v12 = v3;
                                    int64_t v13 = v2;
                                    printf(""\n%d + %d = %d\n"", v12 & 0xffffffff, v13 & 0xffffffff, v13 + v12 & 0xffffffff);
                                }
                            }
                        }
                    }
                }
            }
            puts(""\nWow, that was a rush! Hope you enjoyed watching me perform my calculations."");
            printf(""Until next time, goodbye!"");
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // initialize random seed
    int r = rand() % 10 + 1; // generate random number between 1 and 10

    printf(""Welcome to the Automated Fortune Teller!\n"");

    switch(r) {
        case 1:
            printf(""Today is your lucky day! You will receive a surprise gift!\n"");
            break;
        case 2:
            printf(""You will meet someone special today.\n"");
            break;
        case 3:
            printf(""You will face a challenge, but you are strong enough to overcome it.\n"");
            break;
        case 4:
            printf(""Your hard work will pay off in the near future.\n"");
            break;
        case 5:
            printf(""You will have a successful career and financial stability.\n"");
            break;
        case 6:
            printf(""You will find love and romance in unexpected places.\n"");
            break;
        case 7:
            printf(""You will have a long and happy life with your loved ones.\n"");
            break;
        case 8:
            printf(""You will travel to a new and exciting place soon.\n"");
            break;
        case 9:
            printf(""You will find peace and happiness within yourself.\n"");
            break;
        default:
            printf(""Be cautious today, as bad luck may come your way.\n"");
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(int32_t seed);
int32_t function_10a0(int32_t * timer);
int32_t function_10b0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x103c00000f9e; // 0x2274
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(int32_t seed) {
    // 0x1090
    srand(seed);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(int32_t * timer) {
    // 0x10a0
    return time(timer);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(void) {
    // 0x10b0
    return rand();
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g2;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g2 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x12ec
int main(int argc, char ** argv) {
    // 0x11a9
    srand(time(NULL));
    uint32_t v1 = rand() % 10 + 1; // 0x11f4
    puts(""Welcome to the Automated Fortune Teller!"");
    if (v1 < 10) {
        int32_t v2 = *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1); // 0x1225
        return (int64_t)v2 + (int64_t)&g1;
    }
    // 0x12d6
    puts(""Be cautious today, as bad luck may come your way."");
    return 0;
}

// Address range: 0x12ec - 0x12f9
int64_t _fini(void) {
    // 0x12ec
    int64_t result; // 0x12ec
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            uint32_t v1 = rand() % 10 + 1;
            puts(""Welcome to the Automated Fortune Teller!"");
            if (v1 < 10) {
                int32_t v2 = *(int32_t *)(4 * (int64_t)v1 + (int64_t)&g1);
                return (int64_t)v2 + (int64_t)&g1;
            }
            puts(""Be cautious today, as bad luck may come your way."");
            return 0;
        }

",0
"//FormAI DATASET v1.0 Category: Port Scanner ; Style: sophisticated
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>

#define MAX_PORTS 65535 // maximum number of ports to scan

// function to scan a single port
void scan_port(char *host, int port) {
    // create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror(""socket"");
        return;
    }
    
    // resolve the hostname
    struct hostent *he;
    struct in_addr **addr_list;
    if ((he = gethostbyname(host)) == NULL) {
        herror(""gethostbyname"");
        return;
    }
    addr_list = (struct in_addr **) he->h_addr_list;
    
    // set up the address struct
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr = *addr_list[0];
    memset(&(addr.sin_zero), '\0', 8);
    
    // connect to the port
    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == 0) {
        printf(""Port %d is open on %s\n"", port, host);
    }
    
    // close the socket
    close(sockfd);
}

// main function
int main(int argc, char *argv[]) {
    // check for valid arguments
    if (argc < 2) {
        printf(""Usage: %s <host> [end-port]\n"", argv[0]);
        return 0;
    }
    
    // get the host to scan
    char *host = argv[1];
    
    // get the end port (if provided)
    int end_port = MAX_PORTS;
    if (argc > 2) {
        end_port = atoi(argv[2]);
        if (end_port < 1 || end_port > MAX_PORTS) {
            printf(""Invalid end port: %s\n"", argv[2]);
            return 1;
        }
    }
    
    // scan the ports
    printf(""Scanning ports 1-%d on %s...\n"", end_port, host);
    for (int port = 1; port <= end_port; port++) {
        scan_port(host, port);
    }
    printf(""Done.\n"");
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <netdb.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10f0(int64_t * d);
int32_t function_1100(char * s);
void function_1110(void);
int16_t function_1120(int16_t hostshort);
int32_t function_1130(char * format, ...);
int64_t * function_1140(int64_t * s, int32_t c, int32_t n);
int32_t function_1150(int32_t fd);
struct hostent * function_1160(char * name);
void function_1170(char * str);
void function_1180(char * s);
int32_t function_1190(char * nptr);
int32_t function_11a0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_11b0(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);
int64_t scan_port(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(int64_t * d) {
    // 0x10f0
    __cxa_finalize(d);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * s) {
    // 0x1100
    return puts(s);
}

// Address range: 0x1110 - 0x111b
void function_1110(void) {
    // 0x1110
    __stack_chk_fail();
}

// Address range: 0x1120 - 0x112b
int16_t function_1120(int16_t hostshort) {
    // 0x1120
    return htons(hostshort);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * format, ...) {
    // 0x1130
    return printf(format);
}

// Address range: 0x1140 - 0x114b
int64_t * function_1140(int64_t * s, int32_t c, int32_t n) {
    // 0x1140
    return memset(s, c, n);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(int32_t fd) {
    // 0x1150
    return close(fd);
}

// Address range: 0x1160 - 0x116b
struct hostent * function_1160(char * name) {
    // 0x1160
    return gethostbyname(name);
}

// Address range: 0x1170 - 0x117b
void function_1170(char * str) {
    // 0x1170
    herror(str);
}

// Address range: 0x1180 - 0x118b
void function_1180(char * s) {
    // 0x1180
    perror(s);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(char * nptr) {
    // 0x1190
    return atoi(nptr);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x11a0
    return connect(fd, addr, len);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x11b0
    return socket(domain, type, protocol);
}

// Address range: 0x11c0 - 0x11e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x11c0
    int64_t v1; // 0x11c0
    __libc_start_main(0x13c7, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x11f0 - 0x1219
int64_t deregister_tm_clones(void) {
    // 0x11f0
    return &g1;
}

// Address range: 0x1220 - 0x1259
int64_t register_tm_clones(void) {
    // 0x1220
    return 0;
}

// Address range: 0x1260 - 0x1299
int64_t __do_global_dtors_aux(void) {
    // 0x1260
    if (*(char *)&g1 != 0) {
        // 0x1298
        int64_t result; // 0x1260
        return result;
    }
    // 0x126d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x127b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1287
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x12a0 - 0x12a9
int64_t frame_dummy(void) {
    // 0x12a0
    return register_tm_clones();
}

// Address range: 0x12a9 - 0x13c7
int64_t scan_port(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x12bc
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x12da
    if (sock_fd != -1) {
        char * name = (char *)a1; // 0x1303
        if (gethostbyname(name) != NULL) {
            int64_t host_short = 0x100000000 * a2 >> 32; // 0x12b9
            int16_t addr = 2; // bp-40, 0x1333
            htons((int16_t)host_short);
            int64_t v2; // bp-32, 0x12a9
            memset(&v2, 0, 8);
            if (connect(sock_fd, (struct sockaddr *)&addr, 16) == 0) {
                // 0x138a
                printf(""Port %d is open on %s\n"", host_short & 0xffffffff, name);
            }
            // 0x13a7
            close(sock_fd);
        } else {
            // 0x1313
            herror(""gethostbyname"");
        }
    } else {
        // 0x12e8
        perror(""socket"");
    }
    int64_t result = 0; // 0x13be
    if (v1 != __readfsqword(40)) {
        // 0x13c0
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13c5
    return result;
}

// Address range: 0x13c7 - 0x14c8
int main(int argc, char ** argv) {
    uint32_t v1 = (int32_t)argc; // 0x13d3
    if (v1 <= 1) {
        // 0x13e0
        printf(""Usage: %s <host> [end-port]\n"", argv);
        // 0x14c6
        return 0;
    }
    int64_t v2 = (int64_t)argv;
    int64_t v3 = *(int64_t *)(v2 + 8); // 0x140c
    int32_t str_as_i = 0xffff; // 0x141f
    if (v1 != 2) {
        int64_t * str = (int64_t *)(v2 + 16); // 0x1429
        str_as_i = atoi((char *)*str);
        if (str_as_i >= 0x10000) {
            // 0x1446
            printf(""Invalid end port: %s\n"", (char *)*str);
            // 0x14c6
            return 1;
        }
    }
    // 0x1495
    printf(""Scanning ports 1-%d on %s...\n"", (int64_t)str_as_i, (char *)v3);
    for (int32_t i = 1; i < str_as_i + 1; i++) {
        // 0x1495
        scan_port(v3, (int64_t)i);
    }
    // 0x14b2
    puts(""Done."");
    // 0x14c6
    return 0;
}

// Address range: 0x14c8 - 0x14d5
int64_t _fini(void) {
    // 0x14c8
    int64_t result; // 0x14c8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 22

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <netdb.h>
        #include <netinet/in.h>
        #include <sys/socket.h>
        #include <unistd.h>

        int main(int argc, char **argv) {
            if (argc <= 1) {
                printf(""Usage: %s <host> [end-port]\n"", argv[0]);
                return 0;
            }
            char *name = argv[1];
            int end_port = 0;
            if (argc == 3) {
                end_port = atoi(argv[2]);
            }
            printf(""Scanning ports 1-%d on %s...\n"", end_port, name);
            for (int i = 1; i <= end_port; i++) {
                scan_port(name, i);
            }
            puts(""Done."");
            return 0;
        }

        int scan_port(char *name, int port) {
            int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            if (sock_fd != -1) {
                struct hostent *host = gethostbyname(name);
                if (host != NULL) {
                    uint16_t host_short = htons(port);
                    struct sockaddr addr;
                    memset(&addr, 0, 16);
                    addr.sa_family = AF_INET;
                    addr.sa_data[2] = (port >> 8) & 0xff;
                    addr.sa_data[3] = port & 0xff;
                    if (connect(sock_fd, (struct sockaddr *)&addr, 16) == 0) {
                        printf(""Port %d is open on %s\n"", port, name);
                    }
                } else {
                    herror(""gethostbyname"");
                }
            } else {
                perror(""socket"");
            }
            close(sock_fd);
            return 0;
        }


",1
"//FormAI DATASET v1.0 Category: Text to Morse code conversion ; Style: invasive
#include <stdio.h>
#include <string.h>

void toMorseCode(char *input);

int main(){
    printf(""*****************\n"");
    printf(""* Morse Cod-e-r *\n"");
    printf(""*****************\n\n"");

    char input[1000];
    printf(""Enter Text to Convert to Morse Code:\n"");
    fgets(input, 1000, stdin);

    toMorseCode(input);

    return 0;
}

void toMorseCode(char *input){
    char *morseCode[] = {"".-"", ""-..."", ""-.-."", ""-.."", ""."", ""..-."", ""--."", ""...."", "".."", "".---"", ""-.-"", "".-.."", ""--"", ""-."", ""---"", "".--."", ""--.-"", "".-."", ""..."", ""-"", ""..-"", ""...-"", "".--"", ""-..-"", ""-.--"", ""--.."", ""/""};
    char *alphaBets[] = {""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"", ""L"", ""M"", ""N"", ""O"", ""P"", ""Q"", ""R"", ""S"", ""T"", ""U"", ""V"", ""W"", ""X"", ""Y"", ""Z"", "" ""};

    int i, j;
    for(i = 0; i < strlen(input); i++){
        char *currentChar = input[i];
        for(j = 0; j < 27; j++){
            if(strcmp(currentChar, alphaBets[j]) == 0){
                printf(""%s "", morseCode[j]);
                break;
            }
        }
    }
    printf(""\n\n"");
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
int32_t function_10a0(char * s);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
char * function_10e0(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_10f0(char * s1, char * s2);
int64_t register_tm_clones(void);
int64_t toMorseCode(int64_t * str);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x3e8
struct _IO_FILE * g2 = NULL; // 0x4010
char g3 = 0; // 0x4018
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g4;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return strlen(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
char * function_10e0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x10e0
    return fgets(s, n, stream);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * s1, char * s2) {
    // 0x10f0
    return strcmp(s1, s2);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x11e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return (int64_t)&g2;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (g3 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    g3 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x1288
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11f8
    puts(""*****************"");
    puts(""* Morse Cod-e-r *"");
    puts(""*****************\n"");
    puts(""Enter Text to Convert to Morse Code:"");
    int64_t str; // bp-1016, 0x11e9
    fgets((char *)&str, (int32_t)&g1, g2);
    toMorseCode(&str);
    int64_t result = 0; // 0x127f
    if (v1 != __readfsqword(40)) {
        // 0x1281
        __stack_chk_fail();
        result = &g4;
    }
    // 0x1286
    return result;
}

// Address range: 0x1288 - 0x1668
int64_t toMorseCode(int64_t * str) {
    int64_t v1 = __readfsqword(40); // 0x129f
    int32_t v2 = 0; // 0x1638
    if (strlen((char *)str) != 0) {
        while (true) {
            char str2 = *(char *)((int64_t)v2 + (int64_t)str); // 0x159d
            int64_t v3 = 0;
            int64_t v4; // bp-8, 0x1288
            int64_t v5 = 8 * v3 + (int64_t)&v4;
            int64_t str3 = *(int64_t *)(v5 - 240); // 0x15bf
            while (strcmp((char *)(int64_t)str2, (char *)str3) != 0) {
                int64_t v6 = v3 + 1;
                if (v6 >= 27) {
                    goto lab_0x1616;
                }
                v3 = v6;
                v5 = 8 * v3 + (int64_t)&v4;
                str3 = *(int64_t *)(v5 - 240);
            }
            // 0x15dd
            printf(""%s "", (char *)*(int64_t *)(v5 - 464));
          lab_0x1616:
            // 0x1616
            v2++;
            if (v2 >= strlen((char *)str)) {
                // break -> 0x163e
                break;
            }
        }
    }
    // 0x163e
    puts(""\n"");
    int64_t result = 0; // 0x165b
    if (v1 != __readfsqword(40)) {
        // 0x165d
        __stack_chk_fail();
        result = &g4;
    }
    // 0x1662
    return result;
}

// Address range: 0x1668 - 0x1675
int64_t _fini(void) {
    // 0x1668
    int64_t result; // 0x1668
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            puts(""*****************"");
            puts(""* Morse Cod-e-r *"");
            puts(""*****************\n"");
            puts(""Enter Text to Convert to Morse Code:"");
            char str[100];
            fgets(str, 100, stdin);
            toMorseCode(str);
            return 0;
        }

        int toMorseCode(char * str) {
            int i = 0;
            while (str[i] != '\0') {
                int j = 0;
                while (str[i] != str[j]) {
                    j++;
                }
                printf(""%s "", str[i] == str[j] ? ""."" : ""-"");
                i++;
            }
            puts(""\n"");
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Smart home light control ; Style: thoughtful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_LIGHTS 10

// Struct to hold each light's data
struct Light {
    char name[20];
    int brightness;
    bool isOn;
};

// Function prototypes
void turnOnLight(struct Light * light);
void turnOffLight(struct Light * light);
void adjustBrightness(struct Light * light, int brightness);
void displayLights(struct Light lights[], int numLights);

int main() {
    // create some Light objects
    struct Light livingRoom = {""Living Room"", 100, true};
    struct Light kitchen = {""Kitchen"", 50, false};
    struct Light bedroom = {""Bedroom"", 75, true};

    // create an array of Light objects
    struct Light lights[MAX_LIGHTS];
    lights[0] = livingRoom;
    lights[1] = kitchen;
    lights[2] = bedroom;
    int numLights = 3;

    // display all the current lights
    displayLights(lights, numLights);

    // turn off all the lights
    for (int i=0; i<numLights; i++) {
        turnOffLight(&lights[i]);
    }

    // display all the current lights again
    displayLights(lights, numLights);

    // turn on the living room light and set its brightness to 75
    turnOnLight(&livingRoom);
    adjustBrightness(&livingRoom, 75);

    // display all the current lights again
    displayLights(lights, numLights);

    // add a new light to the array
    struct Light newLight = {""Office"", 25, true};
    lights[numLights] = newLight;
    numLights++;

    // display all the current lights one last time
    displayLights(lights, numLights);

    return 0;
}

void turnOnLight(struct Light * light) {
    light->isOn = true;
}

void turnOffLight(struct Light * light) {
    light->isOn = false;
}

void adjustBrightness(struct Light * light, int brightness) {
    light->brightness = brightness;
}

void displayLights(struct Light lights[], int numLights) {
    printf(""Current Lights:\n"");
    for (int i=0; i<numLights; i++) {
        printf(""%s - %s, Brightness: %d%%\n"", lights[i].name, lights[i].isOn ? ""On"" : ""Off"", lights[i].brightness);
    }
    printf(""\n"");
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t adjustBrightness(int64_t * a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t displayLights(int64_t * a1, int64_t a2);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
int32_t function_1090(char * s);
void function_10a0(void);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);
int64_t turnOffLight(int64_t result);
int64_t turnOnLight(int64_t * a1);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(void) {
    // 0x10a0
    __stack_chk_fail();
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return printf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1490
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b9
    int64_t v2 = 0x5220676e6976694c; // bp-440, 0x11d7
    int64_t v3 = 0x5220676e6976694c; // bp-312, 0x127e
    displayLights(&v3, 3);
    for (int64_t i = 0; i < 3; i++) {
        // 0x133f
        turnOffLight(28 * i + (int64_t)&v3);
    }
    // 0x137d
    int64_t v4; // bp-8, 0x11a9
    int64_t v5 = &v4; // 0x11ae
    displayLights(&v3, 3);
    turnOnLight(&v2);
    adjustBrightness(&v2, 75);
    displayLights(&v3, 3);
    *(int64_t *)(v5 - 220) = 0x65636966664f;
    *(int64_t *)(v5 - 212) = 0;
    *(int64_t *)(v5 - 204) = 0;
    *(int32_t *)(v5 - 196) = 1;
    displayLights(&v3, 4);
    int64_t result = 0; // 0x1483
    if (v1 != __readfsqword(40)) {
        // 0x1485
        __stack_chk_fail();
        result = &g2;
    }
    // 0x148a
    return result;
}

// Address range: 0x1490 - 0x14a7
int64_t turnOnLight(int64_t * a1) {
    int64_t result = (int64_t)a1;
    *(char *)(result + 24) = 1;
    return result;
}

// Address range: 0x14a7 - 0x14be
int64_t turnOffLight(int64_t result) {
    // 0x14a7
    *(char *)(result + 24) = 0;
    return result;
}

// Address range: 0x14be - 0x14da
int64_t adjustBrightness(int64_t * a1, int64_t a2) {
    int64_t result = (int64_t)a1;
    *(int32_t *)(result + 20) = (int32_t)a2;
    return result;
}

// Address range: 0x14da - 0x15b1
int64_t displayLights(int64_t * a1, int64_t a2) {
    // 0x14da
    puts(""Current Lights:"");
    if ((uint32_t)(int32_t)a2 <= 0) {
        // 0x15a4
        return putchar(10);
    }
    int64_t v1 = 0;
    int64_t v2 = 28 * v1 + (int64_t)a1; // 0x1523
    uint32_t v3 = *(int32_t *)(v2 + 20); // 0x1526
    char * v4 = *(char *)(v2 + 24) == 0 ? ""Off"" : ""On""; // 0x158f
    printf(""%s - %s, Brightness: %d%%\n"", (char *)v2, v4, (int64_t)v3);
    v1++;
    while (v1 != (a2 & 0xffffffff)) {
        // 0x1508
        v2 = 28 * v1 + (int64_t)a1;
        v3 = *(int32_t *)(v2 + 20);
        v4 = *(char *)(v2 + 24) == 0 ? ""Off"" : ""On"";
        printf(""%s - %s, Brightness: %d%%\n"", (char *)v2, v4, (int64_t)v3);
        v1++;
    }
    // 0x15a4
    return putchar(10);
}

// Address range: 0x15b4 - 0x15c1
int64_t _fini(void) {
    // 0x15b4
    int64_t result; // 0x15b4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int i;
            int lights[4] = {0, 0, 0, 0};
            int brightness = 0;
            char * light_names[4] = {""Red"", ""Green"", ""Blue"", ""White""};

            printf(""Current Lights:\n"");
            for (i = 0; i < 4; i++) {
                printf(""%s - %s, Brightness: %d%%\n"", light_names[i], lights[i] ? ""On"" : ""Off"", brightness);
            }
            printf(""\n"");

            lights[0] = 1;
            brightness = 75;
            printf(""Current Lights:\n"");
            for (i = 0; i < 4; i++) {
                printf(""%s - %s, Brightness: %d%%\n"", light_names[i], lights[i] ? ""On"" : ""Off"", brightness);
            }
            printf(""\n"");

            lights[0] = 0;
            lights[1] = 1;
            lights[2] = 1;
            lights[3] = 1;
            brightness = 100;
            printf(""Current Lights:\n"");
            for (i = 0; i < 4; i++) {
                printf(""%s - %s, Brightness: %d%%\n"", light_names[i], lights[i] ? ""On"" : ""Off"", brightness);
            }
            printf(""\n"");

            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/statvfs.h>

#define BLOCK_SIZE 512 //bytes

int main(int argc, char *argv[]) {

    if (argc != 2) {
        printf(""Usage: disk_analyzer <path>\n"");
        exit(EXIT_FAILURE);
    }

    const char *path = argv[1];

    struct statvfs stat;
    if (statvfs(path, &stat) != 0) {
        perror(""Failed to stat file system"");
        exit(EXIT_FAILURE);
    }

    long fs_block_size = stat.f_frsize;
    long total_blocks = stat.f_blocks;
    long free_blocks = stat.f_bfree;
    long avail_blocks = stat.f_bavail;

    printf(""File system block size: %ld bytes (%ld blocks of %d bytes each)\n"", fs_block_size, total_blocks, BLOCK_SIZE);
    printf(""Total disk space: %ld bytes (%ld KB)\n"", total_blocks * fs_block_size, total_blocks * fs_block_size / 1024);
    printf(""Free disk space: %ld bytes (%ld KB)\n"", free_blocks * fs_block_size, free_blocks * fs_block_size / 1024);
    printf(""Available disk space: %ld bytes (%ld KB)\n"", avail_blocks * fs_block_size, avail_blocks * fs_block_size / 1024);

    double used_percent = 100.0 * (total_blocks - free_blocks) / total_blocks;
    printf(""Used disk space: %.2f%%\n"", used_percent);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/statvfs.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct statvfs {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12[6];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
int32_t function_10d0(char * file, struct statvfs * buf);
void function_10e0(char * s);
void function_10f0(int32_t status);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x3ff
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * file, struct statvfs * buf) {
    // 0x10d0
    return statvfs(file, buf);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(char * s) {
    // 0x10e0
    perror(s);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(int32_t status) {
    // 0x10f0
    exit(status);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x11e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g2;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g2 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x1426
int main(int argc, char ** argv) {
    // 0x11e9
    int128_t v1; // 0x11e9
    int128_t v2 = v1;
    int64_t v3 = __readfsqword(40); // 0x1205
    if ((int32_t)argc != 2) {
        // 0x121d
        puts(""Usage: disk_analyzer <path>"");
        exit(1);
        // UNREACHABLE
    }
    int64_t path = *(int64_t *)((int64_t)argv + 8); // 0x123d
    int64_t buf; // bp-136, 0x11e9
    if (statvfs((char *)path, (struct statvfs *)&buf) != 0) {
        // 0x1262
        perror(""Failed to stat file system"");
        exit(1);
        // UNREACHABLE
    }
    // 0x127b
    int32_t v4; // 0x11e9
    int64_t v5 = v4; // 0x1286
    int64_t v6 = v1; // 0x1291
    printf(""File system block size: %ld bytes (%ld blocks of %d bytes each)\n"", v4, v4, 512);
    int64_t v7 = v4; // 0x12d8
    int64_t v8 = v7 * v5; // 0x12d8
    uint64_t v9 = v8 < 0 ? v8 + (int64_t)&g1 : v8; // 0x12ea
    printf(""Total disk space: %ld bytes (%ld KB)\n"", v4 * v4, (int32_t)(v9 / 1024));
    int64_t v10 = v7 * v6; // 0x1322
    uint64_t v11 = v10 < 0 ? v10 + (int64_t)&g1 : v10; // 0x1334
    printf(""Free disk space: %ld bytes (%ld KB)\n"", v4 * (int32_t)v1, (int32_t)(v11 / 1024));
    int64_t v12 = v7 * (int64_t)v1; // 0x136c
    uint64_t v13 = v12 < 0 ? v12 + (int64_t)&g1 : v12; // 0x137e
    printf(""Available disk space: %ld bytes (%ld KB)\n"", v4 * (int32_t)v1, (int32_t)(v13 / 1024));
    __asm_pxor(v2, v2);
    int128_t v14 = __asm_cvtsi2sd(v5 - v6); // 0x13c1
    int128_t v15 = __asm_mulsd(__asm_movsd(0x4059000000000000), v14); // 0x13ce
    __asm_pxor(v14, v14);
    int64_t v16 = __asm_movsd_1(__asm_divsd(v15, __asm_cvtsi2sd(v5))); // 0x13e3
    printf(""Used disk space: %.2f%%\n"", (float64_t)(int64_t)__asm_movq(v16));
    int64_t result = 0; // 0x141d
    if (v3 != __readfsqword(40)) {
        // 0x141f
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1424
    return result;
}

// Address range: 0x1428 - 0x1435
int64_t _fini(void) {
    // 0x1428
    int64_t result; // 0x1428
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <sys/statvfs.h>

        int main(int argc, char ** argv) {
            if (argc != 2) {
                puts(""Usage: disk_analyzer <path>"");
                exit(1);
            }
            int path = *(int *)((int)argv + 8);
            struct statvfs buf;
            if (statvfs((char *)path, &buf) != 0) {
                perror(""Failed to stat file system"");
                exit(1);
            }
            int v4 = buf.f_bsize;
            int v5 = buf.f_blocks;
            int v6 = buf.f_bfree;
            printf(""File system block size: %d bytes (%d blocks of %d bytes each)\n"", v4, v5, 512);
            int v7 = v4 * v5;
            printf(""Total disk space: %d bytes (%d KB)\n"", v7, v7 / 1024);
            int v8 = v4 * v6;
            printf(""Free disk space: %d bytes (%d KB)\n"", v8, v8 / 1024);
            int v9 = v4 * (v5 - v6);
            printf(""Available disk space: %d bytes (%d KB)\n"", v9, v9 / 1024);
            double v10 = (double)v5 - (double)v6;
            double v11 = 0.01 * v10;
            double v12 = v10 / (double)v5;
            printf(""Used disk space: %.2f%%\n"", v12);
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Tic Tac Toe AI ; Style: romantic
#include <stdio.h>
#include <stdlib.h>

int check_board(int []);
void print_board(int []);
void play(int [], int);
void computer_play(int []);

int main()
{
    int board[9] = {0,0,0,0,0,0,0,0,0};
    int player;

    printf(""Welcome to Tic Tac Toe!\n\n"");
    printf(""Please choose a number from 1 to 9 to place your 'X'.\n\n"");

    while(check_board(board) == 0) {
        printf(""Player 1 (X):\n"");
        player = 1;
        play(board, player);
        print_board(board);

        if(check_board(board) == 1) {
            break;
        }
        printf(""Computer (O):\n"");
        player = -1;
        computer_play(board);
        print_board(board);
    }

    if(check_board(board) == 1) {
        printf(""Player 1 wins!"");
    }
    else if(check_board(board) == -1) {
        printf(""Computer wins!"");
    }
    else {
        printf(""Game ended in a tie."");
    }

    return 0;
}

int check_board(int board[])
{
    int i;

    // Check rows
    for(i=0; i<9; i+=3) {
        if(board[i] == board[i+1] && board[i] == board[i+2]) {
            if(board[i] == 1) {
                return 1;
            }
            else if(board[i] == -1) {
                return -1;
            }
        }
    }

    // Check columns
    for(i=0; i<3; i++) {
        if(board[i] == board[i+3] && board[i] == board[i+6]) {
            if(board[i] == 1) {
                return 1;
            }
            else if(board[i] == -1) {
                return -1;
            }
        }
    }

    // Check diagonals
    if(board[0] == board[4] && board[0] == board[8]) {
        if(board[0] == 1) {
            return 1;
        }
        else if(board[0] == -1) {
            return -1;
        }
    }
    if(board[2] == board[4] && board[2] == board[6]) {
        if(board[2] == 1) {
            return 1;
        }
        else if(board[2] == -1) {
            return -1;
        }
    }

    // Check if the game is a tie
    for(i=0; i<9; i++) {
        if(board[i] == 0) {
            return 0;
        }
    }

    return 2;
}

void print_board(int board[]) 
{
    int i;
    printf(""\n"");
    for(i=0; i<9; i++) {
        if(board[i] == 1) {
            printf("" X "");
        }
        else if(board[i] == -1) {
            printf("" O "");
        }
        else {
            printf(""   "");
        }

        if(i == 2 || i == 5) {
            printf(""\n-----------\n"");
        }
        else if(i == 8) {
            printf(""\n\n"");
        }
        else {
            printf(""|"");
        }
    }
}

void play(int board[], int player)
{
    int position;
    scanf(""%d"", &position);

    while(position < 1 || position > 9 || board[position-1] != 0) {
        printf(""\nInvalid input. Please choose a number from 1 to 9 to place your 'X'.\n"");
        scanf(""%d"", &position);
    }

    board[position-1] = player;
}

void computer_play(int board[])
{
    int position, i;

    // Check if the computer can win
    for(i=0; i<9; i++) {
        if(board[i] == 0) {
            board[i] = -1;
            if(check_board(board) == -1) {
                return;
            }
            else {
                board[i] = 0;
            }
        }
    }

    // Check if the player can win
    for(i=0; i<9; i++) {
        if(board[i] == 0) {
            board[i] = 1;
            if(check_board(board) == 1) {
                board[i] = -1;
                return;
            }
            else {
                board[i] = 0;
            }
        }
    }

    // Otherwise, make a random move
    srand(time(NULL));

    do {
        position = rand() % 9;
    } while(board[position] != 0);

    board[position] = -1;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t check_board(int64_t * a1);
int64_t computer_play(int64_t * a1);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(int32_t c);
int32_t function_10d0(char * s);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
void function_1100(int32_t seed);
int32_t function_1110(int32_t * timer);
int32_t function_1120(char * format, ...);
int32_t function_1130(void);
int64_t play(int64_t * a1, int64_t a2);
int64_t print_board(int64_t * a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t c) {
    // 0x10c0
    return putchar(c);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
void function_1100(int32_t seed) {
    // 0x1100
    srand(seed);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int32_t * timer) {
    // 0x1110
    return time(timer);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * format, ...) {
    // 0x1120
    return scanf(format);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(void) {
    // 0x1130
    return rand();
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g1;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (*(char *)&g1 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x1391
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1235
    int64_t v2 = 0; // bp-56, 0x1244
    puts(""Welcome to Tic Tac Toe!\n"");
    puts(""Please choose a number from 1 to 9 to place your 'X'.\n"");
    if ((int32_t)check_board(&v2) == 0) {
        puts(""Player 1 (X):"");
        play(&v2, 1);
        print_board(&v2);
        while ((int32_t)check_board(&v2) != 1) {
            // 0x12cf
            puts(""Computer (O):"");
            computer_play(&v2);
            print_board(&v2);
            if ((int32_t)check_board(&v2) != 0) {
                // break -> 0x1314
                break;
            }
            puts(""Player 1 (X):"");
            play(&v2, 1);
            print_board(&v2);
        }
    }
    // 0x1314
    if ((int32_t)check_board(&v2) != 1) {
        // 0x133b
        if ((int32_t)check_board(&v2) != -1) {
            // 0x1362
            printf(""Game ended in a tie."");
        } else {
            // 0x134c
            printf(""Computer wins!"");
        }
    } else {
        // 0x1325
        printf(""Player 1 wins!"");
    }
    int64_t result = 0; // 0x1388
    if (v1 != __readfsqword(40)) {
        // 0x138a
        __stack_chk_fail();
        result = &g2;
    }
    // 0x138f
    return result;
}

// Address range: 0x1391 - 0x161e
int64_t check_board(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2; // 0x1391
    int32_t v3 = v2;
    int64_t v4 = 0;
    int64_t v5 = 4 * v4 + v1;
    int32_t v6 = *(int32_t *)v5; // 0x13bd
    if (v6 == *(int32_t *)(v5 + 4)) {
        // 0x13dd
        if (v6 == *(int32_t *)(v5 + 8)) {
            // 0x1411
            if (v6 == 1) {
                // 0x161c
                return 1;
            }
            // 0x1436
            if (v6 == -1) {
                // 0x161c
                return 0xffffffff;
            }
        }
    }
    // 0x145b
    v4 += 3;
    int64_t v7 = 0; // 0x1463
    while (v4 < 9) {
        // 0x13a9
        v5 = 4 * v4 + v1;
        v6 = *(int32_t *)v5;
        if (v6 == *(int32_t *)(v5 + 4)) {
            // 0x13dd
            if (v6 == *(int32_t *)(v5 + 8)) {
                // 0x1411
                if (v6 == 1) {
                    // 0x161c
                    return 1;
                }
                // 0x1436
                if (v6 == -1) {
                    // 0x161c
                    return 0xffffffff;
                }
            }
        }
        // 0x145b
        v4 += 3;
        v7 = 0;
    }
    int64_t v8 = 4 * v7 + v1;
    int32_t v9 = *(int32_t *)v8; // 0x1489
    if (v9 == *(int32_t *)(v8 + 12)) {
        // 0x14a9
        if (v9 == *(int32_t *)(v8 + 24)) {
            // 0x14dd
            if (v9 == 1) {
                // 0x161c
                return 1;
            }
            // 0x1502
            if (v9 == -1) {
                // 0x161c
                return 0xffffffff;
            }
        }
    }
    int64_t v10 = v7 + 1;
    v7 = v10;
    while (v10 < 3) {
        // 0x1475
        v8 = 4 * v7 + v1;
        v9 = *(int32_t *)v8;
        if (v9 == *(int32_t *)(v8 + 12)) {
            // 0x14a9
            if (v9 == *(int32_t *)(v8 + 24)) {
                // 0x14dd
                if (v9 == 1) {
                    // 0x161c
                    return 1;
                }
                // 0x1502
                if (v9 == -1) {
                    // 0x161c
                    return 0xffffffff;
                }
            }
        }
        // 0x1527
        v10 = v7 + 1;
        v7 = v10;
    }
    int32_t v11 = *(int32_t *)(v1 + 16); // 0x1543
    if (v11 == v3) {
        // 0x1549
        if (*(int32_t *)(v1 + 32) == v3) {
            // 0x155d
            if (v3 == 1) {
                // 0x161c
                return 1;
            }
            // 0x1572
            if (v3 == -1) {
                // 0x161c
                return 0xffffffff;
            }
        }
    }
    int32_t v12 = *(int32_t *)(v1 + 8); // 0x158f
    if (v12 == v11) {
        // 0x159f
        if (v12 == *(int32_t *)(v1 + 24)) {
            // 0x15b7
            if (v12 == 1) {
                // 0x161c
                return 1;
            }
            // 0x15cd
            if (v12 == -1) {
                // 0x161c
                return 0xffffffff;
            }
        }
    }
    int32_t v13 = 0; // 0x160d
    int64_t result = 0; // 0x1604
    while (*(int32_t *)(4 * (int64_t)v13 + v1) != 0) {
        // 0x1611
        v13++;
        result = 2;
        if (v13 >= 9) {
            // break -> 0x161c
            break;
        }
        result = 0;
    }
    // 0x161c
    return result;
}

// Address range: 0x161e - 0x170a
int64_t print_board(int64_t * a1) {
    // 0x161e
    putchar(10);
    int64_t v1 = 0;
    int32_t v2 = *(int32_t *)(4 * v1 + (int64_t)a1); // 0x1658
    if (v2 != 1) {
        if (v2 != -1) {
            // 0x16a6
            printf(""   "");
        } else {
            // 0x1690
            printf("" O "");
        }
    } else {
        // 0x165f
        printf("" X "");
    }
    int32_t putchar_rc; // 0x161e
    if (v1 != 2 == (v1 != 5)) {
        if (v1 != 8) {
            // 0x16ee
            putchar_rc = putchar(124);
        } else {
            // 0x16dd
            putchar_rc = puts(""\n"");
        }
    } else {
        // 0x16c6
        putchar_rc = puts(""\n-----------"");
    }
    int64_t v3 = v1 + 1;
    while (v3 != 9) {
        // 0x1644
        v1 = v3;
        v2 = *(int32_t *)(4 * v1 + (int64_t)a1);
        if (v2 != 1) {
            if (v2 != -1) {
                // 0x16a6
                printf(""   "");
            } else {
                // 0x1690
                printf("" O "");
            }
        } else {
            // 0x165f
            printf("" X "");
        }
        if (v1 != 2 == (v1 != 5)) {
            if (v1 != 8) {
                // 0x16ee
                putchar_rc = putchar(124);
            } else {
                // 0x16dd
                putchar_rc = puts(""\n"");
            }
        } else {
            // 0x16c6
            putchar_rc = puts(""\n-----------"");
        }
        // 0x16f8
        v3 = v1 + 1;
    }
    // 0x1706
    return putchar_rc;
}

// Address range: 0x170a - 0x17cc
int64_t play(int64_t * a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x171d
    int64_t v2; // bp-20, 0x170a
    scanf(""%d"", &v2);
    int32_t * v3; // 0x170a
    while (true) {
        // 0x1773
        if ((int32_t)v2 <= 9) {
            // 0x1782
            v3 = (int32_t *)((int64_t)a1 - 4 + (0x100000000 * v2 >> 30));
            if (*v3 == 0) {
                // break -> 0x179c
                break;
            }
        }
        // 0x1749
        puts(""\nInvalid input. Please choose a number from 1 to 9 to place your 'X'."");
        scanf(""%d"", &v2);
    }
    // 0x179c
    *v3 = (int32_t)a2;
    int64_t result = 0; // 0x17c3
    if (v1 != __readfsqword(40)) {
        // 0x17c5
        __stack_chk_fail();
        result = &g2;
    }
    // 0x17ca
    return result;
}

// Address range: 0x17cc - 0x1967
int64_t computer_play(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = 0;
    int32_t * v3 = (int32_t *)(4 * v2 + v1); // 0x17f9
    int64_t result; // 0x17cc
    int64_t v4; // 0x1820
    if (*v3 == 0) {
        // 0x17ff
        *v3 = -1;
        v4 = check_board(a1);
        result = v4;
        if ((int32_t)v4 == -1) {
            // 0x1965
            return result;
        }
        // 0x182e
        *v3 = 0;
    }
    // 0x1848
    v2++;
    int64_t v5 = 0; // 0x1850
    while (v2 < 9) {
        // 0x17e5
        v3 = (int32_t *)(4 * v2 + v1);
        if (*v3 == 0) {
            // 0x17ff
            *v3 = -1;
            v4 = check_board(a1);
            result = v4;
            if ((int32_t)v4 == -1) {
                // 0x1965
                return result;
            }
            // 0x182e
            *v3 = 0;
        }
        // 0x1848
        v2++;
        v5 = 0;
    }
    int64_t result2 = 4 * v5 + v1; // 0x186f
    int32_t * v6 = (int32_t *)result2;
    if (*v6 == 0) {
        // 0x1878
        *v6 = 1;
        if ((int32_t)check_board(a1) == 1) {
            // 0x18a3
            *v6 = -1;
            return result2;
        }
        // 0x18c2
        *v6 = 0;
    }
    int64_t v7 = v5 + 1;
    v5 = v7;
    while (v7 < 9) {
        // 0x185e
        result2 = 4 * v5 + v1;
        v6 = (int32_t *)result2;
        if (*v6 == 0) {
            // 0x1878
            *v6 = 1;
            if ((int32_t)check_board(a1) == 1) {
                // 0x18a3
                *v6 = -1;
                return result2;
            }
            // 0x18c2
            *v6 = 0;
        }
        // 0x18dc
        v7 = v5 + 1;
        v5 = v7;
    }
    // 0x18ea
    srand(time(NULL));
    int64_t v8 = 4 * (int64_t)(rand() % 9) + v1; // 0x193f
    int32_t * v9 = (int32_t *)v8;
    while (*v9 != 0) {
        // 0x1900
        v8 = 4 * (int64_t)(rand() % 9) + v1;
        v9 = (int32_t *)v8;
    }
    // 0x1948
    *v9 = -1;
    result2 = v8;
  lab_0x1965:
    // 0x1965
    return result2;
}

// Address range: 0x1968 - 0x1975
int64_t _fini(void) {
    // 0x1968
    int64_t result; // 0x1968
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to Tic Tac Toe!\n"");
            puts(""Please choose a number from 1 to 9 to place your 'X'.\n"");
            int board[9] = {0};
            int turn = 1;
            while (1) {
                if (turn == 1) {
                    printf(""Player 1 (X):"");
                } else {
                    printf(""Computer (O):"");
                }
                int input;
                scanf(""%d"", &input);
                if (input < 1 || input > 9) {
                    puts(""Invalid input. Please choose a number from 1 to 9 to place your 'X'."");
                    continue;
                }
                if (board[input - 1] != 0) {
                    puts(""Invalid input. Please choose a number from 1 to 9 to place your 'X'."");
                    continue;
                }
                board[input - 1] = turn;
                if (check_board(board) == 1) {
                    if (turn == 1) {
                        puts(""Player 1 wins!"");
                    } else {
                        puts(""Computer wins!"");
                    }
                    break;
                }
                if (check_board(board) == -1) {
                    puts(""Game ended in a tie."");
                    break;
                }
                turn = turn == 1 ? 2 : 1;
            }
            return 0;
        }

        int check_board(int board[9]) {
            int i;
            for (i = 0; i < 3; i++) {
                if (board[i] == board[i + 3] && board[i] == board[i + 6]) {
                    if (board[i] == 1) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
            }
            for (i = 0; i < 3; i++) {
                if (board[i * 3] == board[i * 3 + 1] && board[i * 3] == board[i * 3 + 2]) {
                    if (board[i * 3] == 1) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
            }
            if (board[0] == board[4] && board[0] == board[8]) {
                if (board[0] == 1) {
                    return 1;
                } else {
                    return -1;
                }
            }
            if (board[2] == board[4] && board[2] == board[6]) {
                if (board[2] == 1) {
                    return 1;
                } else {
                    return -1;
                }
            }
            for (i = 0; i < 9; i++) {
                if (board[i] == 0) {
                    return 2;
                }
            }
            return -1;
        }

        int computer_play(int board[9]) {
            int i;
            for (i = 0; i < 9; i++) {
                if (board[i] == 0) {
                    board[i] = -1;
                    if (check_board(board) == 1) {
                        board[i] = 0;
                        return i + 1;
                    }
                    board[i] = 0;
                }
            }
            srand(time(NULL));
            int r = rand() % 9;
            if (board[r] == 0) {
                board[r] = -1;
                if (check_board(board) == 1) {
                    board[r] = 0;
                    return r + 1;
                }
                board[r] = 0;
            }
            return -1;
        }


",2
"//FormAI DATASET v1.0 Category: Prime Number Generator ; Style: ultraprecise
#include <stdio.h>

int is_prime(int num);

int main(void) {
    int count = 0;
    int num = 2;

    printf(""Prime Numbers: "");

    while (count < 50) {
        if (is_prime(num)) {
            printf(""%d "", num);
            count++;
        }
        num++;
    }

    return 0;
}

int is_prime(int num) {
    if (num < 2) {
        return 0;
    }
    for (int i = 2; i <= num / 2; i++) {
        if (num % i == 0) {
            return 0;
        }
    }
    return 1;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1040(int64_t * d);
int32_t function_1050(char * format, ...);
int64_t is_prime(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1040 - 0x104b
void function_1040(int64_t * d) {
    // 0x1040
    __cxa_finalize(d);
}

// Address range: 0x1050 - 0x105b
int32_t function_1050(char * format, ...) {
    // 0x1050
    return printf(format);
}

// Address range: 0x1060 - 0x1086
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1060
    int64_t v1; // 0x1060
    __libc_start_main(0x1149, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1090 - 0x10b9
int64_t deregister_tm_clones(void) {
    // 0x1090
    return &g1;
}

// Address range: 0x10c0 - 0x10f9
int64_t register_tm_clones(void) {
    // 0x10c0
    return 0;
}

// Address range: 0x1100 - 0x1139
int64_t __do_global_dtors_aux(void) {
    // 0x1100
    if (*(char *)&g1 != 0) {
        // 0x1138
        int64_t result; // 0x1100
        return result;
    }
    // 0x110d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x111b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1127
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1140 - 0x1149
int64_t frame_dummy(void) {
    // 0x1140
    return register_tm_clones();
}

// Address range: 0x1149 - 0x11b5
int main(int argc, char ** argv) {
    // 0x1149
    printf(""Prime Numbers: "");
    int32_t v1 = 2; // 0x1149
    int32_t v2 = 0;
    int64_t v3 = v1; // 0x117c
    int32_t v4 = v2; // 0x1185
    if ((int32_t)is_prime(v3) != 0) {
        // 0x1187
        printf(""%d "", v3);
        v4 = v2 + 1;
    }
    // 0x11a4
    v1++;
    while (v4 < 50) {
        // 0x1179
        v2 = v4;
        v3 = v1;
        v4 = v2;
        if ((int32_t)is_prime(v3) != 0) {
            // 0x1187
            printf(""%d "", v3);
            v4 = v2 + 1;
        }
        // 0x11a4
        v1++;
    }
    // 0x11ae
    return 0;
}

// Address range: 0x11b5 - 0x1206
int64_t is_prime(int64_t a1) {
    // 0x11b5
    if ((int32_t)a1 <= 1) {
        // 0x1204
        return 0;
    }
    int64_t v1 = 0x100000000 * a1;
    int64_t v2 = v1 >> 32; // 0x11bd
    int32_t v3 = v2;
    int64_t v4 = 0x100000000 * (int64_t)(v3 >> 31) | v2 & 0xffffffff;
    uint32_t v5 = (int32_t)(v1 < 0) + v3 >> 1; // 0x11f8
    if (v5 < 2) {
        // 0x1204
        return 1;
    }
    int32_t v6 = 2; // 0x11fd
    int64_t result = 0; // 0x11e1
    while ((int32_t)(v4 % (int64_t)v6) != 0) {
        // 0x11ee
        v6++;
        result = 1;
        if ((int64_t)v6 > (int64_t)v5) {
            // break -> 0x1204
            break;
        }
        result = 0;
    }
    // 0x1204
    return result;
}

// Address range: 0x1208 - 0x1215
int64_t _fini(void) {
    // 0x1208
    int64_t result; // 0x1208
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 11

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            printf(""Prime Numbers: "");
            int v1 = 2;
            int v2 = 0;
            int64_t v3 = v1;
            int32_t v4 = v2;
            if ((int32_t)is_prime(v3) != 0) {
                printf(""%d "", v3);
                v4 = v2 + 1;
            }
            v1++;
            while (v4 < 50) {
                v2 = v4;
                v3 = v1;
                v4 = v2;
                if ((int32_t)is_prime(v3) != 0) {
                    printf(""%d "", v3);
                    v4 = v2 + 1;
                }
                v1++;
            }
            return 0;
        }

        int is_prime(int64_t a1) {
            if ((int32_t)a1 <= 1) {
                return 0;
            }
            int64_t v1 = 0x100000000 * a1;
            int64_t v2 = v1 >> 32;
            int32_t v3 = v2;
            int64_t v4 = 0x100000000 * (int64_t)(v3 >> 31) | v2 & 0xffffffff;
            uint32_t v5 = (int32_t)(v1 < 0) + v3 >> 1;
            if (v5 < 2) {
                return 1;
            }
            int32_t v6 = 2;
            int64_t result = 0;
            while ((int32_t)(v4 % (int64_t)v6) != 0) {
                v6++;
                result = 1;
                if ((int64_t)v6 > (int64_t)v5) {
                    break;
                }
                result = 0;
            }
            return result;
        }


",1
"//FormAI DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: surrealist
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

char* conspiracy_theories[] = {
    ""The moon landing was actually filmed in a studio on Mars."",
    ""The government controls the weather with a secret machine."",
    ""The Earth is actually flat and the round Earth theory is a hoax."",
    ""The Illuminati run the world behind the scenes."",
    ""COVID-19 was created in a lab as a form of population control."",
    ""Aliens have been living among us for centuries."",
    ""The Bermuda Triangle is a portal to another dimension."",
    ""Mandela Effect proves that we are living in a parallel universe."",
    ""The world is controlled by a secret society of lizard people.""
};

int main(void) {
    srand(time(NULL)); // seed the random number generator with the current time
    int conspiracy_index = rand() % 9; // generate a random index to select a conspiracy theory
    
    printf(""Did you know that: %s\n\n"", conspiracy_theories[conspiracy_index]);
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * format, ...);
void function_1090(int32_t seed);
int32_t function_10a0(int32_t * timer);
int32_t function_10b0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char * g1[9] = {
    ""The moon landing was actually filmed in a studio on Mars."",
    ""The government controls the weather with a secret machine."",
    ""The Earth is actually flat and the round Earth theory is a hoax."",
    ""The Illuminati run the world behind the scenes."",
    ""COVID-19 was created in a lab as a form of population control."",
    ""Aliens have been living among us for centuries."",
    ""The Bermuda Triangle is a portal to another dimension."",
    ""Mandela Effect proves that we are living in a parallel universe."",
    ""The world is controlled by a secret society of lizard people.""
}; // 0x4020
int64_t g2 = 0; // 0x4068
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * format, ...) {
    // 0x1080
    return printf(format);
}

// Address range: 0x1090 - 0x109b
void function_1090(int32_t seed) {
    // 0x1090
    srand(seed);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(int32_t * timer) {
    // 0x10a0
    return time(timer);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(void) {
    // 0x10b0
    return rand();
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g2;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g2 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x122a
int main(int argc, char ** argv) {
    // 0x11a9
    srand(time(NULL));
    int64_t v1 = *(int64_t *)(8 * (int64_t)(rand() % 9) + (int64_t)&g1); // 0x1208
    printf(""Did you know that: %s\n\n"", (char *)v1);
    return 0;
}

// Address range: 0x122c - 0x1239
int64_t _fini(void) {
    // 0x122c
    int64_t result; // 0x122c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int64_t v1 = *(int64_t *)(8 * (int64_t)(rand() % 9) + (int64_t)&g1);
            printf(""Did you know that: %s\n\n"", (char *)v1);
            return 0;
        }

",0
"//FormAI DATASET v1.0 Category: Spam Detection System ; Style: grateful
#include <stdio.h>
#include <string.h>

int main()
{
    char message[1000];
    int spam = 0;
    
    printf(""Enter the message: "");
    fgets(message, 1000, stdin); // To get input from user

    char spamWords[5][12] = {""win"", ""cash"", ""free"", ""prize"", ""buy""}; // List of spam words
    
    for(int i = 0; i < strlen(message); i++) 
    {
        if(message[i] >= 'A' && message[i] <= 'Z')
        {
            message[i] = message[i] + 32; // Converting to lowercase
        }
    }
    
    for(int i = 0; i < 5; i++) // Check for spam words
    {
        if(strstr(message, spamWords[i])) // Checking if spam word is present
        {
            spam = 1; // If present, spam variable is set to true
            break;
        }
    }
    
    if(spam == 1)
    {
        printf(""This message is spam!\n""); 
    }
    else
    {
        printf(""This message is not spam!\n"");
    }
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
int32_t function_10a0(char * s);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
char * function_10e0(char * s, int32_t n, struct _IO_FILE * stream);
char * function_10f0(char * haystack, char * needle);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x3e8
struct _IO_FILE * g2 = NULL; // 0x4010
char g3 = 0; // 0x4018
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g4;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return strlen(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
char * function_10e0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x10e0
    return fgets(s, n, stream);
}

// Address range: 0x10f0 - 0x10fb
char * function_10f0(char * haystack, char * needle) {
    // 0x10f0
    return strstr(haystack, needle);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x11e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return (int64_t)&g2;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (g3 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    g3 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x13d4
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11f9
    printf(""Enter the message: "");
    int64_t str; // bp-1032, 0x11e9
    fgets((char *)&str, (int32_t)&g1, g2);
    int64_t v2 = 0x6e6977; // bp-1096, 0x1241
    if (strlen((char *)&str) != 0) {
        for (int32_t i = 0; i < strlen((char *)&str); i++) {
            // 0x12bc
            int64_t v3; // bp-8, 0x11e9
            char * v4 = (char *)((int64_t)&v3 - 1024 + (int64_t)i); // 0x12c4
            char v5 = *v4; // 0x12c4
            if (v5 <= 90) {
                // 0x12e4
                *v4 = v5 + 32;
            }
        }
    }
    int64_t v6 = &v2; // 0x1338
    int64_t v7 = 0;
    while (strstr((char *)&str, (char *)(12 * v7 + v6)) == NULL) {
        // 0x1383
        v7++;
        if (v7 >= 5) {
            // 0x13a6
            puts(""This message is not spam!"");
            goto lab_0x13b5;
        }
    }
    // 0x1395
    puts(""This message is spam!"");
    goto lab_0x13b5;
  lab_0x13b5:;
    int64_t result = 0; // 0x13c7
    if (v1 != __readfsqword(40)) {
        // 0x13c9
        __stack_chk_fail();
        result = &g4;
    }
    // 0x13ce
    return result;
}

// Address range: 0x13d4 - 0x13e1
int64_t _fini(void) {
    // 0x13d4
    int64_t result; // 0x13d4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            char str[1024];
            printf(""Enter the message: "");
            fgets(str, 1024, stdin);
            for (int i = 0; i < strlen(str); i++) {
                char * v4 = (char *)((int64_t)&v3 - 1024 + (int64_t)i);
                char v5 = *v4;
                if (v5 <= 90) {
                    *v4 = v5 + 32;
                }
            }
            int v6 = 0;
            while (strstr(str, (char *)(12 * v6 + &v2)) == NULL) {
                v6++;
                if (v6 >= 5) {
                    puts(""This message is not spam!"");
                    goto lab_0x13b5;
                }
            }
            puts(""This message is spam!"");
            lab_0x13b5:;
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Binary search trees ; Style: careful
#include <stdio.h>
#include <stdlib.h>

// Structure definition for a node in the binary search tree
typedef struct bst_node {
    int data;
    struct bst_node* left;
    struct bst_node* right;
} bst_node;

// Function to create a new node with the given data
bst_node* create_node(int data) {
    bst_node* new_node = (bst_node*) malloc(sizeof(bst_node));
    new_node->data = data;
    new_node->left = NULL;
    new_node->right = NULL;
    return new_node;
}

// Function to insert a node with the given data into the binary search tree
bst_node* insert_node(bst_node* root, int data) {
    if (root == NULL) {
        return create_node(data);
    } else if (root->data > data) {
        root->left = insert_node(root->left, data);
    } else {
        root->right = insert_node(root->right, data);
    }
    return root;
}

// Function to perform a pre-order traversal of the binary search tree
void pre_order_traversal(bst_node* root) {
    if (root != NULL) {
        printf(""%d "", root->data);
        pre_order_traversal(root->left);
        pre_order_traversal(root->right);
    }
}

int main() {
    bst_node* root = create_node(50);
    insert_node(root, 30);
    insert_node(root, 20);
    insert_node(root, 40);
    insert_node(root, 70);
    insert_node(root, 60);
    insert_node(root, 80);
    printf(""Pre-order traversal of binary search tree:\n"");
    pre_order_traversal(root);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t create_node(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
int32_t function_1070(char * s);
int32_t function_1080(char * format, ...);
int64_t * function_1090(int32_t size);
int64_t insert_node(int64_t result, int64_t a2);
int64_t pre_order_traversal(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
int32_t function_1070(char * s) {
    // 0x1070
    return puts(s);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * format, ...) {
    // 0x1080
    return printf(format);
}

// Address range: 0x1090 - 0x109b
int64_t * function_1090(int32_t size) {
    // 0x1090
    return malloc(size);
}

// Address range: 0x10a0 - 0x10c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10a0
    int64_t v1; // 0x10a0
    __libc_start_main(0x1296, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10d0 - 0x10f9
int64_t deregister_tm_clones(void) {
    // 0x10d0
    return &g1;
}

// Address range: 0x1100 - 0x1139
int64_t register_tm_clones(void) {
    // 0x1100
    return 0;
}

// Address range: 0x1140 - 0x1179
int64_t __do_global_dtors_aux(void) {
    // 0x1140
    if (*(char *)&g1 != 0) {
        // 0x1178
        int64_t result; // 0x1140
        return result;
    }
    // 0x114d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x115b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1167
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1180 - 0x1189
int64_t frame_dummy(void) {
    // 0x1180
    return register_tm_clones();
}

// Address range: 0x1189 - 0x11cd
int64_t create_node(int64_t a1) {
    int64_t * mem = malloc(24); // 0x119d
    int64_t result = (int64_t)mem; // 0x119d
    *(int32_t *)mem = (int32_t)a1;
    *(int64_t *)(result + 8) = 0;
    *(int64_t *)(result + 16) = 0;
    return result;
}

// Address range: 0x11cd - 0x1240
int64_t insert_node(int64_t result, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 >> 32; // 0x11dd
    if (result == 0) {
        // 0x123e
        return create_node(v1 & 0xffffffff);
    }
    int64_t v2; // 0x11cd
    if (v1 < (v2 & 0xffffffff)) {
        int64_t * v3 = (int64_t *)(result + 8); // 0x1202
        *v3 = insert_node(*v3, v1 & 0xffffffff);
    } else {
        int64_t * v4 = (int64_t *)(result + 16); // 0x1221
        *v4 = insert_node(*v4, v1 & 0xffffffff);
    }
    // 0x123e
    return result;
}

// Address range: 0x1240 - 0x1296
int64_t pre_order_traversal(int64_t a1) {
    // 0x1240
    int64_t result; // 0x1240
    if (a1 != 0) {
        // 0x1257
        int64_t v1; // 0x1240
        printf(""%d "", v1 & 0xffffffff);
        pre_order_traversal(*(int64_t *)(a1 + 8));
        result = pre_order_traversal(*(int64_t *)(a1 + 16));
    }
    // 0x1293
    return result;
}

// Address range: 0x1296 - 0x1338
int main(int argc, char ** argv) {
    int64_t v1 = create_node(50); // 0x12a7
    insert_node(v1, 30);
    insert_node(v1, 20);
    insert_node(v1, 40);
    insert_node(v1, 70);
    insert_node(v1, 60);
    insert_node(v1, 80);
    puts(""Pre-order traversal of binary search tree:"");
    pre_order_traversal(v1);
    return 0;
}

// Address range: 0x1338 - 0x1345
int64_t _fini(void) {
    // 0x1338
    int64_t result; // 0x1338
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int64_t v1 = create_node(50);
            insert_node(v1, 30);
            insert_node(v1, 20);
            insert_node(v1, 40);
            insert_node(v1, 70);
            insert_node(v1, 60);
            insert_node(v1, 80);
            puts(""Pre-order traversal of binary search tree:"");
            pre_order_traversal(v1);
            return 0;
        }

        int64_t create_node(int64_t a1) {
            int64_t * mem = malloc(24);
            int64_t result = (int64_t)mem;
            *(int32_t *)mem = (int32_t)a1;
            *(int64_t *)(result + 8) = 0;
            *(int64_t *)(result + 16) = 0;
            return result;
        }

        int64_t insert_node(int64_t result, int64_t a2) {
            int64_t v1 = 0x100000000 * a2 >> 32;
            if (result == 0) {
                return create_node(v1 & 0xffffffff);
            }
            int64_t v2;
            if (v1 < (v2 & 0xffffffff)) {
                int64_t * v3 = (int64_t *)(result + 8);
                *v3 = insert_node(*v3, v1 & 0xffffffff);
            } else {
                int64_t * v4 = (int64_t *)(result + 16);
                *v4 = insert_node(*v4, v1 & 0xffffffff);
            }
            return result;
        }

        int64_t pre_order_traversal(int64_t a1) {
            int64_t result;
            if (a1 != 0) {
                int64_t v1;
                printf(""%d "", v1 & 0xffffffff);
                pre_order_traversal(*(int64_t *)(a1 + 8));
                result = pre_order_traversal(*(int64_t *)(a1 + 16));
            }
            return result;
        }


",1
"//FormAI DATASET v1.0 Category: Building a FTP Client ; Style: light-weight
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_BUFFER 1024

int main(int argc, char *argv[]) {
    if (argc != 4) {
        printf(""Usage: %s <server IP> <server port> <file name>\n"", argv[0]);
        return 0;
    }

    char *server_ip = argv[1];
    int server_port = atoi(argv[2]);
    char *file_name = argv[3];

    int client_socket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in server_address;
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = inet_addr(server_ip);
    server_address.sin_port = htons(server_port);

    if (connect(client_socket, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {
        printf(""Error: Failed to connect to the server\n"");
        return 0;
    }

    printf(""Connected to the server\n"");

    char buffer[MAX_BUFFER];
    memset(buffer, 0, MAX_BUFFER);

    int bytes_sent = send(client_socket, file_name, strlen(file_name), 0);
    if (bytes_sent < 0) {
        printf(""Error: Failed to send the file name\n"");
        return 0;
    }

    printf(""File name sent to the server\n"");

    int bytes_received = recv(client_socket, buffer, MAX_BUFFER, 0);
    if (bytes_received < 0) {
        printf(""Error: Failed to receive file contents length from the server\n"");
        return 0;
    }

    int file_contents_length = atoi(buffer);
    printf(""File contents length received from the server: %d bytes\n"", file_contents_length);

    if (file_contents_length <= 0) {
        printf(""Error: File contents length is invalid\n"");
        return 0;
    }

    FILE *file = fopen(file_name, ""wb"");
    if (file == NULL) {
        printf(""Error: Failed to create the file\n"");
        return 0;
    }

    int total_bytes_received = 0;
    while (total_bytes_received < file_contents_length) {
        bytes_received = recv(client_socket, buffer, MAX_BUFFER, 0);
        if (bytes_received < 0) {
            printf(""Error: Failed to receive file contents from the server\n"");
            fclose(file);
            return 0;
        }

        fwrite(buffer, sizeof(char), bytes_received, file);
        total_bytes_received += bytes_received;

        float progress = (float) total_bytes_received / file_contents_length * 100;
        printf(""Progress: %.2f%%\n"", progress);
    }

    fclose(file);
    printf(""File transfer completed\n"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1120(int64_t * d);
int32_t function_1130(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_1140(char * s);
int32_t function_1150(struct _IO_FILE * stream);
int32_t function_1160(char * s);
void function_1170(void);
int16_t function_1180(int16_t hostshort);
int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11a0(char * format, ...);
int64_t * function_11b0(int64_t * s, int32_t c, int32_t n);
int32_t function_11c0(char * cp);
struct _IO_FILE * function_11d0(char * filename, char * modes);
int32_t function_11e0(char * nptr);
int32_t function_11f0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1200(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_1210(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1120 - 0x112b
void function_1120(int64_t * d) {
    // 0x1120
    __cxa_finalize(d);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1130
    return recv(fd, buf, n, flags);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * s) {
    // 0x1140
    return puts(s);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(struct _IO_FILE * stream) {
    // 0x1150
    return fclose(stream);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(char * s) {
    // 0x1160
    return strlen(s);
}

// Address range: 0x1170 - 0x117b
void function_1170(void) {
    // 0x1170
    __stack_chk_fail();
}

// Address range: 0x1180 - 0x118b
int16_t function_1180(int16_t hostshort) {
    // 0x1180
    return htons(hostshort);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1190
    return send(fd, buf, n, flags);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(char * format, ...) {
    // 0x11a0
    return printf(format);
}

// Address range: 0x11b0 - 0x11bb
int64_t * function_11b0(int64_t * s, int32_t c, int32_t n) {
    // 0x11b0
    return memset(s, c, n);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(char * cp) {
    // 0x11c0
    return inet_addr(cp);
}

// Address range: 0x11d0 - 0x11db
struct _IO_FILE * function_11d0(char * filename, char * modes) {
    // 0x11d0
    return fopen(filename, modes);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(char * nptr) {
    // 0x11e0
    return atoi(nptr);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x11f0
    return connect(fd, addr, len);
}

// Address range: 0x1200 - 0x120b
int32_t function_1200(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x1200
    return fwrite(ptr, size, n, s);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1210
    return socket(domain, type, protocol);
}

// Address range: 0x1220 - 0x1246
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1220
    int64_t v1; // 0x1220
    __libc_start_main(0x1309, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1250 - 0x1279
int64_t deregister_tm_clones(void) {
    // 0x1250
    return &g2;
}

// Address range: 0x1280 - 0x12b9
int64_t register_tm_clones(void) {
    // 0x1280
    return 0;
}

// Address range: 0x12c0 - 0x12f9
int64_t __do_global_dtors_aux(void) {
    // 0x12c0
    if (*(char *)&g2 != 0) {
        // 0x12f8
        int64_t result; // 0x12c0
        return result;
    }
    // 0x12cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x12e7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1300 - 0x1309
int64_t frame_dummy(void) {
    // 0x1300
    return register_tm_clones();
}

// Address range: 0x1309 - 0x16d2
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1325
    if ((int32_t)argc == 4) {
        int64_t v2 = (int64_t)argv; // 0x1368
        int32_t str_as_i = atoi((char *)*(int64_t *)(v2 + 16)); // 0x138b
        int64_t buf = *(int64_t *)(v2 + 24); // 0x139d
        int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x13b7
        int16_t addr = 2; // bp-1064, 0x13c2
        inet_addr((char *)*(int64_t *)(v2 + 8));
        htons((int16_t)str_as_i);
        if (connect(sock_fd, (struct sockaddr *)&addr, 16) >= 0) {
            char * str = (char *)buf; // 0x13a1
            puts(""Connected to the server"");
            int64_t buf2; // bp-1048, 0x1309
            memset(&buf2, 0, (int32_t)&g1);
            if (send(sock_fd, (int64_t *)buf, strlen(str), 0) >= 0) {
                // 0x14ab
                puts(""File name sent to the server"");
                if (recv(sock_fd, &buf2, (int32_t)&g1, 0) >= 0) {
                    int32_t str_as_i2 = atoi((char *)&buf2); // 0x150a
                    printf(""File contents length received from the server: %d bytes\n"", (int64_t)str_as_i2);
                    if (str_as_i2 >= 0 == (str_as_i2 != 0)) {
                        struct _IO_FILE * file = fopen(str, ""wb""); // 0x1567
                        if (file != NULL) {
                            int32_t v3 = 0; // 0x1693
                            if (str_as_i2 > 0) {
                                int32_t nmemb = recv(sock_fd, &buf2, (int32_t)&g1, 0); // 0x15be
                                while (nmemb >= 0) {
                                    // 0x15fa
                                    int128_t v4; // 0x1309
                                    int128_t v5 = v4;
                                    int128_t v6; // 0x1309
                                    int128_t v7 = v6;
                                    int128_t v8; // 0x1309
                                    int128_t v9 = v8;
                                    fwrite(&buf2, 1, nmemb, file);
                                    int32_t v10 = nmemb + v3; // 0x1624
                                    __asm_pxor(v5, v5);
                                    int128_t v11 = __asm_cvtsi2ss(v10); // 0x162e
                                    __asm_pxor(v7, v7);
                                    int128_t v12 = __asm_cvtsi2ss(str_as_i2); // 0x163a
                                    int64_t v13 = __asm_movss_1(__asm_mulss(__asm_movss(*(int32_t *)0x2204), __asm_divss(__asm_movaps(v11), v12))); // 0x1655
                                    __asm_pxor(v9, v9);
                                    int128_t v14 = __asm_cvtss2sd((int32_t)v13); // 0x1661
                                    int128_t v15 = __asm_movq_2(__asm_movq(v14)); // 0x166e
                                    printf(""Progress: %.2f%%\n"", (float64_t)(int64_t)v15);
                                    v8 = v14;
                                    v6 = v12;
                                    v4 = v15;
                                    v3 = v10;
                                    if (v10 >= str_as_i2) {
                                        goto lab_0x1699;
                                    }
                                    nmemb = recv(sock_fd, &buf2, (int32_t)&g1, 0);
                                }
                                // 0x15d2
                                puts(""Error: Failed to receive file contents from the server"");
                                fclose(file);
                            } else {
                              lab_0x1699:
                                // 0x1699
                                fclose(file);
                                puts(""File transfer completed"");
                            }
                        } else {
                            // 0x157d
                            puts(""Error: Failed to create the file"");
                        }
                    } else {
                        // 0x153a
                        puts(""Error: File contents length is invalid"");
                    }
                } else {
                    // 0x14e7
                    puts(""Error: Failed to receive file contents length from the server"");
                }
            } else {
                // 0x1492
                puts(""Error: Failed to send the file name"");
            }
        } else {
            // 0x1417
            puts(""Error: Failed to connect to the server"");
        }
    } else {
        // 0x133d
        printf(""Usage: %s <server IP> <server port> <file name>\n"", argv);
    }
    int64_t result = 0; // 0x16c9
    if (v1 != __readfsqword(40)) {
        // 0x16cb
        __stack_chk_fail();
        result = &g3;
    }
    // 0x16d0
    return result;
}

// Address range: 0x16d4 - 0x16e1
int64_t _fini(void) {
    // 0x16d4
    int64_t result; // 0x16d4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 24

","nclude <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char ** argv) {
    if ((int32_t)argc == 4) {
        int32_t str_as_i = atoi((char *)*(int64_t *)(argv + 16));
        int64_t buf = *(int64_t *)(argv + 24);
        int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
        int16_t addr = 2;
        inet_addr((char *)*(int64_t *)(argv + 8));
        htons((int16_t)str_as_i);
        if (connect(sock_fd, (struct sockaddr *)&addr, 16) >= 0) {
            char * str = (char *)buf;
            puts(""Connected to the server"");
            int64_t buf2;
            memset(&buf2, 0, (int32_t)&g1);
            if (send(sock_fd, (int64_t *)buf, strlen(str), 0) >= 0) {
                puts(""File name sent to the server"");
                if (recv(sock_fd, &buf2, (int32_t)&g1, 0) >= 0) {
                    int32_t str_as_i2 = atoi((char *)&buf2);
                    printf(""File contents length received from the server: %d bytes\n"", (int64_t)str_as_i2);
                    if (str_as_i2 >= 0 == (str_as_i2 != 0)) {
                        struct _IO_FILE * file = fopen(str, ""wb"");
                        if (file != NULL) {
                            int32_t v3 = 0;
                            if (str_as_i2 > 0) {
                                int32_t nmemb = recv(sock_fd, &buf2, (int32_t)&g1, 0);
                                while (nmemb >= 0) {
                                    int128_t v4;
                                    int128_t v5 = v4;
                                    int128_t v6 = v4;
                                    int128_t v7 = v4;
                                    int128_t v8 = v4;
                                    fwrite(&buf2, 1, nmemb, file);
                                    int32_t v9 = nmemb + v3;
                                    __asm_pxor(v5, v5);
                                    int128_t v10 = __asm_cvtsi2ss(v9);
                                    __asm_pxor(v7, v7);
                                    int128_t v11 = __asm_cvtsi2ss(str_as_i2);
                                    int64_t v12 = __asm_movss_1(__asm_mulss(__asm_movss(*(int32_t *)0x2204), __asm_divss(__asm_movaps(v10), v11)));
                                    __asm_pxor(v8, v8);
                                    int128_t v13 = __asm_cvtss2sd((int32_t)v12);
                                    int128_t v14 = __asm_movq_2(__asm_movq(v13));
                                    printf(""Progress: %.2f%%\n"", (float64_t)(int64_t)v14);
                                    v3 = v9;
                                    if (v9 >= str_as_i2) {
                                        goto lab_0x1699;
                                    }
                                    nmemb = recv(sock_fd, &buf2, (int32_t)&g1, 0);
                                }
                                puts(""Error: Failed to receive file contents from the server"");
                                fclose(file);
                            } else {
                              lab_0x1699:
                                fclose(file);
                                puts(""File transfer completed"");
                            }
                        } else {
                            puts(""Error: Failed to create the file"");
                        }
                    } else {
                        puts(""Error: File contents length is invalid"");
                    }
                } else {
                    puts(""Error: Failed to receive file contents length from the server"");
                }
            } else {
                puts(""Error: Failed to send the file name"");
            }
        } else {
            puts(""Error: Failed to connect to the server"");
        }
    } else {
        printf(""Usage: %s <server IP> <server port> <file name>\n"", argv);
    }
    return 0;
}


",1
"//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: synchronous
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    char name[20];
    int age;
    srand(time(NULL)); // seed random number generator with current time
    int fortune = rand() % 8; // generate random number from 0 to 7
    printf(""Welcome to the Automated Fortune Teller! Please enter your name: "");
    scanf(""%s"", name);
    printf(""And what is your age, %s? "", name);
    scanf(""%d"", &age);
    if (age < 18) {
        printf(""I'm sorry, but you must be at least 18 years old to use this program.\n"");
    } else {
        printf(""Great, let's get started.\n"");
        switch(fortune) {
            case 0:
                printf(""%s, you will come into a great sum of money in the near future.\n"", name);
                break;
            case 1:
                printf(""%s, you will find true love within the next year.\n"", name);
                break;
            case 2:
                printf(""%s, beware of someone close to you who may betray you.\n"", name);
                break;
            case 3:
                printf(""%s, you will go on a journey to a far-off land soon.\n"", name);
                break;
            case 4:
                printf(""%s, you will find success in your career in the next few months.\n"", name);
                break;
            case 5:
                printf(""%s, be careful of your health in the coming weeks.\n"", name);
                break;
            case 6:
                printf(""%s, you will meet an old friend you haven't seen in years.\n"", name);
                break;
            case 7:
                printf(""%s, you will have a chance encounter that will change your life forever.\n"", name);
                break;
        }
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
void function_10e0(int32_t seed);
int32_t function_10f0(int32_t * timer);
int32_t function_1100(char * format, ...);
int32_t function_1110(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xfa500000fc6; // 0x22cc
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int32_t seed) {
    // 0x10e0
    srand(seed);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(int32_t * timer) {
    // 0x10f0
    return time(timer);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return scanf(format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(void) {
    // 0x1110
    return rand();
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g2;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g2 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x1411
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1215
    srand(time(NULL));
    int32_t v2 = rand(); // 0x1235
    printf(""Welcome to the Automated Fortune Teller! Please enter your name: "");
    int64_t v3; // bp-40, 0x1209
    scanf(""%s"", &v3);
    printf(""And what is your age, %s? "", &v3);
    int64_t v4; // bp-48, 0x1209
    scanf(""%d"", &v4);
    if ((int32_t)v4 > 17) {
        uint32_t v5 = v2 % 8; // 0x1243
        puts(""Great, let's get started."");
        if (v5 < 8) {
            int32_t v6 = *(int32_t *)(4 * (int64_t)v5 + (int64_t)&g1); // 0x12f4
            return (int64_t)v6 + (int64_t)&g1;
        }
    } else {
        // 0x12b5
        puts(""I'm sorry, but you must be at least 18 years old to use this program."");
    }
    int64_t result = 0; // 0x1408
    if (v1 != __readfsqword(40)) {
        // 0x140a
        __stack_chk_fail();
        result = &g3;
    }
    // 0x140f
    return result;
}

// Address range: 0x1414 - 0x1421
int64_t _fini(void) {
    // 0x1414
    int64_t result; // 0x1414
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int age = rand();
            printf(""Welcome to the Automated Fortune Teller! Please enter your name: "");
            char name[100];
            scanf(""%s"", name);
            printf(""And what is your age, %s? "", name);
            scanf(""%d"", &age);
            if (age > 17) {
                int fortune = rand() % 8;
                puts(""Great, let's get started."");
                if (fortune < 8) {
                    printf(""You have a fortune of %d.\n"", fortune);
                }
            } else {
                puts(""I'm sorry, but you must be at least 18 years old to use this program."");
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Image Steganography ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void encode(char *input_image, char *output_image, char *message) {
    FILE *fptr1, *fptr2;
    char buffer, ch;
    int i = 0;

    fptr1 = fopen(input_image, ""rb"");
    fptr2 = fopen(output_image, ""wb"");

    while(!feof(fptr1)) {
        fread(&buffer, sizeof(char), 1, fptr1);

        if(i < strlen(message)) {
            ch = message[i];

            for(int bit = 0; bit < 8; bit++) {
                int value = (ch >> bit) & 1;

                buffer = (buffer & 0xFE) | value;

                fwrite(&buffer, sizeof(char), 1, fptr2);
                fread(&buffer, sizeof(char), 1, fptr1);
            }
        } else {
            fwrite(&buffer, sizeof(char), 1, fptr2);
        }

        i++;
    }

    fclose(fptr1);
    fclose(fptr2);
}

void decode(char *output_image, int message_length) {
    FILE *fptr;
    char buffer, ch;
    int i = 0;

    fptr = fopen(output_image, ""rb"");

    while(!feof(fptr) && i < message_length) {
        ch = 0;

        for(int bit = 0; bit < 8; bit++) {
            fread(&buffer, sizeof(char), 1, fptr);

            ch = ch | ((buffer & 1) << bit);
        }

        printf(""%c"", ch);

        i++;
    }

    fclose(fptr);
}

int main() {
    char input_image[] = ""input_image.bmp"";
    char output_image[] = ""output_image.bmp"";
    char message[] = ""This message is hidden in the image"";
    int message_length = strlen(message);

    encode(input_image, output_image, message);

    printf(""Message encoded successfully.\n"");

    decode(output_image, message_length);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t decode(int64_t * file_path, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t encode(int64_t * file_path, int64_t * file_path2, int64_t * str);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
int32_t function_10d0(int32_t c);
int32_t function_10e0(char * s);
int32_t function_10f0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
int32_t function_1100(struct _IO_FILE * stream);
int32_t function_1110(char * s);
void function_1120(void);
int32_t function_1130(struct _IO_FILE * stream);
struct _IO_FILE * function_1140(char * filename, char * modes);
int32_t function_1150(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(int32_t c) {
    // 0x10d0
    return putchar(c);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * s) {
    // 0x10e0
    return puts(s);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x10f0
    return fread(ptr, size, n, stream);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(struct _IO_FILE * stream) {
    // 0x1100
    return fclose(stream);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s) {
    // 0x1110
    return strlen(s);
}

// Address range: 0x1120 - 0x112b
void function_1120(void) {
    // 0x1120
    __stack_chk_fail();
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(struct _IO_FILE * stream) {
    // 0x1130
    return feof(stream);
}

// Address range: 0x1140 - 0x114b
struct _IO_FILE * function_1140(char * filename, char * modes) {
    // 0x1140
    return fopen(filename, modes);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x1150
    return fwrite(ptr, size, n, s);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x14b2, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g1;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g1 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x13d7
int64_t encode(int64_t * file_path, int64_t * file_path2, int64_t * str) {
    int64_t v1 = __readfsqword(40); // 0x1262
    struct _IO_FILE * file = fopen((char *)file_path, ""rb""); // 0x1289
    struct _IO_FILE * file2 = fopen((char *)file_path2, ""wb""); // 0x12a3
    if (feof(file) == 0) {
        int32_t v2 = 0;
        int64_t data; // bp-62, 0x1249
        fread(&data, 1, 1, file);
        uint64_t v3; // 0x1249
        uint32_t v4; // 0x1249
        int32_t v5; // 0x1363
        unsigned char v6; // 0x12f6
        if (v2 >= strlen((char *)str)) {
            // 0x136f
            fwrite(&data, 1, 1, file2);
        } else {
            // 0x12e9
            v6 = *(char *)((int64_t)v2 + (int64_t)str);
            v4 = 0;
            v3 = v4 == 0 ? (int64_t)v6 : (int64_t)((int32_t)v6 >> v4);
            data = 0x100000000000000 * (v3 % 2 | data & 254) / 0x100000000000000;
            fwrite(&data, 1, 1, file2);
            fread(&data, 1, 1, file);
            v5 = v4 + 1;
            while (v5 != 8) {
                // 0x1305
                v4 = v5;
                v3 = v4 == 0 ? (int64_t)v6 : (int64_t)((int32_t)v6 >> v4);
                data = 0x100000000000000 * (v3 % 2 | data & 254) / 0x100000000000000;
                fwrite(&data, 1, 1, file2);
                fread(&data, 1, 1, file);
                v5 = v4 + 1;
            }
        }
        int32_t v7 = v2 + 1; // 0x139e
        while (feof(file) == 0) {
            // 0x12b1
            v2 = v7;
            fread(&data, 1, 1, file);
            if (v2 >= strlen((char *)str)) {
                // 0x136f
                fwrite(&data, 1, 1, file2);
            } else {
                // 0x12e9
                v6 = *(char *)((int64_t)v2 + (int64_t)str);
                v4 = 0;
                v3 = v4 == 0 ? (int64_t)v6 : (int64_t)((int32_t)v6 >> v4);
                data = 0x100000000000000 * (v3 % 2 | data & 254) / 0x100000000000000;
                fwrite(&data, 1, 1, file2);
                fread(&data, 1, 1, file);
                v5 = v4 + 1;
                while (v5 != 8) {
                    // 0x1305
                    v4 = v5;
                    v3 = v4 == 0 ? (int64_t)v6 : (int64_t)((int32_t)v6 >> v4);
                    data = 0x100000000000000 * (v3 % 2 | data & 254) / 0x100000000000000;
                    fwrite(&data, 1, 1, file2);
                    fread(&data, 1, 1, file);
                    v5 = v4 + 1;
                }
            }
            // 0x138c
            v7 = v2 + 1;
        }
    }
    // 0x13a4
    fclose(file);
    fclose(file2);
    int64_t result = 0; // 0x13ca
    if (v1 != __readfsqword(40)) {
        // 0x13cc
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13d1
    return result;
}

// Address range: 0x13d7 - 0x14b2
int64_t decode(int64_t * file_path, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x13ea
    struct _IO_FILE * file = fopen((char *)file_path, ""rb""); // 0x1411
    int32_t v2 = a2; // 0x148a
    int32_t v3 = 0; // 0x1485
    if (v2 > 0 == feof(file) == 0) {
        uint32_t v4 = 0;
        int64_t data; // bp-34, 0x13d7
        fread(&data, 1, 1, file);
        uint64_t v5 = data % 2; // 0x144d
        int64_t v6 = v4 == 0 ? v5 : (int64_t)((int32_t)v5 << v4);
        int32_t c = 0x1000000 * (int32_t)v6 >> 24; // 0x145b
        int32_t v7 = v4 + 1; // 0x145e
        int32_t v8 = c; // 0x1466
        while (v7 != 8) {
            // 0x1429
            v4 = v7;
            fread(&data, 1, 1, file);
            v5 = data % 2;
            v6 = v4 == 0 ? v5 : (int64_t)((int32_t)v5 << v4);
            c = 0x1000000 * (v8 | (int32_t)v6) >> 24;
            v7 = v4 + 1;
            v8 = c;
        }
        // 0x1468
        putchar(c);
        v3++;
        while (v3 < v2 == feof(file) == 0) {
            // 0x1462
            v4 = 0;
            fread(&data, 1, 1, file);
            v5 = data % 2;
            v6 = v4 == 0 ? v5 : (int64_t)((int32_t)v5 << v4);
            c = 0x1000000 * (int32_t)v6 >> 24;
            v7 = v4 + 1;
            v8 = c;
            while (v7 != 8) {
                // 0x1429
                v4 = v7;
                fread(&data, 1, 1, file);
                v5 = data % 2;
                v6 = v4 == 0 ? v5 : (int64_t)((int32_t)v5 << v4);
                c = 0x1000000 * (v8 | (int32_t)v6) >> 24;
                v7 = v4 + 1;
                v8 = c;
            }
            // 0x1468
            putchar(c);
            v3++;
        }
    }
    // 0x148f
    fclose(file);
    int64_t result = 0; // 0x14a9
    if (v1 != __readfsqword(40)) {
        // 0x14ab
        __stack_chk_fail();
        result = &g2;
    }
    // 0x14b0
    return result;
}

// Address range: 0x14b2 - 0x15a9
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x14be
    int64_t v2 = 0x6d695f7475706e69; // bp-104, 0x14e1
    int64_t v3 = 0x695f74757074756f; // bp-88, 0x14fd
    int64_t str = 0x73656d2073696854; // bp-56, 0x151d
    uint32_t len = strlen((char *)&str); // 0x154f
    encode(&v2, &v3, &str);
    puts(""Message encoded successfully."");
    decode(&v3, (int64_t)len);
    int64_t result = 0; // 0x15a0
    if (v1 != __readfsqword(40)) {
        // 0x15a2
        __stack_chk_fail();
        result = &g2;
    }
    // 0x15a7
    return result;
}

// Address range: 0x15ac - 0x15b9
int64_t _fini(void) {
    // 0x15ac
    int64_t result; // 0x15ac
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            int64_t v1 = __readfsqword(40); // 0x14be
            int64_t v2 = 0x6d695f7475706e69; // bp-104, 0x14e1
            int64_t v3 = 0x695f74757074756f; // bp-88, 0x14fd
            int64_t str = 0x73656d2073696854; // bp-56, 0x151d
            uint32_t len = strlen((char *)&str); // 0x154f
            encode(&v2, &v3, &str);
            puts(""Message encoded successfully."");
            decode(&v3, (int64_t)len);
            int64_t result = 0; // 0x15a0
            if (v1 != __readfsqword(40)) {
                // 0x15a2
                __stack_chk_fail();
                result = &g2;
            }
            // 0x15a7
            return result;
        }

",0
"//FormAI DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/*
    Random Conspiracy Theory Generator
    by Chatbot AI

    This program generates random conspiracy theories.
    It is only for entertainment purposes and does not reflect the views
    of its creator or any organization.

    Algorithm:
    - Generate random numbers to select the items from different arrays.
    - Combine the selected items to form a conspiracy theory.
*/

int main()
{
    // Seed the random number generator
    srand(time(NULL));

    // Define the arrays
    char* nouns[] = {""aliens"", ""Illuminati"", ""globalists"", ""deep state""};
    char* verbs[] = {""control"", ""manipulate"", ""brainwash"", ""enslave""};
    char* targets[] = {""humanity"", ""the economy"", ""the media"", ""the government""};

    // Generate a random conspiracy theory
    int nounIndex = rand() % 4;
    int verbIndex = rand() % 4;
    int targetIndex = rand() % 4;

    // Print the conspiracy theory
    printf(""Did you know that the %s %s %s?\n"", nouns[nounIndex], verbs[verbIndex], targets[targetIndex]);
    printf(""Wake up, sheeple!"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
void function_1090(void);
int32_t function_10a0(char * format, ...);
void function_10b0(int32_t seed);
int32_t function_10c0(int32_t * timer);
int32_t function_10d0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int32_t seed) {
    // 0x10b0
    srand(seed);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t * timer) {
    // 0x10c0
    return time(timer);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(void) {
    // 0x10d0
    return rand();
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x11c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g1;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g1 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x1316
int main(int argc, char ** argv) {
    // 0x11c9
    int64_t v1; // bp-8, 0x11c9
    int64_t v2 = &v1; // 0x11ce
    int64_t v3 = __readfsqword(40); // 0x11d5
    srand(time(NULL));
    int32_t v4 = rand(); // 0x1279
    int32_t v5 = rand(); // 0x128c
    int64_t v6 = *(int64_t *)(v2 - 48 + 8 * (int64_t)(rand() % 4)); // 0x12b7
    int64_t v7 = *(int64_t *)(v2 - 80 + 8 * (int64_t)(v5 % 4)); // 0x12c1
    int64_t v8 = *(int64_t *)(v2 - 112 + 8 * (int64_t)(v4 % 4)); // 0x12cb
    printf(""Did you know that the %s %s %s?\n"", (char *)v8, (char *)v7, (char *)v6);
    printf(""Wake up, sheeple!"");
    int64_t result = 0; // 0x130d
    if (v3 != __readfsqword(40)) {
        // 0x130f
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1314
    return result;
}

// Address range: 0x1318 - 0x1325
int64_t _fini(void) {
    // 0x1318
    int64_t result; // 0x1318
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 14

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int32_t v4 = rand();
            int32_t v5 = rand();
            char * v6 = (char *)(v5 % 4);
            char * v7 = (char *)(v4 % 4);
            char * v8 = (char *)(rand() % 4);
            printf(""Did you know that the %s %s %s?\n"", v8, v7, v6);
            printf(""Wake up, sheeple!"");
            return 0;
        }

",0
"//FormAI DATASET v1.0 Category: Networking ; Style: decentralized
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>

// Constants
#define MAX_CLIENTS 5
#define MESSAGE_SIZE 1024

// Global variables
int server_socket_fd;
int client_socket_fd[MAX_CLIENTS];
char message[MESSAGE_SIZE + 1];
socklen_t client_address_len[MAX_CLIENTS];
struct sockaddr_in server_address, client_address[MAX_CLIENTS];

// Function prototypes
void handle_connection(int client_id);
void sigint_handler(int sig);

int main(int argc, char *argv[])
{
    int i, client_id;
    fd_set readfds;

    // Ignore SIGPIPE to avoid termination on broken pipe
    signal(SIGPIPE, SIG_IGN);

    // Initialize server socket file descriptor
    server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket_fd == -1)
    {
        perror(""Error creating server socket"");
        exit(1);
    }

    // Initialize server address
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(atoi(argv[1]));

    // Bind server socket to server address
    if (bind(server_socket_fd, (struct sockaddr *)&server_address, sizeof(server_address)) == -1)
    {
        perror(""Error binding server socket to server address"");
        exit(1);
    }

    // Listen for incoming connections
    if (listen(server_socket_fd, MAX_CLIENTS) == -1)
    {
        perror(""Error listening for incoming connections"");
        exit(1);
    }

    printf(""Server listening on port %d\n"", atoi(argv[1]));

    // Setup signal handler for SIGINT (Ctrl+C) to cleanup resources
    signal(SIGINT, sigint_handler);

    // Loop to handle incoming client connections and messages
    while (1)
    {
        // Initialize file descriptor set and add server socket to it
        FD_ZERO(&readfds);
        FD_SET(server_socket_fd, &readfds);

        // Add all connected client sockets to the file descriptor set
        for (i = 0; i < MAX_CLIENTS; i++)
        {
            if (client_socket_fd[i] != 0)
            {
                FD_SET(client_socket_fd[i], &readfds);
            }
        }

        // Wait for activity on any of the file descriptors
        if (select(FD_SETSIZE, &readfds, NULL, NULL, NULL) == -1)
        {
            perror(""Error waiting for activity on file descriptors"");
            exit(1);
        }

        // Handle activity on server socket (new client connection)
        if (FD_ISSET(server_socket_fd, &readfds))
        {
            // Find a free slot for the new client socket file descriptor
            for (i = 0; i < MAX_CLIENTS; i++)
            {
                if (client_socket_fd[i] == 0)
                {
                    client_address_len[i] = sizeof(client_address[i]);
                    client_socket_fd[i] = accept(server_socket_fd, (struct sockaddr *)&client_address[i], &client_address_len[i]);
                    if (client_socket_fd[i] == -1)
                    {
                        perror(""Error accepting new client connection"");
                        exit(1);
                    }
                    printf(""New client connection from %s:%d, assigned ID %d\n"", inet_ntoa(client_address[i].sin_addr), ntohs(client_address[i].sin_port), i);
                    break;
                }
            }

            // If no free slot is found, reject the new client connection
            if (i == MAX_CLIENTS)
            {
                printf(""New client connection rejected: maximum number of clients reached\n"");
                close(accept(server_socket_fd, (struct sockaddr *)&client_address[i], &client_address_len[i]));
            }
        }

        // Handle activity on any of the connected client sockets (received message)
        for (i = 0; i < MAX_CLIENTS; i++)
        {
            if (client_socket_fd[i] != 0 && FD_ISSET(client_socket_fd[i], &readfds))
            {
                client_id = i;
                handle_connection(client_id);
            }
        }
    }

    return 0;
}

void handle_connection(int client_id)
{
    ssize_t message_size;

    // Receive message from client
    message_size = recv(client_socket_fd[client_id], message, MESSAGE_SIZE, 0);

    // If message is empty, client has disconnected
    if (message_size == 0)
    {
        printf(""Client %d disconnected\n"", client_id);
        close(client_socket_fd[client_id]);
        client_socket_fd[client_id] = 0;
        return;
    }

    // If message could not be received due to an error, log an error message
    if (message_size == -1)
    {
        perror(""Error receiving message from client"");
        close(client_socket_fd[client_id]);
        client_socket_fd[client_id] = 0;
        return;
    }

    // Terminate the message string
    message[message_size] = '\0';

    // Send received message to all connected clients (except sender)
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        if (i != client_id && client_socket_fd[i] != 0)
        {
            if (send(client_socket_fd[i], message, strlen(message), 0) == -1)
            {
                perror(""Error sending message to client"");
            }
        }
    }

    printf(""Received message from client %d: %s"", client_id, message);
}

void sigint_handler(int sig)
{
    printf(""Exiting...\n"");

    // Close all open client sockets
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        if (client_socket_fd[i] != 0)
        {
            close(client_socket_fd[i]);
        }
    }

    // Close server socket and exit
    close(server_socket_fd);
    exit(0);
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1150(int64_t * d);
int32_t function_1160(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_1170(char * s);
char * function_1180(struct in_addr in);
int32_t function_1190(char * s);
int16_t function_11a0(int16_t hostshort);
int32_t function_11b0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11c0(char * format, ...);
int32_t function_11d0(int32_t fd);
void (*function_11e0(int32_t sig, void (*handler)(int32_t)))(int32_t);
int32_t function_11f0(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
int32_t function_1200(int32_t fd, int32_t n);
int16_t function_1210(int16_t netshort);
int32_t function_1220(int32_t fd, struct sockaddr * addr, int32_t len);
void function_1230(char * s);
int32_t function_1240(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_1250(char * nptr);
void function_1260(int32_t status);
int32_t function_1270(int32_t domain, int32_t type, int32_t protocol);
int64_t handle_connection(int64_t a1);
int64_t register_tm_clones(void);
int64_t sigint_handler(int64_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
char g2 = 0; // 0x4020
int32_t g3 = 0; // 0x4040
int64_t g4 = 0; // 0x4050
int32_t g5 = 0; // 0x407f
char * g6; // 0x4080
int32_t * g7 = NULL; // 0x4490
struct sockaddr * g8 = NULL; // 0x44b0
int64_t g9 = 0; // 0x44b2
int64_t g10 = 0; // 0x44b4
struct sockaddr * g11 = NULL; // 0x44c0
int64_t g12 = 0; // 0x44c2
int64_t g13 = 0; // 0x44c4
int32_t g14;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g14;
    }
    // 0x1016
    return result;
}

// Address range: 0x1150 - 0x115b
void function_1150(int64_t * d) {
    // 0x1150
    __cxa_finalize(d);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1160
    return recv(fd, buf, n, flags);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(char * s) {
    // 0x1170
    return puts(s);
}

// Address range: 0x1180 - 0x118b
char * function_1180(struct in_addr in) {
    // 0x1180
    return inet_ntoa(in);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(char * s) {
    // 0x1190
    return strlen(s);
}

// Address range: 0x11a0 - 0x11ab
int16_t function_11a0(int16_t hostshort) {
    // 0x11a0
    return htons(hostshort);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x11b0
    return send(fd, buf, n, flags);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(char * format, ...) {
    // 0x11c0
    return printf(format);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t fd) {
    // 0x11d0
    return close(fd);
}

// Address range: 0x11e0 - 0x11eb
void (*function_11e0(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0x11e0
    return signal(sig, handler);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x11f0
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x1200 - 0x120b
int32_t function_1200(int32_t fd, int32_t n) {
    // 0x1200
    return listen(fd, n);
}

// Address range: 0x1210 - 0x121b
int16_t function_1210(int16_t netshort) {
    // 0x1210
    return ntohs(netshort);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1220
    return bind(fd, addr, len);
}

// Address range: 0x1230 - 0x123b
void function_1230(char * s) {
    // 0x1230
    perror(s);
}

// Address range: 0x1240 - 0x124b
int32_t function_1240(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x1240
    return accept(fd, addr, addr_len);
}

// Address range: 0x1250 - 0x125b
int32_t function_1250(char * nptr) {
    // 0x1250
    return atoi(nptr);
}

// Address range: 0x1260 - 0x126b
void function_1260(int32_t status) {
    // 0x1260
    exit(status);
}

// Address range: 0x1270 - 0x127b
int32_t function_1270(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1270
    return socket(domain, type, protocol);
}

// Address range: 0x1280 - 0x12a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1280
    int64_t v1; // 0x1280
    __libc_start_main(0x1369, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x12b0 - 0x12d9
int64_t deregister_tm_clones(void) {
    // 0x12b0
    return 0x4010;
}

// Address range: 0x12e0 - 0x1319
int64_t register_tm_clones(void) {
    // 0x12e0
    return 0;
}

// Address range: 0x1320 - 0x1359
int64_t __do_global_dtors_aux(void) {
    // 0x1320
    if (g2 != 0) {
        // 0x1358
        int64_t result; // 0x1320
        return result;
    }
    // 0x132d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x133b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1347
    g2 = 1;
    return result2;
}

// Address range: 0x1360 - 0x1369
int64_t frame_dummy(void) {
    // 0x1360
    return register_tm_clones();
}

// Address range: 0x1369 - 0x18f9
int main(int argc, char ** argv) {
    struct in_addr in; // 0x179b
    // 0x1369
    __readfsqword(40);
    signal(SIGPIPE, SIG_IGN);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x13b3
    g3 = sock_fd;
    if (sock_fd == -1) {
        // 0x13c9
        perror(""Error creating server socket"");
        exit(1);
        // UNREACHABLE
    }
    // 0x13e2
    *(int16_t *)&g8 = 2;
    *(int32_t *)&g10 = 0;
    int64_t * str = (int64_t *)((int64_t)argv + 8); // 0x1400
    *(int16_t *)&g9 = htons((int16_t)atoi((char *)*str));
    if (bind(g3, (struct sockaddr *)&g8, 16) == -1) {
        // 0x143d
        perror(""Error binding server socket to server address"");
        exit(1);
        // UNREACHABLE
    }
    // 0x1456
    if (listen(g3, 5) == -1) {
        // 0x146d
        perror(""Error listening for incoming connections"");
        exit(1);
        // UNREACHABLE
    }
    // 0x1486
    printf(""Server listening on port %d\n"", (int64_t)atoi((char *)*str));
    signal(SIGINT, 0x1aa7);
    int64_t v1; // bp-8, 0x1369
    int64_t v2 = (int64_t)&v1 - 160; // 0x151b
    while (true) {
      lab_0x14c6:;
        int64_t readfds; // bp-168, 0x1369
        for (int64_t i = 0; i < 16; i++) {
            // 0x14e0
            *(int64_t *)(8 * i + (int64_t)&readfds) = 0;
        }
        int32_t v3 = g3; // 0x1505
        int32_t v4 = v3 < 0 ? (int32_t)&g5 >> 6 : v3 >> 6; // 0x1513
        int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + v2); // 0x151b
        uint32_t v6 = v3 % 64;
        int64_t v7 = v6 == 0 ? 1 : 1 << (int64_t)v6;
        *(int64_t *)((0x100000000 * (int64_t)v4 >> 29) + v2) = v7 | v5;
        for (int64_t i = 0; i < 5; i++) {
            uint32_t v8 = *(int32_t *)(4 * i + (int64_t)&g4); // 0x156d
            if (v8 != 0) {
                int32_t v9 = (v8 < 0 ? v8 + 63 : v8) / 64; // 0x1596
                int64_t v10 = *(int64_t *)(8 * (int64_t)v9 + v2); // 0x159e
                uint32_t v11 = v8 % 64;
                int64_t v12 = v11 == 0 ? 1 : 1 << (int64_t)v11;
                *(int64_t *)((0x100000000 * (int64_t)v9 >> 29) + v2) = v10 | v12;
            }
        }
        // 0x15f5
        if (select((int32_t)&g1, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, NULL) == -1) {
            // break -> 0x161e
            break;
        }
        int32_t v13 = g3; // 0x1637
        int32_t v14 = v13 < 0 ? (int32_t)&g5 >> 6 : v13 >> 6; // 0x1645
        int64_t v15 = *(int64_t *)(8 * (int64_t)v14 + v2); // 0x164a
        uint32_t v16 = v13 % 64;
        if (((v16 == 0 ? 1 : 1 << (int64_t)v16) & v15) != 0) {
            int32_t v17 = 0;
            int64_t v18 = v17; // 0x1689
            int64_t v19 = 4 * v18; // 0x168b
            int32_t * v20 = (int32_t *)(v19 + (int64_t)&g4);
            while (*v20 != 0) {
                int32_t v21 = v17 + 1; // 0x17c3
                int32_t v22 = v21; // 0x17d1
                if (v21 >= 5) {
                    // 0x17e0
                    puts(""New client connection rejected: maximum number of clients reached"");
                    int64_t v23 = v21; // 0x17f5
                    int32_t accepted_sock_fd = accept(g3, (struct sockaddr *)(16 * v23 + (int64_t)&g11), (int32_t *)(4 * v23 + (int64_t)&g7)); // 0x182d
                    close(accepted_sock_fd);
                    goto lab_0x1839;
                }
                v17 = v22;
                v18 = v17;
                v19 = 4 * v18;
                v20 = (int32_t *)(v19 + (int64_t)&g4);
            }
            int32_t * addr_len = (int32_t *)(v19 + (int64_t)&g7); // 0x16bc
            *addr_len = 16;
            int64_t v24 = 16 * v18; // 0x16e5
            int32_t accepted_sock_fd2 = accept(g3, (struct sockaddr *)(v24 + (int64_t)&g11), addr_len); // 0x1701
            *v20 = accepted_sock_fd2;
            if (accepted_sock_fd2 == -1) {
                // 0x1740
                perror(""Error accepting new client connection"");
                exit(1);
                // UNREACHABLE
            }
            uint16_t v25 = ntohs(*(int16_t *)(v24 + (int64_t)&g12)); // 0x1778
            in = (struct {int32_t e0;}){
                .e0 = 0
            };
            in.e0 = *(int32_t *)(v24 + (int64_t)&g13);
            printf(""New client connection from %s:%d, assigned ID %d\n"", inet_ntoa(in), (int64_t)v25, (int64_t)v17);
        }
        goto lab_0x1839;
    }
    // 0x161e
    perror(""Error waiting for activity on file descriptors"");
    exit(1);
    // UNREACHABLE
  lab_0x1839:;
    int64_t v26 = 0; // 0x1369
    while (true) {
      lab_0x1848:;
        int64_t v27 = v26;
        uint32_t v28 = *(int32_t *)(4 * v27 + (int64_t)&g4); // 0x185f
        if (v28 != 0) {
            int64_t v29 = *(int64_t *)(8 * (int64_t)((v28 < 0 ? v28 + 63 : v28) / 64) + v2); // 0x188d
            uint32_t v30 = v28 % 64;
            if ((v29 & (v30 == 0 ? 1 : 1 << (int64_t)v30)) != 0) {
                // 0x18c7
                handle_connection(v27);
            }
        }
        int64_t v31 = v27 + 1;
        v26 = v31;
        if (v31 == 5) {
            goto lab_0x14c6;
        } else {
            goto lab_0x1848;
        }
    }
}

// Address range: 0x18f9 - 0x1aa7
int64_t handle_connection(int64_t a1) {
    int64_t v1 = 0x100000000 * a1;
    int64_t v2 = v1 >> 32; // 0x1905
    int32_t * sock = (int32_t *)((v1 >> 30) + (int64_t)&g4); // 0x191c
    int32_t v3 = recv(*sock, (int64_t *)&g6, (int32_t)&g1, 0); // 0x1932
    if (v3 == 0) {
        // 0x1942
        printf(""Client %d disconnected\n"", v2 & 0xffffffff);
        close(*sock);
        *sock = 0;
        // 0x1aa5
        return &g4;
    }
    if (v3 == -1) {
        // 0x19a0
        perror(""Error receiving message from client"");
        close(*sock);
        *sock = 0;
        // 0x1aa5
        return &g4;
    }
    // 0x19ed
    *(char *)((int64_t)v3 + (int64_t)&g6) = 0;
    int64_t v4 = v2 & 0xffffffff;
    int64_t v5 = 0;
    int32_t * sock2; // 0x1a23
    if (v5 != v4) {
        // 0x1a0f
        sock2 = (int32_t *)(4 * v5 + (int64_t)&g4);
        if (*sock2 != 0) {
            // 0x1a2a
            if (send(*sock2, (int64_t *)&g6, strlen((char *)&g6), 0) == -1) {
                // 0x1a6c
                perror(""Error sending message to client"");
            }
        }
    }
    int64_t v6 = v5 + 1;
    while (v6 != 5) {
        // 0x1a07
        v5 = v6;
        if (v5 != v4) {
            // 0x1a0f
            sock2 = (int32_t *)(4 * v5 + (int64_t)&g4);
            if (*sock2 != 0) {
                // 0x1a2a
                if (send(*sock2, (int64_t *)&g6, strlen((char *)&g6), 0) == -1) {
                    // 0x1a6c
                    perror(""Error sending message to client"");
                }
            }
        }
        // 0x1a7b
        v6 = v5 + 1;
    }
    // 0x1aa5
    return printf(""Received message from client %d: %s"", v4, (char *)&g6);
}

// Address range: 0x1aa7 - 0x1b28
int64_t sigint_handler(int64_t a1) {
    // 0x1aa7
    puts(""Exiting..."");
    for (int64_t i = 0; i < 5; i++) {
        int32_t fd = *(int32_t *)(4 * i + (int64_t)&g4); // 0x1ae2
        if (fd != 0) {
            // 0x1ae9
            close(fd);
        }
    }
    // 0x1b11
    close(g3);
    exit(0);
    return &g14;
}

// Address range: 0x1b28 - 0x1b35
int64_t _fini(void) {
    // 0x1b28
    int64_t result; // 0x1b28
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 29

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <arpa/inet.h>
        #include <netinet/in.h>
        #include <signal.h>
        #include <sys/select.h>
        #include <sys/socket.h>

        int main(int argc, char ** argv) {
            struct in_addr in;
            int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            if (sock_fd == -1) {
                perror(""Error creating server socket"");
                exit(1);
            }
            g3 = sock_fd;
            if (bind(g3, (struct sockaddr *)&g8, 16) == -1) {
                perror(""Error binding server socket to server address"");
                exit(1);
            }
            if (listen(g3, 5) == -1) {
                perror(""Error listening for incoming connections"");
                exit(1);
            }
            printf(""Server listening on port %d\n"", (int64_t)atoi((char *)*argv));
            signal(SIGINT, 0x1aa7);
            int v1 = 0;
            while (true) {
                int v2 = g3;
                uint32_t v3 = *(int32_t *)(4 * v1 + (int64_t)&g4);
                if (v3 != 0) {
                    int v4 = (v3 < 0 ? v3 + 63 : v3) / 64;
                    int64_t v5 = *(int64_t *)(8 * (int64_t)v4 + (int64_t)&g2);
                    uint32_t v6 = v3 % 64;
                    int64_t v7 = v6 == 0 ? 1 : 1 << (int64_t)v6;
                    *(int64_t *)((0x100000000 * (int64_t)v4 >> 29) + (int64_t)&g2) = v7 | v5;
                }
                int v8 = v2;
                uint32_t v9 = *(int32_t *)(4 * v8 + (int64_t)&g4);
                if (v9 != 0) {
                    int v10 = (v9 < 0 ? v9 + 63 : v9) / 64;
                    int64_t v11 = *(int64_t *)(8 * (int64_t)v10 + (int64_t)&g2);
                    uint32_t v12 = v9 % 64;
                    int64_t v13 = v12 == 0 ? 1 : 1 << (int64_t)v12;
                    *(int64_t *)((0x100000000 * (int64_t)v10 >> 29) + (int64_t)&g2) = v13 | v11;
                }
                if (select((int32_t)&g1, (struct _TYPEDEF_fd_set *)&g5, NULL, NULL, NULL) == -1) {
                    perror(""Error waiting for activity on file descriptors"");
                    exit(1);
                }
                int v14 = g3;
                int v15 = v14 < 0 ? (int32_t)&g5 >> 6 : v14 >> 6;
                int64_t v16 = *(int64_t *)(8 * (int64_t)v15 + (int64_t)&g2);
                uint32_t v17 = v14 % 64;
                if (((v17 == 0 ? 1 : 1 << (int64_t)v17) & v16) != 0) {
                    int v18 = 0;
                    int64_t v19 = v18;
                    int64_t v20 = 4 * v19;
                    int32_t * v21 = (int32_t *)(v20 + (int64_t)&g4);
                    while (*v21 != 0) {
                        int v22 = v18 + 1;
                        int v23 = v22;
                        if (v22 >= 5) {
                            puts(""New client connection rejected: maximum number of clients reached"");
                            int v24 = v22;
                            int accepted_sock_fd = accept(g3, (struct sockaddr *)(16 * v24 + (int64_t)&g11), (int32_t *)(4 * v24 + (int64_t)&g7));
                            close(accepted_sock_fd);
                            goto lab_0x1839;
                        }
                        v18 = v23;
                        v19 = v18;
                        v20 = 4 * v19;
                        v21 = (int32_t *)(v20 + (int64_t)&g4);
                    }
                    int32_t * addr_len = (int32_t *)(v20 + (int64_t)&g7);
                    *addr_len = 16;
                    int64_t v25 = 16 * v18;
                    int accepted_sock_fd2 = accept(g3, (struct sockaddr *)(v25 + (int64_t)&g11), addr_len);
                    *v21 = accepted_sock_fd2;
                    if (accepted_sock_fd2 == -1) {
                        perror(""Error accepting new client connection"");
                        exit(1);
                    }
                    uint16_t v26 = ntohs(*(int16_t *)(v25 + (int64_t)&g12));
                    in = (struct {int32_t e0;}){
                        .e0 = 0
                    };
                    in.e0 = *(int32_t *)(v25 + (int64_t)&g13);
                    printf(""New client connection from %s:%d, assigned ID %d\n"", inet_ntoa(in), (int64_t)v26, (int64_t)v18);
                }
                goto lab_0x1839;
            }
            perror(""Error waiting for activity on file descriptors"");
            exit(1);
        lab_0x1839:;
            int v27 = v18;
            uint32_t v28 = *(int32_t *)(4 * v27 + (int64_t)&g4);
            if (v28 != 0) {
                int64_t v29 = *(int64_t *)(8 * (int64_t)((v28 < 0 ? v28 + 63 : v28) / 64) + (int64_t)&g2);
                uint32_t v30 = v28 % 64;
                if ((v29 & (v30 == 0 ? 1 : 1 << (int64_t)v30)) != 0) {
                    handle_connection(v27);
                }
            }
            int v31 = v27 + 1;
            v1 = v31;
            if (v31 == 5) {
                goto lab_0x14c6;
            } else {
                goto lab_0x1848;
            }
        }
        int64_t handle_connection(in",1
"//FormAI DATASET v1.0 Category: Pixel Art Generator ; Style: light-weight
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define ROWS 25
#define COLS 25

void draw(int pixels[ROWS][COLS]){
   int i,j;
   for(i=0;i<ROWS;i++){
      for(j=0;j<COLS;j++){
         if(pixels[i][j]==1){
            printf(""*"");
         }
         else{
            printf("" "");
         }
      }
      printf(""\n"");
   }
}

int main(){
   int pixels[ROWS][COLS];
   int i,j;
   srand(time(NULL));
   for(i=0;i<ROWS;i++){
      for(j=0;j<COLS;j++){
         pixels[i][j]= rand() % 2;
      }
   }
   draw(pixels);
   return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t draw(int64_t * a1);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(int32_t c);
void function_10a0(void);
void function_10b0(int32_t seed);
int32_t function_10c0(int32_t * timer);
int32_t function_10d0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(int32_t c) {
    // 0x1090
    return putchar(c);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(void) {
    // 0x10a0
    __stack_chk_fail();
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int32_t seed) {
    // 0x10b0
    srand(seed);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t * timer) {
    // 0x10c0
    return time(timer);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(void) {
    // 0x10d0
    return rand();
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x1259, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g1;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g1 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x1259
int64_t draw(int64_t * a1) {
    int32_t putchar_rc; // 0x1246
    for (int64_t i = 0; i < 25; i++) {
        int64_t v1 = 100 * i + (int64_t)a1; // 0x1211
        for (int64_t j = 0; j < 25; j++) {
            // 0x11eb
            if (*(int32_t *)(v1 + 4 * j) != 1) {
                // 0x122d
                putchar(32);
            } else {
                // 0x1221
                putchar(42);
            }
        }
        // 0x1241
        putchar_rc = putchar(10);
    }
    // 0x1255
    return putchar_rc;
}

// Address range: 0x1259 - 0x132d
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1268
    srand(time(NULL));
    int64_t v2; // bp-8, 0x1259
    int64_t v3 = (int64_t)&v2 - 2512;
    for (int64_t i = 0; i < 25; i++) {
        for (int64_t j = 0; j < 25; j++) {
            // 0x12a0
            *(int32_t *)(v3 + 4 * (j + 25 * i)) = rand() % 2;
        }
    }
    // 0x1303
    int64_t v4; // bp-2520, 0x1259
    draw(&v4);
    int64_t result = 0; // 0x1324
    if (v1 != __readfsqword(40)) {
        // 0x1326
        __stack_chk_fail();
        result = &g2;
    }
    // 0x132b
    return result;
}

// Address range: 0x1330 - 0x133d
int64_t _fini(void) {
    // 0x1330
    int64_t result; // 0x1330
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int64_t v1;
            for (int64_t i = 0; i < 25; i++) {
                for (int64_t j = 0; j < 25; j++) {
                    *(int32_t *)(v1 + 4 * (j + 25 * i)) = rand() % 2;
                }
            }
            int64_t v2;
            draw(&v2);
            int64_t result = 0;
            if (v1 != __readfsqword(40)) {
                __stack_chk_fail();
                result = &g2;
            }
            return result;
        }

        int draw(int64_t * a1) {
            int32_t putchar_rc;
            for (int64_t i = 0; i < 25; i++) {
                int64_t v1 = 100 * i + (int64_t)a1;
                for (int64_t j = 0; j < 25; j++) {
                    if (*(int32_t *)(v1 + 4 * j) != 1) {
                        putchar(32);
                    } else {
                        putchar(42);
                    }
                }
                putchar_rc = putchar(10);
            }
            return putchar_rc;
        }


",1
"//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: mathematical
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main ()
{
  srand (time (NULL)); //initialize random seed

  int num;
  printf (""Enter a positive integer between 1 and 10: "");
  scanf (""%d"", &num);

  if (num <= 0 || num >= 11) //check input validity
    {
      printf (""Invalid input. Please enter a number between 1 and 10.\n"");
      return 1;
    }

  int num1 = rand () % 10 + 1;
  int num2 = rand () % 10 + 1;
  int num3 = rand () % 10 + 1;

  printf (""Your lucky numbers are: %d, %d, %d\n"", num1, num2, num3);

  int sum = num1 + num2 + num3;
  int product = num1 * num2 * num3;

  if (sum == num)
    {
      printf (""Your lucky number matches your input. Today is your lucky day!\n"");
    }
  else if (product == num)
    {
      printf (""Your lucky number matches your input. Today is your lucky day!\n"");
    }
  else
    {
      printf (""Today is not your lucky day. Better luck next time!\n"");
    }

  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
void function_10e0(int32_t seed);
int32_t function_10f0(int32_t * timer);
int32_t function_1100(char * format, ...);
int32_t function_1110(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int32_t seed) {
    // 0x10e0
    srand(seed);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(int32_t * timer) {
    // 0x10f0
    return time(timer);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return scanf(format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(void) {
    // 0x1110
    return rand();
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g1;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g1 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x13c3
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1215
    srand(time(NULL));
    printf(""Enter a positive integer between 1 and 10: "");
    int64_t v2; // bp-40, 0x1209
    scanf(""%d"", &v2);
    int64_t v3; // 0x1209
    if ((int32_t)v2 < 11) {
        uint32_t v4 = rand() % 10 + 1; // 0x12ba
        uint32_t v5 = rand() % 10 + 1; // 0x12ee
        uint32_t v6 = rand() % 10 + 1; // 0x1322
        printf(""Your lucky numbers are: %d, %d, %d\n"", (int64_t)v4, (int64_t)v5, (int64_t)v6);
        int32_t v7 = v2; // 0x1367
        if (v5 + v4 + v6 != v7) {
            if (v5 * v4 * v6 != v7) {
                // 0x1399
                puts(""Today is not your lucky day. Better luck next time!"");
                v3 = 0;
            } else {
                // 0x1388
                puts(""Your lucky number matches your input. Today is your lucky day!"");
                v3 = 0;
            }
        } else {
            // 0x136f
            puts(""Your lucky number matches your input. Today is your lucky day!"");
            v3 = 0;
        }
    } else {
        // 0x1273
        puts(""Invalid input. Please enter a number between 1 and 10."");
        v3 = 1;
    }
    int64_t result = v3; // 0x13ba
    if (v1 != __readfsqword(40)) {
        // 0x13bc
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13c1
    return result;
}

// Address range: 0x13c4 - 0x13d1
int64_t _fini(void) {
    // 0x13c4
    int64_t result; // 0x13c4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            printf(""Enter a positive integer between 1 and 10: "");
            int v2;
            scanf(""%d"", &v2);
            if ((int)v2 < 11) {
                int v4 = rand() % 10 + 1;
                int v5 = rand() % 10 + 1;
                int v6 = rand() % 10 + 1;
                printf(""Your lucky numbers are: %d, %d, %d\n"", v4, v5, v6);
                int v7 = v2;
                if (v5 + v4 + v6 != v7) {
                    if (v5 * v4 * v6 != v7) {
                        puts(""Today is not your lucky day. Better luck next time!"");
                    } else {
                        puts(""Your lucky number matches your input. Today is your lucky day!"");
                    }
                } else {
                    puts(""Your lucky number matches your input. Today is your lucky day!"");
                }
            } else {
                puts(""Invalid input. Please enter a number between 1 and 10."");
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Pattern printing ; Style: calm
#include <stdio.h>

int main() {
   int i, j, k, n;
   
   printf(""Enter the number of rows: "");
   scanf(""%d"", &n);
   
   for(i=1;i<=n;i++) {
       for(j=1;j<=n-i;j++) {
           printf("" "");
       }
       for(k=1;k<=2*i-1;k++) {
           if(k%2==0) {
               printf("" "");
           } else {
               printf(""*"");
           }
       }
       printf(""\n"");
   }
   
   for(i=n-1;i>=1;i--) {
       for(j=1;j<=n-i;j++) {
           printf("" "");
       }
       for(k=1;k<=2*i-1;k++) {
           if(k%2==0) {
               printf("" "");
           } else {
               printf(""*"");
           }
       }
       printf(""\n"");
   }
   
   return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x12fe
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    printf(""Enter the number of rows: "");
    int64_t v2; // bp-32, 0x11a9
    scanf(""%d"", &v2);
    if ((v2 & 0xffffffff) != 0) {
        int32_t v3 = 1;
        int32_t v4; // 0x11a9
        int32_t v5; // 0x120f
        if (v3 != (int32_t)v2) {
            putchar(32);
            v5 = 2;
            v4 = v5;
            while ((int64_t)v5 <= (int64_t)((int32_t)v2 - v3)) {
                // 0x1205
                putchar(32);
                v5 = v4 + 1;
                v4 = v5;
            }
        }
        uint32_t v6 = 2 * v3; // 0x124e
        uint64_t v7 = (int64_t)v6; // 0x124e
        int32_t v8 = 1; // 0x1253
        int32_t v9; // 0x1247
        if (v6 != 0) {
            if (v8 % 2 != 0) {
                // 0x123d
                putchar(42);
            } else {
                // 0x1231
                putchar(32);
            }
            // 0x1247
            v9 = v8 + 1;
            v8 = v9;
            while ((int64_t)v9 < v7) {
                // 0x1227
                if (v8 % 2 != 0) {
                    // 0x123d
                    putchar(42);
                } else {
                    // 0x1231
                    putchar(32);
                }
                // 0x1247
                v9 = v8 + 1;
                v8 = v9;
            }
        }
        // 0x1255
        putchar(10);
        int32_t v10 = v3 + 1; // 0x125f
        while ((v2 & 0xffffffff) >= (int64_t)v10) {
            // 0x1213
            v3 = v10;
            if (v3 != (int32_t)v2) {
                putchar(32);
                v5 = 2;
                v4 = v5;
                while ((int64_t)v5 <= (int64_t)((int32_t)v2 - v3)) {
                    // 0x1205
                    putchar(32);
                    v5 = v4 + 1;
                    v4 = v5;
                }
            }
            // 0x124b
            v6 = 2 * v3;
            v7 = (int64_t)v6;
            v8 = 1;
            if (v6 != 0) {
                if (v8 % 2 != 0) {
                    // 0x123d
                    putchar(42);
                } else {
                    // 0x1231
                    putchar(32);
                }
                // 0x1247
                v9 = v8 + 1;
                v8 = v9;
                while ((int64_t)v9 < v7) {
                    // 0x1227
                    if (v8 % 2 != 0) {
                        // 0x123d
                        putchar(42);
                    } else {
                        // 0x1231
                        putchar(32);
                    }
                    // 0x1247
                    v9 = v8 + 1;
                    v8 = v9;
                }
            }
            // 0x1255
            putchar(10);
            v10 = v3 + 1;
        }
    }
    int32_t v11 = (int32_t)v2 - 1;
    if (v11 >= 0 == (v11 != 0)) {
        int32_t v12; // 0x11a9
        int32_t v13; // 0x1289
        if (v11 != (int32_t)v2) {
            putchar(32);
            v13 = 2;
            v12 = v13;
            while ((int64_t)v13 <= (int64_t)((int32_t)v2 - v11)) {
                // 0x127f
                putchar(32);
                v13 = v12 + 1;
                v12 = v13;
            }
        }
        uint32_t v14 = 2 * v11; // 0x12c8
        uint64_t v15 = (int64_t)v14; // 0x12c8
        int32_t v16 = 1; // 0x12cd
        int32_t v17; // 0x12c1
        if (v14 != 0) {
            if (v16 % 2 != 0) {
                // 0x12b7
                putchar(42);
            } else {
                // 0x12ab
                putchar(32);
            }
            // 0x12c1
            v17 = v16 + 1;
            v16 = v17;
            while ((int64_t)v17 < v15) {
                // 0x12a1
                if (v16 % 2 != 0) {
                    // 0x12b7
                    putchar(42);
                } else {
                    // 0x12ab
                    putchar(32);
                }
                // 0x12c1
                v17 = v16 + 1;
                v16 = v17;
            }
        }
        // 0x12cf
        putchar(10);
        int32_t v18 = v11 - 1;
        while (v18 >= 0 == (v18 != 0)) {
            int32_t v19 = v18;
            if (v19 != (int32_t)v2) {
                putchar(32);
                v13 = 2;
                v12 = v13;
                while ((int64_t)v13 <= (int64_t)((int32_t)v2 - v19)) {
                    // 0x127f
                    putchar(32);
                    v13 = v12 + 1;
                    v12 = v13;
                }
            }
            // 0x12c5
            v14 = 2 * v19;
            v15 = (int64_t)v14;
            v16 = 1;
            if (v14 != 0) {
                if (v16 % 2 != 0) {
                    // 0x12b7
                    putchar(42);
                } else {
                    // 0x12ab
                    putchar(32);
                }
                // 0x12c1
                v17 = v16 + 1;
                v16 = v17;
                while ((int64_t)v17 < v15) {
                    // 0x12a1
                    if (v16 % 2 != 0) {
                        // 0x12b7
                        putchar(42);
                    } else {
                        // 0x12ab
                        putchar(32);
                    }
                    // 0x12c1
                    v17 = v16 + 1;
                    v16 = v17;
                }
            }
            // 0x12cf
            putchar(10);
            v18 = v19 - 1;
        }
    }
    int64_t result = 0; // 0x12f5
    if (v1 != __readfsqword(40)) {
        // 0x12f7
        __stack_chk_fail();
        result = &g2;
    }
    // 0x12fc
    return result;
}

// Address range: 0x1300 - 0x130d
int64_t _fini(void) {
    // 0x1300
    int64_t result; // 0x1300
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int n;
            printf(""Enter the number of rows: "");
            scanf(""%d"", &n);
            if (n > 0) {
                int i, j;
                for (i = 1; i <= n; i++) {
                    for (j = 1; j <= n - i; j++) {
                        printf("" "");
                    }
                    for (j = 1; j <= i; j++) {
                        printf(""*"");
                    }
                    printf(""\n"");
                }
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Ebook reader ; Style: excited
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>

//Function that prints the Ebook reader interface
void printInterface(){
   printf(""\t\t---------------\n"");
   printf(""\t\t| EBOOK READER |\n"");
   printf(""\t\t---------------\n"");
   printf(""\t     ____________________________\n"");
   printf(""\t    /                            \\\n"");
   printf(""\t   /                              \\\n"");
   printf(""\t  /                                \\\n"");
   printf(""\t /__________________________________\\\n"");
   printf(""\t|                                    |\n"");
   printf(""\t|           Ebook Reader            |\n"");
   printf(""\t|____________________________________|\n"");
   printf(""\t|                                    |\n"");
   printf(""\t|          1. Open an Ebook          |\n"");
   printf(""\t|          2. Close Ebook            |\n"");
   printf(""\t|          3. Bookmark Page          |\n"");
   printf(""\t|          4. View Bookmarks         |\n"");
   printf(""\t|          5. Exit                   | \n"");
   printf(""\t|____________________________________|\n"");
}

//Function that opens an Ebook and prints out its content
void openEbook(char book[]){
    FILE *ebook;
    char line[100];

    ebook = fopen(book, ""r"");
    
    if(ebook == NULL){
        printf(""\nERROR! Could not open file %s\n"", book);
        exit(1);
    }
    
    printf(""\nWelcome to %s\n"", book);
    printf(""------------------------\n"");
   
    while(fgets(line, sizeof(line), ebook)){
        printf(""%s"", line);
    }
    
    fclose(ebook);;
}

//Struct that stores the bookmark information
struct Bookmark{
    char book[100];
    int page;
};

//Function that bookmarks a specific page in a specific book
void bookmarkPage(struct Bookmark *b, char book[], int page){
    strcpy(b->book, book);
    b->page = page;
    printf(""\nBookmark added at page %d in %s\n"", b->page, b->book);
}

//Function that displays all the saved bookmarks
void viewBookmarks(struct Bookmark *b, int count){
    if(count == 0){
        printf(""\nNo bookmarks saved.\n"");
        return;
    }
    printf(""\nBOOKMARKS:\n"");
    printf(""-----------------------\n"");
    for(int i = 0; i < count; i++){
        printf(""Book: %s\tPage: %d\n"", b[i].book, b[i].page);
    }
    printf(""-----------------------\n"");
}

int main(){
    int choice, page, bookmarkCount = 0;
    char book[100];
    struct Bookmark bookmarks[10];

    //Main loop of the program
    do {
        printInterface();
        printf(""\nSelect an option: "");
        scanf(""%d"", &choice);

        switch(choice){
            case 1:
                printf(""\nEnter the name of the book: "");
                scanf(""%s"", book);
                openEbook(book);
                break;
            case 2:
                printf(""\nEbook closed.\n"");
                break;
            case 3:
                printf(""\nEnter the name of the book to bookmark: "");
                scanf(""%s"", book);
                printf(""Enter the page number to bookmark: "");
                scanf(""%d"", &page);
                bookmarkPage(&bookmarks[bookmarkCount++], book, page);
                break;
            case 4:
                viewBookmarks(bookmarks, bookmarkCount);
                break;
            case 5:
                printf(""\nThank you for using Ebook Reader.\n"");
                break;
            default:
                printf(""\nInvalid input. Please try again.\n"");
        }

    } while(choice != 5);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t bookmarkPage(int64_t a1, int64_t str2, int64_t a3);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
char * function_10d0(char * dest, char * src);
int32_t function_10e0(char * s);
int32_t function_10f0(struct _IO_FILE * stream);
void function_1100(void);
int32_t function_1110(char * format, ...);
char * function_1120(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_1130(char * filename, char * modes);
int32_t function_1140(char * format, ...);
void function_1150(int32_t status);
int64_t openEbook(int64_t a1);
int64_t printInterface(void);
int64_t register_tm_clones(void);
int64_t viewBookmarks(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xdce00000ca9; // 0x23ec
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
char * function_10d0(char * dest, char * src) {
    // 0x10d0
    return strcpy(dest, src);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * s) {
    // 0x10e0
    return puts(s);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(struct _IO_FILE * stream) {
    // 0x10f0
    return fclose(stream);
}

// Address range: 0x1100 - 0x110b
void function_1100(void) {
    // 0x1100
    __stack_chk_fail();
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return printf(format);
}

// Address range: 0x1120 - 0x112b
char * function_1120(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1120
    return fgets(s, n, stream);
}

// Address range: 0x1130 - 0x113b
struct _IO_FILE * function_1130(char * filename, char * modes) {
    // 0x1130
    return fopen(filename, modes);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return scanf(format);
}

// Address range: 0x1150 - 0x115b
void function_1150(int32_t status) {
    // 0x1150
    exit(status);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x1587, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g2;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g2 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x1362
int64_t printInterface(void) {
    // 0x1249
    puts(""\t\t---------------"");
    puts(""\t\t| EBOOK READER |"");
    puts(""\t\t---------------"");
    puts(""\t     ____________________________"");
    puts(""\t    /                            \\"");
    puts(""\t   /                              \\"");
    puts(""\t  /                                \\"");
    puts(""\t /__________________________________\\"");
    puts(""\t|                                    |"");
    puts(""\t|           Ebook Reader            |"");
    puts(""\t|____________________________________|"");
    puts(""\t|                                    |"");
    puts(""\t|          1. Open an Ebook          |"");
    puts(""\t|          2. Close Ebook            |"");
    puts(""\t|          3. Bookmark Page          |"");
    puts(""\t|          4. View Bookmarks         |"");
    puts(""\t|          5. Exit                   | "");
    return puts(""\t|____________________________________|"");
}

// Address range: 0x1362 - 0x145a
int64_t openEbook(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x1378
    char * file_path = (char *)a1; // 0x139b
    struct _IO_FILE * file = fopen(file_path, ""r""); // 0x139b
    if (file == NULL) {
        // 0x13ab
        printf(""\nERROR! Could not open file %s\n"", file_path);
        exit(1);
        // UNREACHABLE
    }
    // 0x13d3
    printf(""\nWelcome to %s\n"", file_path);
    puts(""------------------------"");
    int64_t str; // bp-120, 0x1362
    if (fgets((char *)&str, 100, file) != NULL) {
        printf(""%s"", &str);
        while (fgets((char *)&str, 100, file) != NULL) {
            // 0x1402
            printf(""%s"", &str);
        }
    }
    // 0x1437
    fclose(file);
    int64_t result = 0; // 0x1451
    if (v1 != __readfsqword(40)) {
        // 0x1453
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1458
    return result;
}

// Address range: 0x145a - 0x14b2
int64_t bookmarkPage(int64_t a1, int64_t str2, int64_t a3) {
    char * str = (char *)a1; // 0x147f
    strcpy(str, (char *)str2);
    *(int32_t *)(a1 + 100) = (int32_t)a3;
    return printf(""\nBookmark added at page %d in %s\n"", a3 & 0xffffffff, str);
}

// Address range: 0x14b2 - 0x1587
int64_t viewBookmarks(int64_t a1, int64_t a2) {
    uint32_t v1 = (int32_t)a2; // 0x14c2
    if (v1 == 0) {
        // 0x1585
        return puts(""\nNo bookmarks saved."");
    }
    // 0x14df
    puts(""\nBOOKMARKS:"");
    puts(""-----------------------"");
    if (v1 <= 0) {
        // 0x1585
        return puts(""-----------------------"");
    }
    int64_t v2 = 0;
    int64_t v3 = 104 * v2 + a1; // 0x1527
    printf(""Book: %s\tPage: %d\n"", (char *)v3, (int64_t)*(int32_t *)(v3 + 100));
    v2++;
    while (v2 != (a2 & 0xffffffff)) {
        // 0x1506
        v3 = 104 * v2 + a1;
        printf(""Book: %s\tPage: %d\n"", (char *)v3, (int64_t)*(int32_t *)(v3 + 100));
        v2++;
    }
    // 0x1585
    return puts(""-----------------------"");
}

// Address range: 0x1587 - 0x177c
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1596
    printInterface();
    printf(""\nSelect an option: "");
    int64_t v2; // bp-1172, 0x1587
    scanf(""%d"", &v2);
    while ((int32_t)v2 >= 6) {
        // 0x1743
        puts(""\nInvalid input. Please try again."");
        if ((int32_t)v2 == 5) {
            // 0x1761
            if (v1 == __readfsqword(40)) {
                // 0x177a
                return 0;
            }
            // 0x1775
            __stack_chk_fail();
            // 0x177a
            return &g3;
        }
        printInterface();
        printf(""\nSelect an option: "");
        scanf(""%d"", &v2);
    }
    int32_t v3 = *(int32_t *)((4 * v2 & 0x3fffffffc) + (int64_t)&g1); // 0x160b
    return (int64_t)v3 + (int64_t)&g1;
}

// Address range: 0x177c - 0x1789
int64_t _fini(void) {
    // 0x177c
    int64_t result; // 0x177c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 22

","nclude <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char ** argv) {
    int i = 0;
    char * str = (char *)malloc(100);
    char * str2 = (char *)malloc(100);
    char * str3 = (char *)malloc(100);
    char * str4 = (char *)malloc(100);
    char * str5 = (char *)malloc(100);
    char * str6 = (char *)malloc(100);
    char * str7 = (char *)malloc(100);
    char * str8 = (char *)malloc(100);
    char * str9 = (char *)malloc(100);
    char * str10 = (char *)malloc(100);
    char * str11 = (char *)malloc(100);
    char * str12 = (char *)malloc(100);
    char * str13 = (char *)malloc(100);
    char * str14 = (char *)malloc(100);
    char * str15 = (char *)malloc(100);
    char * str16 = (char *)malloc(100);
    char * str17 = (char *)malloc(100);
    char * str18 = (char *)malloc(100);
    char * str19 = (char *)malloc(100);
    char * str20 = (char *)malloc(100);
    char * str21 = (char *)malloc(100);
    char * str22 = (char *)malloc(100);
    char * str23 = (char *)malloc(100);
    char * str24 = (char *)malloc(100);
    char * str25 = (char *)malloc(100);
    char * str26 = (char *)malloc(100);
    char * str27 = (char *)malloc(100);
    char * str28 = (char *)malloc(100);
    char * str29 = (char *)malloc(100);
    char * str30 = (char *)malloc(100);
    char * str31 = (char *)malloc(100);
    char * str32 = (char *)malloc(100);
    char * str33 = (char *)malloc(100);
    char * str34 = (char *)malloc(100);
    char * str35 = (char *)malloc(100);
    char * str36 = (char *)malloc(100);
    char * str37 = (char *)malloc(100);
    char * str38 = (char *)malloc(100);
    char * str39 = (char *)malloc(100);
    char * str40 = (char *)malloc(100);
    char * str41 = (char *)malloc(100);
    char * str42 = (char *)malloc(100);
    char * str43 = (char *)malloc(100);
    char * str44 = (char *)malloc(100);
    char * str45 = (char *)malloc(100);
    char * str46 = (char *)malloc(100);
    char * str47 = (char *)malloc(100);
    char * str48 = (char *)malloc(100);
    char * str49 = (char *)malloc(100);
    char * str50 = (char *)malloc(100);
    char * str51 = (char *)malloc(100);
    char * str52 = (char *)malloc(100);
    char * str53 = (char *)malloc(100);
    char * str54 = (char *)malloc(100);
    char * str55 = (char *)malloc(100);
    char * str56 = (char *)malloc(100);
    char * str57 = (char *)malloc(100);
    char * str58 = (char *)malloc(100);
    char * str59 = (char *)malloc(100);
    char * str60 = (char *)malloc(100);
    char * str61 = (char *)malloc(100);
    char * str62 = (char *)malloc(100);
    char * str63 = (char *)malloc(100);
    char * str64 = (char *)malloc(100);
    char * str65 = (char *)malloc(100);
    char * str66 = (char *)malloc(100);
    char * str67 = (char *)malloc(100);
    char * str68 = (char *)malloc(100);
    char * str69 = (char *)malloc(100);
    char * str70 = (char *)malloc(100);
    char * str71 = (char *)malloc(100);
    char * str72 = (char *)malloc(100);
    char * str73 = (char *)malloc(100);
    char * str74 = (char *)malloc(100);
    char * str75 = (char *)malloc(100);
    char * str76 = (char *)malloc(100);
    char * str77 = (char *)malloc(100);
    char * str78 = (char *)malloc(100);
    char * str79 = (char *)malloc(100);
    char * str80 = (char *)malloc(100);
    char * str81 = (char *)malloc(100);
    char * str82 = (char *)malloc(100);
    char * str83 = (char *)malloc(100);
    char * str84 = (char *)malloc(100);
    char * str85 = (char *)malloc(100);
    char * str86 = (char *)malloc(100);
    char * str87 = (char *)malloc(100);
    char * str88 = (char *)malloc(100);
    char * str89 = (char *)malloc(100);
    char * str90 = (char *)malloc(100);
    char * str91 = (char *)malloc(100);
    char * str92 = (char *)malloc(100);
    char * str93 = (char *)malloc(100);
    char * str94 = (char *)malloc(100);
    char * str95 = (char *)malloc(100);
    char * str96 = (char *)malloc(100);
    char * str97 = (char *)malloc(100);
    char * str98 = (char *)malloc(100);
    char * str99 = (char *)malloc(100);
    char * str100 = (char *)malloc(100);
    char * str101 = (char *)malloc(100);
    char * str102 = (char *)malloc(100);
    char * str103 = (char *)malloc(100);
    char * str104 = (char *)malloc(100);
    char * str105 = (char *)malloc(100);
    char * str106 = (char *)malloc(100);
    char * str107 = (char *)malloc(100);
    char * str108 = (char *)malloc(100);
    char * str109 = (char *)malloc(100);
    char * str110 = (char *)malloc(100);
    char * str111 = (char *)malloc(100);
    char * str112 = (char *)malloc(100);
    char * str113 = (char *)malloc(100);
    char * str114 = (char *)malloc(100);
    char * str115",0
"//FormAI DATASET v1.0 Category: Memory Game ; Style: excited
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define ROWS 4
#define COLS 4

void displayBoard(char board[][COLS], int tries);
void populateBoard(char board[][COLS]);
void updateBoard(char board[][COLS], int row1, int col1, int row2, int col2);
int checkIfWon(char board[][COLS]);

int main()
{
    char board[ROWS][COLS];
    int tries = 0;
    int row1, col1, row2, col2;
    
    srand(time(NULL)); //set the random seed for generating random board
    
    populateBoard(board);
    
    do {
        displayBoard(board, tries);
        
        printf(""Enter the row and column number of first card: "");
        scanf(""%d %d"", &row1, &col1);
        
        printf(""Enter the row and column number of second card: "");
        scanf(""%d %d"", &row2, &col2);
        
        if(board[row1 - 1][col1 - 1] == board[row2 - 1][col2 - 1]){
            updateBoard(board, row1 - 1, col1 - 1, row2 - 1, col2 - 1);
        }
        else {
            system(""clear""); //clear the console before displaying the message
            printf(""\n\nOops! Cards do not match, Please try again! \n\n"");
            tries++;
        }
        
    } while(checkIfWon(board) != 1);
    
    displayBoard(board, tries);
    printf(""\n\nCongratulations! You have won!\n\n"");
    
    return 0;
}

void populateBoard(char board[][COLS])
{
    int count = 1;
    
    for(int i = 0; i < ROWS; i++){
        for(int j = 0; j < COLS; j++){
            if(count > 8){
                count = 1;
            }
            board[i][j] = count + '0'; //convert the integer to character
            count++;
        }
    }
    
    //shuffle the cards randomly
    for(int i = 0; i < ROWS; i++){
        for(int j = 0; j < COLS; j++){
            int randRow = rand() % ROWS;
            int randCol = rand() % COLS;
            char temp = board[i][j];
            board[i][j] = board[randRow][randCol];
            board[randRow][randCol] = temp;
        }
    }
}

void displayBoard(char board[][COLS], int tries)
{
    system(""clear""); //clear the console before displaying board
    
    printf(""\n***WELCOME TO MEMORY GAME***\n\n"");
    printf(""\nNumber of tries: %d\n\n"", tries);
    
    printf(""    "");
    for(int i = 1; i <= COLS; i++){
        printf(""%d   "", i);
    }
    
    printf(""\n"");
    
    for(int i = 0; i < ROWS; i++){
        printf("" %d  "", i + 1);
        for(int j = 0; j < COLS; j++){
            if(board[i][j] == 'X'){
                printf(""%c   "", board[i][j]);
            }
            else {
                printf(""*   "");
            }
        }
        printf(""\n"");
    }
    
    printf(""\n"");
}

void updateBoard(char board[][COLS], int row1, int col1, int row2, int col2)
{
    board[row1][col1] = 'X';
    board[row2][col2] = 'X';
}

int checkIfWon(char board[][COLS])
{
    for(int i = 0; i < ROWS; i++){
        for(int j = 0; j < COLS; j++){
            if(board[i][j] == '*'){
                return 0;
            }
        }
    }
    
    return 1;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t checkIfWon(int64_t * a1);
int64_t deregister_tm_clones(void);
int64_t displayBoard(int64_t * a1, int64_t a2);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
int32_t function_10d0(int32_t c);
int32_t function_10e0(char * s);
void function_10f0(void);
int32_t function_1100(char * command);
int32_t function_1110(char * format, ...);
void function_1120(int32_t seed);
int32_t function_1130(int32_t * timer);
int32_t function_1140(char * format, ...);
int32_t function_1150(void);
int64_t populateBoard(int64_t * a1);
int64_t register_tm_clones(void);
int64_t updateBoard(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(int32_t c) {
    // 0x10d0
    return putchar(c);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * s) {
    // 0x10e0
    return puts(s);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(void) {
    // 0x10f0
    __stack_chk_fail();
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * command) {
    // 0x1100
    return system(command);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return printf(format);
}

// Address range: 0x1120 - 0x112b
void function_1120(int32_t seed) {
    // 0x1120
    srand(seed);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(int32_t * timer) {
    // 0x1130
    return time(timer);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return scanf(format);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(void) {
    // 0x1150
    return rand();
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x1249, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g1;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g1 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x13e4
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1255
    srand(time(NULL));
    int64_t v2; // bp-40, 0x1249
    populateBoard(&v2);
    int64_t v3; // bp-8, 0x1249
    int64_t v4 = (int64_t)&v3 - 32;
    int32_t v5 = 0;
    displayBoard(&v2, (int64_t)v5);
    printf(""Enter the row and column number of first card: "");
    int64_t v6; // bp-56, 0x1249
    int64_t v7; // bp-60, 0x1249
    scanf(""%d %d"", &v7, &v6);
    printf(""Enter the row and column number of second card: "");
    int64_t v8; // bp-48, 0x1249
    int64_t v9; // bp-52, 0x1249
    scanf(""%d %d"", &v9, &v8);
    char v10 = *(char *)((0x100000000 * v7 - 0x100000000 >> 30) + v4 + (0x100000000 * v6 - 0x100000000 >> 32)); // 0x131f
    char v11 = *(char *)((0x100000000 * v9 - 0x100000000 >> 30) + v4 + (0x100000000 * v8 - 0x100000000 >> 32)); // 0x1342
    int32_t v12; // 0x1249
    if (v10 != v11) {
        // 0x1372
        system(""clear"");
        puts(""\n\nOops! Cards do not match, Please try again! \n"");
        v12 = v5 + 1;
    } else {
        // 0x1349
        updateBoard(&v2, v7 + 0xffffffff & 0xffffffff, v6 + 0xffffffff & 0xffffffff, v9 + 0xffffffff & 0xffffffff, v8 + 0xffffffff & 0xffffffff);
        v12 = v5;
    }
    int32_t v13 = v12;
    while ((int32_t)checkIfWon(&v2) != 1) {
        // 0x1288
        v5 = v13;
        displayBoard(&v2, (int64_t)v5);
        printf(""Enter the row and column number of first card: "");
        scanf(""%d %d"", &v7, &v6);
        printf(""Enter the row and column number of second card: "");
        scanf(""%d %d"", &v9, &v8);
        v10 = *(char *)((0x100000000 * v7 - 0x100000000 >> 30) + v4 + (0x100000000 * v6 - 0x100000000 >> 32));
        v11 = *(char *)((0x100000000 * v9 - 0x100000000 >> 30) + v4 + (0x100000000 * v8 - 0x100000000 >> 32));
        if (v10 != v11) {
            // 0x1372
            system(""clear"");
            puts(""\n\nOops! Cards do not match, Please try again! \n"");
            v12 = v5 + 1;
        } else {
            // 0x1349
            updateBoard(&v2, v7 + 0xffffffff & 0xffffffff, v6 + 0xffffffff & 0xffffffff, v9 + 0xffffffff & 0xffffffff, v8 + 0xffffffff & 0xffffffff);
            v12 = v5;
        }
        // 0x1394
        v13 = v12;
    }
    // 0x13a9
    displayBoard(&v2, (int64_t)v13);
    puts(""\n\nCongratulations! You have won!\n"");
    int64_t result = 0; // 0x13db
    if (v1 != __readfsqword(40)) {
        // 0x13dd
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13e2
    return result;
}

// Address range: 0x13e4 - 0x152c
int64_t populateBoard(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = 0;
    int32_t v3 = 1; // 0x143c
    int64_t v4 = 4 * v2 + v1; // 0x1431
    int32_t v5; // 0x13e4
    int32_t v6; // 0x13e4
    for (int64_t i = 0; i < 4; i++) {
        // 0x140d
        v6 = v3;
        v5 = v6 < 9 ? v6 : 1;
        *(char *)(v4 + i) = (char)v5 + 48;
        v3 = v5 + 1;
    }
    // 0x144a
    v2++;
    int64_t v7 = 0; // 0x1452
    while (v2 != 4) {
        // 0x1444
        v4 = 4 * v2 + v1;
        for (int64_t i = 0; i < 4; i++) {
            // 0x140d
            v6 = v3;
            v5 = v6 < 9 ? v6 : 1;
            *(char *)(v4 + i) = (char)v5 + 48;
            v3 = v5 + 1;
        }
        // 0x144a
        v2++;
        v7 = 0;
    }
    char * v8; // 0x14df
    int32_t v9; // 0x146c
    int32_t v10; // 0x147f
    char * v11; // 0x14ab
    int64_t result; // 0x14dd
    for (int64_t i = 0; i < 4; i++) {
        // 0x146c
        v9 = rand();
        v10 = rand();
        v11 = (char *)(4 * v7 + v1 + i);
        result = v10 % 4;
        v8 = (char *)(4 * (int64_t)(v9 % 4) + v1 + result);
        *v11 = *v8;
        *v8 = *v11;
    }
    int64_t v12 = v7 + 1;
    v7 = v12;
    while (v12 != 4) {
        for (int64_t i = 0; i < 4; i++) {
            // 0x146c
            v9 = rand();
            v10 = rand();
            v11 = (char *)(4 * v7 + v1 + i);
            result = v10 % 4;
            v8 = (char *)(4 * (int64_t)(v9 % 4) + v1 + result);
            *v11 = *v8;
            *v8 = *v11;
        }
        // 0x151a
        v12 = v7 + 1;
        v7 = v12;
    }
    // 0x1528
    return result;
}

// Address range: 0x152c - 0x168d
int64_t displayBoard(int64_t * a1, int64_t a2) {
    // 0x152c
    system(""clear"");
    puts(""\n***WELCOME TO MEMORY GAME***\n"");
    printf(""\nNumber of tries: %d\n\n"", a2 & 0xffffffff);
    printf(""    "");
    for (int64_t i = 1; i < 5; i++) {
        // 0x1593
        printf(""%d   "", i);
    }
    // 0x15b6
    putchar(10);
    int64_t v1 = 0;
    int64_t v2 = v1 + 1;
    printf("" %d  "", v2);
    char v3; // 0x160a
    for (int64_t i = 0; i < 4; i++) {
        // 0x15f1
        v3 = *(char *)(4 * v1 + (int64_t)a1 + i);
        if (v3 != 88) {
            // 0x164a
            printf(""*   "");
        } else {
            // 0x1612
            printf(""%c   "", v3);
        }
    }
    // 0x1668
    putchar(10);
    while (v2 != 4) {
        // 0x15cc
        v1 = v2;
        v2 = v1 + 1;
        printf("" %d  "", v2);
        for (int64_t i = 0; i < 4; i++) {
            // 0x15f1
            v3 = *(char *)(4 * v1 + (int64_t)a1 + i);
            if (v3 != 88) {
                // 0x164a
                printf(""*   "");
            } else {
                // 0x1612
                printf(""%c   "", v3);
            }
        }
        // 0x1668
        putchar(10);
    }
    // 0x1680
    return putchar(10);
}

// Address range: 0x168d - 0x16e3
int64_t updateBoard(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    int64_t v1 = (int64_t)a1;
    *(char *)((0x100000000 * a2 >> 30) + v1 + (0x100000000 * a3 >> 32)) = 88;
    int64_t result = 0x100000000 * a5 >> 32; // 0x16da
    *(char *)((0x100000000 * a4 >> 30) + v1 + result) = 88;
    return result;
}

// Address range: 0x16e3 - 0x1744
int64_t checkIfWon(int64_t * a1) {
    int32_t v1 = 0; // 0x1733
    int64_t v2 = 4 * (int64_t)v1 + (int64_t)a1; // 0x1712
    int64_t result; // 0x16e3
    for (int32_t i = 0; i < 4; i++) {
        // 0x1701
        result = 0;
        if (*(char *)(v2 + (int64_t)i) == 42) {
            return result;
        }
    }
    // 0x1733
    v1++;
    result = 1;
    while (v1 < 4) {
        // 0x172d
        v2 = 4 * (int64_t)v1 + (int64_t)a1;
        for (int32_t i = 0; i < 4; i++) {
            // 0x1701
            result = 0;
            if (*(char *)(v2 + (int64_t)i) == 42) {
                return result;
            }
        }
        // 0x1733
        v1++;
        result = 1;
    }
  lab_0x1742:
    // 0x1742
    return result;
}

// Address range: 0x1744 - 0x1751
int64_t _fini(void) {
    // 0x1744
    int64_t result; // 0x1744
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 22

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int board[4][4];
            int tries = 0;
            populateBoard(board);
            displayBoard(board, tries);
            printf(""Enter the row and column number of first card: "");
            int row1, col1;
            scanf(""%d %d"", &row1, &col1);
            printf(""Enter the row and column number of second card: "");
            int row2, col2;
            scanf(""%d %d"", &row2, &col2);
            char card1 = board[row1][col1];
            char card2 = board[row2][col2];
            if (card1 != card2) {
                system(""clear"");
                puts(""\n\nOops! Cards do not match, Please try again! \n"");
                tries++;
                displayBoard(board, tries);
            } else {
                updateBoard(board, row1, col1, row2, col2);
                tries++;
                displayBoard(board, tries);
            }
            while (checkIfWon(board) != 1) {
                tries++;
                displayBoard(board, tries);
                printf(""Enter the row and column number of first card: "");
                scanf(""%d %d"", &row1, &col1);
                printf(""Enter the row and column number of second card: "");
                scanf(""%d %d"", &row2, &col2);
                card1 = board[row1][col1];
                card2 = board[row2][col2];
                if (card1 != card2) {
                    system(""clear"");
                    puts(""\n\nOops! Cards do not match, Please try again! \n"");
                    tries++;
                    displayBoard(board, tries);
                } else {
                    updateBoard(board, row1, col1, row2, col2);
                    tries++;
                    displayBoard(board, tries);
                }
            }
            system(""clear"");
            puts(""\n\nCongratulations! You have won!\n"");
            return 0;
        }

        int populateBoard(int board[4][4]) {
            int i, j;
            int num = 1;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    board[i][j] = num;
                    num++;
                }
            }
            int randomRow, randomCol;
            char temp;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    randomRow = rand() % 4;
                    randomCol = rand() % 4;
                    temp = board[i][j];
                    board[i][j] = board[randomRow][randomCol];
                    board[randomRow][randomCol] = temp;
                }
            }
            return 0;
        }

        int displayBoard(int board[4][4], int tries) {
            system(""clear"");
            printf(""\n***WELCOME TO MEMORY GAME***\n"");
            printf(""\nNumber of tries: %d\n\n"", tries);
            printf(""    "");
            for (int i = 1; i < 5; i++) {
                printf(""%d   "", i);
            }
            putchar(10);
            int i;
            for (i = 0; i < 4; i++) {
                printf("" %d  "", i + 1);
                for (int j = 0; j < 4; j++) {
                    if (board[i][j] != 88) {
                        printf(""*   "");
                    } else {
                        printf(""%c   "", board[i][j]);
                    }
                }
                putchar(10);
            }
            return 0;
        }

        int updateBoard(int board[4][4], int row1, int col1, int row2, int col2) {
            board[row1][col1] = 88;
            board[row2][col2] = 88;
            return 0;
        }

        int checkIfWon(int board[4][4]) {
            int i, j;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    if (board[i][j] != 88) {
                        return 0;
                    }
                }
            }
            return 1;
        }


",2
"//FormAI DATASET v1.0 Category: Simple Web Server ; Style: scalable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

#define PORT 8080
#define MAX_REQUEST_SIZE 1024

void handle_request(int connfd);

int main(int argc, char const *argv[]) {
    int sockfd, connfd;
    struct sockaddr_in server_address, client_address;
    socklen_t client_address_len;

    // Create socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror(""socket"");
        exit(EXIT_FAILURE);
    }

    // Configure server address
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(PORT);

    // Bind socket to address and port
    if (bind(sockfd, (struct sockaddr *)&server_address, sizeof(server_address)) == -1) {
        perror(""bind"");
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(sockfd, 5) == -1) {
        perror(""listen"");
        exit(EXIT_FAILURE);
    }

    printf(""Server listening on port %d\n"", PORT);

    // Accept incoming connections and handle requests
    while (1) {
        client_address_len = sizeof(client_address);
        if ((connfd = accept(sockfd, (struct sockaddr *)&client_address, &client_address_len)) == -1) {
            perror(""accept"");
            exit(EXIT_FAILURE);
        }

        handle_request(connfd);

        close(connfd);
    }

    return 0;
}

void handle_request(int connfd) {
    char request[MAX_REQUEST_SIZE];
    ssize_t request_len;
    char response[] = ""HTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 12\n\nHello World!"";

    // Read request from client
    request_len = read(connfd, request, MAX_REQUEST_SIZE);
    if (request_len == -1) {
        perror(""read"");
        exit(EXIT_FAILURE);
    }

    // Print request to console
    printf(""%.*s\n"", (int)request_len, request);

    // Send response to client
    if (write(connfd, response, strlen(response)) == -1) {
        perror(""write"");
        exit(EXIT_FAILURE);
    }
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1100(int64_t * d);
int32_t function_1110(int32_t fd, int64_t * buf, int32_t n);
int32_t function_1120(char * s);
void function_1130(void);
int16_t function_1140(int16_t hostshort);
int32_t function_1150(char * format, ...);
int32_t function_1160(int32_t fd);
int32_t function_1170(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_1180(int32_t fd, int32_t n);
int32_t function_1190(int32_t fd, struct sockaddr * addr, int32_t len);
void function_11a0(char * s);
int32_t function_11b0(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
void function_11c0(int32_t status);
int32_t function_11d0(int32_t domain, int32_t type, int32_t protocol);
int64_t handle_request(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1100 - 0x110b
void function_1100(int64_t * d) {
    // 0x1100
    __cxa_finalize(d);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int32_t fd, int64_t * buf, int32_t n) {
    // 0x1110
    return write(fd, buf, n);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * s) {
    // 0x1120
    return strlen(s);
}

// Address range: 0x1130 - 0x113b
void function_1130(void) {
    // 0x1130
    __stack_chk_fail();
}

// Address range: 0x1140 - 0x114b
int16_t function_1140(int16_t hostshort) {
    // 0x1140
    return htons(hostshort);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * format, ...) {
    // 0x1150
    return printf(format);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(int32_t fd) {
    // 0x1160
    return close(fd);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x1170
    return read(fd, buf, nbytes);
}

// Address range: 0x1180 - 0x118b
int32_t function_1180(int32_t fd, int32_t n) {
    // 0x1180
    return listen(fd, n);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1190
    return bind(fd, addr, len);
}

// Address range: 0x11a0 - 0x11ab
void function_11a0(char * s) {
    // 0x11a0
    perror(s);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x11b0
    return accept(fd, addr, addr_len);
}

// Address range: 0x11c0 - 0x11cb
void function_11c0(int32_t status) {
    // 0x11c0
    exit(status);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x11d0
    return socket(domain, type, protocol);
}

// Address range: 0x11e0 - 0x1206
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x11e0
    int64_t v1; // 0x11e0
    __libc_start_main(0x12c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1210 - 0x1239
int64_t deregister_tm_clones(void) {
    // 0x1210
    return &g2;
}

// Address range: 0x1240 - 0x1279
int64_t register_tm_clones(void) {
    // 0x1240
    return 0;
}

// Address range: 0x1280 - 0x12b9
int64_t __do_global_dtors_aux(void) {
    // 0x1280
    if (*(char *)&g2 != 0) {
        // 0x12b8
        int64_t result; // 0x1280
        return result;
    }
    // 0x128d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x129b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x12a7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x12c0 - 0x12c9
int64_t frame_dummy(void) {
    // 0x12c0
    return register_tm_clones();
}

// Address range: 0x12c9 - 0x140a
int main(int argc, char ** argv) {
    // 0x12c9
    __readfsqword(40);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x12fa
    if (sock_fd == -1) {
        // 0x1308
        perror(""socket"");
        exit(1);
        // UNREACHABLE
    }
    int16_t addr = 2; // bp-56, 0x1321
    htons(0x1f90);
    if (bind(sock_fd, (struct sockaddr *)&addr, 16) == -1) {
        // 0x1357
        perror(""bind"");
        exit(1);
        // UNREACHABLE
    }
    // 0x1370
    if (listen(sock_fd, 5) == -1) {
        // 0x1384
        perror(""listen"");
        exit(1);
        // UNREACHABLE
    }
    // 0x139d
    printf(""Server listening on port %d\n"", 0x1f90);
    int32_t addr_len = 16; // bp-68, 0x13b6
    int64_t addr2; // bp-40, 0x12c9
    int32_t accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x13cd
    if (accepted_sock_fd == -1) {
        // 0x13db
        perror(""accept"");
        exit(1);
        // UNREACHABLE
    }
    handle_request((int64_t)accepted_sock_fd);
    close(accepted_sock_fd);
    addr_len = 16;
    int32_t accepted_sock_fd2 = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x13cd
    while (accepted_sock_fd2 != -1) {
        // 0x13f4
        handle_request((int64_t)accepted_sock_fd2);
        close(accepted_sock_fd2);
        addr_len = 16;
        accepted_sock_fd2 = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len);
    }
    // 0x13db
    perror(""accept"");
    exit(1);
    // UNREACHABLE
}

// Address range: 0x140a - 0x159e
int64_t handle_request(int64_t a1) {
    int32_t fd = a1; // 0x1419
    int64_t v1 = __readfsqword(40); // 0x141f
    int64_t str = 0x312e312f50545448; // bp-1128, 0x1442
    int64_t buf; // bp-1048, 0x140a
    uint32_t v2 = read(fd, &buf, (int32_t)&g1); // 0x14e7
    if (v2 == -1) {
        // 0x14fd
        perror(""read"");
        exit(1);
        // UNREACHABLE
    }
    // 0x1516
    printf(""%.*s\n"", (int64_t)v2, &buf);
    if (write(fd, &str, strlen((char *)&str)) == -1) {
        // 0x156e
        perror(""write"");
        exit(1);
        // UNREACHABLE
    }
    int64_t result = 0; // 0x1595
    if (v1 != __readfsqword(40)) {
        // 0x1597
        __stack_chk_fail();
        result = &g3;
    }
    // 0x159c
    return result;
}

// Address range: 0x15a0 - 0x15ad
int64_t _fini(void) {
    // 0x15a0
    int64_t result; // 0x15a0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 23

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        int main(int argc, char ** argv) {
            int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            if (sock_fd == -1) {
                perror(""socket"");
                exit(1);
            }
            int addr = 2;
            htons(0x1f90);
            if (bind(sock_fd, (struct sockaddr *)&addr, 16) == -1) {
                perror(""bind"");
                exit(1);
            }
            if (listen(sock_fd, 5) == -1) {
                perror(""listen"");
                exit(1);
            }
            printf(""Server listening on port %d\n"", 0x1f90);
            int addr_len = 16;
            int accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr, &addr_len);
            if (accepted_sock_fd == -1) {
                perror(""accept"");
                exit(1);
            }
            handle_request((int64_t)accepted_sock_fd);
            close(accepted_sock_fd);
            addr_len = 16;
            int accepted_sock_fd2 = accept(sock_fd, (struct sockaddr *)&addr, &addr_len);
            while (accepted_sock_fd2 != -1) {
                handle_request((int64_t)accepted_sock_fd2);
                close(accepted_sock_fd2);
                addr_len = 16;
                accepted_sock_fd2 = accept(sock_fd, (struct sockaddr *)&addr, &addr_len);
            }
            perror(""accept"");
            exit(1);
        }

        int handle_request(int64_t a1) {
            int fd = a1;
            int64_t str = 0x312e312f50545448;
            int64_t buf;
            int v2 = read(fd, &buf, (int32_t)&g1);
            if (v2 == -1) {
                perror(""read"");
                exit(1);
            }
            printf(""%.*s\n"", (int64_t)v2, &buf);
            if (write(fd, &str, strlen((char *)&str)) == -1) {
                perror(""write"");
                exit(1);
            }
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Ebook reader ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// define a structure to represent a book
typedef struct {
    char title[50];
    char author[50];
    char publisher[50];
    int year;
    double price;
    char isbn[20];
    char format[10];
    int pages;
    char language[20];
} Book;

// function to display the details of a book
void display_book(Book b) {
    printf(""\nTitle: %s\n"", b.title);
    printf(""Author: %s\n"", b.author);
    printf(""Publisher: %s\n"", b.publisher);
    printf(""Year: %d\n"", b.year);
    printf(""Price: $%.2f\n"", b.price);
    printf(""ISBN: %s\n"", b.isbn);
    printf(""Format: %s\n"", b.format);
    printf(""Pages: %d\n"", b.pages);
    printf(""Language: %s\n"", b.language);
}

// function to read the details of a book from file
Book read_book_from_file(FILE* fp) {
    Book b;
    fscanf(fp, ""%s %s %s %d %lf %s %s %d %s"", b.title, b.author, b.publisher, &b.year, &b.price, b.isbn, b.format, &b.pages, b.language);
    return b;
}

int main() {
    char filename[50];
    printf(""Enter the name of the E-book file: "");
    scanf(""%s"", filename);

    // open the file for reading
    FILE* fp = fopen(filename, ""r"");
    if(fp == NULL) {
        printf(""Error opening file %s\n"", filename);
        exit(1);
    }

    // read the number of books in the file
    int num_books;
    fscanf(fp, ""%d"", &num_books);

    // allocate memory for the array of books
    Book* books = (Book*) malloc(num_books * sizeof(Book));

    // read each book from the file
    for(int i = 0; i < num_books; i++) {
        books[i] = read_book_from_file(fp);
    }

    // close the file
    fclose(fp);

    // display the details of each book
    for(int i = 0; i < num_books; i++) {
        display_book(books[i]);
    }

    // free the memory allocated for the array of books
    free(books);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t display_book(uint32_t a1, int64_t a2);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
void function_10d0(int64_t * ptr);
int32_t function_10e0(struct _IO_FILE * stream, char * format, ...);
int32_t function_10f0(struct _IO_FILE * stream);
void function_1100(void);
int32_t function_1110(char * format, ...);
int64_t * function_1120(int32_t size);
struct _IO_FILE * function_1130(char * filename, char * modes);
int32_t function_1140(char * format, ...);
void function_1150(int32_t status);
int64_t read_book_from_file(int64_t * a1, int64_t stream);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int64_t * ptr) {
    // 0x10d0
    free(ptr);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(struct _IO_FILE * stream, char * format, ...) {
    // 0x10e0
    return fscanf(stream, format);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(struct _IO_FILE * stream) {
    // 0x10f0
    return fclose(stream);
}

// Address range: 0x1100 - 0x110b
void function_1100(void) {
    // 0x1100
    __stack_chk_fail();
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return printf(format);
}

// Address range: 0x1120 - 0x112b
int64_t * function_1120(int32_t size) {
    // 0x1120
    return malloc(size);
}

// Address range: 0x1130 - 0x113b
struct _IO_FILE * function_1130(char * filename, char * modes) {
    // 0x1130
    return fopen(filename, modes);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return scanf(format);
}

// Address range: 0x1150 - 0x115b
void function_1150(int32_t status) {
    // 0x1150
    exit(status);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x157b, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g1;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g1 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x1354
int64_t display_book(uint32_t a1, int64_t a2) {
    // 0x1249
    int64_t v1; // 0x1249
    printf(""\nTitle: %s\n"", &v1);
    int64_t v2; // bp+58, 0x1249
    printf(""Author: %s\n"", &v2);
    int64_t v3; // bp+108, 0x1249
    printf(""Publisher: %s\n"", &v3);
    printf(""Year: %d\n"", (int64_t)a1);
    printf(""Price: $%.2f\n"", (float64_t)(int64_t)__asm_movq(a2));
    int64_t v4; // bp+176, 0x1249
    printf(""ISBN: %s\n"", &v4);
    int64_t v5; // bp+196, 0x1249
    printf(""Format: %s\n"", &v5);
    int32_t v6; // 0x1249
    printf(""Pages: %d\n"", (int64_t)(uint32_t)v6);
    int64_t v7; // bp+212, 0x1249
    return printf(""Language: %s\n"", &v7);
}

// Address range: 0x1354 - 0x157b
int64_t read_book_from_file(int64_t * a1, int64_t stream) {
    int64_t result = (int64_t)a1;
    int64_t v1 = __readfsqword(40); // 0x1372
    int64_t v2; // bp-104, 0x1354
    int64_t v3; // bp-112, 0x1354
    int64_t v4; // bp-164, 0x1354
    int64_t v5; // bp-214, 0x1354
    int64_t v6; // bp-264, 0x1354
    int64_t v7; // bp-60, 0x1354
    int64_t v8; // bp-64, 0x1354
    int64_t v9; // bp-76, 0x1354
    int64_t v10; // bp-96, 0x1354
    fscanf((struct _IO_FILE *)stream, ""%s %s %s %d %lf %s %s %d %s"", &v6, &v5, &v4, &v3, &v2, &v10, &v9, &v8, &v7);
    *a1 = v6;
    *(int64_t *)(result + 152) = v3;
    *(int64_t *)(result + 160) = v2;
    *(int64_t *)(result + 168) = v10;
    *(int64_t *)(result + 200) = v8;
    if (v1 != __readfsqword(40)) {
        // 0x1569
        __stack_chk_fail();
    }
    // 0x156e
    return result;
}

// Address range: 0x157b - 0x18e4
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x158b
    printf(""Enter the name of the E-book file: "");
    int64_t file_path; // bp-88, 0x157b
    scanf(""%s"", &file_path);
    struct _IO_FILE * file = fopen((char *)&file_path, ""r""); // 0x15da
    if (file == NULL) {
        // 0x15ea
        printf(""Error opening file %s\n"", &file_path);
        exit(1);
        // UNREACHABLE
    }
    // 0x160f
    int64_t v2; // bp-116, 0x157b
    fscanf(file, ""%d"", &v2);
    int64_t * mem = malloc(224 * (int32_t)v2); // 0x1645
    int64_t v3 = (int64_t)mem; // 0x1645
    int64_t v4; // bp-344, 0x157b
    if ((v2 & 0xffffffff) != 0) {
        int32_t v5 = 0; // 0x17e0
        read_book_from_file(&v4, (int64_t)file);
        *(int64_t *)v3 = v4;
        v5++;
        int64_t v6 = v5; // 0x17ea
        while ((v2 & 0xffffffff) > v6) {
            // 0x165a
            read_book_from_file(&v4, (int64_t)file);
            *(int64_t *)(224 * v6 + v3) = v4;
            v5++;
            v6 = v5;
        }
    }
    // 0x17f0
    fclose(file);
    if ((v2 & 0xffffffff) != 0) {
        int64_t v7 = &v4; // 0x1584
        int32_t v8 = 0; // 0x18a9
        int64_t v9 = v3; // 0x1823
        *(int64_t *)(v7 - 8) = *(int64_t *)(v9 + 216);
        *(int64_t *)(v7 - 16) = *(int64_t *)(v9 + 208);
        *(int64_t *)(v7 - 24) = *(int64_t *)(v9 + 200);
        *(int64_t *)(v7 - 32) = *(int64_t *)(v9 + 192);
        *(int64_t *)(v7 - 40) = *(int64_t *)(v9 + 184);
        *(int64_t *)(v7 - 48) = *(int64_t *)(v9 + 176);
        *(int64_t *)(v7 - 56) = *(int64_t *)(v9 + 168);
        *(int64_t *)(v7 - 64) = *(int64_t *)(v9 + 160);
        *(int64_t *)(v7 - 72) = *(int64_t *)(v9 + 152);
        *(int64_t *)(v7 - 80) = *(int64_t *)(v9 + 144);
        *(int64_t *)(v7 - 88) = *(int64_t *)(v9 + 136);
        *(int64_t *)(v7 - 96) = *(int64_t *)(v9 + 128);
        *(int64_t *)(v7 - 104) = *(int64_t *)(v9 + 120);
        *(int64_t *)(v7 - 112) = *(int64_t *)(v9 + 112);
        *(int64_t *)(v7 - 120) = *(int64_t *)(v9 + 104);
        *(int64_t *)(v7 - 128) = *(int64_t *)(v9 + 96);
        *(int64_t *)(v7 - 136) = *(int64_t *)(v9 + 88);
        *(int64_t *)(v7 - 144) = *(int64_t *)(v9 + 80);
        *(int64_t *)(v7 - 152) = *(int64_t *)(v9 + 72);
        *(int64_t *)(v7 - 160) = *(int64_t *)(v9 + 64);
        *(int64_t *)(v7 - 168) = *(int64_t *)(v9 + 56);
        *(int64_t *)(v7 - 176) = *(int64_t *)(v9 + 48);
        *(int64_t *)(v7 - 184) = *(int64_t *)(v9 + 40);
        *(int64_t *)(v7 - 192) = *(int64_t *)(v9 + 32);
        *(int64_t *)(v7 - 200) = *(int64_t *)(v9 + 24);
        *(int64_t *)(v7 - 208) = *(int64_t *)(v9 + 16);
        *(int64_t *)(v7 - 216) = *(int64_t *)(v9 + 8);
        *(int64_t *)(v7 - 224) = *(int64_t *)v9;
        display_book(v8, (int64_t)&g2);
        v8++;
        int64_t v10 = v8; // 0x18b3
        while ((v2 & 0xffffffff) > v10) {
            // 0x1808
            v9 = 224 * v10 + v3;
            *(int64_t *)(v7 - 8) = *(int64_t *)(v9 + 216);
            *(int64_t *)(v7 - 16) = *(int64_t *)(v9 + 208);
            *(int64_t *)(v7 - 24) = *(int64_t *)(v9 + 200);
            *(int64_t *)(v7 - 32) = *(int64_t *)(v9 + 192);
            *(int64_t *)(v7 - 40) = *(int64_t *)(v9 + 184);
            *(int64_t *)(v7 - 48) = *(int64_t *)(v9 + 176);
            *(int64_t *)(v7 - 56) = *(int64_t *)(v9 + 168);
            *(int64_t *)(v7 - 64) = *(int64_t *)(v9 + 160);
            *(int64_t *)(v7 - 72) = *(int64_t *)(v9 + 152);
            *(int64_t *)(v7 - 80) = *(int64_t *)(v9 + 144);
            *(int64_t *)(v7 - 88) = *(int64_t *)(v9 + 136);
            *(int64_t *)(v7 - 96) = *(int64_t *)(v9 + 128);
            *(int64_t *)(v7 - 104) = *(int64_t *)(v9 + 120);
            *(int64_t *)(v7 - 112) = *(int64_t *)(v9 + 112);
            *(int64_t *)(v7 - 120) = *(int64_t *)(v9 + 104);
            *(int64_t *)(v7 - 128) = *(int64_t *)(v9 + 96);
            *(int64_t *)(v7 - 136) = *(int64_t *)(v9 + 88);
            *(int64_t *)(v7 - 144) = *(int64_t *)(v9 + 80);
            *(int64_t *)(v7 - 152) = *(int64_t *)(v9 + 72);
            *(int64_t *)(v7 - 160) = *(int64_t *)(v9 + 64);
            *(int64_t *)(v7 - 168) = *(int64_t *)(v9 + 56);
            *(int64_t *)(v7 - 176) = *(int64_t *)(v9 + 48);
            *(int64_t *)(v7 - 184) = *(int64_t *)(v9 + 40);
            *(int64_t *)(v7 - 192) = *(int64_t *)(v9 + 32);
            *(int64_t *)(v7 - 200) = *(int64_t *)(v9 + 24);
            *(int64_t *)(v7 - 208) = *(int64_t *)(v9 + 16);
            *(int64_t *)(v7 - 216) = *(int64_t *)(v9 + 8);
            *(int64_t *)(v7 - 224) = *(int64_t *)v9;
            display_book(v8, (int64_t)&g2);
            v8++;
            v10 = v8;
        }
    }
    // 0x18b9
    free(mem);
    int64_t result = 0; // 0x18d7
    if (v1 != __readfsqword(40)) {
        // 0x18d9
        __stack_chk_fail();
        result = &g2;
    }
    // 0x18de
    return result;
}

// Address range: 0x18e4 - 0x18f1
int64_t _fini(void) {
    // 0x18e4
    int64_t result; // 0x18e4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","nclude <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t display_book(uint32_t a1, int64_t a2);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
void function_10d0(int64_t * ptr);
int32_t function_10e0(struct _IO_FILE * stream, char * format, ...);
int32_t function_10f0(struct _IO_FILE * stream);
void function_1100(void);
int32_t function_1110(char * format, ...);
int64_t * function_1120(int32_t size);
struct _IO_FILE * function_1130(char * filename, char * modes);
int32_t function_1140(char * format, ...);
void function_1150(int32_t status);
int64_t read_book_from_file(int64_t * a1, int64_t stream);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int64_t * ptr) {
    // 0x10d0
    free(ptr);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(struct _IO_FILE * stream, char * format, ...) {
    // 0x10e0
    return fscanf(stream, format);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(struct _IO_FILE * stream) {
    // 0x10f0
    return fclose(stream);
}

// Address range: 0x1100 - 0x110b
void function_1100(void) {
    // 0x1100
    __stack_chk_fail();
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return printf(format);
}

// Address range: 0x1120 - 0x112b
int64_t * function_1120(int32_t size) {
    // 0x1120
    return malloc(size);
}

// Address range: 0x1130 - 0x113b
struct _IO_FILE * function_1130(char * filename, char * modes) {
    // 0x1130
    return fopen(filename, modes);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return scanf(format);
}

// Address range: 0x1150 - 0x115b
void function_1150(int32_t status) {
    // 0x1150
    exit(status);
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x157b, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g1;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g1 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x1354
int64_t display_book(uint32_t a1, int64_t",0
"//FormAI DATASET v1.0 Category: Tower of Hanoi Problem ; Style: scientific
#include <stdio.h>
#include <stdlib.h>

/*
This program solves the Tower of Hanoi problem for any number of disks and any number of towers.
The problem involves moving a stack of n disks of different sizes from the first tower to the last tower, using a middle tower as an intermediary.
The solution uses recursion to solve the problem, moving smaller stacks of disks one at a time until the entire stack has been moved to the last tower.
*/

void towerOfHanoi(int n, int source, int middle[], int destination) {
    if (n == 0) {
        return;
    }

    // Move smaller stack of n-1 disks from source to middle tower
    towerOfHanoi(n-1, source, destination, middle);

    // Move the largest disk from the source tower to destination tower
    printf(""Move disk %d from Tower %d to Tower %d\n"", n, source, destination);

    // Move smaller stack of n-1 disks from the middle tower to destination tower
    towerOfHanoi(n-1, middle, source, destination);
}

int main() {
    int numDisks, numTowers;
    printf(""Enter the number of disks: "");
    scanf(""%d"", &numDisks);

    printf(""Enter the number of towers: "");
    scanf(""%d"", &numTowers);

    if (numDisks <= 0 || numTowers <= 2) {
        printf(""Invalid input!\n"");
        return 1;
    }

    int *middleTowers = malloc(sizeof(int) * (numTowers - 2));

    printf(""Tower of Hanoi solution for %d disks and %d towers:\n"", numDisks, numTowers);
    towerOfHanoi(numDisks, 1, middleTowers, numTowers);

    free(middleTowers);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
void function_10a0(int64_t * ptr);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
int64_t * function_10e0(int32_t size);
int32_t function_10f0(char * format, ...);
int64_t register_tm_clones(void);
int64_t towerOfHanoi(int64_t a1, int64_t a2, int64_t a3, int64_t a4);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * ptr) {
    // 0x10a0
    free(ptr);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
int64_t * function_10e0(int32_t size) {
    // 0x10e0
    return malloc(size);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return scanf(format);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x1268, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g1;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g1 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x1268
int64_t towerOfHanoi(int64_t a1, int64_t a2, int64_t a3, int64_t a4) {
    int64_t result; // 0x11e9
    if ((int32_t)a1 != 0) {
        int64_t v1 = 0x100000000 * a1 >> 32; // 0x11f5
        int64_t v2 = 0x100000000 * a4 >> 32; // 0x11ff
        int64_t v3 = a2 & 0xffffffff;
        int64_t v4 = a3 & 0xffffffff; // 0x120c
        int64_t v5 = v1 + 0xffffffff & 0xffffffff; // 0x1219
        towerOfHanoi(v5, v3, v2, v4);
        int64_t v6 = v2 & 0xffffffff; // 0x1226
        printf(""Move disk %d from Tower %d to Tower %d\n"", v1 & 0xffffffff, v3, v6);
        result = towerOfHanoi(v5, v4, 0x100000000 * a2 >> 32, v6);
    }
    // 0x1266
    return result;
}

// Address range: 0x1268 - 0x1377
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1274
    printf(""Enter the number of disks: "");
    int64_t v2; // bp-32, 0x1268
    scanf(""%d"", &v2);
    printf(""Enter the number of towers: "");
    int64_t v3; // bp-28, 0x1268
    scanf(""%d"", &v3);
    int64_t v4; // 0x1268
    if ((int32_t)v2 < 1) {
        // 0x12f0
        puts(""Invalid input!"");
        v4 = 1;
        goto lab_0x1361;
    } else {
        // 0x12e8
        if ((int32_t)v3 > 2) {
            int64_t * mem = malloc((int32_t)((0x100000000 * v3 + 0x3ffffffe00000000) / 0x40000000)); // 0x1315
            printf(""Tower of Hanoi solution for %d disks and %d towers:\n"", v2 & 0xffffffff, v3 & 0xffffffff);
            towerOfHanoi(v2 & 0xffffffff, 1, (int64_t)mem, v3 & 0xffffffff);
            free(mem);
            v4 = 0;
            goto lab_0x1361;
        } else {
            // 0x12f0
            puts(""Invalid input!"");
            v4 = 1;
            goto lab_0x1361;
        }
    }
  lab_0x1361:;
    int64_t result = v4; // 0x136e
    if (v1 != __readfsqword(40)) {
        // 0x1370
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1375
    return result;
}

// Address range: 0x1378 - 0x1385
int64_t _fini(void) {
    // 0x1378
    int64_t result; // 0x1378
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int n;
            int i;
            int * p;

            printf(""Enter the number of disks: "");
            scanf(""%d"", &n);
            printf(""Enter the number of towers: "");
            scanf(""%d"", &i);

            if (n < 1) {
                puts(""Invalid input!"");
                return 1;
            }

            if (i > 2) {
                p = malloc((0x100000000 * i + 0x3ffffffe00000000) / 0x40000000);
                printf(""Tower of Hanoi solution for %d disks and %d towers:\n"", n, i);
                towerOfHanoi(n, 1, (int)p, i);
                free(p);
            } else {
                puts(""Invalid input!"");
                return 1;
            }

            return 0;
        }

        void towerOfHanoi(int n, int from, int to, int via) {
            if (n == 1) {
                printf(""Move disk %d from Tower %d to Tower %d\n"", from, to, via);
                return;
            }
            towerOfHanoi(n - 1, from, via, to);
            printf(""Move disk %d from Tower %d to Tower %d\n"", from, to, via);
            towerOfHanoi(n - 1, via, to, from);
        }


",2
"//FormAI DATASET v1.0 Category: Automated Fortune Teller ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    // Set up the random number generator
    srand(time(NULL));
    
    // Define the fortune options
    char* fortunes[] = {
        ""You will find love in unexpected places."",
        ""Good fortune will come your way."",
        ""You will be paid handsomely for your hard work."",
        ""A new opportunity will present itself."",
        ""Your dreams will become a reality."",
        ""Someone important will enter your life."",
        ""You will go on an amazing adventure."",
        ""Your creative talents will be recognized."",
        ""Happiness is just around the corner."",
        ""Your hard work will pay off in the near future."",
        ""Your health will improve."",
        ""You will meet someone special soon."",
        ""A long lost friend will reappear."",
        ""Your financial situation will improve."",
        ""You will receive a surprise gift."",
        ""Inner peace is on its way to you."",
        ""Your luck is about to change.""
    };
    
    // Get the user's name and ask if they want a fortune told
    char name[100];
    printf(""Hello! What is your name?\n"");
    fgets(name, 100, stdin);
    printf(""Hello, %s! Would you like me to tell your fortune? (y/n)\n"", name);
    
    char fortuneAnswer[2];
    fgets(fortuneAnswer, 2, stdin);
    
    if (fortuneAnswer[0] == 'y') {
        // Choose a random fortune to display
        int randomFortuneIndex = rand() % 17;
        printf(""Your fortune is: %s\n"", fortunes[randomFortuneIndex]);
    } else {
        printf(""Okay, maybe next time!\n"");
    }
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
void function_10e0(int32_t seed);
char * function_10f0(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1100(int32_t * timer);
int32_t function_1110(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

struct _IO_FILE * g1 = NULL; // 0x4010
char g2 = 0; // 0x4018
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int32_t seed) {
    // 0x10e0
    srand(seed);
}

// Address range: 0x10f0 - 0x10fb
char * function_10f0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x10f0
    return fgets(s, n, stream);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(int32_t * timer) {
    // 0x1100
    return time(timer);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(void) {
    // 0x1110
    return rand();
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return (int64_t)&g1;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (g2 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    g2 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x1410
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1218
    srand(time(NULL));
    puts(""Hello! What is your name?"");
    int64_t str; // bp-120, 0x1209
    fgets((char *)&str, 100, g1);
    printf(""Hello, %s! Would you like me to tell your fortune? (y/n)\n"", &str);
    char str2; // bp-122, 0x1209
    fgets(&str2, 2, g1);
    if (str2 != 121) {
        // 0x13e6
        puts(""Okay, maybe next time!"");
    } else {
        int32_t v2 = rand(); // 0x1385
        int64_t v3; // bp-8, 0x1209
        int64_t v4 = *(int64_t *)((int64_t)&v3 - 256 + 8 * (int64_t)(v2 % 17)); // 0x13c5
        printf(""Your fortune is: %s\n"", (char *)v4);
    }
    int64_t result = 0; // 0x1407
    if (v1 != __readfsqword(40)) {
        // 0x1409
        __stack_chk_fail();
        result = &g3;
    }
    // 0x140e
    return result;
}

// Address range: 0x1410 - 0x141d
int64_t _fini(void) {
    // 0x1410
    int64_t result; // 0x1410
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            puts(""Hello! What is your name?"");
            char str[100];
            fgets(str, 100, stdin);
            printf(""Hello, %s! Would you like me to tell your fortune? (y/n)\n"", str);
            char str2;
            fgets(&str2, 2, stdin);
            if (str2 != 'y') {
                puts(""Okay, maybe next time!"");
            } else {
                int v = rand();
                char * fortune = ""You will have a great day!"";
                printf(""Your fortune is: %s\n"", fortune);
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Maze Route Finder ; Style: thoughtful
#include <stdio.h>
#define ROWS 10
#define COLS 10

char maze[ROWS][COLS] =
{{'#','#','#','#','#','#','#','#','#','#'},
{'#',' ',' ','#',' ','#',' ',' ',' ','#'},
{'#',' ',' ','#',' ','#','#','#',' ','#'},
{'#',' ',' ',' ',' ',' ',' ',' ',' ','#'},
{'#',' ','#','#',' ','#','#','#',' ','#'},
{'#',' ',' ',' ',' ',' ',' ',' ',' ','#'},
{'#','#','#','#','#','#',' ','#',' ','#'},
{'#',' ',' ',' ',' ',' ',' ','#',' ','#'},
{'#',' ','#','#',' ','#','#','#',' ','#'},
{'#',' ',' ',' ',' ',' ',' ','#',' ','#'}};

int sr, sc, er, ec;

void printMaze() {
    for (int i = 0; i < ROWS; ++i) {
        for (int j = 0; j < COLS; ++j) {
            printf(""%c"", maze[i][j]);
        }
        printf(""\n"");
    }
}

int findPath(int r, int c) {
    if (r == er && c == ec) {
        return 1;
    }
    if (maze[r][c] != ' ') {
        return 0;
    }
    maze[r][c] = '.';
    if (findPath(r-1, c) || findPath(r, c+1)
        || findPath(r+1, c) || findPath(r, c-1)) {
        return 1;
    }
    maze[r][c] = ' ';
    return 0;
}

int main() {
    printf(""MAZE ROUTE FINDER\n"");
    printf(""-----------------\n"");
    printf(""Enter starting row: "");
    scanf(""%d"", &sr);
    printf(""Enter starting col: "");
    scanf(""%d"", &sc);
    printf(""Enter ending row: "");
    scanf(""%d"", &er);
    printf(""Enter ending col: "");
    scanf(""%d"", &ec);
    if (findPath(sr, sc)) {
        maze[sr][sc] = 'S';
        maze[er][ec] = 'E';
        printf(""The path to the end is:\n"");
        printMaze();
    } else {
        printf(""No path to the end could be found.\n"");
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t findPath(int64_t a1, int64_t a2);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
int32_t function_1090(char * s);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t printMaze(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char g1 = 0; // 0x4084
int64_t g2 = 0; // 0x4088
int64_t g3 = 0; // 0x408c
int64_t g4 = 0; // 0x4090
int64_t g5; // 0x4094
int32_t g6;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g6;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x1341, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g2;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x121d
int64_t printMaze(void) {
    int32_t putchar_rc; // 0x120a
    for (int64_t i = 0; i < 10; i++) {
        int64_t v1 = 10 * i + (int64_t)""###########  # #   ##  # ### ##        ## ## ### ##        ####### # ##      # ## ## ### ##      # #""; // 0x11e0
        for (int64_t j = 0; j < 10; j++) {
            // 0x11c7
            putchar((int32_t)*(char *)(v1 + j));
        }
        // 0x1205
        putchar_rc = putchar(10);
    }
    // 0x1219
    return putchar_rc;
}

// Address range: 0x121d - 0x1341
int64_t findPath(int64_t a1, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 >> 32; // 0x122c
    if (*(int32_t *)&g4 == (int32_t)a1) {
        // 0x123a
        if (*(int32_t *)0x4094 == (int32_t)v1) {
            // 0x133f
            return 1;
        }
    }
    int64_t v2 = 0x100000000 * a1;
    char * v3 = (char *)(v1 + (int64_t)""###########  # #   ##  # ### ##        ## ## ### ##        ####### # ##      # ## ## ### ##      # #"" + 2 * ((v2 >> 30) + (v2 >> 32))); // 0x1276
    if (*v3 != 32) {
        // 0x133f
        return 0;
    }
    // 0x1287
    *v3 = 46;
    int64_t v4 = v1 & 0xffffffff; // 0x12ba
    if ((int32_t)findPath(a1 + 0xffffffff & 0xffffffff, v4) != 0) {
        // 0x133f
        return 1;
    }
    int64_t v5 = a1 & 0xffffffff;
    if ((int32_t)findPath(v5, v1 + 1 & 0xffffffff) != 0 || (int32_t)findPath(a1 + 1 & 0xffffffff, v4) != 0) {
        // 0x133f
        return 1;
    }
    int64_t result = 1; // 0x1307
    if ((int32_t)findPath(v5, v1 + 0xffffffff & 0xffffffff) == 0) {
        // 0x1310
        *v3 = 32;
        result = 0;
    }
    // 0x133f
    return result;
}

// Address range: 0x1341 - 0x14d9
int main(int argc, char ** argv) {
    // 0x1341
    puts(""MAZE ROUTE FINDER"");
    puts(""-----------------"");
    printf(""Enter starting row: "");
    scanf(""%d"", &g2);
    printf(""Enter starting col: "");
    scanf(""%d"", &g3);
    printf(""Enter ending row: "");
    scanf(""%d"", &g4);
    printf(""Enter ending col: "");
    scanf(""%d"", &g5);
    uint32_t v1 = *(int32_t *)&g3; // 0x142f
    uint32_t v2 = *(int32_t *)&g2; // 0x1435
    if ((int32_t)findPath((int64_t)v2, (int64_t)v1) == 0) {
        // 0x14c3
        puts(""No path to the end could be found."");
    } else {
        int32_t v3 = *(int32_t *)&g2; // 0x1448
        int32_t v4 = *(int32_t *)&g3; // 0x144e
        *(char *)((int64_t)v4 + (int64_t)""###########  # #   ##  # ### ##        ## ## ### ##        ####### # ##      # ## ## ### ##      # #"" + 10 * (int64_t)v3) = 83;
        int32_t v5 = *(int32_t *)&g4; // 0x1478
        int32_t v6 = *(int32_t *)&g5; // 0x147e
        *(char *)((int64_t)v6 + (int64_t)""###########  # #   ##  # ### ##        ## ## ### ##        ####### # ##      # ## ## ### ##      # #"" + 10 * (int64_t)v5) = 69;
        puts(""The path to the end is:"");
        printMaze();
    }
    // 0x14d2
    return 0;
}

// Address range: 0x14dc - 0x14e9
int64_t _fini(void) {
    // 0x14dc
    int64_t result; // 0x14dc
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            puts(""MAZE ROUTE FINDER"");
            puts(""-----------------"");
            printf(""Enter starting row: "");
            scanf(""%d"", &g2);
            printf(""Enter starting col: "");
            scanf(""%d"", &g3);
            printf(""Enter ending row: "");
            scanf(""%d"", &g4);
            printf(""Enter ending col: "");
            scanf(""%d"", &g5);
            uint32_t v1 = *(int32_t *)&g3;
            uint32_t v2 = *(int32_t *)&g2;
            if ((int32_t)findPath((int64_t)v2, (int64_t)v1) == 0) {
                puts(""No path to the end could be found."");
            } else {
                int32_t v3 = *(int32_t *)&g2;
                int32_t v4 = *(int32_t *)&g3;
                *(char *)((int64_t)v4 + (int64_t)""",1
"//FormAI DATASET v1.0 Category: Temperature Converter ; Style: systematic
#include <stdio.h>

int main() {
    int choice;
    float temperature, result;
    printf(""Choose any one of the below conversions:\n"");
    printf(""1. Celsius to Fahrenheit\n2. Fahrenheit to Celsius\n"");
    scanf(""%d"", &choice);

    switch(choice) {
        case 1:
            printf(""Enter temperature in Celsius: "");
            scanf(""%f"", &temperature);
            result = (temperature * 9/5) + 32;
            printf(""%.2f Celsius = %.2f Fahrenheit"", temperature, result);
            break;
        case 2:
            printf(""Enter temperature in Fahrenheit: "");
            scanf(""%f"", &temperature);
            result = (temperature - 32) * 5/9;
            printf(""%.2f Fahrenheit = %.2f Celsius"", temperature, result);
            break;
        default:
            printf(""Invalid choice!"");
            break;
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x137a
int main(int argc, char ** argv) {
    // 0x11a9
    int128_t v1; // 0x11a9
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = __readfsqword(40); // 0x11b5
    puts(""Choose any one of the below conversions:"");
    puts(""1. Celsius to Fahrenheit\n2. Fahrenheit to Celsius"");
    int64_t v5; // bp-28, 0x11a9
    scanf(""%d"", &v5);
    int32_t v6; // bp-24, 0x11a9
    int64_t v7; // 0x11fd
    switch ((int32_t)v7) {
        case 1: {
            // 0x1213
            printf(""Enter temperature in Celsius: "");
            scanf(""%f"", &v6);
            int128_t v8 = __asm_mulss(__asm_movss(0x41100000), __asm_movss(v6)); // 0x124f
            int128_t v9 = __asm_divss(__asm_movaps(v8), __asm_movss(0x40a00000)); // 0x125e
            int128_t v10 = __asm_addss(__asm_movss(*(int32_t *)0x2118), v9); // 0x126a
            int64_t v11 = __asm_movss_1(v10); // 0x126e
            __asm_pxor(v10, v10);
            int128_t v12 = __asm_cvtss2sd((int32_t)v11); // 0x1277
            int128_t v13 = __asm_movss(v6); // 0x127c
            __asm_pxor(v3, v3);
            int64_t v14 = __asm_movq(__asm_cvtss2sd_2(v13)); // 0x1289
            int128_t v15 = __asm_movapd(v12); // 0x128e
            printf(""%.2f Celsius = %.2f Fahrenheit"", (float64_t)(int64_t)__asm_movq_3(v14), (float64_t)(int64_t)v15);
            // break -> 0x135f
            break;
        }
        case 2: {
            // 0x12b0
            printf(""Enter temperature in Fahrenheit: "");
            scanf(""%f"", &v6);
            int128_t v16 = __asm_subss(__asm_movaps(__asm_movss(v6)), __asm_movss(0x42000000)); // 0x12ef
            int128_t v17 = __asm_divss(__asm_mulss(__asm_movss(0x40a00000), v16), __asm_movss(0x41100000)); // 0x1307
            int64_t v18 = __asm_movss_1(v17); // 0x130b
            __asm_pxor(v17, v17);
            int128_t v19 = __asm_cvtss2sd((int32_t)v18); // 0x1314
            int128_t v20 = __asm_movss(v6); // 0x1319
            __asm_pxor(v2, v2);
            int64_t v21 = __asm_movq(__asm_cvtss2sd_2(v20)); // 0x1326
            int128_t v22 = __asm_movapd(v19); // 0x132b
            printf(""%.2f Fahrenheit = %.2f Celsius"", (float64_t)(int64_t)__asm_movq_3(v21), (float64_t)(int64_t)v22);
            // break -> 0x135f
            break;
        }
        default: {
            // 0x134a
            printf(""Invalid choice!"");
            // break -> 0x135f
            break;
        }
    }
    int64_t result = 0; // 0x1371
    if (v4 != __readfsqword(40)) {
        // 0x1373
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1378
    return result;
}

// Address range: 0x137c - 0x1389
int64_t _fini(void) {
    // 0x137c
    int64_t result; // 0x137c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","nclude <stdio.h>

int main(int argc, char ** argv) {
    int choice;
    float celsius, fahrenheit;

    printf(""Choose any one of the below conversions:\n"");
    printf(""1. Celsius to Fahrenheit\n2. Fahrenheit to Celsius\n"");
    scanf(""%d"", &choice);

    switch (choice) {
        case 1:
            printf(""Enter temperature in Celsius: "");
            scanf(""%f"", &celsius);
            fahrenheit = (9.0 / 5.0) * celsius + 32;
            printf(""%.2f Celsius = %.2f Fahrenheit\n"", celsius, fahrenheit);
            break;
        case 2:
            printf(""Enter temperature in Fahrenheit: "");
            scanf(""%f"", &fahrenheit);
            celsius = (fahrenheit - 32) * 5.0 / 9.0;
            printf(""%.2f Fahrenheit = %.2f Celsius\n"", fahrenheit, celsius);
            break;
        default:
            printf(""Invalid choice!\n"");
            break;
    }

    return 0;
}

",2
"//FormAI DATASET v1.0 Category: Text processing ; Style: Sherlock Holmes
#include <stdio.h>
#include <string.h>

typedef struct {
    char *name;
    char *occupation;
    int age;
    char *address;
} person;

void print_person(person p) {
    printf(""=========================\n"");
    printf(""Name: %s\n"", p.name);
    printf(""Occupation: %s\n"", p.occupation);
    printf(""Age: %d\n"", p.age);
    printf(""Address: %s\n"", p.address);
    printf(""=========================\n"");
}

int main() {
    person p;
    p.name = ""Sherlock Holmes"";
    p.occupation = ""Detective"";
    p.age = 34;
    p.address = ""221B Baker Street, London"";

    print_person(p);

    char *text = ""It was a dark and stormy night. Sherlock Holmes sat by the fire, deep in thought. Suddenly, the door burst open and in rushed a man, soaking wet and breathless."";

    int num_sentences = 0;
    for (int i = 0; i < strlen(text); i++) {
        char c = text[i];
        if (c == '.' || c == '!' || c == '?') {
            num_sentences++;
        }
    }

    printf(""Number of sentences in the text: %d\n"", num_sentences);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
int32_t function_1070(char * s);
int32_t function_1080(char * s);
int32_t function_1090(char * format, ...);
int64_t print_person(int64_t a1, int64_t a2, uint32_t a3, int64_t a4);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
int32_t function_1070(char * s) {
    // 0x1070
    return puts(s);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return strlen(s);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * format, ...) {
    // 0x1090
    return printf(format);
}

// Address range: 0x10a0 - 0x10c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10a0
    int64_t v1; // 0x10a0
    __libc_start_main(0x121c, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10d0 - 0x10f9
int64_t deregister_tm_clones(void) {
    // 0x10d0
    return &g1;
}

// Address range: 0x1100 - 0x1139
int64_t register_tm_clones(void) {
    // 0x1100
    return 0;
}

// Address range: 0x1140 - 0x1179
int64_t __do_global_dtors_aux(void) {
    // 0x1140
    if (*(char *)&g1 != 0) {
        // 0x1178
        int64_t result; // 0x1140
        return result;
    }
    // 0x114d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x115b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1167
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1180 - 0x1189
int64_t frame_dummy(void) {
    // 0x1180
    return register_tm_clones();
}

// Address range: 0x1189 - 0x121c
int64_t print_person(int64_t a1, int64_t a2, uint32_t a3, int64_t a4) {
    // 0x1189
    puts(""========================="");
    printf(""Name: %s\n"", (char *)a1);
    printf(""Occupation: %s\n"", (char *)a2);
    printf(""Age: %d\n"", (int64_t)a3);
    printf(""Address: %s\n"", (char *)a4);
    return puts(""========================="");
}

// Address range: 0x121c - 0x12e9
int main(int argc, char ** argv) {
    // 0x121c
    print_person((int64_t)""Sherlock Holmes"", (int64_t)""Detective"", 34, (int64_t)""221B Baker Street, London"");
    int32_t v1 = 0; // 0x12c3
    int32_t v2 = 0; // 0x12c3
    if (strlen(""It was a dark and stormy night. Sherlock Holmes sat by the fire, deep in thought. Suddenly, the door burst open and in rushed a man, soaking wet and breathless."") == 0) {
        // 0x12c5
        printf(""Number of sentences in the text: %d\n"", (int64_t)0);
        return 0;
    }
    int32_t v3; // 0x121c
    while (true) {
      lab_0x1281:;
        int32_t v4 = v2;
        char v5 = *(char *)((int64_t)v1 + (int64_t)""It was a dark and stormy night. Sherlock Holmes sat by the fire, deep in thought. Suddenly, the door burst open and in rushed a man, soaking wet and breathless.""); // 0x128e
        switch (v5) {
            case 46: {
                // 0x12a6
                v3 = v4 + 1;
                goto lab_0x12aa;
            }
            case 33: {
                // 0x12a6
                v3 = v4 + 1;
                goto lab_0x12aa;
            }
            default: {
                // 0x12a0
                v3 = v4;
                if (v5 != 63) {
                    goto lab_0x12aa;
                } else {
                    // 0x12a6
                    v3 = v4 + 1;
                    goto lab_0x12aa;
                }
            }
        }
    }
  lab_0x12c5:;
    // 0x12c5
    int32_t v6; // 0x121c
    printf(""Number of sentences in the text: %d\n"", (int64_t)v6);
    return 0;
  lab_0x12aa:
    // 0x12aa
    v2 = v3;
    v1++;
    v6 = v2;
    if (v1 >= strlen(""It was a dark and stormy night. Sherlock Holmes sat by the fire, deep in thought. Suddenly, the door burst open and in rushed a man, soaking wet and breathless."")) {
        // break -> 0x12c5
        goto lab_0x12c5;
    }
    goto lab_0x1281;
}

// Address range: 0x12ec - 0x12f9
int64_t _fini(void) {
    // 0x12ec
    int64_t result; // 0x12ec
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            puts(""========================="");
            printf(""Name: %s\n"", ""Sherlock Holmes"");
            printf(""Occupation: %s\n"", ""Detective"");
            printf(""Age: %d\n"", 34);
            printf(""Address: %s\n"", ""221B Baker Street, London"");
            puts(""========================="");

            int v1 = 0;
            int v2 = 0;
            while (true) {
                int v3 = v2;
                char v4 = *(char *)((int)v1 + (int)""It was a dark and stormy night. Sherlock Holmes sat by the fire, deep in thought. Suddenly, the door burst open and in rushed a man, soaking wet and breathless."");
                switch (v4) {
                    case 46: {
                        v3 = v3 + 1;
                        goto lab_0x12aa;
                    }
                    case 33: {
                        v3 = v3 + 1;
                        goto lab_0x12aa;
                    }
                    default: {
                        v3 = v3;
                        if (v4 != 63) {
                            goto lab_0x12aa;
                        } else {
                            v3 = v3 + 1;
                            goto lab_0x12aa;
                        }
                    }
                }
            }
        lab_0x12c5:;
            int v6;
            printf(""Number of sentences in the text: %d\n"", v6);
            return 0;
        lab_0x12aa:
            v2 = v3;
            v1++;
            v6 = v2;
            if (v1 >= strlen(""It was a dark and stormy night. Sherlock Holmes sat by the fire, deep in thought. Suddenly, the door burst open and in rushed a man, soaking wet and breathless."")) {
                break;
            }
            goto lab_0x1281;
        }

",1
"//FormAI DATASET v1.0 Category: Unit converter ; Style: accurate
#include<stdio.h>

//Function declaration
void display_menu();
float convert_temperature(float, char, char);
float convert_length(float, char, char);
float convert_weight(float, char, char);

int main() {
    int choice;
    float value;
    char unit1, unit2;
    
    //Display the main menu
    display_menu();
    printf(""\nEnter your choice: "");
    scanf(""%d"", &choice);
    
    switch(choice) {
        //Case for temperature conversion
        case 1:
            printf(""Enter the temperature value: "");
            scanf(""%f"", &value);
            printf(""Enter the input unit (C/F): "");
            scanf("" %c"", &unit1);
            printf(""Enter the output unit (C/F): "");
            scanf("" %c"", &unit2);
            printf(""\n\nResult: %.2f%c = %.2f%c\n"", value, unit1, convert_temperature(value, unit1, unit2), unit2);
            break;
            
        //Case for length conversion
        case 2:
            printf(""Enter the length value: "");
            scanf(""%f"", &value);
            printf(""Enter the input unit (M/C/K): "");
            scanf("" %c"", &unit1);
            printf(""Enter the output unit (M/C/K): "");
            scanf("" %c"", &unit2);
            printf(""\n\nResult: %.2f%c = %.2f%c\n"", value, unit1, convert_length(value, unit1, unit2), unit2);
            break;
            
        //Case for weight conversion
        case 3:
            printf(""Enter the weight value: "");
            scanf(""%f"", &value);
            printf(""Enter the input unit (K/G): "");
            scanf("" %c"", &unit1);
            printf(""Enter the output unit (K/G): "");
            scanf("" %c"", &unit2);
            printf(""\n\nResult: %.2f%c = %.2f%c\n"", value, unit1, convert_weight(value, unit1, unit2), unit2);
            break;
            
        //Default case
        default:
            printf(""Invalid choice.\n"");
    }
    
    return 0;
}

//Function definition for displaying the menu
void display_menu() {
    printf(""========== Unit Converter ==========\n"");
    printf(""1. Temperature Conversion\n"");
    printf(""2. Length Conversion\n"");
    printf(""3. Weight Conversion\n"");
}

//Function definition for temperature conversion
float convert_temperature(float value, char unit1, char unit2) {
    float result;
    if(unit1 == 'C' && unit2 == 'F') {
        result = (value * 9 / 5) + 32;
    }
    else if(unit1 == 'F' && unit2 == 'C') {
        result = (value - 32) * 5 / 9;
    }
    else {
        result = value;
    }
    return result;
}

//Function definition for length conversion
float convert_length(float value, char unit1, char unit2) {
    float result;
    if(unit1 == 'M' && unit2 == 'C') {
        result = value * 100;
    }
    else if(unit1 == 'M' && unit2 == 'K') {
        result = value / 1000;
    }
    else if(unit1 == 'C' && unit2 == 'M') {
        result = value / 100;
    }
    else if(unit1 == 'C' && unit2 == 'K') {
        result = value / 100000;
    }
    else if(unit1 == 'K' && unit2 == 'M') {
        result = value * 1000;
    }
    else if(unit1 == 'K' && unit2 == 'C') {
        result = value * 100000;
    }
    else {
        result = value;
    }
    return result;
}

//Function definition for weight conversion
float convert_weight(float value, char unit1, char unit2) {
    float result;
    if(unit1 == 'K' && unit2 == 'G') {
        result = value * 1000;
    }
    else if(unit1 == 'G' && unit2 == 'K') {
        result = value / 1000;
    }
    else {
        result = value;
    }
    return result;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int128_t convert_length(int64_t a1, int64_t a2);
int128_t convert_temperature(int64_t a1, int64_t a2);
int128_t convert_weight(int64_t a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t display_menu(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1530
int main(int argc, char ** argv) {
    // 0x11a9
    int128_t v1; // 0x11a9
    int128_t v2 = v1;
    int128_t v3 = v1;
    int128_t v4 = v1;
    int64_t v5 = __readfsqword(40); // 0x11b6
    display_menu();
    printf(""\nEnter your choice: "");
    int64_t v6; // bp-40, 0x11a9
    scanf(""%d"", &v6);
    int32_t v7 = v6; // 0x1201
    int32_t v8; // bp-36, 0x11a9
    char v9; // bp-41, 0x11a9
    char v10; // bp-42, 0x11a9
    if (v7 == 3) {
        // 0x1410
        printf(""Enter the weight value: "");
        scanf(""%f"", &v8);
        printf(""Enter the input unit (K/G): "");
        scanf("" %c"", &v10);
        printf(""Enter the output unit (K/G): "");
        scanf("" %c"", &v9);
        __asm_movd(v8);
        int128_t v11 = __asm_cvtss2sd(convert_weight((int64_t)v10 & 0xffffffff, (int64_t)v9 & 0xffffffff)); // 0x14c2
        int128_t v12 = __asm_movss(v8); // 0x14cd
        __asm_pxor(v2, v2);
        int64_t v13 = __asm_movq(__asm_cvtss2sd(v12)); // 0x14da
        int128_t v14 = __asm_movapd(v11); // 0x14e1
        printf(""\n\nResult: %.2f%c = %.2f%c\n"", (float64_t)(int64_t)__asm_movq_1(v13), v10, (float64_t)(int64_t)v14, v9);
        goto lab_0x1511;
    } else {
        if (v7 > 3) {
            // 0x1502
            puts(""Invalid choice."");
            goto lab_0x1511;
        } else {
            switch (v7) {
                case 1: {
                    // 0x1226
                    printf(""Enter the temperature value: "");
                    scanf(""%f"", &v8);
                    printf(""Enter the input unit (C/F): "");
                    scanf("" %c"", &v10);
                    printf(""Enter the output unit (C/F): "");
                    scanf("" %c"", &v9);
                    __asm_movd(v8);
                    int128_t v15 = __asm_cvtss2sd(convert_temperature((int64_t)v10 & 0xffffffff, (int64_t)v9 & 0xffffffff)); // 0x12d8
                    int128_t v16 = __asm_movss(v8); // 0x12e3
                    __asm_pxor(v4, v4);
                    int64_t v17 = __asm_movq(__asm_cvtss2sd(v16)); // 0x12f0
                    int128_t v18 = __asm_movapd(v15); // 0x12f7
                    printf(""\n\nResult: %.2f%c = %.2f%c\n"", (float64_t)(int64_t)__asm_movq_1(v17), v10, (float64_t)(int64_t)v18, v9);
                    goto lab_0x1511;
                }
                case 2: {
                    // 0x131b
                    printf(""Enter the length value: "");
                    scanf(""%f"", &v8);
                    printf(""Enter the input unit (M/C/K): "");
                    scanf("" %c"", &v10);
                    printf(""Enter the output unit (M/C/K): "");
                    scanf("" %c"", &v9);
                    __asm_movd(v8);
                    int128_t v19 = __asm_cvtss2sd(convert_length((int64_t)v10 & 0xffffffff, (int64_t)v9 & 0xffffffff)); // 0x13cd
                    int128_t v20 = __asm_movss(v8); // 0x13d8
                    __asm_pxor(v3, v3);
                    int64_t v21 = __asm_movq(__asm_cvtss2sd(v20)); // 0x13e5
                    int128_t v22 = __asm_movapd(v19); // 0x13ec
                    printf(""\n\nResult: %.2f%c = %.2f%c\n"", (float64_t)(int64_t)__asm_movq_1(v21), v10, (float64_t)(int64_t)v22, v9);
                    goto lab_0x1511;
                }
                default: {
                    // 0x1502
                    puts(""Invalid choice."");
                    goto lab_0x1511;
                }
            }
        }
    }
  lab_0x1511:;
    int64_t result = 0; // 0x1523
    if (v5 != __readfsqword(40)) {
        // 0x1525
        __stack_chk_fail();
        result = &g2;
    }
    // 0x152a
    return result;
}

// Address range: 0x1530 - 0x1577
int64_t display_menu(void) {
    // 0x1530
    puts(""========== Unit Converter =========="");
    puts(""1. Temperature Conversion"");
    puts(""2. Length Conversion"");
    return puts(""3. Weight Conversion"");
}

// Address range: 0x1577 - 0x161d
int128_t convert_temperature(int64_t a1, int64_t a2) {
    // 0x1577
    int128_t v1; // 0x1577
    int32_t v2 = __asm_movss_2(v1); // 0x157f
    char v3 = a1; // 0x1588
    int64_t v4 = 0x100000000000000 * a2 >> 56; // 0x158b
    if (v3 == 67) {
        if ((char)v4 == 70) {
            int128_t v5 = __asm_divss(__asm_movaps(__asm_mulss(__asm_movss(0x41100000), __asm_movss(v2))), __asm_movss(0x40a00000)); // 0x15b6
            // 0x1616
            return __asm_movss((int32_t)__asm_movss_2(__asm_addss(__asm_movss(0x42000000), v5)));
        }
    }
    if (v3 == 70) {
        if ((char)v4 == 67) {
            int128_t v6 = __asm_subss(__asm_movaps(__asm_movss(v2)), __asm_movss(0x42000000)); // 0x15e9
            int128_t v7 = __asm_divss(__asm_mulss(__asm_movss(0x40a00000), v6), __asm_movss(0x41100000)); // 0x1601
            // 0x1616
            return __asm_movss((int32_t)__asm_movss_2(v7));
        }
    }
    // 0x1616
    return __asm_movss((int32_t)__asm_movss_2(__asm_movss(v2)));
}

// Address range: 0x161d - 0x1723
int128_t convert_length(int64_t a1, int64_t a2) {
    // 0x161d
    int128_t v1; // 0x161d
    int32_t v2 = __asm_movss_2(v1); // 0x1625
    char v3 = a1;
    int64_t v4 = 0x100000000000000 * a2 >> 56; // 0x1631
    if (v3 == 77) {
        char v5 = v4; // 0x163a
        if (v5 == 67) {
            // 0x171c
            return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x42c80000), __asm_movss(v2))));
        }
        if (v5 == 75) {
            // 0x171c
            return __asm_movss((int32_t)__asm_movss_2(__asm_divss(__asm_movss(v2), __asm_movss(0x447a0000))));
        }
    }
    if (v3 == 67) {
        char v6 = v4;
        if (v6 == 77) {
            // 0x171c
            return __asm_movss((int32_t)__asm_movss_2(__asm_divss(__asm_movss(v2), __asm_movss(0x42c80000))));
        }
        if (v6 == 75) {
            int128_t v7 = __asm_divss(__asm_movss(v2), __asm_movss(*(int32_t *)0x21e0)); // 0x16bf
            // 0x171c
            return __asm_movss((int32_t)__asm_movss_2(v7));
        }
    }
    if (v3 == 75) {
        char v8 = v4;
        if (v8 == 77) {
            // 0x171c
            return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x447a0000), __asm_movss(v2))));
        }
        if (v8 == 67) {
            // 0x171c
            return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x47c35000), __asm_movss(v2))));
        }
    }
    // 0x171c
    return __asm_movss((int32_t)__asm_movss_2(__asm_movss(v2)));
}

// Address range: 0x1723 - 0x1793
int128_t convert_weight(int64_t a1, int64_t a2) {
    // 0x1723
    int128_t v1; // 0x1723
    int32_t v2 = __asm_movss_2(v1); // 0x172b
    char v3 = a1; // 0x1734
    int64_t v4 = 0x100000000000000 * a2 >> 56; // 0x1737
    if (v3 == 75) {
        if ((char)v4 == 71) {
            // 0x178c
            return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x447a0000), __asm_movss(v2))));
        }
    }
    if (v3 == 71) {
        if ((char)v4 == 75) {
            // 0x178c
            return __asm_movss((int32_t)__asm_movss_2(__asm_divss(__asm_movss(v2), __asm_movss(0x447a0000))));
        }
    }
    // 0x178c
    return __asm_movss((int32_t)__asm_movss_2(__asm_movss(v2)));
}

// Address range: 0x1794 - 0x17a1
int64_t _fini(void) {
    // 0x1794
    int64_t result; // 0x1794
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>
        #include <math.h>

        typedef int64_t int128_t;
        typedef double float64_t;

        int64_t __do_global_dtors_aux(void);
        int64_t _fini(void);
        int64_t _init(void);
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
        int128_t convert_length(int64_t a1, int64_t a2);
        int128_t convert_temperature(int64_t a1, int64_t a2);
        int128_t convert_weight(int64_t a1, int64_t a2);
        int64_t deregister_tm_clones(void);
        int64_t display_menu(void);
        int64_t frame_dummy(void);
        void function_1070(int64_t * d);
        int32_t function_1080(char * s);
        void function_1090(void);
        int32_t function_10a0(char * format, ...);
        int32_t function_10b0(char * format, ...);
        int64_t register_tm_clones(void);

        int64_t g1 = 0;
        int32_t g2;

        void __cxa_finalize(int64_t * a1);
        void __gmon_start__(void);
        int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
        void __stack_chk_fail(void);

        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            __libc_start_main(0x11a9, (int32_t)a6, (char **)&g1, NULL, NULL, (void (*)())a3);
            __asm_hlt();
        }

        int64_t deregister_tm_clones(void) {
            return &g1;
        }

        int64_t register_tm_clones(void) {
            return 0;
        }

        int64_t __do_global_dtors_aux(void) {
            if (*(char *)&g1 != 0) {
                __cxa_finalize((int64_t *)*(int64_t *)0x4008);
            }
            int64_t result = deregister_tm_clones();
            *(char *)&g1 = 1;
            return result;
        }

        int64_t frame_dummy(void) {
            return register_tm_clones();
        }

        int64_t display_menu(void) {
            puts(""========== Unit Converter =========="");
            puts(""1. Temperature Conversion"");
            puts(""2. Length Conversion"");
            return puts(""3. Weight Conversion"");
        }

        int128_t convert_temperature(int64_t a1, int64_t a2) {
            int128_t v1;
            int32_t v2 = __asm_movss_2(v1);
            char v3 = a1;
            int64_t v4 = 0x100000000000000 * a2 >> 56;
            if (v3 == 67) {
                if ((char)v4 == 70) {
                    int128_t v5 = __asm_divss(__asm_movaps(__asm_mulss(__asm_movss(0x41100000), __asm_movss(v2)), __asm_movss(0x40a00000));
                    return __asm_movss((int32_t)__asm_movss_2(__asm_addss(__asm_movss(0x42000000), v5)));
                }
            }
            if (v3 == 70) {
                if ((char)v4 == 67) {
                    int128_t v6 = __asm_subss(__asm_movaps(__asm_movss(v2), __asm_movss(0x42000000));
                    int128_t v7 = __asm_divss(__asm_mulss(__asm_movss(0x40a00000), v6), __asm_movss(0x41100000));
                    return __asm_movss((int32_t)__asm_movss_2(v7));
                }
            }
            return __asm_movss((int32_t)__asm_movss_2(__asm_movss(v2)));
        }

        int128_t convert_length(int64_t a1, int64_t a2) {
            int128_t v1;
            int32_t v2 = __asm_movss_2(v1);
            char v3 = a1;
            int64_t v4 = 0x100000000000000 * a2 >> 56;
            if (v3 == 77) {
                char v5 = v4;
                if (v5 == 67) {
                    return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x42c80000), __asm_movss(v2)));
                }
                if (v5 == 75) {
                    return __asm_movss((int32_t)__asm_movss_2(__asm_divss(__asm_movss(v2), __asm_movss(0x447a0000)));
                }
            }
            if (v3 == 67) {
                char v6 = v4;
                if (v6 == 77) {
                    return __asm_movss((int32_t)__asm_movss_2(__asm_divss(__asm_movss(v2), __asm_movss(0x42c80000)));
                }
                if (v6 == 75) {
                    int128_t v7 = __asm_divss(__asm_movss(v2), __asm_movss(*(int32_t *)0x21e0));
                    return __asm_movss((int32_t)__asm_movss_2(v7));
                }
            }
            if (v3 == 75) {
                char v8 = v4;
                if (v8 == 77) {
                    return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x447a0000), __asm_movss(v2)));
                }
                if (v8 == 67) {
                    return __asm_movss((int32_t)__asm_movss_2(__asm_mulss(__asm_movss(0x47c35000), __asm_movss(v2)));
                }
            }
            return __asm_movss((int32_t)__asm_movss_2(__asm_movss(v2))",0
"//FormAI DATASET v1.0 Category: Color Code Converter ; Style: cheerful
#include <stdio.h>
#include <string.h>

int main(){
    char colorCode[7], color[20];
    printf(""Welcome to the Cheery Color Code Converter!\n"");
    printf(""Enter a 6-digit hexadecimal color code: "");
    scanf(""%s"", colorCode);
    // Check if entered color code is valid
    if(strlen(colorCode) != 6){
        printf(""Invalid color code!\n"");
        return 0;
    }
    // Converting hex digits to decimal
    int r = (int) strtol(strndup(colorCode, 2), NULL, 16);
    int g = (int) strtol(strndup(colorCode+2, 2), NULL, 16);
    int b = (int) strtol(strndup(colorCode+4, 2), NULL, 16);
    // Getting color name based on decimal values
    if(r > g && r > b) strcpy(color, ""RED"");
    else if(g > r && g > b) strcpy(color, ""GREEN"");
    else if(b > r && b > g) strcpy(color, ""BLUE"");
    else if(r == g && r > b) strcpy(color, ""YELLOW"");
    else if(r == b && r > g) strcpy(color, ""MAGENTA"");
    else if(g == b && g > r) strcpy(color, ""CYAN"");
    else strcpy(color, ""GREY"");
    // Printing results
    printf(""The decimal values are: R=%d, G=%d, B=%d\n"", r, g, b);
    printf(""The color is: %s\n"", color);
    printf(""Have a delightful day!\n"");
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
int32_t function_10c0(char * s);
void function_10d0(void);
int32_t function_10e0(char * format, ...);
char * function_10f0(char * string, int32_t n);
int32_t function_1100(char * nptr, char ** endptr, int32_t base);
int32_t function_1110(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return strlen(s);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(void) {
    // 0x10d0
    __stack_chk_fail();
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return printf(format);
}

// Address range: 0x10f0 - 0x10fb
char * function_10f0(char * string, int32_t n) {
    // 0x10f0
    return strndup(string, n);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * nptr, char ** endptr, int32_t base) {
    // 0x1100
    return strtol(nptr, endptr, base);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return scanf(format);
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g1;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g1 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x1455
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1215
    puts(""Welcome to the Cheery Color Code Converter!"");
    printf(""Enter a 6-digit hexadecimal color code: "");
    int64_t str; // bp-47, 0x1209
    scanf(""%s"", &str);
    if (strlen((char *)&str) == 6) {
        int32_t str_as_l = strtol(strndup((char *)&str, 2), NULL, 16); // 0x12b0
        int64_t str2; // bp-45, 0x1209
        int32_t str_as_l2 = strtol(strndup((char *)&str2, 2), NULL, 16); // 0x12df
        int64_t str3; // bp-43, 0x1209
        int32_t str_as_l3 = strtol(strndup((char *)&str3, 2), NULL, 16); // 0x130e
        int64_t v2; // bp-40, 0x1209
        if (str_as_l > str_as_l2 == str_as_l > str_as_l3) {
            // 0x1326
            v2 = 0x444552;
        } else {
            if (str_as_l2 > str_as_l == str_as_l2 > str_as_l3) {
                // 0x1345
                v2 = 0x45455247;
            } else {
                if (str_as_l3 > str_as_l == str_as_l3 > str_as_l2) {
                    // 0x136a
                    v2 = 0x45554c42;
                } else {
                    if (str_as_l == str_as_l2 == str_as_l > str_as_l3) {
                        // 0x138a
                        v2 = 0x4c4c4559;
                    } else {
                        if (str_as_l > str_as_l2 == str_as_l == str_as_l3) {
                            // 0x13b0
                            v2 = 0x41544e4547414d;
                        } else {
                            if (str_as_l2 > str_as_l == str_as_l2 == str_as_l3) {
                                // 0x13d3
                                v2 = 0x4e415943;
                            } else {
                                // 0x13e3
                                v2 = 0x59455247;
                            }
                        }
                    }
                }
            }
        }
        // 0x13f1
        printf(""The decimal values are: R=%d, G=%d, B=%d\n"", (int64_t)str_as_l, (int64_t)str_as_l2, (int64_t)str_as_l3);
        printf(""The color is: %s\n"", &v2);
        puts(""Have a delightful day!"");
    } else {
        // 0x1274
        puts(""Invalid color code!"");
    }
    int64_t result = 0; // 0x144c
    if (v1 != __readfsqword(40)) {
        // 0x144e
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1453
    return result;
}

// Address range: 0x1458 - 0x1465
int64_t _fini(void) {
    // 0x1458
    int64_t result; // 0x1458
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to the Cheery Color Code Converter!"");
            printf(""Enter a 6-digit hexadecimal color code: "");
            char str[7];
            scanf(""%s"", str);
            if (strlen(str) == 6) {
                int str_as_l = strtol(strndup(str, 2), NULL, 16);
                int str_as_l2 = strtol(strndup(str, 2), NULL, 16);
                int str_as_l3 = strtol(strndup(str, 2), NULL, 16);
                int v2;
                if (str_as_l > str_as_l2 == str_as_l > str_as_l3) {
                    v2 = 0x444552;
                } else {
                    if (str_as_l2 > str_as_l == str_as_l2 > str_as_l3) {
                        v2 = 0x45455247;
                    } else {
                        if (str_as_l3 > str_as_l == str_as_l3 > str_as_l2) {
                            v2 = 0x45554c42;
                        } else {
                            if (str_as_l == str_as_l2 == str_as_l > str_as_l3) {
                                v2 = 0x4c4c4559;
                            } else {
                                if (str_as_l > str_as_l2 == str_as_l == str_as_l3) {
                                    v2 = 0x41544e4547414d;
                                } else {
                                    if (str_as_l2 > str_as_l == str_as_l2 == str_as_l3) {
                                        v2 = 0x4e415943;
                                    } else {
                                        v2 = 0x59455247;
                                    }
                                }
                            }
                        }
                    }
                }
                printf(""The decimal values are: R=%d, G=%d, B=%d\n"", str_as_l, str_as_l2, str_as_l3);
                printf(""The color is: %s\n"", &v2);
                puts(""Have a delightful day!"");
            } else {
                puts(""Invalid color code!"");
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Image to ASCII art converter ; Style: Donald Knuth
#include <stdio.h>

// Function to print the ASCII art of the given image
void printASCII(char *img[], int rows, int cols)
{
    // ASCII characters in increasing order of density
    char ascii[] = {' ', '.', ':', '-', '=', '+', '*', '#', '%', '@'};

    // Scale of the image (ratio of ASCII character to pixel width)
    float scale = 0.1;

    // Loop through the rows of the image
    for (int i = 0; i < rows; i++)
    {
        // Loop through the columns of the image
        for (int j = 0; j < cols; j++)
        {
            // Calculate the average intensity of the current pixel
            int r = (img[i][j] & 0xff0000) >> 16;
            int g = (img[i][j] & 0x00ff00) >> 8;
            int b = img[i][j] & 0x0000ff;
            float intensity = (r + g + b) / 3.0 / 255;

            // Calculate the equivalent ASCII character for this intensity
            int index = (int)(intensity / scale);
            if (index > 9)
                index = 9;

            // Output the ASCII character
            printf(""%c"", ascii[index]);
        }

        // Move to the next line
        printf(""\n"");
    }
}

int main()
{
    // Example image as a 3x5 array
    char *img[] = {
        ""\xff\xff\xff\x00\x00"", ""\xff\x7f\x00\xff\x00"", ""\xff\xff\x7f\x7f\x7f""};
    int rows = 3;
    int cols = 5;

    // Print the ASCII art of the image
    printASCII(img, rows, cols);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1050(int64_t * d);
int32_t function_1060(int32_t c);
void function_1070(void);
int64_t printASCII(int64_t * a1, int64_t a2, uint32_t a3);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0x7fff000000ffffff; // 0x2008
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1050 - 0x105b
void function_1050(int64_t * d) {
    // 0x1050
    __cxa_finalize(d);
}

// Address range: 0x1060 - 0x106b
int32_t function_1060(int32_t c) {
    // 0x1060
    return putchar(c);
}

// Address range: 0x1070 - 0x107b
void function_1070(void) {
    // 0x1070
    __stack_chk_fail();
}

// Address range: 0x1080 - 0x10a6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1080
    int64_t v1; // 0x1080
    __libc_start_main(0x12fd, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10b0 - 0x10d9
int64_t deregister_tm_clones(void) {
    // 0x10b0
    return &g2;
}

// Address range: 0x10e0 - 0x1119
int64_t register_tm_clones(void) {
    // 0x10e0
    return 0;
}

// Address range: 0x1120 - 0x1159
int64_t __do_global_dtors_aux(void) {
    // 0x1120
    if (*(char *)&g2 != 0) {
        // 0x1158
        int64_t result; // 0x1120
        return result;
    }
    // 0x112d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x113b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1147
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1160 - 0x1169
int64_t frame_dummy(void) {
    // 0x1160
    return register_tm_clones();
}

// Address range: 0x1169 - 0x12fd
int64_t printASCII(int64_t * a1, int64_t a2, uint32_t a3) {
    int64_t v1 = __readfsqword(40); // 0x117f
    int128_t v2 = __asm_movss(0x3dcccccd); // 0x11a2
    int64_t v3 = __asm_movss_1(v2); // 0x11aa
    if ((int32_t)a2 > 0) {
        // 0x12c0
        int64_t v4; // bp-8, 0x1169
        int64_t v5 = (int64_t)&v4 - 18;
        int64_t v6 = 0;
        int128_t v7 = v2; // 0x12c6
        int64_t v8; // 0x1169
        unsigned char v9; // 0x11e6
        int128_t v10; // 0x1265
        int128_t v11; // 0x127d
        int128_t v12; // 0x128f
        int32_t v13; // 0x1294
        int64_t * v14; // 0x11db
        int128_t v15; // 0x1169
        if (a3 > 0) {
            // 0x11c7
            v14 = (int64_t *)(8 * v6 + (int64_t)a1);
            v8 = 0;
            v15 = v2;
            v9 = *(char *)(*v14 + v8);
            __asm_pxor(v15, v15);
            v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
            v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
            v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
            v13 = __asm_cvttss2si(v12);
            putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
            v8++;
            v7 = v12;
            while (v8 != (int64_t)a3) {
                // 0x11c7
                v15 = v12;
                v9 = *(char *)(*v14 + v8);
                __asm_pxor(v15, v15);
                v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
                v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
                v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
                v13 = __asm_cvttss2si(v12);
                putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
                v8++;
                v7 = v12;
            }
        }
        // 0x12cc
        putchar(10);
        int64_t v16 = v6 + 1;
        while (v16 != (a2 & 0xffffffff)) {
            int128_t v17 = v7;
            v6 = v16;
            v7 = v17;
            if (a3 > 0) {
                // 0x11c7
                v14 = (int64_t *)(8 * v6 + (int64_t)a1);
                v8 = 0;
                v15 = v17;
                v9 = *(char *)(*v14 + v8);
                __asm_pxor(v15, v15);
                v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
                v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
                v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
                v13 = __asm_cvttss2si(v12);
                putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
                v8++;
                v7 = v12;
                while (v8 != (int64_t)a3) {
                    // 0x11c7
                    v15 = v12;
                    v9 = *(char *)(*v14 + v8);
                    __asm_pxor(v15, v15);
                    v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
                    v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
                    v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
                    v13 = __asm_cvttss2si(v12);
                    putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
                    v8++;
                    v7 = v12;
                }
            }
            // 0x12cc
            putchar(10);
            v16 = v6 + 1;
        }
    }
    int64_t result = 0; // 0x12f4
    if (v1 != __readfsqword(40)) {
        // 0x12f6
        __stack_chk_fail();
        result = &g3;
    }
    // 0x12fb
    return result;
}

// Address range: 0x12fd - 0x1376
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1309
    int64_t v2 = &g1; // bp-40, 0x131f
    printASCII(&v2, 3, 5);
    int64_t result = 0; // 0x136d
    if (v1 != __readfsqword(40)) {
        // 0x136f
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1374
    return result;
}

// Address range: 0x1378 - 0x1385
int64_t _fini(void) {
    // 0x1378
    int64_t result; // 0x1378
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 12

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            int64_t g1 = 0x7fff000000ffffff; // 0x2008
            int64_t g2 = 0; // 0x4010
            int32_t g3;

            int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
                __libc_start_main(0x12fd, (int32_t)a6, (char **)&g3, NULL, NULL, (void (*)())a3);
                __asm_hlt();
            }

            int64_t _init(void) {
                int64_t result = 0; // 0x1012
                if (*(int64_t *)0x3fe8 != 0) {
                    // 0x1014
                    __gmon_start__();
                    result = &g3;
                }
                // 0x1016
                return result;
            }

            void function_1050(int64_t * d) {
                __cxa_finalize(d);
            }

            int32_t function_1060(int32_t c) {
                return putchar(c);
            }

            void function_1070(void) {
                __stack_chk_fail();
            }

            int64_t printASCII(int64_t * a1, int64_t a2, uint32_t a3) {
                int64_t v1 = __readfsqword(40); // 0x117f
                int128_t v2 = __asm_movss(0x3dcccccd); // 0x11a2
                int64_t v3 = __asm_movss_1(v2); // 0x11aa
                if ((int32_t)a2 > 0) {
                    // 0x12c0
                    int64_t v4; // bp-8, 0x1169
                    int64_t v5 = (int64_t)&v4 - 18;
                    int64_t v6 = 0;
                    int128_t v7 = v2; // 0x12c6
                    int64_t v8; // 0x1169
                    unsigned char v9; // 0x11e6
                    int128_t v10; // 0x1265
                    int128_t v11; // 0x127d
                    int128_t v12; // 0x128f
                    int32_t v13; // 0x1294
                    int64_t * v14; // 0x11db
                    int128_t v15; // 0x1169
                    if (a3 > 0) {
                        // 0x11c7
                        v14 = (int64_t *)(8 * v6 + (int64_t)a1);
                        v8 = 0;
                        v15 = v2;
                        v9 = *(char *)(*v14 + v8);
                        __asm_pxor(v15, v15);
                        v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
                        v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
                        v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
                        v13 = __asm_cvttss2si(v12);
                        putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
                        v8++;
                        v7 = v12;
                        while (v8 != (int64_t)a3) {
                            // 0x11c7
                            v15 = v12;
                            v9 = *(char *)(*v14 + v8);
                            __asm_pxor(v15, v15);
                            v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
                            v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
                            v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
                            v13 = __asm_cvttss2si(v12);
                            putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
                            v8++;
                            v7 = v12;
                        }
                    }
                    // 0x12cc
                    putchar(10);
                    int64_t v16 = v6 + 1;
                    while (v16 != (a2 & 0xffffffff)) {
                        int128_t v17 = v7;
                        v6 = v16;
                        v7 = v17;
                        if (a3 > 0) {
                            // 0x11c7
                            v14 = (int64_t *)(8 * v6 + (int64_t)a1);
                            v8 = 0;
                            v15 = v17;
                            v9 = *(char *)(*v14 + v8);
                            __asm_pxor(v15, v15);
                            v10 = __asm_cvtsi2sd(2 * (int32_t)(v9 / 128) + (int32_t)v9);
                            v11 = __asm_divsd(__asm_divsd(v10, __asm_movsd(0x4008000000000000)), __asm_movsd(0x406fe00000000000));
                            v12 = __asm_divss(__asm_movss((int32_t)__asm_movss_1(__asm_cvtsd2ss(v11))), (int32_t)v3);
                            v13 = __asm_cvttss2si(v12);
                            putchar((int32_t)*(char *)(v5 + (int64_t)(v13 < 9 ? v13 : 9)));
                            v8++;
                            v7 = v12;
                            while (v8 != (int64_t)a3) {
                                // 0x11c7
                                v15 = v12;
                                v9",0
"//FormAI DATASET v1.0 Category: Medical Store Management System ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_MEDS 100
#define MAX_LENGTH 50

struct medicine {
    int id;
    char name[MAX_LENGTH];
    float price;
    int stock;
};

int num_medicines = 0;
struct medicine medicines[MAX_MEDS];

void add_medicine() {
    struct medicine new_med;
    new_med.id = num_medicines + 1;

    printf(""Enter medicine name: "");
    fgets(new_med.name, MAX_LENGTH, stdin);
    new_med.name[strcspn(new_med.name, ""\n"")] = 0;

    printf(""Enter medicine price: "");
    scanf(""%f"", &new_med.price);

    printf(""Enter medicine stock: "");
    scanf(""%d"", &new_med.stock);

    getchar();

    medicines[num_medicines] = new_med;
    num_medicines++;

    printf(""Medicine added successfully.\n"");
}

void print_stock() {
    printf(""id \tname \tprice \tstock\n"");

    for (int i = 0; i < num_medicines; i++) {
        printf(""%d \t%s \t%.2f \t%d\n"",
               medicines[i].id,
               medicines[i].name,
               medicines[i].price,
               medicines[i].stock);
    }
}

void search_medicine() {
    char search_name[MAX_LENGTH];

    printf(""Enter name of medicine to search: "");
    fgets(search_name, MAX_LENGTH, stdin);
    search_name[strcspn(search_name, ""\n"")] = 0;

    for (int i = 0; i < num_medicines; i++) {
        if (strcmp(search_name, medicines[i].name) == 0) {
            printf(""id: %d\nname: %s\nprice: %.2f\nstock: %d\n"",
                   medicines[i].id,
                   medicines[i].name,
                   medicines[i].price,
                   medicines[i].stock);
            return;
        }
    }

    printf(""Medicine not found.\n"");

}

void sell_medicine() {
    int sell_id, sell_amount;

    printf(""Enter id of medicine to sell: "");
    scanf(""%d"", &sell_id);

    printf(""Enter amount of medicine to sell: "");
    scanf(""%d"", &sell_amount);

    getchar();

    for (int i = 0; i < num_medicines; i++) {
        if (medicines[i].id == sell_id) {
            if (medicines[i].stock >= sell_amount) {
                medicines[i].stock -= sell_amount;
                printf(""Sale successful. Total price: %.2f\n"",
                       sell_amount * medicines[i].price);
                return;
            } else {
                printf(""Not enough stock.\n"");
                return;
            }
        }
    }

    printf(""Medicine not found.\n"");
}

int main() {
    int choice;

    do {
        printf(""Menu\n"");
        printf(""1. Add medicine\n"");
        printf(""2. Print stock\n"");
        printf(""3. Search medicine\n"");
        printf(""4. Sell medicine\n"");
        printf(""5. Exit\n"");

        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        getchar();

        switch (choice) {
            case 1:
                add_medicine();
                break;
            case 2:
                print_stock();
                break;
            case 3:
                search_medicine();
                break;
            case 4:
                sell_medicine();
                break;
            case 5:
                printf(""Exiting program.\n"");
                break;
            default:
                printf(""Invalid choice.\n"");
                break;
        }

    } while (choice != 5);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t add_medicine(void);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(char * s);
void function_10d0(void);
int32_t function_10e0(char * format, ...);
int32_t function_10f0(char * s, char * reject);
char * function_1100(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1110(char * s1, char * s2);
int32_t function_1120(void);
int32_t function_1130(char * format, ...);
int64_t print_stock(void);
int64_t register_tm_clones(void);
int64_t search_medicine(void);
int64_t sell_medicine(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x9d300000993; // 0x220c
struct _IO_FILE * g2 = NULL; // 0x4020
char g3 = 0; // 0x4028
int32_t g4 = 0; // 0x4040
int32_t g5 = 0; // 0x4041
int64_t g6 = 0; // 0x4060
int64_t g7 = 0; // 0x4098
int64_t g8 = 0; // 0x409c
int32_t g9;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g9;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return puts(s);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(void) {
    // 0x10d0
    __stack_chk_fail();
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return printf(format);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * s, char * reject) {
    // 0x10f0
    return strcspn(s, reject);
}

// Address range: 0x1100 - 0x110b
char * function_1100(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1100
    return fgets(s, n, stream);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s1, char * s2) {
    // 0x1110
    return strcmp(s1, s2);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(void) {
    // 0x1120
    return getchar();
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * format, ...) {
    // 0x1130
    return scanf(format);
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1764, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return 0x4010;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (g3 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    g3 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x13a4
int64_t add_medicine(void) {
    int64_t v1 = __readfsqword(40); // 0x1236
    printf(""Enter medicine name: "");
    int64_t str; // bp-100, 0x1229
    fgets((char *)&str, 50, g2);
    int32_t ini_seg_bytes = strcspn((char *)&str, ""\n""); // 0x1299
    int64_t v2; // bp-8, 0x1229
    *(char *)((int64_t)&v2 - 92 + (int64_t)ini_seg_bytes) = 0;
    printf(""Enter medicine price: "");
    int64_t v3; // bp-48, 0x1229
    scanf(""%f"", &v3);
    printf(""Enter medicine stock: "");
    int64_t v4; // bp-44, 0x1229
    scanf(""%d"", &v4);
    getchar();
    int64_t v5 = 64 * (int64_t)g4; // 0x1316
    *(int64_t *)(v5 + (int64_t)&g6) = (int64_t)(int32_t)&g5;
    *(int64_t *)((v5 | 56) + (int64_t)&g6) = v3;
    g4 = &g5;
    puts(""Medicine added successfully."");
    int64_t result = 0; // 0x1397
    if (v1 != __readfsqword(40)) {
        // 0x1399
        __stack_chk_fail();
        result = &g9;
    }
    // 0x139e
    return result;
}

// Address range: 0x13a4 - 0x146b
int64_t print_stock(void) {
    // 0x13a4
    puts(""id \tname \tprice \tstock"");
    if (g4 == 0) {
        // 0x1467
        return 0;
    }
    int32_t v1 = 0; // 0x1461
    int128_t v2; // 0x13a4
    int128_t v3 = v2;
    int64_t v4 = 0; // 0x13d0
    uint32_t v5 = *(int32_t *)(v4 + (int64_t)&g8); // 0x13de
    int128_t v6 = __asm_movss(*(int32_t *)(v4 + (int64_t)&g7)); // 0x13f4
    __asm_pxor(v3, v3);
    int128_t v7 = __asm_cvtss2sd(v6); // 0x13fd
    int64_t v8 = __asm_movq(v7); // 0x1401
    uint32_t v9 = *(int32_t *)(v4 + (int64_t)&g6); // 0x1433
    int128_t v10 = __asm_movq_1(v8); // 0x1436
    printf(""%d \t%s \t%.2f \t%d\n"", (int64_t)v9, (char *)(v4 + (int64_t)&g6 + 4), (float64_t)(int64_t)v10, (int64_t)v5);
    v1++;
    int64_t result = g4; // 0x1458
    int64_t v11 = v1; // 0x1461
    while (v11 < result) {
        // 0x13cb
        v3 = v7;
        v4 = 64 * v11;
        v5 = *(int32_t *)(v4 + (int64_t)&g8);
        v6 = __asm_movss(*(int32_t *)(v4 + (int64_t)&g7));
        __asm_pxor(v3, v3);
        v7 = __asm_cvtss2sd(v6);
        v8 = __asm_movq(v7);
        v9 = *(int32_t *)(v4 + (int64_t)&g6);
        v10 = __asm_movq_1(v8);
        printf(""%d \t%s \t%.2f \t%d\n"", (int64_t)v9, (char *)(v4 + (int64_t)&g6 + 4), (float64_t)(int64_t)v10, (int64_t)v5);
        v1++;
        result = g4;
        v11 = v1;
    }
    // 0x1467
    return result;
}

// Address range: 0x146b - 0x15cd
int64_t search_medicine(void) {
    // 0x146b
    int128_t v1; // 0x146b
    int128_t v2 = v1;
    int64_t v3 = __readfsqword(40); // 0x1477
    printf(""Enter name of medicine to search: "");
    int64_t str; // bp-72, 0x146b
    fgets((char *)&str, 50, g2);
    int32_t ini_seg_bytes = strcspn((char *)&str, ""\n""); // 0x14c3
    int64_t v4; // bp-8, 0x146b
    *(char *)((int64_t)&v4 - 64 + (int64_t)ini_seg_bytes) = 0;
    int32_t v5 = 0; // 0x15a2
    if (g4 == 0) {
      lab_0x15a8:
        // 0x15a8
        puts(""Medicine not found."");
    } else {
        int64_t v6 = 0; // 0x14de
        char * str2 = (char *)(v6 + (int64_t)&g6 + 4);
        while (strcmp((char *)&str, str2) != 0) {
            // 0x1599
            v5++;
            int64_t v7 = v5; // 0x15a2
            if (v7 >= (int64_t)g4) {
                goto lab_0x15a8;
            }
            v6 = 64 * v7;
            str2 = (char *)(v6 + (int64_t)&g6 + 4);
        }
        uint32_t v8 = *(int32_t *)(v6 + (int64_t)&g8); // 0x151d
        int128_t v9 = __asm_movss(*(int32_t *)(v6 + (int64_t)&g7)); // 0x1533
        __asm_pxor(v2, v2);
        int64_t v10 = __asm_movq(__asm_cvtss2sd(v9)); // 0x1540
        uint32_t v11 = *(int32_t *)(v6 + (int64_t)&g6); // 0x1572
        printf(""id: %d\nname: %s\nprice: %.2f\nstock: %d\n"", (int64_t)v11, str2, (float64_t)(int64_t)__asm_movq_1(v10), (int64_t)v8);
    }
    int64_t result = 0; // 0x15c4
    if (v3 != __readfsqword(40)) {
        // 0x15c6
        __stack_chk_fail();
        result = &g9;
    }
    // 0x15cb
    return result;
}

// Address range: 0x15cd - 0x1764
int64_t sell_medicine(void) {
    // 0x15cd
    int128_t v1; // 0x15cd
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = __readfsqword(40); // 0x15d9
    printf(""Enter id of medicine to sell: "");
    int64_t v5; // bp-28, 0x15cd
    scanf(""%d"", &v5);
    printf(""Enter amount of medicine to sell: "");
    int64_t v6; // bp-24, 0x15cd
    scanf(""%d"", &v6);
    getchar();
    if (g4 == 0) {
      lab_0x173f:
        // 0x173f
        puts(""Medicine not found."");
    } else {
        int32_t v7 = 0; // 0x172c
        int64_t v8 = 0; // 0x165c
        while (*(int32_t *)(v8 + (int64_t)&g6) != (int32_t)v5) {
            // 0x1730
            v7++;
            int64_t v9 = v7; // 0x1739
            if (v9 >= (int64_t)g4) {
                goto lab_0x173f;
            }
            v8 = 64 * v9;
        }
        int32_t * v10 = (int32_t *)(v8 + (int64_t)&g8); // 0x168b
        uint32_t v11 = *v10; // 0x168b
        if ((v6 & 0xffffffff) > (int64_t)v11) {
            // 0x171b
            puts(""Not enough stock."");
        } else {
            // 0x1699
            *v10 = v11 - (int32_t)v6;
            __asm_pxor(v3, v3);
            int128_t v12 = __asm_cvtsi2ss((int32_t)v6); // 0x16d3
            int128_t v13 = __asm_mulss(__asm_movss(*(int32_t *)(v8 + (int64_t)&g7)), v12); // 0x16ef
            __asm_pxor(v2, v2);
            int64_t v14 = __asm_movq(__asm_cvtss2sd(v13)); // 0x16fb
            printf(""Sale successful. Total price: %.2f\n"", (float64_t)(int64_t)__asm_movq_1(v14));
        }
    }
    int64_t result = 0; // 0x175b
    if (v4 != __readfsqword(40)) {
        // 0x175d
        __stack_chk_fail();
        result = &g9;
    }
    // 0x1762
    return result;
}

// Address range: 0x1764 - 0x18b0
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1770
    puts(""Menu"");
    puts(""1. Add medicine"");
    puts(""2. Print stock"");
    puts(""3. Search medicine"");
    puts(""4. Sell medicine"");
    puts(""5. Exit"");
    printf(""Enter your choice: "");
    int64_t v2; // bp-20, 0x1764
    scanf(""%d"", &v2);
    getchar();
    while ((int32_t)v2 >= 6) {
        // 0x1879
        puts(""Invalid choice."");
        if ((int32_t)v2 == 5) {
            // 0x1895
            if (v1 == __readfsqword(40)) {
                // 0x18ae
                return 0;
            }
            // 0x18a9
            __stack_chk_fail();
            // 0x18ae
            return &g9;
        }
        puts(""Menu"");
        puts(""1. Add medicine"");
        puts(""2. Print stock"");
        puts(""3. Search medicine"");
        puts(""4. Sell medicine"");
        puts(""5. Exit"");
        printf(""Enter your choice: "");
        scanf(""%d"", &v2);
        getchar();
    }
    int32_t v3 = *(int32_t *)((4 * v2 & 0x3fffffffc) + (int64_t)&g1); // 0x1826
    return (int64_t)v3 + (int64_t)&g1;
}

// Address range: 0x18b0 - 0x18bd
int64_t _fini(void) {
    // 0x18b0
    int64_t result; // 0x18b0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        // ---------------- Integer Types Definitions -----------------

        typedef int64_t int128_t;

        // ----------------- Float Types Definitions ------------------

        typedef double float64_t;

        // ------------------------ Structures ------------------------

        struct _IO_FILE {
            int32_t e0;
        };

        // ------------------- Function Prototypes --------------------

        int64_t __do_global_dtors_aux(void);
        int64_t _fini(void);
        int64_t _init(void);
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
        int64_t add_medicine(void);
        int64_t deregister_tm_clones(void);
        int64_t frame_dummy(void);
        void function_10b0(int64_t * d);
        int32_t function_10c0(char * s);
        void function_10d0(void);
        int32_t function_10e0(char * format, ...);
        int32_t function_10f0(char * s, char * reject);
        char * function_1100(char * s, int32_t n, struct _IO_FILE * stream);
        int32_t function_1110(char * s1, char * s2);
        int32_t function_1120(void);
        int32_t function_1130(char * format, ...);
        int64_t print_stock(void);
        int64_t register_tm_clones(void);
        int64_t search_medicine(void);
        int64_t sell_medicine(void);

        // --------------------- Global Variables ---------------------

        int64_t g1 = -0x9d300000993; // 0x220c
        struct _IO_FILE * g2 = NULL; // 0x4020
        char g3 = 0; // 0x4028
        int32_t g4 = 0; // 0x4040
        int32_t g5 = 0; // 0x4041
        int64_t g6 = 0; // 0x4060
        int64_t g7 = 0; // 0x4098
        int64_t g8 = 0; // 0x409c
        int32_t g9;

        // ------- Dynamically Linked Functions Without Header --------

        void __cxa_finalize(int64_t * a1);
        void __gmon_start__(void);
        int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
        void __stack_chk_fail(void);

        // ------------------------ Functions -------------------------

        // Address range: 0x1000 - 0x101b
        int64_t _init(void) {
            int64_t result = 0; // 0x1012
            if (*(int64_t *)0x3fe8 != 0) {
                // 0x1014
                __gmon_start__();
                result = &g9;
            }
            // 0x1016
            return result;
        }

        // Address range: 0x10b0 - 0x10bb
        void function_10b0(int64_t * d) {
            // 0x10b0
            __cxa_finalize(d);
        }

        // Address range: 0x10c0 - 0x10cb
        int32_t function_10c0(char * s) {
            // 0x10c0
            return puts(s);
        }

        // Address range: 0x10d0 - 0x10db
        void function_10d0(void) {
            // 0x10d0
            __stack_chk_fail();
        }

        // Address range: 0x10e0 - 0x10eb
        int32_t function_10e0(char * format, ...) {
            // 0x10e0
            return printf(format);
        }

        // Address range: 0x10f0 - 0x10fb
        int32_t function_10f0(char * s, char * reject) {
            // 0x10f0
            return strcspn(s, reject);
        }

        // Address range: 0x1100 - 0x110b
        char * function_1100(char * s, int32_t n, struct _IO_FILE * stream) {
            // 0x1100
            return fgets(s, n, stream);
        }

        // Address range: 0x1110 - 0x111b
        int32_t function_1110(char * s1, char * s2) {
            // 0x1110
            return strcmp(s1, s2);
        }

        // Address range: 0x1120 - 0x112b
        int32_t function_1120(void) {
            // 0x1120
            return getchar();
        }

        // Address range: 0x1130 - 0x113b
        int32_t function_1130(char * format, ...) {
            // 0x1130
            return scanf(format);
        }

        // Address range: 0x1140 - 0x1166
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            // 0x1140
            int64_t v1; // 0x1140
            __libc_start_main(0x1764, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
            __asm_hlt();
            // UNREACHABLE
        }

        // Address range: 0x1170 - 0x1199
        int64_t deregister_tm_clones(void) {
            // 0x1170
            return 0x4010;
        }

        // Address range: 0x11a0 - 0x11d9
        int64_t register_tm_clones(void) {
            // 0x11a0
            return 0;
        }

        // Address range: 0x11e0 - 0x1219
        int64_t __do_global_dtors_aux(void) {
            // 0x11e0
            if (g3 != 0) {
                // 0x1218
                int64_t result; // 0x11e0
                return result;
            }
            // 0x11ed
            if (*(int64_t *)0x3ff8 != 0) {
                // 0x11fb
                __cxa_finalize((int64_t *)*(i",0
"//FormAI DATASET v1.0 Category: Online Examination System ; Style: cheerful
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define the struct for the student's information
typedef struct {
    char name[50];
    int roll;
} Student;

// Define the questions and correct answers
char questions[5][200] = {
    ""What is the capital of India?"",
    ""How many states are there in India?"",
    ""What is the national animal of India?"",
    ""Who is the current Prime Minister of India?"",
    ""What is the national language of India?""
};
char answers[5][50] = {
    ""New Delhi"",
    ""28"",
    ""Tiger"",
    ""Narendra Modi"",
    ""Hindi""
};

// Define the main function
int main() {
    
    // Initialize the variables required
    Student student;
    int i, j, marks = 0;
    char answer[50];
    
    printf(""\nWelcome to the Online Examination System!\n"");
    
    // Ask the student's name
    printf(""\nEnter your name: "");
    scanf(""%[^\n]"", student.name);
    
    // Ask the student's roll number
    printf(""Enter your roll number: "");
    scanf(""%d"", &student.roll);
    
    // Display the instructions for the exam
    printf(""\nWelcome %s (Roll Number: %d)!\n\n"", student.name, student.roll);
    printf(""Instructions:\n"");
    printf("" - The exam has 5 multiple choice questions.\n"");
    printf("" - Each question has only one correct answer.\n"");
    printf("" - You will be awarded 2 marks for each correct answer.\n"");
    printf("" - There is no negative marking for incorrect answers.\n"");
    printf("" - Good luck and have fun!\n\n"");
    
    // Start the exam
    for(i=0; i<5; i++) {
        printf(""%d. %s\n"", i+1, questions[i]);
        printf(""   Enter your answer: "");
        scanf(""%s"", answer);
        if(strcmp(answer, answers[i]) == 0) {
            marks += 2;
        }
    }
    
    // Display the results
    printf(""\nYour total marks: %d\n"", marks);
    if(marks >= 8) {
        printf(""Congratulations %s! You have passed the exam!\n"", student.name);
    } else {
        printf(""Sorry %s, you have failed the exam. Better luck next time!\n"", student.name);
    }
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(char * s);
void function_10a0(void);
int32_t function_10b0(char * format, ...);
int32_t function_10c0(char * s1, char * s2);
int32_t function_10d0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1; // 0x451a
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(void) {
    // 0x10a0
    __stack_chk_fail();
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return printf(format);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s1, char * s2) {
    // 0x10c0
    return strcmp(s1, s2);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return scanf(format);
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x11c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return 0x4520;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)0x451a != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x1434
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11d8
    puts(""\nWelcome to the Online Examination System!"");
    printf(""\nEnter your name: "");
    int64_t v2; // bp-136, 0x11c9
    scanf(""%[^\n]"", &v2);
    printf(""Enter your roll number: "");
    int64_t v3; // bp-84, 0x11c9
    scanf(""%d"", &v3);
    printf(""\nWelcome %s (Roll Number: %d)!\n\n"", &v2, v3 & 0xffffffff);
    puts(""Instructions:"");
    puts("" - The exam has 5 multiple choice questions."");
    puts("" - Each question has only one correct answer."");
    puts("" - You will be awarded 2 marks for each correct answer."");
    puts("" - There is no negative marking for incorrect answers."");
    puts("" - Good luck and have fun!\n"");
    int32_t v4 = 0;
    int64_t v5 = 0;
    int64_t v6 = v5 + 1;
    printf(""%d. %s\n"", v6, (char *)(200 * v5 + (int64_t)""What is the capital of India?""));
    printf(""   Enter your answer: "");
    int64_t str; // bp-72, 0x11c9
    scanf(""%s"", &str);
    int32_t strcmp_rc = strcmp((char *)&str, (char *)(50 * v5 + (int64_t)""New Delhi"")); // 0x1398
    int32_t v7 = strcmp_rc != 0 ? v4 : v4 + 2;
    while (v6 != 5) {
        // 0x12e9
        v4 = v7;
        v5 = v6;
        v6 = v5 + 1;
        printf(""%d. %s\n"", v6, (char *)(200 * v5 + (int64_t)""What is the capital of India?""));
        printf(""   Enter your answer: "");
        scanf(""%s"", &str);
        strcmp_rc = strcmp((char *)&str, (char *)(50 * v5 + (int64_t)""New Delhi""));
        v7 = strcmp_rc != 0 ? v4 : v4 + 2;
    }
    // 0x13bc
    printf(""\nYour total marks: %d\n"", (int64_t)v7);
    if (v7 < 8) {
        // 0x13fe
        printf(""Sorry %s, you have failed the exam. Better luck next time!\n"", &v2);
    } else {
        // 0x13e1
        printf(""Congratulations %s! You have passed the exam!\n"", &v2);
    }
    int64_t result = 0; // 0x142b
    if (v1 != __readfsqword(40)) {
        // 0x142d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1432
    return result;
}

// Address range: 0x1434 - 0x1441
int64_t _fini(void) {
    // 0x1434
    int64_t result; // 0x1434
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 14

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            puts(""\nWelcome to the Online Examination System!"");
            printf(""\nEnter your name: "");
            char name[100];
            scanf(""%[^\n]"", &name);
            printf(""Enter your roll number: "");
            int roll_no;
            scanf(""%d"", &roll_no);
            printf(""\nWelcome %s (Roll Number: %d)!\n\n"", name, roll_no);
            puts(""Instructions:"");
            puts("" - The exam has 5 multiple choice questions."");
            puts("" - Each question has only one correct answer."");
            puts("" - You will be awarded 2 marks for each correct answer."");
            puts("" - There is no negative marking for incorrect answers."");
            puts("" - Good luck and have fun!\n"");
            int marks = 0;
            int question_no = 1;
            while (question_no <= 5) {
                printf(""%d. %s\n"", question_no, ""What is the capital of India?"");
                printf(""   Enter your answer: "");
                char answer[100];
                scanf(""%s"", &answer);
                if (strcmp(answer, ""New Delhi"") == 0) {
                    marks += 2;
                }
                question_no++;
            }
            printf(""\nYour total marks: %d\n"", marks);
            if (marks < 8) {
                printf(""Sorry %s, you have failed the exam. Better luck next time!\n"", name);
            } else {
                printf(""Congratulations %s! You have passed the exam!\n"", name);
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Online Examination System ; Style: happy
#include <stdio.h>

// Function to display the welcome message
void welcomeMessage() {
  printf(""Welcome to the Online Examination System!\n"");
  printf(""******************************************************\n\n"");
}

// Function to display the list of available subjects
void subjectList() {
  printf(""What subject would you like to take the exam for?\n"");
  printf(""1. Mathematics\n"");
  printf(""2. Science\n"");
  printf(""3. English\n"");
  printf(""4. History\n"");
}

// Function to display the instructions before starting the exam
void examInstructions() {
  printf(""\n\nRead the following instructions carefully before starting the exam:\n"");
  printf(""1. You have 1 hour to complete the exam.\n"");
  printf(""2. The exam consists of 50 multiple choice questions.\n"");
  printf(""3. Each question carries 2 marks.\n"");
  printf(""4. There is no negative marking.\n"");
  printf(""******************************************************\n\n"");
}

// Function to take the user's choice of subject
int takeSubjectChoice() {
  int choice;
  printf(""Enter the subject choice (1-4): "");
  scanf(""%d"", &choice);
  return choice;
}

// Function to display the questions and get the user's answers
void takeExam(int subjectChoice) {
  int marks = 0;
  if (subjectChoice == 1) {
    printf(""Mathematics Exam:\n"");
    printf(""1. What is the value of pi?\n"");
    printf(""a. 3.14\nb. 2.71\nc. 1.23\nd. 4.56\n"");
    char answer;
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'a') {
      marks += 2;
    }
    printf(""\n2. What is the formula for finding the area of a circle?\n"");
    printf(""a. 2 * pi * r\nb. pi * r^2\nc. 2 * r^2\nd. pi * r\n"");
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'b') {
      marks += 2;
    }
  }
  else if (subjectChoice == 2) {
    printf(""Science Exam:\n"");
    printf(""1. What is the fundamental force that holds the nucleus of an atom together?\n"");
    printf(""a. Gravity\nb. Strong Force\nc. Weak Force\nd. Electromagnetic Force\n"");
    char answer;
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'b') {
      marks += 2;
    }
    printf(""\n2. Which of the following is a noble gas?\n"");
    printf(""a. Oxygen\nb. Nitrogen\nc. Helium\nd. Hydrogen\n"");
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'c') {
      marks += 2;
    }
  }
  else if (subjectChoice == 3) {
    printf(""English Exam:\n"");
    printf(""1. Identify the sentence that is written in active voice.\n"");
    printf(""a. The cake was baked by my grandma.\nb. The boy was bitten by the dog.\n"");
    printf(""c. The teacher was impressed by the student's essay.\nd. The storm was witnessed by everyone.\n"");
    char answer;
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'c') {
      marks += 2;
    }
    printf(""\n2. Which of the following is a synonym for 'beautiful'?\n"");
    printf(""a. Ugly\nb. Pretty\nc. Innocent\nd. Creative\n"");
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'b') {
      marks += 2;
    }
  }
  else if (subjectChoice == 4) {
    printf(""History Exam:\n"");
    printf(""1. Who was the first president of the United States?\n"");
    printf(""a. George Washington\nb. Thomas Jefferson\nc. John Adams\nd. Abraham Lincoln\n"");
    char answer;
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'a') {
      marks += 2;
    }
    printf(""\n2. When did World War II end?\n"");
    printf(""a. 1945\nb. 1939\nc. 1941\nd. 1940\n"");
    printf(""Enter your answer (a/b/c/d): "");
    scanf("" %c"", &answer);
    if (answer == 'a') {
      marks += 2;
    }
  }
  else {
    printf(""Invalid subject choice!\n"");
    return;
  }
  printf(""\n\nCongratulations on completing the exam!\n"");
  printf(""Your total marks for the exam is %d out of 10.\n"", marks);
}

int main() {
  welcomeMessage();
  subjectList();
  int subjectChoice = takeSubjectChoice();
  examInstructions();
  takeExam(subjectChoice);
  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t examInstructions(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);
int64_t subjectList(void);
int64_t takeExam(int64_t a1);
int64_t takeSubjectChoice(void);
int64_t welcomeMessage(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x16bc, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x11d2
int64_t welcomeMessage(void) {
    // 0x11a9
    puts(""Welcome to the Online Examination System!"");
    return puts(""******************************************************\n"");
}

// Address range: 0x11d2 - 0x1228
int64_t subjectList(void) {
    // 0x11d2
    puts(""What subject would you like to take the exam for?"");
    puts(""1. Mathematics"");
    puts(""2. Science"");
    puts(""3. English"");
    return puts(""4. History"");
}

// Address range: 0x1228 - 0x128d
int64_t examInstructions(void) {
    // 0x1228
    puts(""\n\nRead the following instructions carefully before starting the exam:"");
    puts(""1. You have 1 hour to complete the exam."");
    puts(""2. The exam consists of 50 multiple choice questions."");
    puts(""3. Each question carries 2 marks."");
    puts(""4. There is no negative marking."");
    return puts(""******************************************************\n"");
}

// Address range: 0x128d - 0x12f0
int64_t takeSubjectChoice(void) {
    int64_t v1 = __readfsqword(40); // 0x1299
    printf(""Enter the subject choice (1-4): "");
    int64_t v2; // bp-20, 0x128d
    scanf(""%d"", &v2);
    int64_t result = v2 & 0xffffffff; // 0x12e7
    if (v1 != __readfsqword(40)) {
        // 0x12e9
        __stack_chk_fail();
        result = &g2;
    }
    // 0x12ee
    return result;
}

// Address range: 0x12f0 - 0x16bc
int64_t takeExam(int64_t a1) {
    int32_t v1 = a1; // 0x12fc
    int64_t v2 = __readfsqword(40); // 0x12ff
    int32_t v3; // 0x12f0
    char v4; // bp-21, 0x12f0
    if (v1 != 1) {
        if (v1 != 2) {
            if (v1 != 3) {
                if (v1 != 4) {
                    // 0x166d
                    puts(""Invalid subject choice!"");
                    goto lab_0x16a6;
                } else {
                    // 0x15aa
                    puts(""History Exam:"");
                    puts(""1. Who was the first president of the United States?"");
                    puts(""a. George Washington\nb. Thomas Jefferson\nc. John Adams\nd. Abraham Lincoln"");
                    printf(""Enter your answer (a/b/c/d): "");
                    scanf("" %c"", &v4);
                    int32_t v5 = v4 != 97 ? 0 : 2;
                    puts(""\n2. When did World War II end?"");
                    puts(""a. 1945\nb. 1939\nc. 1941\nd. 1940"");
                    printf(""Enter your answer (a/b/c/d): "");
                    scanf("" %c"", &v4);
                    v3 = v4 != 97 ? v5 : v5 + 2;
                    goto lab_0x167e;
                }
            } else {
                // 0x14c7
                puts(""English Exam:"");
                puts(""1. Identify the sentence that is written in active voice."");
                puts(""a. The cake was baked by my grandma.\nb. The boy was bitten by the dog."");
                puts(""c. The teacher was impressed by the student's essay.\nd. The storm was witnessed by everyone."");
                printf(""Enter your answer (a/b/c/d): "");
                scanf("" %c"", &v4);
                int32_t v6 = v4 != 99 ? 0 : 2;
                puts(""\n2. Which of the following is a synonym for 'beautiful'?"");
                puts(""a. Ugly\nb. Pretty\nc. Innocent\nd. Creative"");
                printf(""Enter your answer (a/b/c/d): "");
                scanf("" %c"", &v4);
                v3 = v4 != 98 ? v6 : v6 + 2;
                goto lab_0x167e;
            }
        } else {
            // 0x13f3
            puts(""Science Exam:"");
            puts(""1. What is the fundamental force that holds the nucleus of an atom together?"");
            puts(""a. Gravity\nb. Strong Force\nc. Weak Force\nd. Electromagnetic Force"");
            printf(""Enter your answer (a/b/c/d): "");
            scanf("" %c"", &v4);
            int32_t v7 = v4 != 98 ? 0 : 2;
            puts(""\n2. Which of the following is a noble gas?"");
            puts(""a. Oxygen\nb. Nitrogen\nc. Helium\nd. Hydrogen"");
            printf(""Enter your answer (a/b/c/d): "");
            scanf("" %c"", &v4);
            v3 = v4 != 99 ? v7 : v7 + 2;
            goto lab_0x167e;
        }
    } else {
        // 0x131f
        puts(""Mathematics Exam:"");
        puts(""1. What is the value of pi?"");
        puts(""a. 3.14\nb. 2.71\nc. 1.23\nd. 4.56"");
        printf(""Enter your answer (a/b/c/d): "");
        scanf("" %c"", &v4);
        int32_t v8 = v4 != 97 ? 0 : 2;
        puts(""\n2. What is the formula for finding the area of a circle?"");
        puts(""a. 2 * pi * r\nb. pi * r^2\nc. 2 * r^2\nd. pi * r"");
        printf(""Enter your answer (a/b/c/d): "");
        scanf("" %c"", &v4);
        v3 = v4 != 98 ? v8 : v8 + 2;
        goto lab_0x167e;
    }
  lab_0x167e:
    // 0x167e
    puts(""\n\nCongratulations on completing the exam!"");
    printf(""Your total marks for the exam is %d out of 10.\n"", (int64_t)v3);
    goto lab_0x16a6;
  lab_0x16a6:;
    int64_t result = 0; // 0x16b3
    if (v2 != __readfsqword(40)) {
        // 0x16b5
        __stack_chk_fail();
        result = &g2;
    }
    // 0x16ba
    return result;
}

// Address range: 0x16bc - 0x1704
int main(int argc, char ** argv) {
    // 0x16bc
    welcomeMessage();
    subjectList();
    int64_t v1 = takeSubjectChoice(); // 0x16e1
    examInstructions();
    takeExam(v1 & 0xffffffff);
    return 0;
}

// Address range: 0x1704 - 0x1711
int64_t _fini(void) {
    // 0x1704
    int64_t result; // 0x1704
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <math.h>
        #include <time.h>
        #include <stdbool.h>
        #include <assert.h>
        #include <limits.h>
        #include <ctype.h>
        #include <stdint.h>
        #include <stddef.h>
        #include <stdarg.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <complex.h>
        #include <fenv.h>
        #include <search.h>
        #include <regex.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <sys/time.h>
        #include <sys/resource.h>
        #include <sys/utsname.h>
        #include <sys/uio.h>
        #include <sys/un.h>
        #include <sys/ipc.h>
        #include <sys/sem.h>
        #include <sys/shm.h>
        #include <sys/msg.h>
        #include <sys/statvfs.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/xattr.h>
        #include <sys/acct.h>
        #include <sys/fcntl.h>
        #include <sys/file.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signalfd.h>
        #include <sys/timerfd.h>
        #include <sys/fanotify.h>
        #include <sys/ioctl.h>
        #include <sys/termios.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/time.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/utsname.h>
        #include <sys/vfs.h>
        #include <sys/wait.h>
        #include <sys/xattr.h>
        #include <sys/epoll.h>
        #include <sys/inotify.h>
        #include <sys/signal",0
"//FormAI DATASET v1.0 Category: File Synchronizer ; Style: interoperable
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <stdbool.h>

void synchronize(char* dirPath1, char* dirPath2){
  DIR *dir1, *dir2;
  struct dirent *dp1, *dp2;
  struct stat statbuf1, statbuf2;
  char filePath1[256], filePath2[256];

  // open the directories dirPath1 and dirPath2
  dir1 = opendir(dirPath1);
  dir2 = opendir(dirPath2);

  if(dir1 == NULL){
    printf(""Error opening directory: %s"", dirPath1);
    return;
  }

  if(dir2 == NULL){
    printf(""Error opening directory: %s"", dirPath2);
    return;
  }

  // iterate over all the files and directories in dirPath1
  while((dp1 = readdir(dir1)) != NULL){

    // ignore . and .. directories
    if(strcmp(dp1->d_name, ""."") == 0 || strcmp(dp1->d_name, "".."") == 0){
      continue;
    }

    // create the full file path1
    sprintf(filePath1, ""%s/%s"", dirPath1, dp1->d_name);

    // get the file status information for the file at filePath1
    if(stat(filePath1, &statbuf1) == -1){
      printf(""Error getting file information: %s"", filePath1);
      continue;
    }

    // iterate over all files and directories in dirPath2
    while((dp2 = readdir(dir2)) != NULL){

      // ignore . and .. directories
      if(strcmp(dp2->d_name, ""."") == 0 || strcmp(dp2->d_name, "".."") == 0){
        continue;
      }

      // create the full file path2
      sprintf(filePath2, ""%s/%s"", dirPath2, dp2->d_name);

      // get the file status information for the file at filePath2
      if(stat(filePath2, &statbuf2) == -1){
        printf(""Error getting file information: %s"", filePath2);
        continue;
      }

      // check if the file names and sizes match
      if(strcmp(dp1->d_name, dp2->d_name) == 0 && statbuf1.st_size == statbuf2.st_size){

        // check if the files are the same
        FILE* file1 = fopen(filePath1, ""rb"");
        FILE* file2 = fopen(filePath2, ""rb"");
        int c1, c2;
        bool filesAreEqual = true;

        while((c1 = getc(file1)) != EOF && (c2 = getc(file2)) != EOF){
          if(c1 != c2){
            filesAreEqual = false;
            break;
          }
        }

        if(filesAreEqual){
          printf(""File %s is already synchronized\n"", filePath1);
          fclose(file1);
          fclose(file2);
          break;
        }

        // if the files do not match, replace the file in dirPath2 with the one in dirPath1
        printf(""Replacing file %s in %s with file from %s\n"", dp2->d_name, dirPath2, dirPath1);
        fclose(file1);
        fclose(file2);
        remove(filePath2);
        rename(filePath1, filePath2);
        break;

      }

    }

    // if the file is not found in dirPath2, create it
    if(dp2 == NULL){
      printf(""File %s is not found in %s, creating it...\n"", dp1->d_name, dirPath2);
      char cmd[256];
      sprintf(cmd, ""cp %s %s"", filePath1, dirPath2);
      system(cmd);
    }

    // go back to the beginning of dirPath2
    rewinddir(dir2);

  }

  // iterate over all the files in dirPath2
  while((dp2 = readdir(dir2)) != NULL){

    // ignore . and .. directories
    if(strcmp(dp2->d_name, ""."") == 0 || strcmp(dp2->d_name, "".."") == 0){
      continue;
    }

    // create the full file path2
    sprintf(filePath2, ""%s/%s"", dirPath2, dp2->d_name);

    // get the file status information for the file at filePath2
    if(stat(filePath2, &statbuf2) == -1){
      printf(""Error getting file information: %s"", filePath2);
      continue;
    }

    // iterate over all files and directories in dirPath1 to check if the file is already synchronized
    bool fileIsSynchronized = false;

    while((dp1 = readdir(dir1)) != NULL){

      // ignore . and .. directories
      if(strcmp(dp1->d_name, ""."") == 0 || strcmp(dp1->d_name, "".."") == 0){
        continue;
      }

      // create the full file path1
      sprintf(filePath1, ""%s/%s"", dirPath1, dp1->d_name);

      // get the file status information for the file at filePath1
      if(stat(filePath1, &statbuf1) == -1){
        printf(""Error getting file information: %s"", filePath1);
        continue;
      }

      // check if the file names and sizes match
      if(strcmp(dp1->d_name, dp2->d_name) == 0 && statbuf1.st_size == statbuf2.st_size){

        // check if the files are the same
        FILE* file1 = fopen(filePath1, ""rb"");
        FILE* file2 = fopen(filePath2, ""rb"");
        int c1, c2;
        bool filesAreEqual = true;

        while((c1 = getc(file1)) != EOF && (c2 = getc(file2)) != EOF){
          if(c1 != c2){
            filesAreEqual = false;
            break;
          }
        }

        if(filesAreEqual){
          fileIsSynchronized = true;
          fclose(file1);
          fclose(file2);
          break;
        }

        fclose(file1);
        fclose(file2);
        break;

      }

    }

    // if the file is not found in dirPath1, delete it from dirPath2
    if(dp1 == NULL && !fileIsSynchronized){
      printf(""Deleting file %s from %s\n"", dp2->d_name, dirPath2);
      remove(filePath2);
    }

    // go back to the beginning of dirPath1
    rewinddir(dir1);

  }

  // close the directories
  closedir(dir1);
  closedir(dir2);

}

int main(int argc, char** argv){
  if(argc != 3){
    printf(""Usage: ./synchronizer dir1 dir2\n"");
    return 1;
  }
  printf(""Synchronizing %s and %s...\n"", argv[1], argv[2]);
  synchronize(argv[1], argv[2]);
  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <dirent.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct stat {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1130(int64_t * d);
int32_t function_1140(char * filename);
int32_t function_1150(char * s);
int32_t function_1160(struct _IO_FILE * stream);
struct __dirstream * function_1170(char * name);
void function_1180(void);
int32_t function_1190(char * command);
int32_t function_11a0(char * format, ...);
void function_11b0(struct __dirstream * dirp);
int32_t function_11c0(struct __dirstream * dirp);
int32_t function_11d0(char * s1, char * s2);
int32_t function_11e0(char * file, struct stat * buf);
struct dirent * function_11f0(struct __dirstream * dirp);
struct _IO_FILE * function_1200(char * filename, char * modes);
int32_t function_1210(char * old, char * new);
int32_t function_1220(char * s, char * format, ...);
int32_t function_1230(struct _IO_FILE * stream);
int64_t register_tm_clones(void);
int64_t synchronize(int64_t a1, int64_t a2);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1130 - 0x113b
void function_1130(int64_t * d) {
    // 0x1130
    __cxa_finalize(d);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * filename) {
    // 0x1140
    return remove(filename);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * s) {
    // 0x1150
    return puts(s);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(struct _IO_FILE * stream) {
    // 0x1160
    return fclose(stream);
}

// Address range: 0x1170 - 0x117b
struct __dirstream * function_1170(char * name) {
    // 0x1170
    return opendir(name);
}

// Address range: 0x1180 - 0x118b
void function_1180(void) {
    // 0x1180
    __stack_chk_fail();
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(char * command) {
    // 0x1190
    return system(command);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(char * format, ...) {
    // 0x11a0
    return printf(format);
}

// Address range: 0x11b0 - 0x11bb
void function_11b0(struct __dirstream * dirp) {
    // 0x11b0
    rewinddir(dirp);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(struct __dirstream * dirp) {
    // 0x11c0
    return closedir(dirp);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(char * s1, char * s2) {
    // 0x11d0
    return strcmp(s1, s2);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(char * file, struct stat * buf) {
    // 0x11e0
    return stat(file, buf);
}

// Address range: 0x11f0 - 0x11fb
struct dirent * function_11f0(struct __dirstream * dirp) {
    // 0x11f0
    return readdir(dirp);
}

// Address range: 0x1200 - 0x120b
struct _IO_FILE * function_1200(char * filename, char * modes) {
    // 0x1200
    return fopen(filename, modes);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(char * old, char * new) {
    // 0x1210
    return rename(old, new);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(char * s, char * format, ...) {
    // 0x1220
    return sprintf(s, format);
}

// Address range: 0x1230 - 0x123b
int32_t function_1230(struct _IO_FILE * stream) {
    // 0x1230
    return getc(stream);
}

// Address range: 0x1240 - 0x1266
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1240
    int64_t v1; // 0x1240
    __libc_start_main(0x1b48, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1270 - 0x1299
int64_t deregister_tm_clones(void) {
    // 0x1270
    return &g1;
}

// Address range: 0x12a0 - 0x12d9
int64_t register_tm_clones(void) {
    // 0x12a0
    return 0;
}

// Address range: 0x12e0 - 0x1319
int64_t __do_global_dtors_aux(void) {
    // 0x12e0
    if (*(char *)&g1 != 0) {
        // 0x1318
        int64_t result; // 0x12e0
        return result;
    }
    // 0x12ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1307
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1320 - 0x1329
int64_t frame_dummy(void) {
    // 0x1320
    return register_tm_clones();
}

// Address range: 0x1329 - 0x1b48
int64_t synchronize(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x1346
    char * name = (char *)a1; // 0x135f
    struct __dirstream * dirp = opendir(name); // 0x135f
    char * name2 = (char *)a2; // 0x1375
    struct __dirstream * dirp2 = opendir(name2); // 0x1375
    struct dirent * v2; // 0x1329
    struct dirent * v3; // 0x1329
    int64_t str4; // bp-536, 0x1329
    int64_t str2; // bp-792, 0x1329
    char * str3; // 0x1329
    struct _IO_FILE * file; // 0x15a9
    struct _IO_FILE * file2; // 0x15c9
    struct _IO_FILE * file3; // 0x1992
    struct _IO_FILE * file4; // 0x19b2
    if (dirp != NULL) {
        if (dirp2 != NULL) {
            struct dirent * v4 = readdir(dirp); // 0x17a1
            int64_t buf; // bp-1080, 0x1329
            int64_t buf2; // bp-936, 0x1329
            if (v4 != NULL) {
                // 0x13df
                v2 = v4;
                while (true) {
                  lab_0x13df:;
                    char * str = (char *)((int64_t)v2 + 19); // 0x13f7
                    if (strcmp(str, ""."") == 0) {
                        goto lab_0x1797;
                    } else {
                        // 0x1404
                        if (strcmp(str, "".."") != 0) {
                            // 0x142a
                            sprintf((char *)&str2, ""%s/%s"", name, str);
                            if (stat((char *)&str2, (struct stat *)&buf) != -1) {
                                struct dirent * v5 = readdir(dirp2); // 0x1700
                                struct dirent * v6 = v5; // 0x1714
                                if (v5 != NULL) {
                                    str3 = (char *)((int64_t)v6 + 19);
                                    if (strcmp(str3, ""."") != 0) {
                                        // 0x14c1
                                        if (strcmp(str3, "".."") != 0) {
                                            // 0x14e7
                                            sprintf((char *)&str4, ""%s/%s"", name2, str3);
                                            if (stat((char *)&str4, (struct stat *)&buf2) != -1) {
                                                // 0x1555
                                                if (true == strcmp(str, str3) == 0) {
                                                    // 0x1595
                                                    file = fopen((char *)&str2, ""rb"");
                                                    file2 = fopen((char *)&str4, ""rb"");
                                                    goto lab_0x15f5;
                                                }
                                            } else {
                                                // 0x1532
                                                printf(""Error getting file information: %s"", &str4);
                                            }
                                        }
                                    }
                                    struct dirent * v7 = readdir(dirp2); // 0x1700
                                    while (v7 != NULL) {
                                        // 0x149c
                                        str3 = (char *)((int64_t)v7 + 19);
                                        if (strcmp(str3, ""."") != 0) {
                                            // 0x14c1
                                            if (strcmp(str3, "".."") != 0) {
                                                // 0x14e7
                                                sprintf((char *)&str4, ""%s/%s"", name2, str3);
                                                if (stat((char *)&str4, (struct stat *)&buf2) != -1) {
                                                    // 0x1555
                                                    if (true == strcmp(str, str3) == 0) {
                                                        // 0x1595
                                                        file = fopen((char *)&str2, ""rb"");
                                                        file2 = fopen((char *)&str4, ""rb"");
                                                        goto lab_0x15f5;
                                                    }
                                                } else {
                                                    // 0x1532
                                                    printf(""Error getting file information: %s"", &str4);
                                                }
                                            }
                                        }
                                        // 0x16f6
                                        v7 = readdir(dirp2);
                                    }
                                }
                                // 0x1724
                                printf(""File %s is not found in %s, creating it...\n"", str, name2);
                                int64_t str5; // bp-280, 0x1329
                                sprintf((char *)&str5, ""cp %s %s"", &str2, name2);
                                system((char *)&str5);
                                // 0x1788
                                rewinddir(dirp2);
                                goto lab_0x1797;
                            } else {
                                // 0x1479
                                printf(""Error getting file information: %s"", &str2);
                                goto lab_0x1797;
                            }
                        } else {
                            goto lab_0x1797;
                        }
                    }
                }
            }
          lab_0x1af0_2:;
            struct dirent * v8 = readdir(dirp2); // 0x1afa
            if (v8 != NULL) {
                // 0x17c0
                v3 = v8;
                while (true) {
                  lab_0x17c0:;
                    char * str6 = (char *)((int64_t)v3 + 19); // 0x17d8
                    if (strcmp(str6, ""."") == 0) {
                        goto lab_0x1af0;
                    } else {
                        // 0x17e5
                        if (strcmp(str6, "".."") != 0) {
                            // 0x180b
                            sprintf((char *)&str4, ""%s/%s"", name2, str6);
                            int32_t v9 = stat((char *)&str4, (struct stat *)&buf2); // 0x184c
                            if (v9 != -1) {
                                struct dirent * v10 = readdir(dirp); // 0x1a74
                                struct dirent * v11 = v10; // 0x1a88
                                if (v10 != NULL) {
                                    struct dirent * v12 = v11;
                                    char * str7 = (char *)((int64_t)v12 + 19); // 0x189d
                                    int64_t v13; // 0x1329
                                    int64_t v14; // 0x1329
                                    int32_t v15; // 0x1911
                                    if (strcmp(str7, ""."") != 0) {
                                        // 0x18aa
                                        if (strcmp(str7, "".."") != 0) {
                                            // 0x18d0
                                            sprintf((char *)&str2, ""%s/%s"", name, str7);
                                            v15 = stat((char *)&str2, (struct stat *)&buf);
                                            if (v15 != -1) {
                                                // 0x193e
                                                if (v14 == v13 == strcmp(str7, str6) == 0) {
                                                    // 0x197e
                                                    file3 = fopen((char *)&str2, ""rb"");
                                                    file4 = fopen((char *)&str4, ""rb"");
                                                    goto lab_0x19de;
                                                }
                                            } else {
                                                // 0x191b
                                                printf(""Error getting file information: %s"", &str2);
                                            }
                                        }
                                    }
                                    struct dirent * v16 = readdir(dirp); // 0x1a74
                                    v11 = v16;
                                    while (v16 != NULL) {
                                        // 0x1885
                                        v12 = v11;
                                        str7 = (char *)((int64_t)v12 + 19);
                                        if (strcmp(str7, ""."") != 0) {
                                            // 0x18aa
                                            if (strcmp(str7, "".."") != 0) {
                                                // 0x18d0
                                                sprintf((char *)&str2, ""%s/%s"", name, str7);
                                                v15 = stat((char *)&str2, (struct stat *)&buf);
                                                if (v15 != -1) {
                                                    // 0x193e
                                                    if (v14 == v13 == strcmp(str7, str6) == 0) {
                                                        // 0x197e
                                                        file3 = fopen((char *)&str2, ""rb"");
                                                        file4 = fopen((char *)&str4, ""rb"");
                                                        goto lab_0x19de;
                                                    }
                                                } else {
                                                    // 0x191b
                                                    printf(""Error getting file information: %s"", &str2);
                                                }
                                            }
                                        }
                                        // 0x1a6a
                                        v16 = readdir(dirp);
                                        v11 = v16;
                                    }
                                }
                                // 0x1aa6
                                printf(""Deleting file %s from %s\n"", str6, name2);
                                remove((char *)&str4);
                                // 0x1ae1
                                rewinddir(dirp);
                                goto lab_0x1af0;
                            } else {
                                // 0x1856
                                printf(""Error getting file information: %s"", &str4);
                                goto lab_0x1af0;
                            }
                        } else {
                            goto lab_0x1af0;
                        }
                    }
                }
            }
          lab_0x1b14:
            // 0x1b14
            closedir(dirp);
            closedir(dirp2);
        } else {
            // 0x13bc
            printf(""Error opening directory: %s"", name2);
        }
    } else {
        // 0x138b
        printf(""Error opening directory: %s"", name);
    }
    int64_t result = 0; // 0x1b3f
    if (v1 != __readfsqword(40)) {
        // 0x1b41
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1b46
    return result;
  lab_0x1af0:;
    struct dirent * v17 = readdir(dirp2); // 0x1afa
    v3 = v17;
    if (v17 == NULL) {
        // break -> 0x1b14
        goto lab_0x1b14;
    }
    goto lab_0x17c0;
  lab_0x1797:;
    struct dirent * v18 = readdir(dirp); // 0x17a1
    v2 = v18;
    if (v18 == NULL) {
        // break -> 0x1af0
        goto lab_0x1af0_2;
    }
    goto lab_0x13df;
  lab_0x19de:;
    int32_t c = getc(file3); // 0x19e8
    if (c == -1) {
        // 0x1ae1
        fclose(file3);
        fclose(file4);
        // 0x1ae1
        rewinddir(dirp);
        goto lab_0x1af0;
    } else {
        int32_t c2 = getc(file4); // 0x1a06
        if (c2 != -1) {
            if (c == c2) {
                goto lab_0x19de;
            } else {
                // 0x1a1a
                fclose(file3);
                fclose(file4);
                // 0x1ae1
                rewinddir(dirp);
                goto lab_0x1af0;
            }
        } else {
            // 0x1ae1
            fclose(file3);
            fclose(file4);
            // 0x1ae1
            rewinddir(dirp);
            goto lab_0x1af0;
        }
    }
  lab_0x15f5:;
    int32_t c3 = getc(file); // 0x15ff
    if (c3 == -1) {
        goto lab_0x163a;
    } else {
        int32_t c4 = getc(file2); // 0x161d
        if (c4 != -1) {
            if (c3 == c4) {
                goto lab_0x15f5;
            } else {
                // 0x167b
                printf(""Replacing file %s in %s with file from %s\n"", str3, name2, name);
                fclose(file);
                fclose(file2);
                remove((char *)&str4);
                rename((char *)&str2, (char *)&str4);
                // 0x1788
                rewinddir(dirp2);
                goto lab_0x1797;
            }
        } else {
            goto lab_0x163a;
        }
    }
  lab_0x163a:
    // 0x163a
    printf(""File %s is already synchronized\n"", &str2);
    fclose(file);
    fclose(file2);
    // 0x1788
    rewinddir(dirp2);
    goto lab_0x1797;
}

// Address range: 0x1b48 - 0x1bcc
int main(int argc, char ** argv) {
    int64_t result; // 0x1b48
    if ((int32_t)argc == 3) {
        int64_t v1 = (int64_t)argv; // 0x1b77
        int64_t * v2 = (int64_t *)(v1 + 16); // 0x1b7f
        int64_t * v3 = (int64_t *)(v1 + 8); // 0x1b8a
        printf(""Synchronizing %s and %s...\n"", (char *)*v3, (char *)*v2);
        synchronize(*v3, *v2);
        result = 0;
    } else {
        // 0x1b61
        puts(""Usage: ./synchronizer dir1 dir2"");
        result = 1;
    }
    // 0x1bca
    return result;
}

// Address range: 0x1bcc - 0x1bd9
int64_t _fini(void) {
    // 0x1bcc
    int64_t result; // 0x1bcc
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 26

","nclude <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

int main(int argc, char ** argv) {
    if ((int32_t)argc == 3) {
        int64_t v1 = (int64_t)argv; // 0x1b77
        int64_t * v2 = (int64_t *)(v1 + 16); // 0x1b7f
        int64_t * v3 = (int64_t *)(v1 + 8); // 0x1b8a
        printf(""Synchronizing %s and %s...\n"", (char *)*v3, (char *)*v2);
        synchronize(*v3, *v2);
        return 0;
    } else {
        puts(""Usage: ./synchronizer dir1 dir2"");
        return 1;
    }
}

int synchronize(char * old, char * new) {
    char * name = old; // 0x135f
    struct __dirstream * dirp = opendir(name); // 0x135f
    char * name2 = new; // 0x1375
    struct __dirstream * dirp2 = opendir(name2); // 0x1375
    struct dirent * v2; // 0x1329
    struct dirent * v3; // 0x1329
    int64_t str4; // bp-536, 0x1329
    int64_t str2; // bp-792, 0x1329
    char * str3; // 0x1329
    struct _IO_FILE * file; // 0x15a9
    struct _IO_FILE * file2; // 0x15c9
    struct _IO_FILE * file3; // 0x1992
    struct _IO_FILE * file4; // 0x19b2
    if (dirp != NULL) {
        if (dirp2 != NULL) {
            struct dirent * v4 = readdir(dirp); // 0x17a1
            int64_t buf; // bp-1080, 0x1329
            int64_t buf2; // bp-936, 0x1329
            if (v4 != NULL) {
                // 0x13df
                v2 = v4;
                while (true) {
                  lab_0x13df:;
                    char * str = (char *)((int64_t)v2 + 19); // 0x13f7
                    if (strcmp(str, ""."") == 0) {
                        goto lab_0x1797;
                    } else {
                        // 0x1404
                        if (strcmp(str, "".."") != 0) {
                            // 0x142a
                            sprintf((char *)&str2, ""%s/%s"", name, str);
                            if (stat((char *)&str2, (struct stat *)&buf) != -1) {
                                struct dirent * v5 = readdir(dirp2); // 0x1700
                                struct dirent * v6 = v5; // 0x1714
                                if (v5 != NULL) {
                                    str3 = (char *)((int64_t)v6 + 19);
                                    if (strcmp(str3, ""."") != 0) {
                                        // 0x14c1
                                        if (strcmp(str3, "".."") != 0) {
                                            // 0x14e7
                                            sprintf((char *)&str4, ""%s/%s"", name2, str3);
                                            if (stat((char *)&str4, (struct stat *)&buf2) != -1) {
                                                // 0x1555
                                                if (true == strcmp(str, str3) == 0) {
                                                    // 0x1595
                                                    file = fopen((char *)&str2, ""rb"");
                                                    file2 = fopen((char *)&str4, ""rb"");
                                                    goto lab_0x15f5;
                                                }
                                            } else {
                                                // 0x1532
                                                printf(""Error getting file information: %s"", &str4);
                                            }
                                        }
                                    }
                                    struct dirent * v7 = readdir(dirp2); // 0x1700
                                    while (v7 != NULL) {
                                        // 0x149c
                                        str3 = (char *)((int64_t)v7 + 19);
                                        if (strcmp(str3, ""."") != 0) {
                                            // 0x14c1
                                            if (strcmp(str3, "".."") != 0) {
                                                // 0x14e7
                                                sprintf((char *)&str4, ""%s/%s"", name2, str3);
                                                if (stat((char *)&str4, (struct stat *)&buf2) != -1) {
                                                    // 0x1555
                                                    if (true == strcmp(str, str3) == 0) {
                                                        // 0x1595
                                                        file = fopen((char *)&str2, ""rb"");
                                                        file2 = fopen((char *)&str4, ""rb"");
                                                        goto lab_0x15f5;
                                                    }
                                                } else {
                                                    // 0x1532
                                                    printf(""Error getting file information: %s"", &str4);
                                                }
                                            }
                                        }
                                        // 0x16f6
                                        v7 = readdir(dirp2);
                                    }
                                }
                                // 0x1724
                                printf(""File %s is not found in %s, creating it...\n"", str, name2);
                                int64_t str5; // bp-280, 0x1329
                                sprintf((char *)&str5, ""cp %s %s"", &str2, name2);
                                system((char *)&str5);
                                // 0x1788
                                rewinddir(dirp2);
                                goto lab_0x1797;
                            } else {
                                // 0x1479
                                printf(""Error getting file information: %s"", &str2);
                                goto lab_0x1797;
                            }
                        } else {
                            goto lab_0x1797;
                        }
                    }
                }
            }
          lab_0x1af0_2:;
            struct dirent * v8 = readdir(dirp2); // 0x1afa
            if (v8 != NULL) {
                // 0x17c0
                v3 = v8;
                while (true) {
                  lab_0x17c0:;
                    char * str6 = (char *)((int64_t)v3 + 19); // 0x17d8
                    if (strcmp(str6, ""."") == 0) {
                        goto lab_0x1af0;
                    } else {
                        // 0x17e5
                        if (strcmp(str6, "".."") != 0) {
                            // 0x180b
                            sprintf((char *)&str4, ""%s/%s"", name2, str6);
                            int3",1
"//FormAI DATASET v1.0 Category: Hotel Management System ; Style: brave
#include <stdio.h>
#include <stdlib.h>

struct Room {
  int room_number;
  char room_type[10];
  int occupancy;
  float room_charge;
};

struct Room rooms[50];
int num_rooms = 0;

void display_menu();
void find_room();
void add_room();
void remove_room();
void display_rooms();
void calculate_cost();

int main() {
  int choice;
  
  do {
    display_menu();
    printf(""Enter your choice: "");
    scanf(""%d"", &choice);
    
    switch(choice) {
      case 1:
        find_room();
        break;
      case 2:
        add_room();
        break;
      case 3:
        remove_room();
        break;
      case 4:
        display_rooms();
        break;
      case 5:
        calculate_cost();
        break;
      case 6:
        printf(""Goodbye!"");
        break;
      default:
        printf(""Invalid choice! Try again.\n"");
        break;
    }
  } while(choice != 6);

  return 0;
}

void display_menu() {
  printf(""\n=== C Hotel Management System ===\n"");
  printf(""1. Find a room\n"");
  printf(""2. Add a room\n"");
  printf(""3. Remove a room\n"");
  printf(""4. Display all rooms\n"");
  printf(""5. Calculate cost\n"");
  printf(""6. Exit\n"");
}

void find_room() {
  int room_number, i, found = 0;
  
  printf(""Enter room number: "");
  scanf(""%d"", &room_number);
  
  for(i = 0; i < num_rooms; i++) {
    if(rooms[i].room_number == room_number) {
      found = 1;
      printf(""Room type: %s\n"", rooms[i].room_type);
      printf(""Occupancy: %d\n"", rooms[i].occupancy);
      printf(""Room charge: %.2f\n"", rooms[i].room_charge);
      break;
    }
  }
  
  if(!found) {
    printf(""Room not found!\n"");
  }
}

void add_room() {
  int room_number, occupancy;
  char room_type[10];
  float room_charge;
  
  printf(""Enter room number: "");
  scanf(""%d"", &room_number);
  
  printf(""Enter room type: "");
  scanf(""%s"", room_type);
  
  printf(""Enter room occupancy: "");
  scanf(""%d"", &occupancy);
  
  printf(""Enter room charge: "");
  scanf(""%f"", &room_charge);
  
  if(num_rooms < 50) {
    rooms[num_rooms].room_number = room_number;
    strcpy(rooms[num_rooms].room_type, room_type);
    rooms[num_rooms].occupancy = occupancy;
    rooms[num_rooms].room_charge = room_charge;
    
    num_rooms++;
    
    printf(""Room added successfully!\n"");
  } else {
    printf(""Maximum rooms reached!\n"");
  }
}

void remove_room() {
  int room_number, i, found = 0;
  
  printf(""Enter room number: "");
  scanf(""%d"", &room_number);
  
  for(i = 0; i < num_rooms; i++) {
    if(rooms[i].room_number == room_number) {
      found = 1;
      
      // Shift elements to the left
      for(int j = i; j < num_rooms - 1; j++) {
        rooms[j] = rooms[j+1];
      }
      
      num_rooms--;
      
      printf(""Room removed successfully!\n"");
      break;
    }
  }
  
  if(!found) {
    printf(""Room not found!\n"");
  }
}

void display_rooms() {
  printf(""List of all rooms:\n"");
  for(int i = 0; i < num_rooms; i++) {
    printf(""Room number: %d\n"", rooms[i].room_number);
    printf(""Room type: %s\n"", rooms[i].room_type);
    printf(""Occupancy: %d\n"", rooms[i].occupancy);
    printf(""Room charge: %.2f\n"", rooms[i].room_charge);
    printf(""-------------------------------\n"");
  }
}

void calculate_cost() {
  int room_number, num_nights;
  float cost;
  
  printf(""Enter room number: "");
  scanf(""%d"", &room_number);
  
  printf(""Enter number of nights: "");
  scanf(""%d"", &num_nights);
  
  for(int i = 0; i < num_rooms; i++) {
    if(rooms[i].room_number == room_number) {
      cost = rooms[i].room_charge * num_nights;
      printf(""Total cost: %.2f\n"", cost);
      break;
    }
  }
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t add_room(void);
int64_t calculate_cost(void);
int64_t deregister_tm_clones(void);
int64_t display_menu(void);
int64_t display_rooms(void);
int64_t find_room(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
char * function_1090(char * dest, char * src);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
int32_t function_10d0(char * format, ...);
int64_t register_tm_clones(void);
int64_t remove_room(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xdfb00000daa; // 0x2044
char g2 = 0; // 0x4020
int64_t g3 = 0; // 0x4040
int64_t g4 = 0; // 0x4050
int64_t g5 = 0; // 0x4054
int32_t g6 = 0; // 0x44f0
int32_t g7 = 0; // 0x44f1
int32_t g8;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g8;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
char * function_1090(char * dest, char * src) {
    // 0x1090
    return strcpy(dest, src);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return scanf(format);
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x11c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return 0x4010;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (g2 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    g2 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x12d1
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11d5
    display_menu();
    printf(""Enter your choice: "");
    int64_t v2; // bp-20, 0x11c9
    scanf(""%d"", &v2);
    while ((int32_t)v2 >= 7) {
        // 0x129a
        puts(""Invalid choice! Try again."");
        if ((int32_t)v2 == 6) {
            // 0x12b6
            if (v1 == __readfsqword(40)) {
                // 0x12cf
                return 0;
            }
            // 0x12ca
            __stack_chk_fail();
            // 0x12cf
            return &g8;
        }
        display_menu();
        printf(""Enter your choice: "");
        scanf(""%d"", &v2);
    }
    int32_t v3 = *(int32_t *)((4 * v2 & 0x3fffffffc) + (int64_t)&g1); // 0x1236
    return (int64_t)v3 + (int64_t)&g1;
}

// Address range: 0x12d1 - 0x1345
int64_t display_menu(void) {
    // 0x12d1
    puts(""\n=== C Hotel Management System ==="");
    puts(""1. Find a room"");
    puts(""2. Add a room"");
    puts(""3. Remove a room"");
    puts(""4. Display all rooms"");
    puts(""5. Calculate cost"");
    return puts(""6. Exit"");
}

// Address range: 0x1345 - 0x14cb
int64_t find_room(void) {
    // 0x1345
    int128_t v1; // 0x1345
    int128_t v2 = v1;
    int64_t v3 = __readfsqword(40); // 0x1351
    printf(""Enter room number: "");
    int64_t v4; // bp-28, 0x1345
    scanf(""%d"", &v4);
    if (g6 == 0) {
      lab_0x14a5:
        // 0x14a5
        puts(""Room not found!"");
    } else {
        int32_t v5 = 0; // 0x148c
        int64_t v6 = 0; // 0x13b1
        while (*(int32_t *)(v6 + (int64_t)&g3) != (int32_t)v4) {
            // 0x1490
            v5++;
            int64_t v7 = v5; // 0x1499
            if (v7 >= (int64_t)g6) {
                goto lab_0x14a5;
            }
            v6 = 24 * v7;
        }
        // 0x13cd
        printf(""Room type: %s\n"", (char *)(v6 + (int64_t)&g3 + 4));
        uint32_t v8 = *(int32_t *)(v6 + (int64_t)&g4); // 0x1429
        printf(""Occupancy: %d\n"", (int64_t)v8);
        int128_t v9 = __asm_movss(*(int32_t *)(v6 + (int64_t)&g5)); // 0x145f
        __asm_pxor(v2, v2);
        int64_t v10 = __asm_movq(__asm_cvtss2sd(v9)); // 0x146c
        printf(""Room charge: %.2f\n"", (float64_t)(int64_t)__asm_movq_1(v10));
    }
    int64_t result = 0; // 0x14c2
    if (v3 != __readfsqword(40)) {
        // 0x14c4
        __stack_chk_fail();
        result = &g8;
    }
    // 0x14c9
    return result;
}

// Address range: 0x14cb - 0x16a0
int64_t add_room(void) {
    int64_t v1 = __readfsqword(40); // 0x14d7
    printf(""Enter room number: "");
    int64_t v2; // bp-40, 0x14cb
    scanf(""%d"", &v2);
    printf(""Enter room type: "");
    int64_t str; // bp-26, 0x14cb
    scanf(""%s"", &str);
    printf(""Enter room occupancy: "");
    int64_t v3; // bp-36, 0x14cb
    scanf(""%d"", &v3);
    printf(""Enter room charge: "");
    int32_t v4; // bp-32, 0x14cb
    scanf(""%f"", &v4);
    if (g6 > 49) {
        // 0x167a
        puts(""Maximum rooms reached!"");
    } else {
        // 0x15b1
        *(int32_t *)(24 * (int64_t)g6 + (int64_t)&g3) = (int32_t)v2;
        strcpy((char *)(24 * (int64_t)g6 + (int64_t)&g3 + 4), (char *)&str);
        *(int32_t *)(24 * (int64_t)g6 + (int64_t)&g4) = (int32_t)v3;
        int64_t v5 = __asm_movss_2(__asm_movss(v4)); // 0x1655
        *(int32_t *)(24 * (int64_t)g6 + (int64_t)&g5) = (int32_t)v5;
        g6 = &g7;
        puts(""Room added successfully!"");
    }
    int64_t result = 0; // 0x1697
    if (v1 != __readfsqword(40)) {
        // 0x1699
        __stack_chk_fail();
        result = &g8;
    }
    // 0x169e
    return result;
}

// Address range: 0x16a0 - 0x1801
int64_t remove_room(void) {
    int64_t v1 = __readfsqword(40); // 0x16ac
    printf(""Enter room number: "");
    int64_t v2; // bp-32, 0x16a0
    scanf(""%d"", &v2);
    uint32_t v3 = g6; // 0x17c6
    if (v3 == 0) {
      lab_0x17db:
        // 0x17db
        puts(""Room not found!"");
    } else {
        int64_t v4 = 0; // 0x17cf
        int32_t v5 = 0;
        while (*(int32_t *)(24 * v4 + (int64_t)&g3) != (int32_t)v2) {
            int32_t v6 = v5 + 1; // 0x17c2
            v4 = v6;
            if (v4 >= (int64_t)v3) {
                goto lab_0x17db;
            }
            v5 = v6;
        }
        int32_t v7 = v3 - 1;
        int64_t v8 = v7;
        int64_t v9 = v5; // 0x17a0
        if (v9 < v8) {
            int32_t v10 = v5 + 1; // 0x173a
            int64_t v11 = 24 * v9; // 0x174c
            int64_t v12 = v10;
            int64_t v13 = 24 * v12; // 0x1766
            int64_t v14 = *(int64_t *)(v13 + (int64_t)&g3); // 0x1774
            int64_t v15 = *(int64_t *)(v13 + (int64_t)&g3 + 8); // 0x1778
            *(int64_t *)(v11 + (int64_t)&g3) = v14;
            *(int64_t *)(v11 + (int64_t)&g3 + 8) = v15;
            int64_t v16 = *(int64_t *)(v13 + (int64_t)&g3 + 16); // 0x1786
            *(int64_t *)(v11 + (int64_t)&g3 + 16) = v16;
            int32_t v17 = v10; // 0x17a0
            while (v12 < v8) {
                // 0x1737
                v10 = v17 + 1;
                v11 = 24 * v12;
                v12 = v10;
                v13 = 24 * v12;
                v14 = *(int64_t *)(v13 + (int64_t)&g3);
                v15 = *(int64_t *)(v13 + (int64_t)&g3 + 8);
                *(int64_t *)(v11 + (int64_t)&g3) = v14;
                *(int64_t *)(v11 + (int64_t)&g3 + 8) = v15;
                v16 = *(int64_t *)(v13 + (int64_t)&g3 + 16);
                *(int64_t *)(v11 + (int64_t)&g3 + 16) = v16;
                v17 = v10;
            }
        }
        // 0x17a2
        g6 = v7;
        puts(""Room removed successfully!"");
    }
    int64_t result = 0; // 0x17f8
    if (v1 != __readfsqword(40)) {
        // 0x17fa
        __stack_chk_fail();
        result = &g8;
    }
    // 0x17ff
    return result;
}

// Address range: 0x1801 - 0x193a
int64_t display_rooms(void) {
    // 0x1801
    puts(""List of all rooms:"");
    if (g6 == 0) {
        // 0x1936
        return 0;
    }
    int32_t v1 = 0; // 0x1930
    int128_t v2; // 0x1801
    int128_t v3 = v2;
    int64_t v4 = 0; // 0x1837
    uint32_t v5 = *(int32_t *)(v4 + (int64_t)&g3); // 0x1845
    printf(""Room number: %d\n"", (int64_t)v5);
    printf(""Room type: %s\n"", (char *)(v4 + (int64_t)&g3 + 4));
    uint32_t v6 = *(int32_t *)(v4 + (int64_t)&g4); // 0x18b3
    printf(""Occupancy: %d\n"", (int64_t)v6);
    int128_t v7 = __asm_movss(*(int32_t *)(v4 + (int64_t)&g5)); // 0x18e9
    __asm_pxor(v3, v3);
    int128_t v8 = __asm_cvtss2sd(v7); // 0x18f2
    printf(""Room charge: %.2f\n"", (float64_t)(int64_t)__asm_movq_1(__asm_movq(v8)));
    puts(""-------------------------------"");
    v1++;
    int64_t result = g6; // 0x1927
    int64_t v9 = v1; // 0x1930
    while (v9 < result) {
        // 0x1828
        v3 = v8;
        v4 = 24 * v9;
        v5 = *(int32_t *)(v4 + (int64_t)&g3);
        printf(""Room number: %d\n"", (int64_t)v5);
        printf(""Room type: %s\n"", (char *)(v4 + (int64_t)&g3 + 4));
        v6 = *(int32_t *)(v4 + (int64_t)&g4);
        printf(""Occupancy: %d\n"", (int64_t)v6);
        v7 = __asm_movss(*(int32_t *)(v4 + (int64_t)&g5));
        __asm_pxor(v3, v3);
        v8 = __asm_cvtss2sd(v7);
        printf(""Room charge: %.2f\n"", (float64_t)(int64_t)__asm_movq_1(__asm_movq(v8)));
        puts(""-------------------------------"");
        v1++;
        result = g6;
        v9 = v1;
    }
    // 0x1936
    return result;
}

// Address range: 0x193a - 0x1a6f
int64_t calculate_cost(void) {
    // 0x193a
    int128_t v1; // 0x193a
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = __readfsqword(40); // 0x1946
    printf(""Enter room number: "");
    int64_t v5; // bp-32, 0x193a
    scanf(""%d"", &v5);
    printf(""Enter number of nights: "");
    int64_t v6; // bp-28, 0x193a
    scanf(""%d"", &v6);
    if (g6 != 0) {
        int32_t v7 = 0; // 0x1a45
        int64_t v8 = 0; // 0x19ce
        while (*(int32_t *)(v8 + (int64_t)&g3) != (int32_t)v5) {
            // 0x1a49
            v7++;
            int64_t v9 = v7; // 0x1a52
            if (v9 >= (int64_t)g6) {
                goto lab_0x1a58;
            }
            v8 = 24 * v9;
        }
        int128_t v10 = __asm_movss(*(int32_t *)(v8 + (int64_t)&g5)); // 0x1a03
        __asm_pxor(v3, v3);
        int64_t v11 = __asm_movss_2(__asm_mulss(__asm_cvtsi2ss((int32_t)v6), v10)); // 0x1a17
        __asm_pxor(v2, v2);
        int64_t v12 = __asm_movq(__asm_cvtss2sd_3((int32_t)v11)); // 0x1a25
        printf(""Total cost: %.2f\n"", (float64_t)(int64_t)__asm_movq_1(v12));
    }
  lab_0x1a58:;
    int64_t result = 0; // 0x1a66
    if (v4 != __readfsqword(40)) {
        // 0x1a68
        __stack_chk_fail();
        result = &g8;
    }
    // 0x1a6d
    return result;
}

// Address range: 0x1a70 - 0x1a7d
int64_t _fini(void) {
    // 0x1a70
    int64_t result; // 0x1a70
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        // ---------------- Integer Types Definitions -----------------

        typedef int64_t int128_t;

        // ----------------- Float Types Definitions ------------------

        typedef double float64_t;

        // ------------------- Function Prototypes --------------------

        int64_t __do_global_dtors_aux(void);
        int64_t _fini(void);
        int64_t _init(void);
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
        int64_t add_room(void);
        int64_t calculate_cost(void);
        int64_t deregister_tm_clones(void);
        int64_t display_menu(void);
        int64_t display_rooms(void);
        int64_t find_room(void);
        int64_t frame_dummy(void);
        void function_1080(int64_t * d);
        char * function_1090(char * dest, char * src);
        int32_t function_10a0(char * s);
        void function_10b0(void);
        int32_t function_10c0(char * format, ...);
        int32_t function_10d0(char * format, ...);
        int64_t register_tm_clones(void);
        int64_t remove_room(void);

        // --------------------- Global Variables ---------------------

        int64_t g1 = -0xdfb00000daa; // 0x2044
        char g2 = 0; // 0x4020
        int64_t g3 = 0; // 0x4040
        int64_t g4 = 0; // 0x4050
        int64_t g5 = 0; // 0x4054
        int32_t g6 = 0; // 0x44f0
        int32_t g7 = 0; // 0x44f1
        int32_t g8;

        // ------- Dynamically Linked Functions Without Header --------

        void __cxa_finalize(int64_t * a1);
        void __gmon_start__(void);
        int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
        void __stack_chk_fail(void);

        // ------------------------ Functions -------------------------

        // Address range: 0x1000 - 0x101b
        int64_t _init(void) {
            int64_t result = 0; // 0x1012
            if (*(int64_t *)0x3fe8 != 0) {
                // 0x1014
                __gmon_start__();
                result = &g8;
            }
            // 0x1016
            return result;
        }

        // Address range: 0x1080 - 0x108b
        void function_1080(int64_t * d) {
            // 0x1080
            __cxa_finalize(d);
        }

        // Address range: 0x1090 - 0x109b
        char * function_1090(char * dest, char * src) {
            // 0x1090
            return strcpy(dest, src);
        }

        // Address range: 0x10a0 - 0x10ab
        int32_t function_10a0(char * s) {
            // 0x10a0
            return puts(s);
        }

        // Address range: 0x10b0 - 0x10bb
        void function_10b0(void) {
            // 0x10b0
            __stack_chk_fail();
        }

        // Address range: 0x10c0 - 0x10cb
        int32_t function_10c0(char * format, ...) {
            // 0x10c0
            return printf(format);
        }

        // Address range: 0x10d0 - 0x10db
        int32_t function_10d0(char * format, ...) {
            // 0x10d0
            return scanf(format);
        }

        // Address range: 0x10e0 - 0x1106
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            // 0x10e0
            int64_t v1; // 0x10e0
            __libc_start_main(0x11c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
            __asm_hlt();
            // UNREACHABLE
        }

        // Address range: 0x1110 - 0x1139
        int64_t deregister_tm_clones(void) {
            // 0x1110
            return 0x4010;
        }

        // Address range: 0x1140 - 0x1179
        int64_t register_tm_clones(void) {
            // 0x1140
            return 0;
        }

        // Address range: 0x1180 - 0x11b9
        int64_t __do_global_dtors_aux(void) {
            // 0x1180
            if (g2 != 0) {
                // 0x11b8
                int64_t result; // 0x1180
                return result;
            }
            // 0x118d
            if (*(int64_t *)0x3ff8 != 0) {
                // 0x119b
                __cxa_finalize((int64_t *)*(int64_t *)0x4008);
            }
            int64_t result2 = deregister_tm_clones(); // 0x11a7
            g2 = 1;
            return result2;
        }

        // Address range: 0x11c0 - 0x11c9
        int64_t frame_dummy(void) {
            // 0x11c0
            return register_tm_clones();
        }

        // Address range: 0x11c9 - 0x12d1
        int main(int argc, char ** argv) {
            int64_t v1 = __readfsqword(40); // 0x11d5
            display_menu();
            printf(""Enter your choice: "");
            int64_t v2; // bp-20, 0x11c9
            scanf(""%d"", &v2);
            while ((int32_t)v2 >= 7) {
                // 0x129a
                puts(""Invalid choice! Try again."");
                if ((int32_t)v2 == 6) {
                    // 0x12b6
                    if (v1 == __readfsqword(40)) {
                        ",0
"//FormAI DATASET v1.0 Category: Internet Speed Test Application ; Style: enthusiastic
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    srand(time(NULL)); // seed random number generator

    // generate random speed test results
    int download_speed = rand() % 1000 + 1; // download speed between 1 and 1000 Mbps
    int upload_speed = rand() % 1000 + 1; // upload speed between 1 and 1000 Mbps
    
    printf(""Welcome to the Internet Speed Test Application\n\n"");
    printf(""Testing download speed...\n"");
    printf(""Download Speed: %d Mbps\n"", download_speed);
    printf(""Testing upload speed...\n"");
    printf(""Upload Speed: %d Mbps\n\n"", upload_speed);

    // determine internet speed quality based on speed test results
    if (download_speed > 500 && upload_speed > 500) {
        printf(""Your internet speed is excellent!\n"");
    } else if (download_speed > 250 && upload_speed > 250) {
        printf(""Your internet speed is good!\n"");
    } else if (download_speed > 100 && upload_speed > 100) {
        printf(""Your internet speed is average.\n"");
    } else {
        printf(""Your internet speed is poor. Consider upgrading your plan.\n"");
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(char * s);
int32_t function_10a0(char * format, ...);
void function_10b0(int32_t seed);
int32_t function_10c0(int32_t * timer);
int32_t function_10d0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x3e8
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int32_t seed) {
    // 0x10b0
    srand(seed);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t * timer) {
    // 0x10c0
    return time(timer);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(void) {
    // 0x10d0
    return rand();
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x11c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g2;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g2 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x1318
int main(int argc, char ** argv) {
    // 0x11c9
    srand(time(NULL));
    int32_t v1 = rand(); // 0x11e6
    int32_t v2 = v1 - v1 / 1000 * (int32_t)&g1 + 1; // 0x120d
    int32_t v3 = rand(); // 0x1213
    int32_t v4 = v3 - v3 / 1000 * (int32_t)&g1 + 1; // 0x123a
    puts(""Welcome to the Internet Speed Test Application\n"");
    puts(""Testing download speed..."");
    printf(""Download Speed: %d Mbps\n"", (int64_t)v2);
    puts(""Testing upload speed..."");
    printf(""Upload Speed: %d Mbps\n\n"", (int64_t)v4);
    if (v2 >= 501 && v4 >= 501) {
        // 0x12b1
        puts(""Your internet speed is excellent!"");
        // 0x1311
        return 0;
    }
    if (v2 >= 251 && v4 >= 251) {
        // 0x12d4
        puts(""Your internet speed is good!"");
        // 0x1311
        return 0;
    }
    if (v2 < 101 || v4 < 101) {
        // 0x1302
        puts(""Your internet speed is poor. Consider upgrading your plan."");
    } else {
        // 0x12f1
        puts(""Your internet speed is average."");
    }
    // 0x1311
    return 0;
}

// Address range: 0x1318 - 0x1325
int64_t _fini(void) {
    // 0x1318
    int64_t result; // 0x1318
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 14

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int v1 = rand();
            int v2 = v1 - v1 / 1000 * (int)&g1 + 1;
            int v3 = rand();
            int v4 = v3 - v3 / 1000 * (int)&g1 + 1;
            puts(""Welcome to the Internet Speed Test Application\n"");
            puts(""Testing download speed..."");
            printf(""Download Speed: %d Mbps\n"", v2);
            puts(""Testing upload speed..."");
            printf(""Upload Speed: %d Mbps\n\n"", v4);
            if (v2 >= 501 && v4 >= 501) {
                puts(""Your internet speed is excellent!"");
                return 0;
            }
            if (v2 >= 251 && v4 >= 251) {
                puts(""Your internet speed is good!"");
                return 0;
            }
            if (v2 < 101 || v4 < 101) {
                puts(""Your internet speed is poor. Consider upgrading your plan."");
            } else {
                puts(""Your internet speed is average."");
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Digital Auction System ; Style: careful
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// global variables
int highestBid = 0;
int bidderID = 0;
int remainingTime = 120;    // in seconds
int auctionEnded = 0;       // flag to check if auction has ended or not

// function to generate random bidder ID
int generateBidderID() {
    srand(time(NULL));
    return rand() % 1000 + 1;
}

// function to get input from bidder
int getBid(int bidderID) {
    int bid;
    printf(""Bidder %d, enter your bid: "", bidderID);
    scanf(""%d"", &bid);
    return bid;
}

// function to check if bid is valid
int validateBid(int bid) {
    if (bid > highestBid) {
        highestBid = bid;
        return 1;
    }
    return 0;
}

int main() {
    printf(""Welcome to the Digital Auction System!\n"");
    printf(""The auction will run for 2 minutes (120 seconds).\n\n"");

    // start the auction
    time_t startTime = time(NULL);
    time_t currentTime;

    while (!auctionEnded) {
        currentTime = time(NULL);
        remainingTime = 120 - difftime(currentTime, startTime);
        if (remainingTime <= 0) {
            auctionEnded = 1;
            break;
        }

        bidderID = generateBidderID();
        int bid = getBid(bidderID);
        int isValidBid = validateBid(bid);

        if (isValidBid) {
            printf(""\nBidder %d has the highest bid at $%d.\n\n"", bidderID, highestBid);
        }
        else {
            printf(""\nBidder %d, your bid of $%d is not valid. The current highest bid is $%d.\n\n"", bidderID, bid, highestBid);
        }
    }

    // end the auction
    printf(""The auction has ended.\n"");
    printf(""The winning bid is $%d by bidder %d.\n"", highestBid, bidderID);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(char * s);
void function_10d0(void);
int32_t function_10e0(char * format, ...);
float64_t function_10f0(int32_t time1, int32_t time0);
void function_1100(int32_t seed);
int32_t function_1110(int32_t * timer);
int32_t function_1120(char * format, ...);
int32_t function_1130(void);
int64_t generateBidderID(void);
int64_t getBid(int64_t a1);
int64_t register_tm_clones(void);
int64_t validateBid(int64_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x3e8
int32_t g2 = 120; // 0x4010
char g3 = 0; // 0x4014
int64_t g4 = 0; // 0x4018
int32_t g5 = 0; // 0x401c
int32_t g6 = 0; // 0x4020
int32_t g7;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g7;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return puts(s);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(void) {
    // 0x10d0
    __stack_chk_fail();
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return printf(format);
}

// Address range: 0x10f0 - 0x10fb
float64_t function_10f0(int32_t time1, int32_t time0) {
    // 0x10f0
    return difftime(time1, time0);
}

// Address range: 0x1100 - 0x110b
void function_1100(int32_t seed) {
    // 0x1100
    srand(seed);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int32_t * timer) {
    // 0x1110
    return time(timer);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * format, ...) {
    // 0x1120
    return scanf(format);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(void) {
    // 0x1130
    return rand();
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1306, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g4;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (g3 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    g3 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x126e
int64_t generateBidderID(void) {
    // 0x1229
    srand(time(NULL));
    int32_t v1 = rand(); // 0x1242
    return v1 + 1 + v1 / 1000 * -1 * (int32_t)&g1;
}

// Address range: 0x126e - 0x12d9
int64_t getBid(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x127d
    printf(""Bidder %d, enter your bid: "", a1 & 0xffffffff);
    int64_t v2; // bp-20, 0x126e
    scanf(""%d"", &v2);
    int64_t result = v2 & 0xffffffff; // 0x12d0
    if (v1 != __readfsqword(40)) {
        // 0x12d2
        __stack_chk_fail();
        result = &g7;
    }
    // 0x12d7
    return result;
}

// Address range: 0x12d9 - 0x1306
int64_t validateBid(int64_t a1) {
    int64_t v1 = 0x100000000 * a1 >> 32; // 0x12e1
    int64_t result = 0; // 0x12ed
    if (v1 > (int64_t)*(int32_t *)&g4) {
        // 0x12ef
        *(int32_t *)&g4 = (int32_t)v1;
        result = 1;
    }
    // 0x1304
    return result;
}

// Address range: 0x1306 - 0x1455
int main(int argc, char ** argv) {
    // 0x1306
    puts(""Welcome to the Digital Auction System!"");
    puts(""The auction will run for 2 minutes (120 seconds).\n"");
    int32_t time_val = time(NULL); // 0x1335
    uint32_t v1; // 0x1432
    if (g6 != 0) {
        // 0x141d
        puts(""The auction has ended."");
        v1 = *(int32_t *)&g4;
        printf(""The winning bid is $%d by bidder %d.\n"", (int64_t)v1, (int64_t)g5);
        return 0;
    }
    float64_t time_diff = difftime(time(NULL), time_val); // 0x135f
    int128_t v2 = __asm_movsd(0x405e000000000000); // 0x1364
    int32_t v3 = __asm_cvttsd2si(__asm_subsd(v2, (int128_t)(int32_t)(float32_t)time_diff)); // 0x1370
    *(int32_t *)0x4010 = v3;
    while (g2 >= 0 == (g2 != 0)) {
        int64_t v4 = generateBidderID(); // 0x1398
        g5 = v4;
        int64_t v5 = getBid(v4 & 0xffffffff) & 0xffffffff; // 0x13b6
        int64_t v6 = validateBid(v5); // 0x13b8
        int64_t v7 = (int64_t)*(int32_t *)&g4;
        int64_t v8 = g5;
        if ((int32_t)v6 == 0) {
            // 0x13ea
            printf(""\nBidder %d, your bid of $%d is not valid. The current highest bid is $%d.\n\n"", v8, v5, v7);
        } else {
            // 0x13c6
            printf(""\nBidder %d has the highest bid at $%d.\n\n"", v8, v7);
        }
        // 0x140f
        if (g6 != 0) {
            // 0x141d
            puts(""The auction has ended."");
            v1 = *(int32_t *)&g4;
            printf(""The winning bid is $%d by bidder %d.\n"", (int64_t)v1, (int64_t)g5);
            return 0;
        }
        time_diff = difftime(time(NULL), time_val);
        v2 = __asm_movsd(0x405e000000000000);
        v3 = __asm_cvttsd2si(__asm_subsd(v2, (int128_t)(int32_t)(float32_t)time_diff));
        *(int32_t *)0x4010 = v3;
    }
    // 0x1384
    g6 = 1;
    // 0x141d
    puts(""The auction has ended."");
    v1 = *(int32_t *)&g4;
    printf(""The winning bid is $%d by bidder %d.\n"", (int64_t)v1, (int64_t)g5);
    return 0;
}

// Address range: 0x1458 - 0x1465
int64_t _fini(void) {
    // 0x1458
    int64_t result; // 0x1458
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","nclude <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(int argc, char ** argv) {
    puts(""Welcome to the Digital Auction System!"");
    puts(""The auction will run for 2 minutes (120 seconds).\n"");
    int32_t time_val = time(NULL);
    uint32_t v1;
    if (g6 != 0) {
        puts(""The auction has ended."");
        v1 = *(int32_t *)&g4;
        printf(""The winning bid is $%d by bidder %d.\n"", (int64_t)v1, (int64_t)g5);
        return 0;
    }
    float64_t time_diff = difftime(time(NULL), time_val);
    int128_t v2 = __asm_movsd(0x405e000000000000);
    int32_t v3 = __asm_cvttsd2si(__asm_subsd(v2, (int128_t)(int32_t)(float32_t)time_diff));
    *(int32_t *)0x4010 = v3;
    while (g2 >= 0 == (g2 != 0)) {
        int64_t v4 = generateBidderID();
        g5 = v4;
        int64_t v5 = getBid(v4 & 0xffffffff) & 0xffffffff;
        int64_t v6 = validateBid(v5);
        int64_t v7 = (int64_t)*(int32_t *)&g4;
        int64_t v8 = g5;
        if ((int32_t)v6 == 0) {
            printf(""\nBidder %d, your bid of $%d is not valid. The current highest bid is $%d.\n\n"", v8, v5, v7);
        } else {
            printf(""\nBidder %d has the highest bid at $%d.\n\n"", v8, v7);
        }
        if (g6 != 0) {
            puts(""The auction has ended."");
            v1 = *(int32_t *)&g4;
            printf(""The winning bid is $%d by bidder %d.\n"", (int64_t)v1, (int64_t)g5);
            return 0;
        }
        time_diff = difftime(time(NULL), time_val);
        v2 = __asm_movsd(0x405e000000000000);
        v3 = __asm_cvttsd2si(__asm_subsd(v2, (int128_t)(int32_t)(float32_t)time_diff));
        *(int32_t *)0x4010 = v3;
    }
    g6 = 1;
    puts(""The auction has ended."");
    v1 = *(int32_t *)&g4;
    printf(""The winning bid is $%d by bidder %d.\n"", (int64_t)v1, (int64_t)g5);
    return 0;
}

int64_t generateBidderID(void) {
    srand(time(NULL));
    int32_t v1 = rand();
    return v1 + 1 + v1 / 1000 * -1 * (int32_t)&g1;
}

int64_t getBid(int64_t a1) {
    int64_t v1 = __readfsqword(40);
    printf(""Bidder %d, enter your bid: "", a1 & 0xffffffff);
    int64_t v2;
    scanf(""%d"", &v2);
    int64_t result = v2 & 0xffffffff;
    if (v1 != __readfsqword(40)) {
        __stack_chk_fail();
        result = &g7;
    }
    return result;
}

int64_t validateBid(int64_t a1) {
    int64_t v1 = 0x100000000 * a1 >> 32;
    int64_t result = 0;
    if (v1 > (int64_t)*(int32_t *)&g4) {
        *(int32_t *)&g4 = (int32_t)v1;
        result = 1;
    }
    return result;
}


",1
"//FormAI DATASET v1.0 Category: Digital Diary ; Style: funny
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {

    char entry[1000];
    char choice;
    int day, month, year;

    printf(""Welcome to your Digital Diary!\n"");
    printf(""What would you like to do today?\n"");
    printf(""a) Create a new entry\n"");
    printf(""b) Read an existing entry\n"");
    printf(""c) Exit\n"");

    scanf(""%c"", &choice);

    switch(choice) {
        
        case 'a':
            printf(""Enter the date of your entry (DD/MM/YYYY): "");
            scanf(""%d/%d/%d"", &day, &month, &year);
            printf(""Write your entry below:\n"");
            fgets(entry, 1000, stdin);
            printf(""Entry saved successfully!\n"");
            break;

        case 'b':
            printf(""Enter the date of the entry you want to read (DD/MM/YYYY): "");
            scanf(""%d/%d/%d"", &day, &month, &year);
            printf(""Entry for %d/%d/%d:\n"", day, month, year);
            // code to read the entry goes here
            break;

        case 'c':
            printf(""Are you sure you want to exit? (Y/N): "");
            scanf(""%c"", &choice);
            if(choice == 'Y' || choice == 'y') {
                printf(""Goodbye!"");
                exit(0);
            }
            break;

        default:
            printf(""Invalid input. Please choose a valid option.\n"");
            break;
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
char * function_10d0(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_10e0(char * format, ...);
void function_10f0(int32_t status);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x3e8
struct _IO_FILE * g2 = NULL; // 0x4010
char g3 = 0; // 0x4018
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g4;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
char * function_10d0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x10d0
    return fgets(s, n, stream);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return scanf(format);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(int32_t status) {
    // 0x10f0
    exit(status);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x11e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return (int64_t)&g2;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (g3 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    g3 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x141a
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11f8
    puts(""Welcome to your Digital Diary!"");
    puts(""What would you like to do today?"");
    puts(""a) Create a new entry"");
    puts(""b) Read an existing entry"");
    puts(""c) Exit"");
    int32_t v2; // bp-1029, 0x11e9
    scanf(""%c"", &v2);
    int32_t v3 = 0x100000000000000 * (int64_t)v2 >> 56; // 0x127a
    if (v3 == 99) {
        // 0x1387
        printf(""Are you sure you want to exit? (Y/N): "");
        scanf(""%c"", &v2);
        char v4 = v2; // 0x13b9
        if (v4 != 89 != v4 != 121) {
            // 0x13cf
            printf(""Goodbye!"");
            exit(0);
            // UNREACHABLE
        }
        goto lab_0x13ff;
    } else {
        if (v3 > 99) {
            // 0x13ed
            puts(""Invalid input. Please choose a valid option."");
            goto lab_0x13ff;
        } else {
            int64_t v5; // bp-1020, 0x11e9
            int64_t v6; // bp-1024, 0x11e9
            int64_t v7; // bp-1028, 0x11e9
            switch (v3) {
                case 97: {
                    // 0x129f
                    printf(""Enter the date of your entry (DD/MM/YYYY): "");
                    scanf(""%d/%d/%d"", &v7, &v6, &v5);
                    puts(""Write your entry below:"");
                    int64_t str; // bp-1016, 0x11e9
                    fgets((char *)&str, (int32_t)&g1, g2);
                    puts(""Entry saved successfully!"");
                    goto lab_0x13ff;
                }
                case 98: {
                    // 0x131d
                    printf(""Enter the date of the entry you want to read (DD/MM/YYYY): "");
                    scanf(""%d/%d/%d"", &v7, &v6, &v5);
                    printf(""Entry for %d/%d/%d:\n"", v7 & 0xffffffff, v6 & 0xffffffff, v5 & 0xffffffff);
                    goto lab_0x13ff;
                }
                default: {
                    // 0x13ed
                    puts(""Invalid input. Please choose a valid option."");
                    goto lab_0x13ff;
                }
            }
        }
    }
  lab_0x13ff:;
    int64_t result = 0; // 0x1411
    if (v1 != __readfsqword(40)) {
        // 0x1413
        __stack_chk_fail();
        result = &g4;
    }
    // 0x1418
    return result;
}

// Address range: 0x141c - 0x1429
int64_t _fini(void) {
    // 0x141c
    int64_t result; // 0x141c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <time.h>

        struct entry {
            int day;
            int month;
            int year;
            char * text;
        };

        struct diary {
            struct entry * entries;
            int size;
            int capacity;
        };

        struct diary * create_diary(int capacity) {
            struct diary * diary = malloc(sizeof(struct diary));
            diary->entries = malloc(sizeof(struct entry) * capacity);
            diary->size = 0;
            diary->capacity = capacity;
            return diary;
        }

        void destroy_diary(struct diary * diary) {
            for (int i = 0; i < diary->size; i++) {
                free(diary->entries[i].text);
            }
            free(diary->entries);
            free(diary);
        }

        void add_entry(struct diary * diary, int day, int month, int year, char * text) {
            if (diary->size == diary->capacity) {
                diary->capacity *= 2;
                diary->entries = realloc(diary->entries, sizeof(struct entry) * diary->capacity);
            }
            diary->entries[diary->size].day = day;
            diary->entries[diary->size].month = month;
            diary->entries[diary->size].year = year;
            diary->entries[diary->size].text = strdup(text);
            diary->size++;
        }

        void print_entry(struct entry * entry) {
            printf(""%d/%d/%d: %s\n"", entry->day, entry->month, entry->year, entry->text);
        }

        void print_diary(struct diary * diary) {
            for (int i = 0; i < diary->size; i++) {
                print_entry(&diary->entries[i]);
            }
        }

        int main(int argc, char ** argv) {
            struct diary * diary = create_diary(10);
            int day, month, year;
            char text[100];
            while (1) {
                printf(""Welcome to your Digital Diary!\n"");
                printf(""What would you like to do today?\n"");
                printf(""a) Create a new entry\n"");
                printf(""b) Read an existing entry\n"");
                printf(""c) Exit\n"");
                char choice;
                scanf(""%c"", &choice);
                switch (choice) {
                    case 'a': {
                        printf(""Enter the date of your entry (DD/MM/YYYY): "");
                        scanf(""%d/%d/%d"", &day, &month, &year);
                        printf(""Write your entry below:\n"");
                        scanf(""%s"", text);
                        add_entry(diary, day, month, year, text);
                        break;
                    }
                    case 'b': {
                        printf(""Enter the date of the entry you want to read (DD/MM/YYYY): "");
                        scanf(""%d/%d/%d"", &day, &month, &year);
                        for (int i = 0; i < diary->size; i++) {
                            if (diary->entries[i].day == day && diary->entries[i].month == month && diary->entries[i].year == year) {
                                print_entry(&diary->entries[i]);
                                break;
                            }
                        }
                        break;
                    }
                    case 'c': {
                        printf(""Are you sure you want to exit? (Y/N): "");
                        char confirmation;
                        scanf(""%c"", &confirmation);
                        if (confirmation == 'Y' || confirmation == 'y') {
                            printf(""Goodbye!\n"");
                            destroy_diary(diary);
                            return 0;
                        }
                        break;
                    }
                    default: {
                        printf(""Invalid input. Please choose a valid option.\n"");
                        break;
                    }
                }
            }
        }

",2
"//FormAI DATASET v1.0 Category: Building a HTTP Client ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(int argc,char**argv){

    if(argc!=2){
        printf(""Usage: %s <url>\n"",argv[0]);
        return 1;
    }

    char*url=argv[1];

    //Separate host and path
    char*host=strtok(url,""/"");
    char*path=strtok(NULL,"""");

    //Create socket
    int sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd<0){
        perror(""Could not create socket"");
        return 1;
    }

    //Resolve host
    struct sockaddr_in server;
    server.sin_family=AF_INET;
    server.sin_addr.s_addr=inet_addr(host);
    server.sin_port=htons(80);

    if(connect(sockfd,(struct sockaddr*)&server,sizeof(server))<0){
        perror(""Could not connect to server"");
        return 1;
    }

    //Send request
    char*request=malloc(strlen(path)+strlen(host)+30);
    sprintf(request,""GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n"",path,host);
    if(write(sockfd,request,strlen(request))<0){
        perror(""Could not send request"");
        return 1;
    }

    //Receive response
    char buffer[1024];
    int count;
    int total=0;
    while((count=read(sockfd,buffer,sizeof(buffer)))>0){
        fwrite(buffer,count,1,stdout);
        total+=count;
    }
    if(count<0){
        perror(""Could not receive response"");
        return 1;
    }

    printf(""\n\nTotal received: %d bytes\n"",total);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1110(int64_t * d);
int32_t function_1120(int32_t fd, int64_t * buf, int32_t n);
int32_t function_1130(char * s);
void function_1140(void);
int16_t function_1150(int16_t hostshort);
int32_t function_1160(char * format, ...);
int32_t function_1170(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_1180(char * cp);
int64_t * function_1190(int32_t size);
void function_11a0(char * s);
char * function_11b0(char * s, char * delim);
int32_t function_11c0(char * s, char * format, ...);
int32_t function_11d0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_11e0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_11f0(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x201b
int32_t g2 = 0; // 0x400
struct _IO_FILE * g3 = NULL; // 0x4010
char g4 = 0; // 0x4018
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g5;
    }
    // 0x1016
    return result;
}

// Address range: 0x1110 - 0x111b
void function_1110(int64_t * d) {
    // 0x1110
    __cxa_finalize(d);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(int32_t fd, int64_t * buf, int32_t n) {
    // 0x1120
    return write(fd, buf, n);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * s) {
    // 0x1130
    return strlen(s);
}

// Address range: 0x1140 - 0x114b
void function_1140(void) {
    // 0x1140
    __stack_chk_fail();
}

// Address range: 0x1150 - 0x115b
int16_t function_1150(int16_t hostshort) {
    // 0x1150
    return htons(hostshort);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(char * format, ...) {
    // 0x1160
    return printf(format);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x1170
    return read(fd, buf, nbytes);
}

// Address range: 0x1180 - 0x118b
int32_t function_1180(char * cp) {
    // 0x1180
    return inet_addr(cp);
}

// Address range: 0x1190 - 0x119b
int64_t * function_1190(int32_t size) {
    // 0x1190
    return malloc(size);
}

// Address range: 0x11a0 - 0x11ab
void function_11a0(char * s) {
    // 0x11a0
    perror(s);
}

// Address range: 0x11b0 - 0x11bb
char * function_11b0(char * s, char * delim) {
    // 0x11b0
    return strtok(s, delim);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(char * s, char * format, ...) {
    // 0x11c0
    return sprintf(s, format);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x11d0
    return connect(fd, addr, len);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x11e0
    return fwrite(ptr, size, n, s);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x11f0
    return socket(domain, type, protocol);
}

// Address range: 0x1200 - 0x1226
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1200
    int64_t v1; // 0x1200
    __libc_start_main(0x12e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1230 - 0x1259
int64_t deregister_tm_clones(void) {
    // 0x1230
    return (int64_t)&g3;
}

// Address range: 0x1260 - 0x1299
int64_t register_tm_clones(void) {
    // 0x1260
    return 0;
}

// Address range: 0x12a0 - 0x12d9
int64_t __do_global_dtors_aux(void) {
    // 0x12a0
    if (g4 != 0) {
        // 0x12d8
        int64_t result; // 0x12a0
        return result;
    }
    // 0x12ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x12c7
    g4 = 1;
    return result2;
}

// Address range: 0x12e0 - 0x12e9
int64_t frame_dummy(void) {
    // 0x12e0
    return register_tm_clones();
}

// Address range: 0x12e9 - 0x15a5
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1306
    int64_t v2; // 0x12e9
    int64_t v3; // 0x12e9
    if ((int32_t)argc == 2) {
        char * next_token = strtok((char *)*(int64_t *)((int64_t)argv + 8), ""/""); // 0x136f
        char * next_token2 = strtok(NULL, (char *)&g1); // 0x138a
        int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x13a5
        if (sock_fd >= 0) {
            int16_t addr = 2; // bp-1080, 0x13d2
            inet_addr(next_token);
            htons(80);
            if (connect(sock_fd, (struct sockaddr *)&addr, 16) >= 0) {
                int64_t * mem = malloc(strlen(next_token2) + 30 + strlen(next_token)); // 0x1465
                sprintf((char *)mem, ""GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n"", next_token2, next_token);
                if (write(sock_fd, mem, strlen((char *)mem)) >= 0) {
                    // 0x1520
                    int64_t buf; // bp-1064, 0x12e9
                    int32_t size = read(sock_fd, &buf, (int32_t)&g2); // 0x1537
                    if (size >= 0 == (size != 0)) {
                        fwrite(&buf, size, 1, g3);
                        int32_t v4 = size; // 0x151a
                        int32_t v5 = read(sock_fd, &buf, (int32_t)&g2); // 0x1537
                        int32_t size2 = v5; // 0x1549
                        int32_t v6 = v4; // 0x1549
                        while (v5 >= 0 == (v5 != 0)) {
                            // 0x14ed
                            fwrite(&buf, size2, 1, g3);
                            v4 = v6 + size2;
                            v5 = read(sock_fd, &buf, (int32_t)&g2);
                            size2 = v5;
                            v6 = v4;
                        }
                        // 0x1520
                        v3 = v4;
                        if (v5 >= 0) {
                            goto lab_0x156a;
                        } else {
                            // 0x1554
                            perror(""Could not receive response"");
                            v2 = 1;
                            goto lab_0x158b;
                        }
                    } else {
                        // 0x154b
                        v3 = 0;
                        if (size >= 0) {
                            goto lab_0x156a;
                        } else {
                            // 0x1554
                            perror(""Could not receive response"");
                            v2 = 1;
                            goto lab_0x158b;
                        }
                    }
                } else {
                    // 0x14c8
                    perror(""Could not send request"");
                    v2 = 1;
                    goto lab_0x158b;
                }
            } else {
                // 0x1421
                perror(""Could not connect to server"");
                v2 = 1;
                goto lab_0x158b;
            }
        } else {
            // 0x13b9
            perror(""Could not create socket"");
            v2 = 1;
            goto lab_0x158b;
        }
    } else {
        // 0x131e
        printf(""Usage: %s <url>\n"", argv);
        v2 = 1;
        goto lab_0x158b;
    }
  lab_0x158b:;
    int64_t result = v2; // 0x1598
    if (v1 != __readfsqword(40)) {
        // 0x159a
        __stack_chk_fail();
        result = &g5;
    }
    // 0x159f
    return result;
  lab_0x156a:
    // 0x156a
    printf(""\n\nTotal received: %d bytes\n"", v3);
    v2 = 0;
    goto lab_0x158b;
}

// Address range: 0x15a8 - 0x15b5
int64_t _fini(void) {
    // 0x15a8
    int64_t result; // 0x15a8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 23

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <arpa/inet.h>
        #include <netinet/in.h>
        #include <sys/socket.h>

        int main(int argc, char ** argv) {
            if ((int32_t)argc == 2) {
                char * next_token = strtok((char *)*(int64_t *)((int64_t)argv + 8), ""/"");
                char * next_token2 = strtok(NULL, (char *)&g1);
                int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
                if (sock_fd >= 0) {
                    int16_t addr = 2;
                    inet_addr(next_token);
                    htons(80);
                    if (connect(sock_fd, (struct sockaddr *)&addr, 16) >= 0) {
                        int64_t * mem = malloc(strlen(next_token2) + 30 + strlen(next_token));
                        sprintf((char *)mem, ""GET /%s HTTP/1.0\r\nHost: %s\r\n\r\n"", next_token2, next_token);
                        if (write(sock_fd, mem, strlen((char *)mem)) >= 0) {
                            int64_t buf;
                            int32_t size = read(sock_fd, &buf, (int32_t)&g2);
                            if (size >= 0 == (size != 0)) {
                                fwrite(&buf, size, 1, g3);
                                int32_t v4 = size;
                                int32_t v5 = read(sock_fd, &buf, (int32_t)&g2);
                                int32_t size2 = v5;
                                int32_t v6 = v4;
                                while (v5 >= 0 == (v5 != 0)) {
                                    fwrite(&buf, size2, 1, g3);
                                    v4 = v6 + size2;
                                    v5 = read(sock_fd, &buf, (int32_t)&g2);
                                    size2 = v5;
                                    v6 = v4;
                                }
                                printf(""\n\nTotal received: %d bytes\n"", v4);
                                return 0;
                            } else {
                                perror(""Could not receive response"");
                                return 1;
                            }
                        } else {
                            perror(""Could not send request"");
                            return 1;
                        }
                    } else {
                        perror(""Could not connect to server"");
                        return 1;
                    }
                } else {
                    perror(""Could not create socket"");
                    return 1;
                }
            } else {
                printf(""Usage: %s <url>\n"", argv);
                return 1;
            }
        }

",1
"//FormAI DATASET v1.0 Category: Database simulation ; Style: artistic
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LENGTH 20
#define MAX_RECORDS 100

struct Record {
    int id;
    char name[MAX_LENGTH];
    char address[MAX_LENGTH];
    int age;
};

struct Database {
    struct Record records[MAX_RECORDS];
    int count;
};

void addRecord(struct Database* database, struct Record record) {
    database->records[database->count] = record;
    database->count++;
}

void deleteRecord(struct Database* database, int id) {
    int foundIndex = -1;
    for (int i = 0; i < database->count; i++) {
        if (database->records[i].id == id) {
            foundIndex = i;
        }
    }
    if (foundIndex != -1) {
        for (int i = foundIndex; i < database->count-1; i++) {
            database->records[i] = database->records[i+1];
        }
        database->count--;
    }
}

struct Record* searchRecord(struct Database* database, int id) {
    for (int i = 0; i < database->count; i++) {
        if (database->records[i].id == id) {
            return &database->records[i];
        }
    }
    return NULL;
}

void printRecord(struct Record record) {
    printf(""ID: %d\n"", record.id);
    printf(""Name: %s\n"", record.name);
    printf(""Address: %s\n"", record.address);
    printf(""Age: %d\n"", record.age);
}

void printDatabase(struct Database* database) {
    for (int i = 0; i < database->count; i++) {
        printf(""Record %d:\n"", i+1);
        printRecord(database->records[i]);
    }
}

int main() {
    struct Database database = { .count = 0 };

    struct Record record1 = { .id = 1, .name = ""John Smith"", .address = ""123 Main St"", .age = 30 };
    struct Record record2 = { .id = 2, .name = ""Jennifer Garcia"", .address = ""456 Elm St"", .age = 25 };
    struct Record record3 = { .id = 3, .name = ""David Lee"", .address = ""789 Pine St"", .age = 40 };

    addRecord(&database, record1);
    addRecord(&database, record2);
    addRecord(&database, record3);

    printf(""Database contents:\n"");
    printDatabase(&database);

    struct Record* foundRecord = searchRecord(&database, 2);
    if (foundRecord != NULL) {
        printf(""Record found:\n"");
        printRecord(*foundRecord);
    } else {
        printf(""Record not found.\n"");
    }

    deleteRecord(&database, 2);
    printf(""Database contents after deletion:\n"");
    printDatabase(&database);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t addRecord(int64_t * a1, int32_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int32_t a7);
int64_t deleteRecord(int64_t * a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
int32_t function_1070(char * s);
void function_1080(void);
int32_t function_1090(char * format, ...);
int64_t printDatabase(int64_t * a1);
int64_t printRecord(int64_t a1);
int64_t register_tm_clones(void);
int64_t searchRecord(int64_t * a1, int64_t a2);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
int32_t function_1070(char * s) {
    // 0x1070
    return puts(s);
}

// Address range: 0x1080 - 0x108b
void function_1080(void) {
    // 0x1080
    __stack_chk_fail();
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * format, ...) {
    // 0x1090
    return printf(format);
}

// Address range: 0x10a0 - 0x10c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10a0
    int64_t v1; // 0x10a0
    __libc_start_main(0x1499, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10d0 - 0x10f9
int64_t deregister_tm_clones(void) {
    // 0x10d0
    return &g1;
}

// Address range: 0x1100 - 0x1139
int64_t register_tm_clones(void) {
    // 0x1100
    return 0;
}

// Address range: 0x1140 - 0x1179
int64_t __do_global_dtors_aux(void) {
    // 0x1140
    if (*(char *)&g1 != 0) {
        // 0x1178
        int64_t result; // 0x1140
        return result;
    }
    // 0x114d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x115b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1167
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1180 - 0x1189
int64_t frame_dummy(void) {
    // 0x1180
    return register_tm_clones();
}

// Address range: 0x1189 - 0x1204
int64_t addRecord(int64_t * a1, int32_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6, int32_t a7) {
    int64_t result = (int64_t)a1;
    int32_t * v1 = (int32_t *)(result + 0x12c0); // 0x119a
    int64_t v2 = 48 * (int64_t)*v1 + result; // 0x11b4
    *(int64_t *)v2 = (int64_t)a2;
    *(int64_t *)(v2 + 8) = a3;
    *(int64_t *)(v2 + 16) = a4;
    *(int64_t *)(v2 + 24) = a5;
    *(int64_t *)(v2 + 32) = a6;
    *(int64_t *)(v2 + 40) = (int64_t)a7;
    *v1 = *v1 + 1;
    return result;
}

// Address range: 0x1204 - 0x130a
int64_t deleteRecord(int64_t * a1, int64_t a2) {
    int64_t result2 = (int64_t)a1;
    int32_t * v1 = (int32_t *)(result2 + 0x12c0); // 0x1253
    uint32_t v2 = *v1; // 0x1253
    if (v2 == 0) {
        // 0x1303
        return 0;
    }
    int64_t result = v2;
    int32_t v3 = 0; // 0x124b
    int32_t v4 = -1;
    v4 = *(int32_t *)result2 != (int32_t)a2 ? v4 : v3;
    v3++;
    int64_t v5 = v3; // 0x125c
    while (v5 < result) {
        // 0x1224
        v4 = *(int32_t *)(48 * v5 + result2) != (int32_t)a2 ? v4 : v3;
        v3++;
        v5 = v3;
    }
    // 0x125e
    if (v4 == -1) {
        // 0x1303
        return result;
    }
    int32_t v6 = v2 - 1; // 0x12e4
    int64_t v7 = v4; // 0x12ea
    int32_t v8 = v4; // 0x12ea
    if (v7 >= (int64_t)v6) {
        // 0x12ec
        *v1 = v6;
        // 0x1303
        return result2;
    }
    v8++;
    int64_t v9 = 48 * v7 + result2; // 0x128d
    int64_t v10 = v8;
    int64_t v11 = 48 * v10 + result2; // 0x12a5
    *(int64_t *)v9 = *(int64_t *)v11;
    *(int64_t *)(v9 + 8) = *(int64_t *)(v11 + 8);
    *(int64_t *)(v9 + 16) = *(int64_t *)(v11 + 16);
    *(int64_t *)(v9 + 24) = *(int64_t *)(v11 + 24);
    *(int64_t *)(v9 + 32) = *(int64_t *)(v11 + 32);
    *(int64_t *)(v9 + 40) = *(int64_t *)(v11 + 40);
    int32_t v12 = *v1 - 1; // 0x12e4
    while (v10 < (int64_t)v12) {
        // 0x1270
        v8++;
        v9 = 48 * v10 + result2;
        v10 = v8;
        v11 = 48 * v10 + result2;
        *(int64_t *)v9 = *(int64_t *)v11;
        *(int64_t *)(v9 + 8) = *(int64_t *)(v11 + 8);
        *(int64_t *)(v9 + 16) = *(int64_t *)(v11 + 16);
        *(int64_t *)(v9 + 24) = *(int64_t *)(v11 + 24);
        *(int64_t *)(v9 + 32) = *(int64_t *)(v11 + 32);
        *(int64_t *)(v9 + 40) = *(int64_t *)(v11 + 40);
        v12 = *v1 - 1;
    }
    // 0x12ec
    *v1 = v12;
    // 0x1303
    return result2;
}

// Address range: 0x130a - 0x1379
int64_t searchRecord(int64_t * a1, int64_t a2) {
    int64_t v1 = (int64_t)a1;
    uint32_t v2 = *(int32_t *)(v1 + 0x12c0); // 0x1367
    if (v2 == 0) {
        // 0x1377
        return 0;
    }
    int32_t v3 = 0; // 0x135f
    int64_t v4 = v1; // 0x1339
    int64_t result = v4; // 0x1341
    while (*(int32_t *)v4 != (int32_t)a2) {
        // 0x1363
        v3++;
        int64_t v5 = v3; // 0x1370
        result = 0;
        if (v5 >= (int64_t)v2) {
            // break -> 0x1377
            break;
        }
        v4 = 48 * v5 + v1;
        result = v4;
    }
    // 0x1377
    return result;
}

// Address range: 0x1379 - 0x13ec
int64_t printRecord(int64_t a1) {
    // 0x1379
    printf(""ID: %d\n"", a1 & 0xffffffff);
    int64_t v1; // bp+12, 0x1379
    printf(""Name: %s\n"", &v1);
    int64_t v2; // bp+32, 0x1379
    printf(""Address: %s\n"", &v2);
    int32_t v3; // 0x1379
    return printf(""Age: %d\n"", (int64_t)(uint32_t)v3);
}

// Address range: 0x13ec - 0x1499
int64_t printDatabase(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int32_t * v2 = (int32_t *)(v1 + 0x12c0); // 0x1482
    if (*v2 == 0) {
        // 0x1491
        return 0;
    }
    // 0x1406
    int64_t v3; // bp-56, 0x13ec
    int64_t v4 = &v3; // 0x13f5
    int32_t v5 = 0; // 0x1409
    v5++;
    printf(""Record %d:\n"", (int64_t)v5);
    int64_t v6 = v1; // 0x1439
    *(int64_t *)(v4 - 48) = *(int64_t *)v6;
    *(int64_t *)(v4 - 40) = *(int64_t *)(v6 + 8);
    *(int64_t *)(v4 - 32) = *(int64_t *)(v6 + 16);
    *(int64_t *)(v4 - 24) = *(int64_t *)(v6 + 24);
    *(int64_t *)(v4 - 16) = *(int64_t *)(v6 + 32);
    *(int64_t *)(v4 - 8) = *(int64_t *)(v6 + 40);
    printRecord((int64_t)&g2);
    int64_t result = (int64_t)*v2; // 0x1482
    int64_t v7 = v5; // 0x148b
    while (v7 < result) {
        // 0x1406
        v5++;
        printf(""Record %d:\n"", (int64_t)v5);
        v6 = 48 * v7 + v1;
        *(int64_t *)(v4 - 48) = *(int64_t *)v6;
        *(int64_t *)(v4 - 40) = *(int64_t *)(v6 + 8);
        *(int64_t *)(v4 - 32) = *(int64_t *)(v6 + 16);
        *(int64_t *)(v4 - 24) = *(int64_t *)(v6 + 24);
        *(int64_t *)(v4 - 16) = *(int64_t *)(v6 + 32);
        *(int64_t *)(v4 - 8) = *(int64_t *)(v6 + 40);
        printRecord((int64_t)&g2);
        result = (int64_t)*v2;
        v7 = v5;
    }
    // 0x1491
    return result;
}

// Address range: 0x1499 - 0x17ad
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x14b5
    int64_t v2; // bp-4840, 0x1499
    __asm_rep_stosq_memset((char *)&v2, 0, 600);
    bool v3; // 0x1499
    *(int32_t *)((v3 ? -0x12c0 : 0x12c0) + (int64_t)&v2) = 0;
    int64_t v4; // 0x1499
    addRecord(&v2, 1, v4, v4, 0x6e69614d20333231, 0x745320, 0);
    addRecord(&v2, 2, v4, v4, 0x206d6c4520363534, 0x7453, 0);
    addRecord(&v2, 3, v4, v4, 0x656e695020393837, 0x745320, 0);
    puts(""Database contents:"");
    printDatabase(&v2);
    int64_t v5 = searchRecord(&v2, 2); // 0x16e1
    if (v5 == 0) {
        // 0x174d
        puts(""Record not found."");
    } else {
        // 0x16f7
        puts(""Record found:"");
        printRecord(0x100000000 * *(int64_t *)v5 >> 32);
    }
    // 0x175c
    deleteRecord(&v2, 2);
    puts(""Database contents after deletion:"");
    printDatabase(&v2);
    int64_t result = 0; // 0x17a0
    if (v1 != __readfsqword(40)) {
        // 0x17a2
        __stack_chk_fail();
        result = &g2;
    }
    // 0x17a7
    return result;
}

// Address range: 0x17b0 - 0x17bd
int64_t _fini(void) {
    // 0x17b0
    int64_t result; // 0x17b0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        struct record {
            int id;
            char name[100];
            char address[100];
            int age;
        };

        int addRecord(struct record *db, int id, char *name, char *address, int age) {
            int i;
            for (i = 0; i < db->id; i++) {
                if (db[i].id == id) {
                    return -1;
                }
            }
            db->id++;
            db[db->id - 1].id = id;
            strcpy(db[db->id - 1].name, name);
            strcpy(db[db->id - 1].address, address);
            db[db->id - 1].age = age;
            return db->id;
        }

        int deleteRecord(struct record *db, int id) {
            int i;
            for (i = 0; i < db->id; i++) {
                if (db[i].id == id) {
                    break;
                }
            }
            if (i == db->id) {
                return -1;
            }
            for (; i < db->id - 1; i++) {
                db[i].id = db[i + 1].id;
                strcpy(db[i].name, db[i + 1].name);
                strcpy(db[i].address, db[i + 1].address);
                db[i].age = db[i + 1].age;
            }
            db->id--;
            return db->id;
        }

        int searchRecord(struct record *db, int id) {
            int i;
            for (i = 0; i < db->id; i++) {
                if (db[i].id == id) {
                    return i;
                }
            }
            return -1;
        }

        int printRecord(struct record *db, int i) {
            printf(""ID: %d\n"", db[i].id);
            printf(""Name: %s\n"", db[i].name);
            printf(""Address: %s\n"", db[i].address);
            printf(""Age: %d\n"", db[i].age);
            return 0;
        }

        int printDatabase(struct record *db) {
            int i;
            for (i = 0; i < db->id; i++) {
                printf(""Record %d:\n"", i + 1);
                printRecord(db, i);
            }
            return 0;
        }

        int main(int argc, char **argv) {
            struct record db;
            db.id = 0;
            addRecord(&db, 1, ""John"", ""123 Main St."", 25);
            addRecord(&db, 2, ""Jane"", ""456 Maple Ave."", 28);
            addRecord(&db, 3, ""Jack"", ""789 Elm St."", 30);
            printf(""Database contents:\n"");
            printDatabase(&db);
            int i = searchRecord(&db, 2);
            if (i == -1) {
                printf(""Record not found.\n"");
            } else {
                printf(""Record found:\n"");
                printRecord(&db, i);
            }
            deleteRecord(&db, 2);
            printf(""Database contents after deletion:\n"");
            printDatabase(&db);
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Chess engine ; Style: scientific
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define BOARD_SIZE 8

// Structure definition for a chess piece
typedef struct ChessPiece {
    int row;
    int col;
    char type;
} ChessPiece;

// Function prototype declarations
void print_board(ChessPiece board[BOARD_SIZE][BOARD_SIZE]);
bool is_valid_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col, char type);
bool is_valid_pawn_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col);
bool is_valid_knight_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col);
bool is_valid_bishop_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col);
bool is_valid_rook_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col);
bool is_valid_queen_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col);
bool is_valid_king_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col);

// Main function
int main() {
    // Initialize the board with starting chess pieces
    ChessPiece board[BOARD_SIZE][BOARD_SIZE] = {
        {'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'},
        {'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'},
        {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
        {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
        {' ', '.', ' ', '.', ' ', '.', ' ', '.'},
        {'.', ' ', '.', ' ', '.', ' ', '.', ' '},
        {'p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'},
        {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'}
    };
    
    // Print the starting chess board
    printf(""Starting chess board:\n"");
    print_board(board);
    
    // Example usage of the is_valid_move function
    if (is_valid_move(board, 6, 1, 4, 1, 'p')) {
        printf(""Pawn move from (6,1) to (4,1) is valid.\n"");
    } else {
        printf(""Pawn move from (6,1) to (4,1) is invalid.\n"");
    }
    
    return 0;
}

// Function to print the chess board
void print_board(ChessPiece board[BOARD_SIZE][BOARD_SIZE]) {
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            printf(""%c "", board[i][j].type);
        }
        printf(""\n"");
    }
}

// Function to check if a given move is valid
bool is_valid_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col, char type) {
    // TODO: Implement this function
    return false;
}

// Function to check if a given pawn move is valid
bool is_valid_pawn_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col) {
    // TODO: Implement this function
    return false;
}

// Function to check if a given knight move is valid
bool is_valid_knight_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col) {
    // TODO: Implement this function
    return false;
}

// Function to check if a given bishop move is valid
bool is_valid_bishop_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col) {
    // TODO: Implement this function
    return false;
}

// Function to check if a given rook move is valid
bool is_valid_rook_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col) {
    // TODO: Implement this function
    return false;
}

// Function to check if a given queen move is valid
bool is_valid_queen_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col) {
    // TODO: Implement this function
    return false;
}

// Function to check if a given king move is valid
bool is_valid_king_move(ChessPiece board[BOARD_SIZE][BOARD_SIZE], int from_row, int from_col, int to_row, int to_col) {
    // TODO: Implement this function
    return false;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
int32_t function_1090(char * s);
void function_10a0(void);
int32_t function_10b0(char * format, ...);
int64_t is_valid_bishop_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t is_valid_king_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t is_valid_knight_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t is_valid_move(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t is_valid_pawn_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t is_valid_queen_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t is_valid_rook_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t print_board(int64_t * a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(void) {
    // 0x10a0
    __stack_chk_fail();
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return printf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x149d
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b8
    int64_t v2; // bp-792, 0x11a9
    __asm_rep_stosq_memset((char *)&v2, 0, 96);
    v2 = 82;
    puts(""Starting chess board:"");
    print_board(&v2);
    if ((char)is_valid_move(&v2, 6, 1, 4, 1, 112) == 0) {
        // 0x1473
        puts(""Pawn move from (6,1) to (4,1) is invalid."");
    } else {
        // 0x1462
        puts(""Pawn move from (6,1) to (4,1) is valid."");
    }
    int64_t result = 0; // 0x1494
    if (v1 != __readfsqword(40)) {
        // 0x1496
        __stack_chk_fail();
        result = &g2;
    }
    // 0x149b
    return result;
}

// Address range: 0x149d - 0x1535
int64_t print_board(int64_t * a1) {
    int32_t putchar_rc; // 0x1522
    for (int64_t i = 0; i < 8; i++) {
        int64_t v1 = (int64_t)a1 + 8 + 96 * i; // 0x14f0
        for (int64_t j = 0; j < 8; j++) {
            // 0x14bf
            printf(""%c "", *(char *)(v1 + 12 * j));
        }
        // 0x151d
        putchar_rc = putchar(10);
    }
    // 0x1531
    return putchar_rc;
}

// Address range: 0x1535 - 0x155b
int64_t is_valid_move(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1535
    return 0;
}

// Address range: 0x155b - 0x157b
int64_t is_valid_pawn_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x155b
    return 0;
}

// Address range: 0x157b - 0x159b
int64_t is_valid_knight_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x157b
    return 0;
}

// Address range: 0x159b - 0x15bb
int64_t is_valid_bishop_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x159b
    return 0;
}

// Address range: 0x15bb - 0x15db
int64_t is_valid_rook_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x15bb
    return 0;
}

// Address range: 0x15db - 0x15fb
int64_t is_valid_queen_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x15db
    return 0;
}

// Address range: 0x15fb - 0x161b
int64_t is_valid_king_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x15fb
    return 0;
}

// Address range: 0x161c - 0x1629
int64_t _fini(void) {
    // 0x161c
    int64_t result; // 0x161c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            int64_t v1 = __readfsqword(40);
            int64_t v2;
            __asm_rep_stosq_memset((char *)&v2, 0, 96);
            v2 = 82;
            puts(""Starting chess board:"");
            print_board(&v2);
            if ((char)is_valid_move(&v2, 6, 1, 4, 1, 112) == 0) {
                puts(""Pawn move from (6,1) to (4,1) is invalid."");
            } else {
                puts(""Pawn move from (6,1) to (4,1) is valid."");
            }
            if (v1 != __readfsqword(40)) {
                __stack_chk_fail();
            }
            return 0;
        }

        int64_t print_board(int64_t * a1) {
            int32_t putchar_rc;
            for (int64_t i = 0; i < 8; i++) {
                int64_t v1 = (int64_t)a1 + 8 + 96 * i;
                for (int64_t j = 0; j < 8; j++) {
                    printf(""%c "", *(char *)(v1 + 12 * j));
                }
                putchar_rc = putchar(10);
            }
            return putchar_rc;
        }

        int64_t is_valid_move(int64_t * a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            return 0;
        }

        int64_t is_valid_pawn_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
            return 0;
        }

        int64_t is_valid_knight_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
            return 0;
        }

        int64_t is_valid_bishop_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
            return 0;
        }

        int64_t is_valid_rook_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
            return 0;
        }

        int64_t is_valid_queen_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
            return 0;
        }

        int64_t is_valid_king_move(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
            return 0;
        }


",1
"//FormAI DATASET v1.0 Category: Memory management ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 1024

typedef struct cyber_node {
    int id;
    char* name;
    char* cyberpower;
    struct cyber_node* next;
} CyberNode;

CyberNode* cyber_city = NULL;

void add_cyber_node(int id, char* name, char* cyberpower) {
    CyberNode* new_node = (CyberNode*) malloc(sizeof(CyberNode));
    new_node->id = id;
    new_node->name = (char*) malloc(strlen(name) + 1);
    strcpy(new_node->name, name);
    new_node->cyberpower = (char*) malloc(strlen(cyberpower) + 1);
    strcpy(new_node->cyberpower, cyberpower);
    new_node->next = NULL;

    if (cyber_city == NULL) {
        cyber_city = new_node;
    } else {
        CyberNode* current_node = cyber_city;
        while (current_node->next != NULL) {
            current_node = current_node->next;
        }
        current_node->next = new_node;
    }
}

void remove_cyber_node(int id) {
    CyberNode* prev_node = NULL;
    CyberNode* current_node = cyber_city;
    while (current_node != NULL) {
        if (current_node->id == id) {
            if (prev_node == NULL) {
                cyber_city = current_node->next;
            } else {
                prev_node->next = current_node->next;
            }
            free(current_node->name);
            free(current_node->cyberpower);
            free(current_node);
            return;
        }
        prev_node = current_node;
        current_node = current_node->next;
    }
}

void print_cyber_nodes() {
    printf(""Cyber City:\n"");
    printf(""ID\tName\tCyberpower\n"");
    printf(""--\t----\t----------\n"");
    CyberNode* current_node = cyber_city;
    while (current_node != NULL) {
        printf(""%d\t%s\t%s\n"", current_node->id, current_node->name, current_node->cyberpower);
        current_node = current_node->next;
    }
}

int main() {
    add_cyber_node(1, ""Samantha"", ""Hacker"");
    add_cyber_node(2, ""Max"", ""Programmer"");
    add_cyber_node(3, ""Logan"", ""Cyber Ninja"");
    add_cyber_node(4, ""Violet"", ""Data Scientist"");
    print_cyber_nodes();
    remove_cyber_node(2);
    printf(""\nAfter removing Max:\n"");
    print_cyber_nodes();
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t add_cyber_node(int64_t a1, int64_t a2, int64_t a3);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
void function_10a0(int64_t * ptr);
char * function_10b0(char * dest, char * src);
int32_t function_10c0(char * s);
int32_t function_10d0(char * s);
int32_t function_10e0(char * format, ...);
int64_t * function_10f0(int32_t size);
int64_t print_cyber_nodes(void);
int64_t register_tm_clones(void);
int64_t remove_cyber_node(int64_t a1);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int64_t g2 = 0; // 0x4018
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * ptr) {
    // 0x10a0
    free(ptr);
}

// Address range: 0x10b0 - 0x10bb
char * function_10b0(char * dest, char * src) {
    // 0x10b0
    return strcpy(dest, src);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return puts(s);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return strlen(s);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return printf(format);
}

// Address range: 0x10f0 - 0x10fb
int64_t * function_10f0(int32_t size) {
    // 0x10f0
    return malloc(size);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x1410, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g1;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g1 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x12e5
int64_t add_cyber_node(int64_t a1, int64_t a2, int64_t a3) {
    int64_t * mem = malloc(32); // 0x1205
    int64_t result = (int64_t)mem; // 0x1205
    *(int32_t *)mem = (int32_t)a1;
    char * str = (char *)a2; // 0x121e
    int64_t * mem2 = malloc(strlen(str) + 1); // 0x122a
    *(int64_t *)(result + 8) = (int64_t)mem2;
    strcpy((char *)mem2, str);
    char * str2 = (char *)a3; // 0x1258
    int64_t * mem3 = malloc(strlen(str2) + 1); // 0x1264
    *(int64_t *)(result + 16) = (int64_t)mem3;
    strcpy((char *)mem3, str2);
    *(int64_t *)(result + 24) = 0;
    int64_t v1 = g2; // 0x12a1
    if (g2 == 0) {
        // 0x12a3
        g2 = result;
        // 0x12e2
        return result;
    }
    int64_t result2 = v1;
    int64_t * v2 = (int64_t *)(result2 + 24);
    v1 = *v2;
    while (v1 != 0) {
        // 0x12c9
        result2 = v1;
        v2 = (int64_t *)(result2 + 24);
        v1 = *v2;
    }
    // 0x12d6
    *v2 = result;
    // 0x12e2
    return result2;
}

// Address range: 0x12e5 - 0x1387
int64_t remove_cyber_node(int64_t a1) {
    int64_t result = g2;
    if (result == 0) {
        // 0x1385
        return result;
    }
    int32_t v1 = a1; // 0x130f
    int64_t result2; // 0x12e5
    int64_t v2; // 0x12e5
    int64_t v3; // 0x12e5
    if (*(int32_t *)result == v1) {
        // 0x1314
        v3 = *(int64_t *)(result + 24);
        result2 = result;
        goto lab_0x131b;
      lab_0x131b:
        // 0x131b
        g2 = v3;
        v2 = result2;
        goto lab_0x133c;
      lab_0x133c:
        // 0x133c
        free((int64_t *)*(int64_t *)(v2 + 8));
        free((int64_t *)*(int64_t *)(v2 + 16));
        free((int64_t *)v2);
        // 0x1385
        return &g3;
    }
    int64_t v4 = result;
    result2 = *(int64_t *)(v4 + 24);
    while (result2 != 0) {
        // 0x1309
        if (*(int32_t *)result2 == v1) {
            // 0x1314
            v3 = *(int64_t *)(result2 + 24);
            if (v4 != 0) {
                // 0x132c
                *(int64_t *)(v4 + 24) = v3;
                v2 = result2;
                goto lab_0x133c;
            } else {
                goto lab_0x131b;
            }
        }
        v4 = result2;
        result2 = *(int64_t *)(v4 + 24);
    }
    // 0x1385
    return result2;
}

// Address range: 0x1387 - 0x1410
int64_t print_cyber_nodes(void) {
    // 0x1387
    puts(""Cyber City:"");
    puts(""ID\tName\tCyberpower"");
    puts(""--\t----\t----------"");
    if (g2 == 0) {
        // 0x140c
        return g2;
    }
    int64_t result = g2; // 0x140a
    int64_t v1 = *(int64_t *)(result + 16); // 0x13d1
    int64_t v2 = *(int64_t *)(result + 8); // 0x13d9
    uint32_t v3 = *(int32_t *)result; // 0x13e1
    printf(""%d\t%s\t%s\n"", (int64_t)v3, (char *)v2, (char *)v1);
    result += 24;
    while (result != 0) {
        // 0x13cd
        v1 = *(int64_t *)(result + 16);
        v2 = *(int64_t *)(result + 8);
        v3 = *(int32_t *)result;
        printf(""%d\t%s\t%s\n"", (int64_t)v3, (char *)v2, (char *)v1);
        result += 24;
    }
    // 0x140c
    return result;
}

// Address range: 0x1410 - 0x14c4
int main(int argc, char ** argv) {
    // 0x1410
    add_cyber_node(1, (int64_t)""Samantha"", (int64_t)""Hacker"");
    add_cyber_node(2, (int64_t)""Max"", (int64_t)""Programmer"");
    add_cyber_node(3, (int64_t)""Logan"", (int64_t)""Cyber Ninja"");
    add_cyber_node(4, (int64_t)""Violet"", (int64_t)""Data Scientist"");
    print_cyber_nodes();
    remove_cyber_node(2);
    puts(""\nAfter removing Max:"");
    print_cyber_nodes();
    return 0;
}

// Address range: 0x14c4 - 0x14d1
int64_t _fini(void) {
    // 0x14c4
    int64_t result; // 0x14c4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            add_cyber_node(1, ""Samantha"", ""Hacker"");
            add_cyber_node(2, ""Max"", ""Programmer"");
            add_cyber_node(3, ""Logan"", ""Cyber Ninja"");
            add_cyber_node(4, ""Violet"", ""Data Scientist"");
            print_cyber_nodes();
            remove_cyber_node(2);
            puts(""\nAfter removing Max:"");
            print_cyber_nodes();
            return 0;
        }

        int add_cyber_node(int id, char * name, char * cyberpower) {
            int64_t * mem = malloc(32);
            int64_t result = (int64_t)mem;
            *(int32_t *)mem = id;
            char * str = name;
            int64_t * mem2 = malloc(strlen(str) + 1);
            *(int64_t *)(result + 8) = (int64_t)mem2;
            strcpy((char *)mem2, str);
            char * str2 = cyberpower;
            int64_t * mem3 = malloc(strlen(str2) + 1);
            *(int64_t *)(result + 16) = (int64_t)mem3;
            strcpy((char *)mem3, str2);
            *(int64_t *)(result + 24) = 0;
            int64_t v1 = g2;
            if (g2 == 0) {
                g2 = result;
                return result;
            }
            int64_t result2 = v1;
            int64_t v2 = result2;
            int64_t v3 = result2;
            while (v3 != 0) {
                if (*(int32_t *)result2 == id) {
                    v3 = *(int64_t *)(result2 + 24);
                    if (v4 != 0) {
                        *(int64_t *)(v4 + 24) = v3;
                        v2 = result2;
                        goto lab_0x133c;
                    } else {
                        goto lab_0x131b;
                    }
                }
                v4 = result2;
                result2 = *(int64_t *)(v4 + 24);
            }
            lab_0x131b:
            *v2 = result;
            lab_0x133c:
            free((int64_t *)*(int64_t *)(v2 + 8));
            free((int64_t *)*(int64_t *)(v2 + 16));
            free((int64_t *)v2);
            return result2;
        }

        int remove_cyber_node(int id) {
            int64_t result = g2;
            if (result == 0) {
                return result;
            }
            int32_t v1 = id;
            int64_t result2;
            int64_t v2;
            int64_t v3;
            if (*(int32_t *)result == v1) {
                v3 = *(int64_t *)(result + 24);
                result2 = result;
                goto lab_0x131b;
            lab_0x131b:
                g2 = v3;
                v2 = result2;
                goto lab_0x133c;
            lab_0x133c:
                free((int64_t *)*(int64_t *)(v2 + 8));
                free((int64_t *)*(int64_t *)(v2 + 16));
                free((int64_t *)v2);
                return &g3;
            }
            int64_t v4 = result;
            result2 = *(int64_t *)(v4 + 24);
            while (result2 != 0) {
                if (*(int32_t *)result2 == v1) {
                    v3 = *(int64_t *)(result2 + 24);
                    if (v4 != 0) {
                        *(int64_t *)(v4 + 24) = v3;
                        v2 = result2;
                        goto lab_0x133c;
                    } else {
                        goto lab_0x131b;
                    }
                }
                v4 = result2;
                result2 = *(int64_t *)(v4 + 24);
            }
            return result2;
        }

        int print_cyber_nodes() {
            puts(""Cyber City:"");
            puts(""ID\tName\tCyberpower"");
            puts(""--\t----\t----------"");
            if (g2 == 0) {
                return g2;
            }
            int64_t result = g2;
            int64_t v1 = *(int64_t *)(result + 16);
            int64_t v2 = *(int64_t *)(result + 8);
            uint32_t v3 = *(int32_t *)result;
            printf(""%d\t%s\t%s\n"", (int64_t)v3, (char *)v2, (char *)v1);
            result += 24;
            while (result != 0) {
                v1 = *(int64_t *)(result + 16);
                v2 = *(int64_t *)(result + 8);
                v3 = *(int32_t *)result;
                printf(""%d\t%s\t%s\n"", (int64_t)v3, (char *)v2, (char *)v1);
                result += 24;
            }
            return result;
        }


",1
"//FormAI DATASET v1.0 Category: Building a FTP Client ; Style: all-encompassing
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <fcntl.h>

#define SERVER_PORT 21
#define BUF_SIZE 512

int sockfd;

char buffer[BUF_SIZE];
char filename[BUF_SIZE];
char username[BUF_SIZE];
char password[BUF_SIZE];

struct sockaddr_in server_addr;
struct sockaddr_in client_addr;

void open_connection(){
    sockfd = socket(AF_INET, SOCK_STREAM, 0); // create socket 
    if (sockfd == -1){
        perror(""Socket error\n"");
        exit(1);
    }
    
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = inet_addr(""127.0.0.1"");
    
    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1){
        perror(""Connection error\n"");
        exit(1);
    }
}

void send_cmd(char *cmd){
    if (send(sockfd, cmd, strlen(cmd), 0) == -1){
        perror(""Command error\n"");
        exit(1);
    }
}

void read_res(){
    int bytes_read = 0;
    memset(buffer, 0, BUF_SIZE);
    bytes_read = recv(sockfd, buffer, BUF_SIZE, 0);
    if (bytes_read == -1){
        perror(""Error reading response\n"");
        exit(1);
    }
    printf(""%s"", buffer);
}

void login(){
    printf(""Enter your username: "");
    scanf(""%s"", username);
    
    char cmd[BUF_SIZE];
    sprintf(cmd, ""USER %s\r\n"", username);
    send_cmd(cmd);
    read_res();
    
    printf(""Enter your password: "");
    scanf(""%s"", password);
    
    sprintf(cmd, ""PASS %s\r\n"", password);
    send_cmd(cmd);
    read_res();
    
    printf(""\n"");
}

void get_file(){
    printf(""Enter name of file to download: "");
    scanf(""%s"", filename);
    
    char cmd[BUF_SIZE];
    sprintf(cmd, ""TYPE I\r\n"");
    send_cmd(cmd);
    read_res();
    
    sprintf(cmd, ""PASV\r\n"");
    send_cmd(cmd);
    read_res();
    
    // parse port
    int port_high, port_low;
    char *tok = strtok(buffer, ""("");
    tok = strtok(NULL, "","");
    tok = strtok(NULL, "","");
    tok = strtok(NULL, "","");
    tok = strtok(NULL, "","");
    port_high = atoi(tok);
    tok = strtok(NULL, "","");
    port_low = atoi(tok);
    
    int data_sockfd;
    struct sockaddr_in data_addr;
    data_sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (data_sockfd == -1){
        perror(""Data socket error\n"");
        exit(1);
    }
    
    data_addr.sin_family = AF_INET;
    data_addr.sin_port = htons(port_high * 256 + port_low);
    data_addr.sin_addr.s_addr = inet_addr(""127.0.0.1"");
    
    if (connect(data_sockfd, (struct sockaddr *)&data_addr, sizeof(data_addr)) == -1){
        perror(""Data connection error\n"");
        exit(1);
    }
    
    sprintf(cmd, ""RETR %s\r\n"", filename);
    send_cmd(cmd);
    read_res();
    
    FILE *fd;
    fd = fopen(filename, ""wb"");
    if (fd == NULL){
        perror(""File error\n"");
        exit(1);
    }
    
    int bytes_read = 0;
    while ((bytes_read = recv(data_sockfd, buffer, BUF_SIZE, 0)) > 0){
        fwrite(buffer, sizeof(char), bytes_read, fd);
    }
    
    fclose(fd);
    printf(""File download complete!\n"");
    
    close(data_sockfd);
}

void disconnect(){
    send_cmd(""QUIT\r\n"");
    read_res();
    
    close(sockfd);
}

int main(){
    open_connection();
    
    read_res(); // Welcome message
    
    login();
    
    get_file();
    
    disconnect();
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t disconnect(void);
int64_t frame_dummy(void);
void function_1190(int64_t * d);
int32_t function_11a0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11b0(int32_t c);
int32_t function_11c0(char * s);
int32_t function_11d0(struct _IO_FILE * stream);
int32_t function_11e0(char * s);
void function_11f0(void);
int16_t function_1200(int16_t hostshort);
int32_t function_1210(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_1220(char * format, ...);
int64_t * function_1230(int64_t * s, int32_t c, int32_t n);
int32_t function_1240(int32_t fd);
int32_t function_1250(char * cp);
struct _IO_FILE * function_1260(char * filename, char * modes);
void function_1270(char * s);
char * function_1280(char * s, char * delim);
int32_t function_1290(char * nptr);
int32_t function_12a0(char * format, ...);
int32_t function_12b0(char * s, char * format, ...);
void function_12c0(int32_t status);
int32_t function_12d0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_12e0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_12f0(int32_t domain, int32_t type, int32_t protocol);
int64_t get_file(void);
int64_t login(void);
int64_t open_connection(void);
int64_t read_res(void);
int64_t register_tm_clones(void);
int64_t send_cmd(int64_t * str);

// --------------------- Global Variables ---------------------

char g1 = 0; // 0x4020
int32_t g2 = 0; // 0x4040
char * g3; // 0x4060
char ** g4 = NULL; // 0x4260
char ** g5 = NULL; // 0x4460
char ** g6 = NULL; // 0x4660
struct sockaddr * g7 = NULL; // 0x4860
int64_t g8 = 0; // 0x4862
int64_t g9 = 0; // 0x4864
int32_t g10;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g10;
    }
    // 0x1016
    return result;
}

// Address range: 0x1190 - 0x119b
void function_1190(int64_t * d) {
    // 0x1190
    __cxa_finalize(d);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x11a0
    return recv(fd, buf, n, flags);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(int32_t c) {
    // 0x11b0
    return putchar(c);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(char * s) {
    // 0x11c0
    return puts(s);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(struct _IO_FILE * stream) {
    // 0x11d0
    return fclose(stream);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(char * s) {
    // 0x11e0
    return strlen(s);
}

// Address range: 0x11f0 - 0x11fb
void function_11f0(void) {
    // 0x11f0
    __stack_chk_fail();
}

// Address range: 0x1200 - 0x120b
int16_t function_1200(int16_t hostshort) {
    // 0x1200
    return htons(hostshort);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1210
    return send(fd, buf, n, flags);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(char * format, ...) {
    // 0x1220
    return printf(format);
}

// Address range: 0x1230 - 0x123b
int64_t * function_1230(int64_t * s, int32_t c, int32_t n) {
    // 0x1230
    return memset(s, c, n);
}

// Address range: 0x1240 - 0x124b
int32_t function_1240(int32_t fd) {
    // 0x1240
    return close(fd);
}

// Address range: 0x1250 - 0x125b
int32_t function_1250(char * cp) {
    // 0x1250
    return inet_addr(cp);
}

// Address range: 0x1260 - 0x126b
struct _IO_FILE * function_1260(char * filename, char * modes) {
    // 0x1260
    return fopen(filename, modes);
}

// Address range: 0x1270 - 0x127b
void function_1270(char * s) {
    // 0x1270
    perror(s);
}

// Address range: 0x1280 - 0x128b
char * function_1280(char * s, char * delim) {
    // 0x1280
    return strtok(s, delim);
}

// Address range: 0x1290 - 0x129b
int32_t function_1290(char * nptr) {
    // 0x1290
    return atoi(nptr);
}

// Address range: 0x12a0 - 0x12ab
int32_t function_12a0(char * format, ...) {
    // 0x12a0
    return scanf(format);
}

// Address range: 0x12b0 - 0x12bb
int32_t function_12b0(char * s, char * format, ...) {
    // 0x12b0
    return sprintf(s, format);
}

// Address range: 0x12c0 - 0x12cb
void function_12c0(int32_t status) {
    // 0x12c0
    exit(status);
}

// Address range: 0x12d0 - 0x12db
int32_t function_12d0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x12d0
    return connect(fd, addr, len);
}

// Address range: 0x12e0 - 0x12eb
int32_t function_12e0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x12e0
    return fwrite(ptr, size, n, s);
}

// Address range: 0x12f0 - 0x12fb
int32_t function_12f0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x12f0
    return socket(domain, type, protocol);
}

// Address range: 0x1300 - 0x1326
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1300
    int64_t v1; // 0x1300
    __libc_start_main(0x1a3b, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1330 - 0x1359
int64_t deregister_tm_clones(void) {
    // 0x1330
    return 0x4010;
}

// Address range: 0x1360 - 0x1399
int64_t register_tm_clones(void) {
    // 0x1360
    return 0;
}

// Address range: 0x13a0 - 0x13d9
int64_t __do_global_dtors_aux(void) {
    // 0x13a0
    if (g1 != 0) {
        // 0x13d8
        int64_t result; // 0x13a0
        return result;
    }
    // 0x13ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x13bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x13c7
    g1 = 1;
    return result2;
}

// Address range: 0x13e0 - 0x13e9
int64_t frame_dummy(void) {
    // 0x13e0
    return register_tm_clones();
}

// Address range: 0x13e9 - 0x149b
int64_t open_connection(void) {
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1400
    g2 = sock_fd;
    if (sock_fd == -1) {
        // 0x1416
        perror(""Socket error\n"");
        exit(1);
        // UNREACHABLE
    }
    // 0x142f
    *(int16_t *)&g7 = 2;
    *(int16_t *)&g8 = htons(21);
    *(int32_t *)&g9 = inet_addr(""127.0.0.1"");
    int32_t result = connect(g2, (struct sockaddr *)&g7, 16); // 0x1475
    if (result != -1) {
        // 0x1498
        return result;
    }
    // 0x147f
    perror(""Connection error\n"");
    exit(1);
    // UNREACHABLE
}

// Address range: 0x149b - 0x14f2
int64_t send_cmd(int64_t * str) {
    int32_t result = send(g2, str, strlen((char *)str), 0); // 0x14cb
    if (result != -1) {
        // 0x14ef
        return result;
    }
    // 0x14d6
    perror(""Command error\n"");
    exit(1);
    // UNREACHABLE
}

// Address range: 0x14f2 - 0x157f
int64_t read_res(void) {
    // 0x14f2
    memset((int64_t *)&g3, 0, 512);
    if (recv(g2, (int64_t *)&g3, 512, 0) != -1) {
        // 0x155e
        return printf(""%s"", (char *)&g3);
    }
    // 0x1545
    perror(""Error reading response\n"");
    exit(1);
    // UNREACHABLE
}

// Address range: 0x157f - 0x169e
int64_t login(void) {
    int64_t v1 = __readfsqword(40); // 0x158e
    printf(""Enter your username: "");
    scanf(""%s"", (char **)&g5);
    int64_t str; // bp-536, 0x157f
    sprintf((char *)&str, ""USER %s\r\n"", (char *)&g5);
    send_cmd(&str);
    read_res();
    printf(""Enter your password: "");
    scanf(""%s"", (char **)&g6);
    sprintf((char *)&str, ""PASS %s\r\n"", (char *)&g6);
    send_cmd(&str);
    read_res();
    putchar(10);
    int64_t result = 0; // 0x1695
    if (v1 != __readfsqword(40)) {
        // 0x1697
        __stack_chk_fail();
        result = &g10;
    }
    // 0x169c
    return result;
}

// Address range: 0x169e - 0x1a0a
int64_t get_file(void) {
    int64_t v1 = __readfsqword(40); // 0x16ad
    printf(""Enter name of file to download: "");
    scanf(""%s"", (char **)&g4);
    int64_t str; // bp-536, 0x169e
    sprintf((char *)&str, ""TYPE I\r\n"");
    send_cmd(&str);
    read_res();
    sprintf((char *)&str, ""PASV\r\n"");
    send_cmd(&str);
    read_res();
    strtok((char *)&g3, ""("");
    strtok(NULL, "","");
    strtok(NULL, "","");
    strtok(NULL, "","");
    int32_t str_as_i = atoi(strtok(NULL, "","")); // 0x17f2
    int32_t str_as_i2 = atoi(strtok(NULL, "","")); // 0x1822
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x183c
    if (sock_fd == -1) {
        // 0x1850
        perror(""Data socket error\n"");
        exit(1);
        // UNREACHABLE
    }
    int16_t addr = 2; // bp-552, 0x1869
    htons((int16_t)(str_as_i2 + 256 * str_as_i));
    inet_addr(""127.0.0.1"");
    if (connect(sock_fd, (struct sockaddr *)&addr, 16) == -1) {
        // 0x18cc
        perror(""Data connection error\n"");
        exit(1);
        // UNREACHABLE
    }
    // 0x18e5
    sprintf((char *)&str, ""RETR %s\r\n"", (char *)&g4);
    send_cmd(&str);
    read_res();
    struct _IO_FILE * file = fopen((char *)&g4, ""wb""); // 0x1937
    if (file == NULL) {
        // 0x194d
        perror(""File error\n"");
        exit(1);
        // UNREACHABLE
    }
    int32_t nmemb = recv(sock_fd, (int64_t *)&g3, 512, 0); // 0x19b4
    if (nmemb >= 0 == (nmemb != 0)) {
        fwrite((int64_t *)&g3, 1, nmemb, file);
        int32_t nmemb2 = recv(sock_fd, (int64_t *)&g3, 512, 0); // 0x19b4
        while (nmemb2 >= 0 == (nmemb2 != 0)) {
            // 0x1972
            fwrite((int64_t *)&g3, 1, nmemb2, file);
            nmemb2 = recv(sock_fd, (int64_t *)&g3, 512, 0);
        }
    }
    // 0x19c8
    fclose(file);
    puts(""File download complete!"");
    close(sock_fd);
    int64_t result = 0; // 0x1a01
    if (v1 != __readfsqword(40)) {
        // 0x1a03
        __stack_chk_fail();
        result = &g10;
    }
    // 0x1a08
    return result;
}

// Address range: 0x1a0a - 0x1a3b
int64_t disconnect(void) {
    // 0x1a0a
    send_cmd((int64_t *)""QUIT\r\n"");
    read_res();
    return close(g2);
}

// Address range: 0x1a3b - 0x1a7c
int main(int argc, char ** argv) {
    // 0x1a3b
    open_connection();
    read_res();
    login();
    get_file();
    disconnect();
    return 0;
}

// Address range: 0x1a7c - 0x1a89
int64_t _fini(void) {
    // 0x1a7c
    int64_t result; // 0x1a7c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 37

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <arpa/inet.h>
        #include <netinet/in.h>
        #include <sys/socket.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <errno.h>
        #include <stdarg.h>
        #include <stdint.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/time.h>
        #include <sys/resource.h>
        #include <sys/uio.h>
        #include <sys/utsname.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/personality.h>
        #include <sys/ptrace.h>
        #include <sys/user.h>
        #include <sys/statfs.h>
        #include <sys/statvfs.h>
        #include <sys/timeb.h>
        #include <sys/times.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #include <sys/time.h>
        #inclu",0
"//FormAI DATASET v1.0 Category: Game ; Style: mind-bending
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {

  // Welcome message to the player
  printf(""Welcome to the Mind-Bending game!\n"");
  printf(""In this game, you will be given a number between 1 to 100.\n"");
  printf(""Your task is to guess the number that the computer is thinking.\n"");
  printf(""You will have 10 attempts to guess the correct number.\n"");

  // Initializing variables
  int numberToGuess, guess, numberOfGuesses = 0;
  srand(time(0));
  numberToGuess = rand() % 100 + 1;

  // Loop for taking input and giving output
  while(1) {
    printf(""Enter your guess: "");
    scanf(""%d"", &guess);
    numberOfGuesses++;

    if(guess == numberToGuess) {
      printf(""Congratulations! You have guessed the correct number in %d attempts.\n"", numberOfGuesses);
      break;
    }
    else if(guess < numberToGuess) {
      printf(""The number is higher than your guess.\n"");
    }
    else {
      printf(""The number is lower than your guess.\n"");
    }

    if(numberOfGuesses == 10) {
      printf(""Sorry! You have used all your attempts.\n"");
      printf(""The correct number was %d.\n"", numberToGuess);
      break;
    }
  }

  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
void function_10e0(int32_t seed);
int32_t function_10f0(int32_t * timer);
int32_t function_1100(char * format, ...);
int32_t function_1110(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int32_t seed) {
    // 0x10e0
    srand(seed);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(int32_t * timer) {
    // 0x10f0
    return time(timer);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return scanf(format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(void) {
    // 0x1110
    return rand();
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g1;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g1 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x136d
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1215
    puts(""Welcome to the Mind-Bending game!"");
    puts(""In this game, you will be given a number between 1 to 100."");
    puts(""Your task is to guess the number that the computer is thinking."");
    puts(""You will have 10 attempts to guess the correct number."");
    srand(time(NULL));
    int32_t v2 = rand() % 100 + 1; // 0x129c
    int32_t v3 = 0; // 0x129f
    printf(""Enter your guess: "");
    int64_t v4; // bp-28, 0x1209
    scanf(""%d"", &v4);
    v3++;
    while (v2 != (int32_t)v4) {
        if ((v4 & 0xffffffff) < (int64_t)v2) {
            // 0x1300
            puts(""The number is higher than your guess."");
        } else {
            // 0x1311
            puts(""The number is lower than your guess."");
        }
        // 0x1320
        if (v3 == 10) {
            // 0x132a
            puts(""Sorry! You have used all your attempts."");
            printf(""The correct number was %d.\n"", (int64_t)v2);
            goto lab_0x1352;
        }
        printf(""Enter your guess: "");
        scanf(""%d"", &v4);
        v3++;
    }
    // 0x12dd
    printf(""Congratulations! You have guessed the correct number in %d attempts.\n"", (int64_t)v3);
    goto lab_0x1352;
  lab_0x1352:;
    int64_t result = 0; // 0x1364
    if (v1 != __readfsqword(40)) {
        // 0x1366
        __stack_chk_fail();
        result = &g2;
    }
    // 0x136b
    return result;
}

// Address range: 0x1370 - 0x137d
int64_t _fini(void) {
    // 0x1370
    int64_t result; // 0x1370
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int v1 = rand() % 100 + 1;
            int v2 = 0;
            printf(""Welcome to the Mind-Bending game!\n"");
            printf(""In this game, you will be given a number between 1 to 100.\n"");
            printf(""Your task is to guess the number that the computer is thinking.\n"");
            printf(""You will have 10 attempts to guess the correct number.\n"");
            printf(""Enter your guess: "");
            int v3;
            scanf(""%d"", &v3);
            v2++;
            while (v1 != v3) {
                if ((v3 & 0xffffffff) < v1) {
                    printf(""The number is higher than your guess.\n"");
                } else {
                    printf(""The number is lower than your guess.\n"");
                }
                if (v2 == 10) {
                    printf(""Sorry! You have used all your attempts.\n"");
                    printf(""The correct number was %d.\n"", v1);
                    break;
                }
                printf(""Enter your guess: "");
                scanf(""%d"", &v3);
                v2++;
            }
            printf(""Congratulations! You have guessed the correct number in %d attempts.\n"", v2);
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Game ; Style: lively
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
  int size;
  printf(""Enter the size of your game board:"");
  scanf(""%d"", &size);

  int game_board[size][size], i, j;
  srand(time(NULL));
  int rand_num;

  // Initializing game board with random numbers
  for (i = 0; i < size; i++)
  {
    for (j = 0; j < size; j++)
    {
      rand_num = rand() % 10;
      game_board[i][j] = rand_num;
    }
  }

  // Printing the game board
  printf(""\nHere is your game board:\n"");
  for (i = 0; i < size; i++)
  {
    for (j = 0; j < size; j++)
    {
      printf(""%d "", game_board[i][j]);
    }
    printf(""\n"");
  }

  // Game logic
  int row, col, sum, count = 0;
  printf(""\nFind the sum of each row and column.\n"");
  while (count < (2 * size))
  {
    printf(""Enter the row and column numbers (separated by a space):"");
    scanf(""%d %d"", &row, &col);
    if (row >= size || col >= size)
    {
      printf(""Invalid row or column number. Try again.\n"");
    }
    else
    {
      sum = 0;
      for (i = 0; i < size; i++)
      {
        sum += game_board[row][i];
      }
      printf(""The sum of row %d is: %d\n"", row, sum);

      sum = 0;
      for (i = 0; i < size; i++)
      {
        sum += game_board[i][col];
      }
      printf(""The sum of column %d is: %d\n"", col, sum);

      count++;
    }
  }

  printf(""\nCongratulations, you won the game!\n"");
  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(int32_t c);
int32_t function_10d0(char * s);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
void function_1100(int32_t seed);
int32_t function_1110(int32_t * timer);
int32_t function_1120(char * format, ...);
int32_t function_1130(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t c) {
    // 0x10c0
    return putchar(c);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
void function_1100(int32_t seed) {
    // 0x1100
    srand(seed);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int32_t * timer) {
    // 0x1110
    return time(timer);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * format, ...) {
    // 0x1120
    return scanf(format);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(void) {
    // 0x1130
    return rand();
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g1;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (*(char *)&g1 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x1671
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1241
    printf(""Enter the size of your game board:"");
    int64_t v2; // bp-120, 0x1229
    scanf(""%d"", &v2);
    int64_t v3 = 0x100000000 * v2;
    uint64_t v4 = v3 >> 30;
    int64_t v5 = 16 * (v4 * (v3 >> 32) + 15) / 16;
    int64_t v6; // bp-184, 0x1229
    int64_t v7 = (int64_t)&v6 - (v5 & -0x1000) - (v5 & 4080); // 0x13b2
    srand(time(NULL));
    if ((v2 & 0xffffffff) != 0) {
        int64_t v8 = 0; // 0x1229
        int32_t v9 = 0; // 0x146d
        int64_t v10 = 0; // 0x146b
        int32_t v11; // 0x1461
        int64_t v12; // 0x1229
        int64_t v13; // 0x146b
        if ((v2 & 0xffffffff) != 0) {
            // 0x1409
            v11 = 0;
            *(int32_t *)(4 * v8 * v4 / 4 + v7) = rand() % 10;
            v11++;
            v12 = v2 & 0xffffffff;
            v13 = v11;
            v10 = v12;
            while (v12 > v13) {
                // 0x1409
                *(int32_t *)(4 * (v13 + v8 * v4 / 4) + v7) = rand() % 10;
                v11++;
                v12 = v2 & 0xffffffff;
                v13 = v11;
                v10 = v12;
            }
        }
        int64_t v14 = v2; // 0x1471
        v9++;
        int64_t v15 = v9;
        v8 = v15;
        while (v10 > v15) {
            // 0x1465
            v10 = 0;
            int64_t v16 = v14; // 0x146b
            if ((v14 & 0xffffffff) != 0) {
                // 0x1409
                v11 = 0;
                *(int32_t *)(4 * v8 * v4 / 4 + v7) = rand() % 10;
                v11++;
                v12 = v2 & 0xffffffff;
                v13 = v11;
                v10 = v12;
                v16 = v2;
                while (v12 > v13) {
                    // 0x1409
                    *(int32_t *)(4 * (v13 + v8 * v4 / 4) + v7) = rand() % 10;
                    v11++;
                    v12 = v2 & 0xffffffff;
                    v13 = v11;
                    v10 = v12;
                    v16 = v2;
                }
            }
            // 0x146d
            v14 = v16;
            v9++;
            v15 = v9;
            v8 = v15;
        }
    }
    // 0x1479
    puts(""\nHere is your game board:"");
    if ((v2 & 0xffffffff) != 0) {
        int32_t v17 = 0; // 0x14e7
        int64_t v18; // 0x14b1
        int32_t v19; // 0x14d1
        int64_t v20; // 0x14db
        if ((v2 & 0xffffffff) != 0) {
            // 0x149a
            v18 = 0;
            v19 = 0;
            printf(""%d "", (int64_t)*(int32_t *)(4 * v18 + v7));
            v19++;
            v20 = v19;
            while ((v2 & 0xffffffff) > v20) {
                // 0x149a
                printf(""%d "", (int64_t)*(int32_t *)(4 * (v20 + v18) + v7));
                v19++;
                v20 = v19;
            }
        }
        // 0x14dd
        putchar(10);
        v17++;
        int64_t v21 = v17;
        while ((v2 & 0xffffffff) > v21) {
            // 0x14d5
            if ((v2 & 0xffffffff) != 0) {
                // 0x149a
                v18 = v21 * v4 / 4;
                v19 = 0;
                printf(""%d "", (int64_t)*(int32_t *)(4 * v18 + v7));
                v19++;
                v20 = v19;
                while ((v2 & 0xffffffff) > v20) {
                    // 0x149a
                    printf(""%d "", (int64_t)*(int32_t *)(4 * (v20 + v18) + v7));
                    v19++;
                    v20 = v19;
                }
            }
            // 0x14dd
            putchar(10);
            v17++;
            v21 = v17;
        }
    }
    // 0x14f3
    puts(""\nFind the sum of each row and column."");
    if (v2 % 0x80000000 != 0) {
        uint64_t v22 = v4 / 4;
        int32_t v23 = 0; // 0x1621
        int64_t v24; // bp-112, 0x1229
        int64_t v25; // bp-116, 0x1229
        uint64_t v26; // 0x1229
        uint64_t v27; // 0x1229
        while (true) {
            // 0x150e
            printf(""Enter the row and column numbers (separated by a space):"");
            scanf(""%d %d"", &v25, &v24);
            v26 = v25 & 0xffffffff;
            v27 = v2 & 0xffffffff;
            if (v26 < v27) {
                // 0x154b
                if ((v24 & 0xffffffff) < v27) {
                    // break -> 0x1579
                    break;
                }
            }
            // 0x1555
            puts(""Invalid row or column number. Try again."");
            if ((2 * v2 & 0xfffffffe) <= 0) {
                // break (via goto) -> 0x1633
                goto lab_0x1633;
            }
        }
        int32_t v28 = 0; // 0x159d
        int32_t v29 = *(int32_t *)(4 * (0x100000000 * v25 >> 32) * v22 + v7); // 0x159a
        v28++;
        int64_t v30 = v28;
        int32_t v31 = v29; // 0x15a7
        int32_t v32; // 0x1597
        while (v27 > v30) {
            // 0x1579
            v32 = *(int32_t *)(4 * (v30 + (0x100000000 * v25 >> 32) * v22) + v7);
            v29 = v32 + v31;
            v28++;
            v30 = v28;
            v31 = v29;
        }
        // 0x15a9
        printf(""The sum of row %d is: %d\n"", v26, (int64_t)v29);
        uint64_t v33 = v2 & 0xffffffff;
        int32_t v34 = 0; // 0x1603
        int64_t v35; // 0x1229
        int32_t v36; // 0x15f6
        int32_t v37; // 0x15f9
        if (v33 != 0) {
            // 0x15d5
            v37 = 0;
            v36 = 0;
            v36 += *(int32_t *)(4 * (0x100000000 * v24 >> 32) + v7);
            v37++;
            v35 = v37;
            v34 = v36;
            while (v33 > v35) {
                // 0x15d5
                v36 += *(int32_t *)(4 * (v35 * v22 + (0x100000000 * v24 >> 32)) + v7);
                v37++;
                v35 = v37;
                v34 = v36;
            }
        }
        // 0x1605
        printf(""The sum of column %d is: %d\n"", v24 & 0xffffffff, (int64_t)v34);
        v23++;
        int64_t v38 = v23; // 0x162d
        while ((2 * v2 & 0xfffffffe) > v38) {
            uint64_t v39 = v38;
            while (true) {
                // 0x150e
                printf(""Enter the row and column numbers (separated by a space):"");
                scanf(""%d %d"", &v25, &v24);
                v26 = v25 & 0xffffffff;
                v27 = v2 & 0xffffffff;
                if (v26 < v27) {
                    // 0x154b
                    if ((v24 & 0xffffffff) < v27) {
                        // break -> 0x1579
                        break;
                    }
                }
                // 0x1555
                puts(""Invalid row or column number. Try again."");
                if ((2 * v2 & 0xfffffffe) <= v39) {
                    // break (via goto) -> 0x1633
                    goto lab_0x1633;
                }
            }
            // 0x1579
            v28 = 0;
            v29 = *(int32_t *)(4 * (0x100000000 * v25 >> 32) * v22 + v7);
            v28++;
            v30 = v28;
            v31 = v29;
            while (v27 > v30) {
                // 0x1579
                v32 = *(int32_t *)(4 * (v30 + (0x100000000 * v25 >> 32) * v22) + v7);
                v29 = v32 + v31;
                v28++;
                v30 = v28;
                v31 = v29;
            }
            // 0x15a9
            printf(""The sum of row %d is: %d\n"", v26, (int64_t)v29);
            v33 = v2 & 0xffffffff;
            v34 = 0;
            if (v33 != 0) {
                // 0x15d5
                v37 = 0;
                v36 = 0;
                v36 += *(int32_t *)(4 * (0x100000000 * v24 >> 32) + v7);
                v37++;
                v35 = v37;
                v34 = v36;
                while (v33 > v35) {
                    // 0x15d5
                    v36 += *(int32_t *)(4 * (v35 * v22 + (0x100000000 * v24 >> 32)) + v7);
                    v37++;
                    v35 = v37;
                    v34 = v36;
                }
            }
            // 0x1605
            printf(""The sum of column %d is: %d\n"", v24 & 0xffffffff, (int64_t)v34);
            v23++;
            v38 = v23;
        }
    }
  lab_0x1633:
    // 0x1633
    puts(""\nCongratulations, you won the game!"");
    int64_t result = 0; // 0x165b
    if (v1 != __readfsqword(40)) {
        // 0x165d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1662
    return result;
}

// Address range: 0x1674 - 0x1681
int64_t _fini(void) {
    // 0x1674
    int64_t result; // 0x1674
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            int size;
            printf(""Enter the size of your game board:"");
            scanf(""%d"", &size);
            int v1 = 0x100000000 * size;
            uint64_t v2 = v1 >> 30;
            int v3 = 16 * (v2 * (v1 >> 32) + 15) / 16;
            int v4;
            srand(time(NULL));
            if ((size & 0xffffffff) != 0) {
                int v5 = 0;
                int v6 = 0;
                int v7 = 0;
                int v8 = 0;
                while (size > v5) {
                    v6 = 0;
                    while (size > v6) {
                        *(int32_t *)(4 * v5 * v2 / 4 + v4) = rand() % 10;
                        v7++;
                        v8 = v7;
                    }
                    v5++;
                    v4 = v8;
                }
            }
            puts(""\nHere is your game board:"");
            if ((size & 0xffffffff) != 0) {
                int v9 = 0;
                while (size > v9) {
                    if ((size & 0xffffffff) != 0) {
                        int v10 = 0;
                        while (size > v10) {
                            printf(""%d "", *(int32_t *)(4 * v9 * v2 / 4 + v4));
                            v10++;
                        }
                        putchar(10);
                    }
                    v9++;
                }
            }
            puts(""\nFind the sum of each row and column."");
            if (size % 0x80000000 != 0) {
                uint64_t v11 = v2 / 4;
                int v12 = 0;
                int v13 = 0;
                while (true) {
                    printf(""Enter the row and column numbers (separated by a space):"");
                    scanf(""%d %d"", &v13, &v12);
                    if (v13 < size) {
                        if (v12 < size) {
                            break;
                        }
                    }
                    puts(""Invalid row or column number. Try again."");
                    if ((2 * size & 0xfffffffe) <= v12) {
                        break;
                    }
                }
                int v14 = 0;
                int v15 = *(int32_t *)(4 * (0x100000000 * v13 >> 32) * v11 + v4);
                v14++;
                int v16 = v14;
                while (size > v16) {
                    v15 += *(int32_t *)(4 * (v16 + (0x100000000 * v13 >> 32) * v11) + v4);
                    v14++;
                    v16 = v14;
                }
                printf(""The sum of row %d is: %d\n"", v13, v15);
                uint64_t v17 = size;
                int v18 = 0;
                int v19 = 0;
                while (v17 > v18) {
                    v19 = 0;
                    while (v17 > v19) {
                        v19 += *(int32_t *)(4 * (v19 * v11 + (0x100000000 * v18 >> 32)) + v4);
                        v18++;
                    }
                    printf(""The sum of column %d is: %d\n"", v18, v19);
                    v17++;
                    v18 = v17;
                }
            }
            puts(""\nCongratulations, you won the game!"");
            return 0;
        }

",1
"//FormAI DATASET v1.0. Category: Graph representation ; Style: content
#include <stdio.h>
#include <stdlib.h>

struct Graph {
    int vertices; // number of vertices in the graph
    int** matrix; // 2D matrix representation of the graph
};

// function to create a graph with n vertices
struct Graph* createGraph(int n) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->vertices = n;

    // allocate memory for the 2D matrix
    graph->matrix = (int**)malloc(n * sizeof(int*));

    for (int i = 0; i < n; i++) {
        graph->matrix[i] = (int*)malloc(n * sizeof(int)); // allocate memory for each row
        for (int j = 0; j < n; j++) {
            graph->matrix[i][j] = 0; // initialize all values to 0
        }
    }

    return graph;
}

// function to add an edge to the graph between vertices src and dest
void addEdge(struct Graph* graph, int src, int dest) {
    graph->matrix[src][dest] = 1;
    graph->matrix[dest][src] = 1; // if graph is undirected
}

// function to print the graph
void printGraph(struct Graph* graph) {
    printf(""Graph:\n"");

    for (int i = 0; i < graph->vertices; i++) {
        for (int j = 0; j < graph->vertices; j++) {
            printf(""%d "", graph->matrix[i][j]);
        }
        printf(""\n"");
    }
}

// main function
int main() {
    struct Graph* graph = createGraph(5);

    // add edges to the graph
    addEdge(graph, 0, 1);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);
    addEdge(graph, 3, 4);
    addEdge(graph, 4, 0);

    // print the graph
    printGraph(graph);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t addEdge(int64_t a1, int64_t a2, int64_t a3);
int64_t createGraph(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
int32_t function_1090(char * s);
int32_t function_10a0(char * format, ...);
int64_t * function_10b0(int32_t size);
int64_t printGraph(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int64_t * function_10b0(int32_t size) {
    // 0x10b0
    return malloc(size);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x1372, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1273
int64_t createGraph(int64_t a1) {
    uint32_t v1 = (int32_t)a1;
    int64_t * mem = malloc(16); // 0x11be
    int64_t result = (int64_t)mem; // 0x11be
    *(int32_t *)mem = v1;
    int64_t mem2 = (int64_t)malloc(8 * v1); // 0x11dc
    int64_t * v2 = (int64_t *)(result + 8); // 0x11e8
    *v2 = mem2;
    if (v1 <= 0) {
        // 0x1269
        return result;
    }
    int64_t v3 = a1 & 0xffffffff;
    int64_t v4 = 0;
    int64_t v5 = 8 * v4; // 0x120c
    *(int64_t *)(v5 + mem2) = (int64_t)malloc(4 * v1);
    int64_t v6 = 0;
    *(int32_t *)(*(int64_t *)(*v2 + v5) + 4 * v6) = 0;
    v6++;
    while (v6 != v3) {
        // 0x1228
        *(int32_t *)(*(int64_t *)(*v2 + v5) + 4 * v6) = 0;
        v6++;
    }
    // 0x125d
    v4++;
    while (v4 != v3) {
        // 0x125d
        v5 = 8 * v4;
        *(int64_t *)(v5 + *v2) = (int64_t)malloc(4 * v1);
        v6 = 0;
        *(int32_t *)(*(int64_t *)(*v2 + v5) + 4 * v6) = 0;
        v6++;
        while (v6 != v3) {
            // 0x1228
            *(int32_t *)(*(int64_t *)(*v2 + v5) + 4 * v6) = 0;
            v6++;
        }
        // 0x125d
        v4++;
    }
    // 0x1269
    return result;
}

// Address range: 0x1273 - 0x12da
int64_t addEdge(int64_t a1, int64_t a2, int64_t a3) {
    int64_t * v1 = (int64_t *)(a1 + 8); // 0x1289
    int64_t v2 = 0x100000000 * a2;
    int64_t v3 = 0x100000000 * a3;
    *(int32_t *)(*(int64_t *)(*v1 + (v2 >> 29)) + (v3 >> 30)) = 1;
    int64_t result = *(int64_t *)(*v1 + (v3 >> 29)) + (v2 >> 30); // 0x12ce
    *(int32_t *)result = 1;
    return result;
}

// Address range: 0x12da - 0x1372
int64_t printGraph(int64_t a1) {
    // 0x12da
    puts(""Graph:"");
    int64_t v1; // 0x12da
    uint64_t result = v1 & 0xffffffff;
    if ((int32_t)v1 == 0) {
        // 0x136e
        return result;
    }
    int64_t v2 = 0; // 0x136c
    int32_t v3 = 0; // 0x135f
    int32_t v4 = 0; // 0x1346
    int64_t v5 = *(int64_t *)(*(int64_t *)(a1 + 8) + 8 * v2); // 0x131f
    printf(""%d "", (int64_t)*(int32_t *)v5);
    v4++;
    int64_t v6 = v4; // 0x1353
    while (result > v6) {
        // 0x130b
        v5 = *(int64_t *)(*(int64_t *)(a1 + 8) + 8 * v2);
        printf(""%d "", (int64_t)*(int32_t *)(v5 + 4 * v6));
        v4++;
        v6 = v4;
    }
    // 0x1355
    putchar(10);
    v3++;
    v2 = v3;
    while (result > v2) {
        // 0x130b
        v4 = 0;
        v5 = *(int64_t *)(*(int64_t *)(a1 + 8) + 8 * v2);
        printf(""%d "", (int64_t)*(int32_t *)v5);
        v4++;
        v6 = v4;
        while (result > v6) {
            // 0x130b
            v5 = *(int64_t *)(*(int64_t *)(a1 + 8) + 8 * v2);
            printf(""%d "", (int64_t)*(int32_t *)(v5 + 4 * v6));
            v4++;
            v6 = v4;
        }
        // 0x1355
        putchar(10);
        v3++;
        v2 = v3;
    }
    // 0x136e
    return result;
}

// Address range: 0x1372 - 0x140d
int main(int argc, char ** argv) {
    int64_t v1 = createGraph(5); // 0x1383
    addEdge(v1, 0, 1);
    addEdge(v1, 1, 2);
    addEdge(v1, 2, 3);
    addEdge(v1, 3, 4);
    addEdge(v1, 4, 0);
    printGraph(v1);
    return 0;
}

// Address range: 0x1410 - 0x141d
int64_t _fini(void) {
    // 0x1410
    int64_t result; // 0x1410
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int g1 = 0;
            int g2;

            int _init(void) {
                int result = 0;
                if (*(int *)0x3fe8 != 0) {
                    __gmon_start__();
                    result = &g2;
                }
                return result;
            }

            void function_1070(int * d) {
                __cxa_finalize(d);
            }

            int function_1080(int c) {
                return putchar(c);
            }

            int function_1090(char * s) {
                return puts(s);
            }

            int function_10a0(char * format, ...) {
                return printf(format);
            }

            int * function_10b0(int size) {
                return malloc(size);
            }

            int _start(int a1, int a2, int a3, int a4, int a5, int a6) {
                __libc_start_main(0x1372, (int)a6, (char **)&a1, NULL, NULL, (void (*)())a3);
                __asm_hlt();
            }

            int deregister_tm_clones(void) {
                return &g1;
            }

            int register_tm_clones(void) {
                return 0;
            }

            int __do_global_dtors_aux(void) {
                if (*(char *)&g1 != 0) {
                    __cxa_finalize((int *)*(int *)0x4008);
                }
                int result = deregister_tm_clones();
                *(char *)&g1 = 1;
                return result;
            }

            int frame_dummy(void) {
                return register_tm_clones();
            }

            int createGraph(int a1) {
                int v1 = a1;
                int * mem = malloc(16);
                int result = (int)mem;
                *(int *)mem = v1;
                int mem2 = (int)malloc(8 * v1);
                int * v2 = (int *)(result + 8);
                *v2 = mem2;
                if (v1 <= 0) {
                    return result;
                }
                int v3 = a1 & 0xffffffff;
                int v4 = 0;
                int v5 = 8 * v4;
                *(int *)(v5 + mem2) = (int)malloc(4 * v1);
                int v6 = 0;
                *(int *)(*v2 + v5) = 0;
                v6++;
                while (v6 != v3) {
                    *(int *)(*v2 + v5) = 0;
                    v6++;
                }
                v4++;
                while (v4 != v3) {
                    v5 = 8 * v4;
                    *(int *)(v5 + *v2) = (int)malloc(4 * v1);
                    v6 = 0;
                    *(int *)(*v2 + v5) = 0;
                    v6++;
                    while (v6 != v3) {
                        *(int *)(*v2 + v5) = 0;
                        v6++;
                    }
                    v4++;
                }
                return result;
            }

            int addEdge(int a1, int a2, int a3) {
                int * v1 = (int *)(a1 + 8);
                int v2 = 0x100000000 * a2;
                int v3 = 0x100000000 * a3;
                *(int *)(*v1 + (v2 >> 29)) = 1;
                int result = *(int *)(*v1 + (v3 >> 29)) + (v2 >> 30);
                *(int *)result = 1;
                return result;
            }

            int printGraph(int a1) {
                puts(""Graph:"");
                int v1;
                int result = v1 & 0xffffffff;
                if ((int)v1 == 0) {
                    return result;
                }
                int v2 = 0;
                int v3 = 0;
                int v4 = 0;
                int v5 = *(int *)(*(int *)(a1 + 8) + 8 * v2);
                printf(""%d "", v5);
                v4++;
                int v6 = v4;
                while (result > v6) {
                    v5 = *(int *)(*(int *)(a1 + 8) + 8 * v2);
                    printf(""%d "", *(v5 + 4 * v6));
                    v4++;
                    v6 = v4;
                }
                putchar(10);
                v3++;
                v2 = v3;
                while (result > v2) {
                    v4 = 0;
                    v5 = *(int *)(*(int *)(a1 + 8) + 8 * v2);
                    printf(""%d "", v5);
                    v4++;
                    v6 = v4;
                    while (result > v6) {
                        v5 = *(int *)(*(int *)(a1 + 8) + 8 * v2);
                        printf(""%d "", *(v5 + 4 * v6));
                        v4++;
                        v6 = v4;
                    }
                    putchar(10);
                    v3++;
                    v2 = v3;
                }
                return result;
            }

            int _fini(void) {
                return 0;
            }
        }

",1
"//FormAI DATASET v1.0 Category: Alien Invasion Probability Calculator ; Style: happy
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main(){
    int prob;
    srand(time(NULL));  //initialize the seed for random number generation
    prob = rand()%101;   //generate a random number between 0 and 100 as probability of alien invasion

    printf(""Welcome to the Alien Invasion Probability Calculator!\n\n"");
    printf(""The current probability of an alien invasion is: %d%%\n\n"", prob);

    if(prob >= 75){
        printf(""It's highly likely that an alien invasion will occur in the near future.\n"");
        printf(""Please make sure to be prepared for any unexpected scenario!\n"");
    }
    else if(prob < 75 && prob >= 50){
        printf(""The probability of an alien invasion is moderate.\n"");
        printf(""It's always better to be safe than sorry, so keep an eye out for any suspicious activity!\n"");
    }
    else{
        printf(""The probability of an alien invasion is low.\n"");
        printf(""Phew! That's a relief. Let's just hope it stays that way.\n"");
    }

    printf(""\nThank you for using the Alien Invasion Probability Calculator!\n"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(char * s);
int32_t function_10a0(char * format, ...);
void function_10b0(int32_t seed);
int32_t function_10c0(int32_t * timer);
int32_t function_10d0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int32_t seed) {
    // 0x10b0
    srand(seed);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t * timer) {
    // 0x10c0
    return time(timer);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(void) {
    // 0x10d0
    return rand();
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x11c9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g1;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g1 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x12bf
int main(int argc, char ** argv) {
    // 0x11c9
    srand(time(NULL));
    int32_t v1 = rand() % 101;
    puts(""Welcome to the Alien Invasion Probability Calculator!\n"");
    printf(""The current probability of an alien invasion is: %d%%\n\n"", (int64_t)v1);
    if (v1 >= 75) {
        // 0x123f
        puts(""It's highly likely that an alien invasion will occur in the near future."");
        puts(""Please make sure to be prepared for any unexpected scenario!"");
        // 0x12a9
        puts(""\nThank you for using the Alien Invasion Probability Calculator!"");
        return 0;
    }
    if (v1 < 50) {
        // 0x128b
        puts(""The probability of an alien invasion is low."");
        puts(""Phew! That's a relief. Let's just hope it stays that way."");
    } else {
        // 0x126b
        puts(""The probability of an alien invasion is moderate."");
        puts(""It's always better to be safe than sorry, so keep an eye out for any suspicious activity!"");
    }
    // 0x12a9
    puts(""\nThank you for using the Alien Invasion Probability Calculator!"");
    return 0;
}

// Address range: 0x12c0 - 0x12cd
int64_t _fini(void) {
    // 0x12c0
    int64_t result; // 0x12c0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 14

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            int v1 = rand() % 101;
            puts(""Welcome to the Alien Invasion Probability Calculator!\n"");
            printf(""The current probability of an alien invasion is: %d%%\n\n"", (int64_t)v1);
            if (v1 >= 75) {
                puts(""It's highly likely that an alien invasion will occur in the near future."");
                puts(""Please make sure to be prepared for any unexpected scenario!"");
                puts(""\nThank you for using the Alien Invasion Probability Calculator!"");
                return 0;
            }
            if (v1 < 50) {
                puts(""The probability of an alien invasion is low."");
                puts(""Phew! That's a relief. Let's just hope it stays that way."");
            } else {
                puts(""The probability of an alien invasion is moderate."");
                puts(""It's always better to be safe than sorry, so keep an eye out for any suspicious activity!"");
            }
            puts(""\nThank you for using the Alien Invasion Probability Calculator!"");
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Breakout Game Clone ; Style: safe
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <termios.h>

#define HEIGHT 20
#define WIDTH 50

#define BRICK_CHAR '#'
#define BALL_CHAR 'o'
#define PADDLE_CHAR '='

struct termios orig_termios;
static void reset_terminal_mode()
{
    tcsetattr(0, TCSANOW, &orig_termios);
}
static void set_conio_terminal_mode()
{
    struct termios new_termios;

    /* take two copies - one for now, one for later */
    tcgetattr(0, &orig_termios);
    memcpy(&new_termios, &orig_termios, sizeof(new_termios));

    /* register cleanup handler, and set the new terminal mode */
    atexit(reset_terminal_mode);
    cfmakeraw(&new_termios);
    tcsetattr(0, TCSANOW, &new_termios);
}
static int kbhit()
{
    struct timeval tv = { 0L, 0L };
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(0, &fds);
    return select(1, &fds, NULL, NULL, &tv);
}

int main()
{
    srand(time(NULL));
    set_conio_terminal_mode();
    int score = 0;
    int lives = 3;

    char screen[HEIGHT][WIDTH];
    for (int i = 0; i < HEIGHT; i++)
    {
        for (int j = 0; j < WIDTH; j++)
        {
            screen[i][j] = ' ';
        }
    }

    int paddle_pos = WIDTH / 2 - 5;
    int ball_x = WIDTH / 2;
    int ball_y = HEIGHT - 2;
    int ball_dir_x = 1;
    int ball_dir_y = -1;

    while (1)
    {
        usleep(10000);

        // Handle input
        if (kbhit())
        {
            char c = getchar();
            if (c == 'a' && paddle_pos > 0)
            {
                paddle_pos--;
            }
            if (c == 'd' && paddle_pos < WIDTH - 10)
            {
                paddle_pos++;
            }
        }

        // Move ball
        if (ball_x + ball_dir_x == 0 || ball_x + ball_dir_x == WIDTH - 1)
        {
            ball_dir_x = -ball_dir_x;
        }
        if (ball_y + ball_dir_y == 0)
        {
            ball_dir_y = -ball_dir_y;
        }
        if (ball_y + ball_dir_y == HEIGHT - 1)
        {
            lives--;
            ball_x = WIDTH / 2;
            ball_y = HEIGHT - 2;
            ball_dir_x = 1;
            ball_dir_y = -1;
            if (lives == 0)
            {
                printf(""Game Over!\n"");
                exit(0);
            }
        }
        if (ball_y + ball_dir_y == HEIGHT - 2 && ball_x + ball_dir_x >= paddle_pos && ball_x + ball_dir_x < paddle_pos + 10)
        {
            ball_dir_y = -ball_dir_y;
            score++;
        }
        ball_x += ball_dir_x;
        ball_y += ball_dir_y;

        // Draw screen
        for (int i = 0; i < HEIGHT; i++)
        {
            for (int j = 0; j < WIDTH; j++)
            {
                if (i == ball_y && j == ball_x)
                {
                    screen[i][j] = BALL_CHAR;
                }
                else if (i == HEIGHT - 1)
                {
                    if (j >= paddle_pos && j < paddle_pos + 10)
                    {
                        screen[i][j] = PADDLE_CHAR;
                    }
                    else
                    {
                        screen[i][j] = ' ';
                    }
                }
                else if (i < 5 && j % 5 == 0)
                {
                    screen[i][j] = BRICK_CHAR;
                }
                else
                {
                    screen[i][j] = ' ';
                }
                printf(""%c"", screen[i][j]);
            }
            printf(""\n"");
        }
        printf(""Score: %d\tLives: %d\n"", score, lives);
        printf(""Use arrow keys to move paddle left and right\n"");
        printf(""Press Ctrl+C to quit\n"");

        // Clear screen
        printf(""\033[2J"");

        // Check for win
        int bricks_left = 0;
        for (int i = 0; i < HEIGHT; i++)
        {
            for (int j = 0; j < WIDTH; j++)
            {
                if (screen[i][j] == BRICK_CHAR)
                {
                    bricks_left = 1;
                    break;
                }
            }
            if (bricks_left)
            {
                break;
            }
        }
        if (!bricks_left)
        {
            printf(""You win!\n"");
            exit(0);
        }
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/select.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct termios {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char e4;
    char e5[1];
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1110(int64_t * d);
int32_t function_1120(int32_t c);
int32_t function_1130(char * s);
void function_1140(void);
int32_t function_1150(char * format, ...);
void function_1160(int32_t seed);
int32_t function_1170(void);
int32_t function_1180(int32_t * timer);
int32_t function_1190(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
void function_11a0(struct termios * termios_p);
int32_t function_11b0(int32_t fd, struct termios * termios_p);
int32_t function_11c0(int32_t fd, int32_t optional_actions, struct termios * termios_p);
int32_t function_11d0(void (*func)(int64_t *), int64_t * arg, int64_t * dso_handle);
void function_11e0(int32_t status);
int32_t function_11f0(int32_t useconds);
int64_t kbhit(void);
int64_t register_tm_clones(void);
int64_t reset_terminal_mode(void);
int64_t set_conio_terminal_mode(void);

// --------------------- Global Variables ---------------------

char * g1 = ""\x1b[2J""; // 0x206a
char * g2 = ""a""; // 0x3f0
char g3 = 0; // 0x4020
struct termios * g4 = NULL; // 0x4040
int32_t g5;

// ------- Dynamically Linked Functions Without Header --------

int32_t __cxa_atexit(void (*a1)(int64_t *), int64_t * a2, int64_t * a3);
void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g5;
    }
    // 0x1016
    return result;
}

// Address range: 0x1110 - 0x111b
void function_1110(int64_t * d) {
    // 0x1110
    __cxa_finalize(d);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(int32_t c) {
    // 0x1120
    return putchar(c);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * s) {
    // 0x1130
    return puts(s);
}

// Address range: 0x1140 - 0x114b
void function_1140(void) {
    // 0x1140
    __stack_chk_fail();
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * format, ...) {
    // 0x1150
    return printf(format);
}

// Address range: 0x1160 - 0x116b
void function_1160(int32_t seed) {
    // 0x1160
    srand(seed);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(void) {
    // 0x1170
    return getchar();
}

// Address range: 0x1180 - 0x118b
int32_t function_1180(int32_t * timer) {
    // 0x1180
    return time(timer);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x1190
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x11a0 - 0x11ab
void function_11a0(struct termios * termios_p) {
    // 0x11a0
    cfmakeraw(termios_p);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(int32_t fd, struct termios * termios_p) {
    // 0x11b0
    return tcgetattr(fd, termios_p);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(int32_t fd, int32_t optional_actions, struct termios * termios_p) {
    // 0x11c0
    return tcsetattr(fd, optional_actions, termios_p);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(void (*func)(int64_t *), int64_t * arg, int64_t * dso_handle) {
    // 0x11d0
    return __cxa_atexit(func, arg, dso_handle);
}

// Address range: 0x11e0 - 0x11eb
void function_11e0(int32_t status) {
    // 0x11e0
    exit(status);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(int32_t useconds) {
    // 0x11f0
    return usleep(useconds);
}

// Address range: 0x1200 - 0x1226
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1200
    int64_t v1; // 0x1200
    __libc_start_main(0x149d, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1230 - 0x1259
int64_t deregister_tm_clones(void) {
    // 0x1230
    return 0x4010;
}

// Address range: 0x1260 - 0x1299
int64_t register_tm_clones(void) {
    // 0x1260
    return 0;
}

// Address range: 0x12a0 - 0x12d9
int64_t __do_global_dtors_aux(void) {
    // 0x12a0
    if (g3 != 0) {
        // 0x12d8
        int64_t result; // 0x12a0
        return result;
    }
    // 0x12ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x12c7
    g3 = 1;
    return result2;
}

// Address range: 0x12e0 - 0x12e9
int64_t frame_dummy(void) {
    // 0x12e0
    return register_tm_clones();
}

// Address range: 0x12e9 - 0x130d
int64_t reset_terminal_mode(void) {
    // 0x12e9
    return tcsetattr(0, TCSANOW, (struct termios *)&g4);
}

// Address range: 0x130d - 0x13da
int64_t set_conio_terminal_mode(void) {
    int64_t v1 = __readfsqword(40); // 0x1319
    tcgetattr(0, (struct termios *)&g4);
    struct termios * termios_p; // bp-88, 0x130d
    *(int64_t *)&termios_p = (int64_t)g4;
    atexit(0x12e9, (int64_t)&g4);
    cfmakeraw((struct termios *)&termios_p);
    tcsetattr(0, TCSANOW, (struct termios *)&termios_p);
    int64_t result = 0; // 0x13d1
    if (v1 != __readfsqword(40)) {
        // 0x13d3
        __stack_chk_fail();
        result = &g5;
    }
    // 0x13d8
    return result;
}

// Address range: 0x13da - 0x149d
int64_t kbhit(void) {
    int64_t v1 = __readfsqword(40); // 0x13e9
    int64_t timeout = 0; // bp-168, 0x13f8
    int64_t readfds; // bp-152, 0x13da
    for (int64_t i = 0; i < 16; i++) {
        // 0x1428
        *(int64_t *)(8 * i + (int64_t)&readfds) = 0;
    }
    // 0x144d
    readfds |= 1;
    int32_t v2 = select(1, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, (struct timeval *)&timeout); // 0x1482
    int64_t result = v2; // 0x1494
    if (v1 != __readfsqword(40)) {
        // 0x1496
        __stack_chk_fail();
        result = &g5;
    }
    // 0x149b
    return result;
}

// Address range: 0x149d - 0x1a41
int main(int argc, char ** argv) {
    // 0x149d
    int64_t v1; // bp-8, 0x149d
    int64_t v2 = &v1; // 0x14a2
    __readfsqword(40);
    srand(time(NULL));
    set_conio_terminal_mode();
    int64_t v3 = v2 - (int64_t)&g2;
    int64_t v4 = 0;
    for (int64_t i = 0; i < 50; i++) {
        // 0x1502
        *(char *)(50 * v4 + v3 + i) = 32;
    }
    // 0x154b
    v4++;
    int32_t v5 = 0; // 0x1559
    int32_t v6 = 3; // 0x1559
    int32_t v7 = 20; // 0x1559
    int32_t v8 = 25; // 0x1559
    int32_t v9 = 18; // 0x1559
    int32_t v10 = 1; // 0x1559
    int32_t v11 = -1; // 0x1559
    while (v4 != 20) {
        for (int64_t i = 0; i < 50; i++) {
            // 0x1502
            *(char *)(50 * v4 + v3 + i) = 32;
        }
        // 0x154b
        v4++;
        v5 = 0;
        v6 = 3;
        v7 = 20;
        v8 = 25;
        v9 = 18;
        v10 = 1;
        v11 = -1;
    }
    int32_t v12; // 0x149d
    int32_t v13; // 0x149d
    int32_t v14; // 0x149d
    int32_t v15; // 0x149d
    int32_t v16; // 0x149d
    int32_t v17; // 0x149d
    while (true) {
      lab_0x158d:
        // 0x158d
        v12 = v11;
        int32_t v18 = v10;
        v14 = v8;
        int32_t v19 = v7;
        v16 = v6;
        v17 = v5;
        usleep(0x2710);
        int32_t v20 = v19; // 0x15a3
        if ((int32_t)kbhit() != 0) {
            char c = getchar(); // 0x15aa
            int32_t v21 = v19 + (int32_t)(v19 > 0 == c == 97);
            v20 = v21 + (int32_t)(c == 100 == v21 < 40);
        }
        // 0x15e2
        v15 = v20;
        if (v18 == -v14) {
            // 0x1607
            v13 = -v18;
            goto lab_0x160d;
        } else {
            // 0x15f4
            v13 = v18;
            if (v18 + v14 != 49) {
                goto lab_0x160d;
            } else {
                // 0x1607
                v13 = -v18;
                goto lab_0x160d;
            }
        }
    }
  lab_0x1670:
    // 0x1670
    puts(""Game Over!"");
    exit(0);
    // UNREACHABLE
  lab_0x18bb:;
    // 0x18bb
    char c2; // 0x149d
    putchar((int32_t)c2);
    int64_t v22; // 0x149d
    int64_t v23 = v22 + 1;
    int64_t v24 = v23; // 0x190c
    if (v23 == 50) {
        // break -> 0x1912
        goto lab_0x1912;
    }
    goto lab_0x1710;
  lab_0x160d:;
    int32_t v35 = v12 != -v9 ? v12 : -v12;
    int32_t v36 = v16; // 0x1636
    int32_t v37 = v14; // 0x1636
    int32_t v38 = v9; // 0x1636
    int32_t v39 = v13; // 0x1636
    int32_t v40 = v35; // 0x1636
    if (v35 + v9 == 19) {
        int32_t v41 = v16 - 1; // 0x1638
        v36 = v41;
        v37 = 25;
        v38 = 18;
        v39 = 1;
        v40 = -1;
        if (v41 == 0) {
            // break -> 0x1670
            goto lab_0x1670;
        }
    }
    int32_t v42 = v40;
    int32_t v43 = v39;
    int32_t v44 = v38;
    int32_t v45 = v36;
    int32_t v46 = v42 + v44;
    uint32_t v47 = v43 + v37;
    int32_t v48; // 0x149d
    int64_t v49; // 0x149d
    int64_t v50; // 0x149d
    int32_t v51; // 0x149d
    int32_t v52; // 0x149d
    int32_t v53; // 0x149d
    if (v46 != 18) {
        // 0x1689
        v50 = v15;
        v49 = v47;
        v48 = v15 + 9;
        v51 = v46;
        v53 = v17;
        v52 = v42;
    } else {
        int64_t v54 = v47;
        int64_t v55 = v15;
        int32_t v56 = v15 + 9;
        v50 = v55;
        v49 = v54;
        v48 = v56;
        v51 = v46;
        v53 = v17;
        v52 = v42;
        if (v56 >= v47 && v55 <= v54) {
            // 0x16cd
            v50 = v55;
            v49 = v54;
            v48 = v56;
            v51 = v44 - v42;
            v53 = v17 + 1;
            v52 = -v42;
        }
    }
    int32_t v57 = v52;
    int32_t v58 = v53;
    int32_t v26 = v51;
    int64_t v27 = v49;
    int64_t v33 = v50;
    uint64_t v34 = (int64_t)v48;
    int64_t v59 = 0; // 0x149d
    while (true) {
        uint64_t v25 = v59;
        int64_t v30 = 50 * v25;
        char * v28 = (char *)(v3 + v27 + v30);
        v24 = 0;
        while (true) {
          lab_0x1710:
            // 0x1710
            v22 = v24;
            if (v25 == (int64_t)v26 == v27 == v22) {
                // 0x172c
                *v28 = 111;
                char v29 = *(char *)(v27 + v2 - (int64_t)&g2 + v30);
                c2 = v29;
                goto lab_0x18bb;
            } else {
                if (v25 != 19) {
                    if (v25 > 4) {
                        // 0x1882
                        *(char *)(v22 + v2 - (int64_t)&g2 + v30) = 32;
                        c2 = 32;
                        goto lab_0x18bb;
                    } else {
                        int32_t v31 = v22;
                        if (-5 * ((int32_t)(0x66666667 * v22 / 0x200000000) - (v31 >> 31)) != -v31) {
                            // 0x1882
                            *(char *)(v22 + v2 - (int64_t)&g2 + v30) = 32;
                            c2 = 32;
                            goto lab_0x18bb;
                        } else {
                            // 0x1847
                            *(char *)(v22 + v2 - (int64_t)&g2 + v30) = 35;
                            c2 = 35;
                            goto lab_0x18bb;
                        }
                    }
                } else {
                    char * v32 = (char *)(v22 + v2 - (int64_t)&g2 + v30);
                    if (v33 > v22 || v22 > v34) {
                        // 0x17d4
                        *v32 = 32;
                        c2 = 32;
                    } else {
                        // 0x1796
                        *v32 = 61;
                        c2 = 61;
                    }
                    goto lab_0x18bb;
                }
            }
        }
      lab_0x1912:
        // 0x1912
        putchar(10);
        int64_t v60 = v25 + 1;
        v59 = v60;
        if (v60 == 20) {
            // break -> 0x1930
            break;
        }
    }
    // 0x1930
    printf(""Score: %d\tLives: %d\n"", (int64_t)v58, (int64_t)v45);
    puts(""Use arrow keys to move paddle left and right"");
    puts(""Press Ctrl+C to quit"");
    printf((char *)&g1);
    int32_t v61 = 0; // 0x149d
    while (true) {
        int32_t v62 = v61;
        int64_t v63 = 50 * (int64_t)v62 + v3; // 0x19d3
        int32_t v64 = 0; // 0x149d
        while (true) {
          lab_0x19a6:;
            int32_t v65 = v64;
            v5 = v58;
            v6 = v45;
            v7 = v15;
            v8 = v47;
            v9 = v26;
            v10 = v43;
            v11 = v57;
            if (*(char *)(v63 + (int64_t)v65) != 35) {
                int32_t v66 = v65 + 1; // 0x19ef
                v64 = v66;
                if (v66 >= 50) {
                    // break -> 0x1a08
                    break;
                }
                goto lab_0x19a6;
            } else {
                goto lab_0x158d;
            }
        }
        int32_t v67 = v62 + 1; // 0x1a08
        v61 = v67;
        if (v67 >= 20) {
            // 0x1a28
            puts(""You win!"");
            exit(0);
            // UNREACHABLE
        }
    }
}

// Address range: 0x1a64 - 0x1a71
int64_t _fini(void) {
    // 0x1a64
    int64_t result; // 0x1a64
    return result;
}

// --------------- Statically Linked Functions ----------------

// int64_t atexit(int64_t a1, int64_t a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 26

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>
        #include <unistd.h>
        #include <sys/select.h>
        #include <termios.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            set_conio_terminal_mode();
            int v1 = 0;
            int v2 = 3;
            int v3 = 20;
            int v4 = 25;
            int v5 = 18;
            int v6 = 1;
            int v7 = -1;
            while (v1 != 20) {
                for (int i = 0; i < 50; i++) {
                    putchar(' ');
                }
                v1++;
                v2 = 3;
                v3 = 20;
                v4 = 25;
                v5 = 18;
                v6 = 1;
                v7 = -1;
            }
            while (true) {
                int v8 = 0;
                int v9 = 0;
                int v10 = 0;
                int v11 = 0;
                int v12 = 0;
                int v13 = 0;
                int v14 = 0;
                int v15 = 0;
                int v16 = 0;
                int v17 = 0;
                while (true) {
                    int v18 = v16;
                    int v19 = v14;
                    int v20 = v9;
                    int v21 = v8;
                    int v22 = v15;
                    int v23 = v13;
                    int v24 = v12;
                    int v25 = v11;
                    int v26 = v10;
                    int v27 = v7;
                    int v28 = v6;
                    int v29 = v5;
                    int v30 = v4;
                    int v31 = v3;
                    int v32 = v2;
                    int v33 = v1;
                    if (v18 == -v14) {
                        v13 = -v18;
                        goto lab_0x160d;
                    } else {
                        v13 = v18;
                        if (v18 + v14 != 49) {
                            goto lab_0x160d;
                        } else {
                            v13 = -v18;
                            goto lab_0x160d;
                        }
                    }
                }
            lab_0x160d:;
                int v35 = v12 != -v9 ? v12 : -v12;
                int v36 = v16;
                int v37 = v14;
                int v38 = v9;
                int v39 = v13;
                int v40 = v35;
                if (v35 + v9 == 19) {
                    int v41 = v16 - 1;
                    v36 = v41;
                    v37 = 25;
                    v38 = 18;
                    v39 = 1;
                    v40 = -1;
                    if (v41 == 0) {
                        goto lab_0x1670;
                    }
                }
                int v42 = v40;
                int v43 = v39;
                int v44 = v38;
                int v45 = v36;
                int v46 = v42 + v44;
                int v47 = v37 + v43;
                int v48 = v15;
                int v49 = v46;
                int v50 = v49;
                int v51 = v48;
                int v52 = v42;
                int v53 = v43;
                if (v46 != 18) {
                    v50 = v49;
                    v51 = v47;
                    v52 = v46;
                    v53 = v39;
                } else {
                    int v54 = v47;
                    int v55 = v49;
                    int v56 = v48;
                    v50 = v55;
                    v51 = v54;
                    v52 = v56;
                    v53 = v39;
                    if (v56 >= v47 && v55 <= v54) {
                        v50 = v55;
                        v51 = v54;
                        v52 = v56;
                        v53 = v39 + 1;
                    }
                }
                int v57 = v52;
                int v58 = v53;
                int v59 = v45;
                int v60 = v49;
                int v61 = v50;
                int v62 = v51;
                int v63 = v58;
                int v64 = v59;
                int v65 = v60;
                int v66 = v61;
                int v67 = v62;
                int v68 = v63;
                int v69 = v64;
                int v70 = v65;
                int v71 = v66;
                int v72 = v67;
                int v73 = v68;
                int v74 = v69;
                int v75 = v70;
                int v76 = v71;
                int v77 = v72;
                int v78 = v73;
                int v79 = v74;
                int v80 = v75;
                int v81 = v76;
                int v82 = v77;
                int v83 = v78;
                int v84 = v79;
                int v85 = v80;
                int v86 = v81;
                int v87 = v82;
                int v88 = v83;
                int v89 = v84;
                int v90 = v85;
                int v91 = v86;
                int v92 = v87;
                int v93 = v88;
                int v94 = v89;
                int v95 = v90;
                int v96 = v91;
                int v97 = v92;
                int v98 = v93;
                int v99 = v94;
                int v100 = v95;
                int v101 = v96;
                int v102 = v97;
                int v103 = v98;
                int v104 = v99;
                int v105 = v100;
                int v106 = v101;
                int v107 = v102;
                int v108 = v103;
                int v109 = v104;
                int v110 = v105;
                int v111 = v106;
                int v112 = v107;
                int v113 = v108;
                int v114 = v109;
                int v115 = v110;
                int v116 = v111;
                int v117 = v112;
                int v118 = v113;
                int v119 = v114;
                int v120 = v115",0
"//FormAI DATASET v1.0 Category: Personal Finance Planner ; Style: Dennis Ritchie
#include<stdio.h>

int main(){
    float income, savings, expenses;
    int age, retire_age;
    float inflation_rate, roi, salary_increase_rate;

    printf(""Enter your current age: "");
    scanf(""%d"", &age);

    printf(""Enter your retirement age: "");
    scanf(""%d"", &retire_age);

    printf(""Enter your current income: "");
    scanf(""%f"", &income);

    printf(""Enter your current savings: "");
    scanf(""%f"", &savings);

    printf(""Enter your monthly expenses: "");
    scanf(""%f"", &expenses);

    printf(""Enter the expected annual increase in salary: "");
    scanf(""%f"", &salary_increase_rate);

    printf(""Enter the expected inflation rate: "");
    scanf(""%f"", &inflation_rate);

    printf(""Enter the expected rate of return on investment: "");
    scanf(""%f"", &roi);

    float total_saving = savings;
    float total_expense = 0;
    float future_income = income;

    printf(""Year\tAge\tIncome\tExpense\tBalance\n"");

    for(int year = age; year <= retire_age; year++){
        float inflation_adjusted_income = future_income * (1 + (salary_increase_rate - inflation_rate) / 100);
        float inflation_adjusted_expense = expenses * (1 + inflation_rate / 100);

        float interest_income = total_saving * roi / 100;
        total_saving += interest_income;

        float total_income = inflation_adjusted_income * 12;
        total_expense += inflation_adjusted_expense * 12;
        float balance = total_saving - total_expense;
        future_income = inflation_adjusted_income;

        printf(""%d\t%d\t%.2f\t%.2f\t%.2f\n"", year, year-age+1, total_income, total_expense, balance);
    }

    printf(""Total Saving: %.2f\n"", total_saving);
    printf(""Total Expense: %.2f\n"", total_expense);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x151c
int main(int argc, char ** argv) {
    // 0x11a9
    int128_t v1; // 0x11a9
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = __readfsqword(40); // 0x11b5
    printf(""Enter your current age: "");
    int64_t v5; // bp-72, 0x11a9
    scanf(""%d"", &v5);
    printf(""Enter your retirement age: "");
    int64_t v6; // bp-68, 0x11a9
    scanf(""%d"", &v6);
    printf(""Enter your current income: "");
    int32_t v7; // bp-84, 0x11a9
    scanf(""%f"", &v7);
    printf(""Enter your current savings: "");
    int32_t v8; // bp-80, 0x11a9
    scanf(""%f"", &v8);
    printf(""Enter your monthly expenses: "");
    int32_t v9; // bp-76, 0x11a9
    scanf(""%f"", &v9);
    printf(""Enter the expected annual increase in salary: "");
    int32_t v10; // bp-56, 0x11a9
    scanf(""%f"", &v10);
    printf(""Enter the expected inflation rate: "");
    int32_t v11; // bp-64, 0x11a9
    scanf(""%f"", &v11);
    printf(""Enter the expected rate of return on investment: "");
    int32_t v12; // bp-60, 0x11a9
    scanf(""%f"", &v12);
    int128_t v13 = __asm_movss(v8); // 0x133c
    int32_t v14 = __asm_movss_1(v13); // 0x1341
    int32_t v15 = __asm_movss_1(__asm_pxor(v13, v13)); // 0x134a
    int64_t v16 = __asm_movss_1(__asm_movss(v7)); // 0x1354
    puts(""Year\tAge\tIncome\tExpense\tBalance"");
    int32_t v17 = v15; // 0x14ad
    int32_t v18 = v14; // 0x14ad
    if ((v6 & 0xffffffff) >= 0x100000000 * v5 >> 32) {
        int32_t v19 = v14;
        int128_t v20; // 0x11a9
        int128_t v21 = v20;
        uint32_t v22 = (int32_t)v5;
        int128_t v23 = __asm_subss(__asm_movss(v10), __asm_movss(v11)); // 0x137d
        int128_t v24 = __asm_addss(__asm_movss(0x3f800000), __asm_divss(__asm_movaps(v23), __asm_movss(0x42c80000))); // 0x1398
        int32_t v25 = __asm_movss_1(__asm_mulss(v24, __asm_movss((int32_t)v16))); // 0x13a5
        int128_t v26 = __asm_divss(__asm_movaps(__asm_movss(v11)), __asm_movss(0x42c80000)); // 0x13ba
        int64_t v27 = __asm_movss_1(__asm_mulss(__asm_movss(v9), __asm_addss(v26, __asm_movss(0x3f800000)))); // 0x13d3
        int64_t v28 = __asm_movss_1(__asm_divss(__asm_mulss_3(__asm_movss(v12), v19), __asm_movss(0x42c80000))); // 0x13ee
        v19 = __asm_movss_1(__asm_addss_4(__asm_movss(v19), (int32_t)v28));
        int64_t v29 = __asm_movss_1(__asm_mulss(__asm_movss(*(int32_t *)0x2198), __asm_movss(v25))); // 0x1413
        int128_t v30 = __asm_mulss(__asm_movss(0x41400000), __asm_movss((int32_t)v27)); // 0x1425
        int128_t v31 = __asm_movss(v15); // 0x1429
        int32_t v32 = __asm_movss_1(__asm_addss(v30, v31));
        int64_t v33 = __asm_movss_1(__asm_subss_5(__asm_movss(v19), v32)); // 0x1441
        int128_t v34 = __asm_movss(v25); // 0x1446
        int64_t v35 = __asm_movss_1(v34); // 0x144b
        __asm_pxor(v31, v31);
        int128_t v36 = __asm_cvtss2sd((int32_t)v33); // 0x1454
        __asm_pxor(v34, v34);
        int128_t v37 = __asm_cvtss2sd(v32); // 0x145d
        __asm_pxor(v21, v21);
        int128_t v38 = __asm_cvtss2sd((int32_t)v29); // 0x1466
        int64_t v39 = __asm_movq(v38); // 0x146b
        int32_t v40 = v22 + 1;
        int128_t v41 = __asm_movapd(v36); // 0x147e
        int128_t v42 = __asm_movapd(v37); // 0x1482
        printf(""%d\t%d\t%.2f\t%.2f\t%.2f\n"", (int64_t)v22, (int64_t)(v40 - (int32_t)v5), (float64_t)(int64_t)__asm_movq_2(v39), (float64_t)(int64_t)v42, (float64_t)(int64_t)v41);
        v17 = v32;
        v18 = v19;
        while ((v6 & 0xffffffff) >= (int64_t)v40) {
            // 0x1373
            v21 = v38;
            v22 = v40;
            v23 = __asm_subss(__asm_movss(v10), __asm_movss(v11));
            v24 = __asm_addss(__asm_movss(0x3f800000), __asm_divss(__asm_movaps(v23), __asm_movss(0x42c80000)));
            v25 = __asm_movss_1(__asm_mulss(v24, __asm_movss((int32_t)v35)));
            v26 = __asm_divss(__asm_movaps(__asm_movss(v11)), __asm_movss(0x42c80000));
            v27 = __asm_movss_1(__asm_mulss(__asm_movss(v9), __asm_addss(v26, __asm_movss(0x3f800000))));
            v28 = __asm_movss_1(__asm_divss(__asm_mulss_3(__asm_movss(v12), v19), __asm_movss(0x42c80000)));
            v19 = __asm_movss_1(__asm_addss_4(__asm_movss(v19), (int32_t)v28));
            v29 = __asm_movss_1(__asm_mulss(__asm_movss(*(int32_t *)0x2198), __asm_movss(v25)));
            v30 = __asm_mulss(__asm_movss(0x41400000), __asm_movss((int32_t)v27));
            v31 = __asm_movss(v32);
            v32 = __asm_movss_1(__asm_addss(v30, v31));
            v33 = __asm_movss_1(__asm_subss_5(__asm_movss(v19), v32));
            v34 = __asm_movss(v25);
            v35 = __asm_movss_1(v34);
            __asm_pxor(v31, v31);
            v36 = __asm_cvtss2sd((int32_t)v33);
            __asm_pxor(v34, v34);
            v37 = __asm_cvtss2sd(v32);
            __asm_pxor(v21, v21);
            v38 = __asm_cvtss2sd((int32_t)v29);
            v39 = __asm_movq(v38);
            v40 = v22 + 1;
            v41 = __asm_movapd(v36);
            v42 = __asm_movapd(v37);
            printf(""%d\t%d\t%.2f\t%.2f\t%.2f\n"", (int64_t)v22, (int64_t)(v40 - (int32_t)v5), (float64_t)(int64_t)__asm_movq_2(v39), (float64_t)(int64_t)v42, (float64_t)(int64_t)v41);
            v17 = v32;
            v18 = v19;
        }
    }
    // 0x14b3
    __asm_pxor(v3, v3);
    int64_t v43 = __asm_movq(__asm_cvtss2sd(v18)); // 0x14bc
    printf(""Total Saving: %.2f\n"", (float64_t)(int64_t)__asm_movq_2(v43));
    __asm_pxor(v2, v2);
    int64_t v44 = __asm_movq(__asm_cvtss2sd(v17)); // 0x14e3
    printf(""Total Expense: %.2f\n"", (float64_t)(int64_t)__asm_movq_2(v44));
    int64_t result = 0; // 0x1513
    if (v4 != __readfsqword(40)) {
        // 0x1515
        __stack_chk_fail();
        result = &g2;
    }
    // 0x151a
    return result;
}

// Address range: 0x151c - 0x1529
int64_t _fini(void) {
    // 0x151c
    int64_t result; // 0x151c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>
        #include <math.h>

        int main(int argc, char ** argv) {
            int age, retirement, income, savings, expenses, salary_increase, inflation, investment_return;
            float balance;
            printf(""Enter your current age: "");
            scanf(""%d"", &age);
            printf(""Enter your retirement age: "");
            scanf(""%d"", &retirement);
            printf(""Enter your current income: "");
            scanf(""%f"", &income);
            printf(""Enter your current savings: "");
            scanf(""%f"", &savings);
            printf(""Enter your monthly expenses: "");
            scanf(""%f"", &expenses);
            printf(""Enter the expected annual increase in salary: "");
            scanf(""%f"", &salary_increase);
            printf(""Enter the expected inflation rate: "");
            scanf(""%f"", &inflation);
            printf(""Enter the expected rate of return on investment: "");
            scanf(""%f"", &investment_return);
            printf(""Year\tAge\tIncome\tExpense\tBalance\n"");
            for (int year = age; year < retirement; year++) {
                balance = savings + (income - expenses) * (1 + inflation / 100);
                savings = balance * (1 + investment_return / 100);
                printf(""%d\t%d\t%.2f\t%.2f\t%.2f\n"", year, year - age, income, expenses, balance);
            }
            printf(""Total Saving: %.2f\n"", savings);
            printf(""Total Expense: %.2f\n"", (income - expenses) * (retirement - age));
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Disk space analyzer ; Style: optimized
#include <stdio.h>
#include <sys/statvfs.h>

void print_disk_space_info() {
    struct statvfs stat;
    if (statvfs(""/"", &stat) == -1) {
        perror(""statvfs error"");
        return;
    }

    unsigned long long total_space = stat.f_frsize * stat.f_blocks;
    unsigned long long free_space = stat.f_frsize * stat.f_bfree;
    unsigned long long used_space = total_space - free_space;

    int percentage_used_space = (int) ((double) used_space / (double) total_space * 100);

    printf(""Disk space usage information:\n"");
    printf(""Total space: %lld bytes\n"", total_space);
    printf(""Used space: %lld bytes (%d%%)\n"", used_space, percentage_used_space);
    printf(""Free space: %lld bytes\n"", free_space);
}

int main() {
    print_disk_space_info();
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/statvfs.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct statvfs {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12[6];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
int32_t function_1090(char * s);
void function_10a0(void);
int32_t function_10b0(char * format, ...);
int32_t function_10c0(char * file, struct statvfs * buf);
void function_10d0(char * s);
int64_t print_disk_space_info(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(void) {
    // 0x10a0
    __stack_chk_fail();
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return printf(format);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * file, struct statvfs * buf) {
    // 0x10c0
    return statvfs(file, buf);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(char * s) {
    // 0x10d0
    perror(s);
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x1354, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g1;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g1 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x1354
int64_t print_disk_space_info(void) {
    // 0x11c9
    int128_t v1; // 0x11c9
    int128_t v2 = v1;
    int128_t v3 = v1;
    int64_t v4 = __readfsqword(40); // 0x11d8
    int64_t buf; // bp-136, 0x11c9
    if (statvfs(""/"", (struct statvfs *)&buf) != -1) {
        // 0x1216
        int64_t v5; // 0x11c9
        int64_t v6 = v5 * (int64_t)v1; // 0x121e
        int64_t v7 = v5 * (int64_t)v1; // 0x1231
        uint64_t v8 = v6 - v7; // 0x1243
        int128_t v9; // 0x11c9
        if (v8 < 0) {
            // 0x1268
            __asm_pxor(v3, v3);
            int128_t v10 = __asm_cvtsi2sd(v8 / 2 | v8 % 2); // 0x1278
            v9 = __asm_addsd(v10, v10);
        } else {
            // 0x125d
            __asm_pxor(v3, v3);
            v9 = __asm_cvtsi2sd(v8);
        }
        uint64_t v11 = 0x100000000 * v6 >> 32; // 0x1281
        int128_t v12; // 0x11c9
        if ((int32_t)v6 < 0) {
            // 0x1298
            __asm_pxor(v2, v2);
            int128_t v13 = __asm_cvtsi2sd(v11 / 2 | v11 % 2); // 0x12a8
            v12 = __asm_addsd(v13, v13);
        } else {
            // 0x128d
            __asm_pxor(v2, v2);
            v12 = __asm_cvtsi2sd(v11);
        }
        int128_t v14 = __asm_divsd(__asm_movapd(v9), v12); // 0x12b5
        uint32_t v15 = __asm_cvttsd2si(__asm_mulsd(__asm_movsd(0x4059000000000000), v14)); // 0x12c5
        puts(""Disk space usage information:"");
        printf(""Total space: %lld bytes\n"", v11);
        printf(""Used space: %lld bytes (%d%%)\n"", v8, (int64_t)v15);
        printf(""Free space: %lld bytes\n"", v7);
    } else {
        // 0x1202
        perror(""statvfs error"");
    }
    int64_t result = 0; // 0x134b
    if (v4 != __readfsqword(40)) {
        // 0x134d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1352
    return result;
}

// Address range: 0x1354 - 0x136d
int main(int argc, char ** argv) {
    // 0x1354
    print_disk_space_info();
    return 0;
}

// Address range: 0x1370 - 0x137d
int64_t _fini(void) {
    // 0x1370
    int64_t result; // 0x1370
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <sys/statvfs.h>

        int main(int argc, char ** argv) {
            print_disk_space_info();
            return 0;
        }

        int print_disk_space_info(void) {
            int64_t buf;
            if (statvfs(""/"", (struct statvfs *)&buf) != -1) {
                int64_t v5 = buf.f_blocks;
                int64_t v6 = buf.f_bfree;
                int64_t v7 = buf.f_bavail;
                uint64_t v8 = v5 * (int64_t)v5;
                uint64_t v9 = v6 * (int64_t)v5;
                uint64_t v10 = v8 - v9;
                uint64_t v11 = 0x100000000 * v5 >> 32;
                if (v10 < 0) {
                    v10 /= 2;
                    v10 += v10;
                }
                if ((int32_t)v5 < 0) {
                    v11 /= 2;
                    v11 += v11;
                }
                uint32_t v12 = 0x100000000 * v10 >> 32;
                if (v12 < 0) {
                    v12 /= 2;
                    v12 += v12;
                }
                uint32_t v13 = 0x100000000 * v11 >> 32;
                if (v13 < 0) {
                    v13 /= 2;
                    v13 += v13;
                }
                uint32_t v14 = 0x100000000 * v12 >> 32;
                if (v14 < 0) {
                    v14 /= 2;
                    v14 += v14;
                }
                uint32_t v15 = 0x100000000 * v13 >> 32;
                if (v15 < 0) {
                    v15 /= 2;
                    v15 += v15;
                }
                uint32_t v16 = 0x100000000 * v14 >> 32;
                if (v16 < 0) {
                    v16 /= 2;
                    v16 += v16;
                }
                uint32_t v17 = 0x100000000 * v15 >> 32;
                if (v17 < 0) {
                    v17 /= 2;
                    v17 += v17;
                }
                uint32_t v18 = 0x100000000 * v16 >> 32;
                if (v18 < 0) {
                    v18 /= 2;
                    v18 += v18;
                }
                uint32_t v19 = 0x100000000 * v17 >> 32;
                if (v19 < 0) {
                    v19 /= 2;
                    v19 += v19;
                }
                uint32_t v20 = 0x100000000 * v18 >> 32;
                if (v20 < 0) {
                    v20 /= 2;
                    v20 += v20;
                }
                uint32_t v21 = 0x100000000 * v19 >> 32;
                if (v21 < 0) {
                    v21 /= 2;
                    v21 += v21;
                }
                uint32_t v22 = 0x100000000 * v20 >> 32;
                if (v22 < 0) {
                    v22 /= 2;
                    v22 += v22;
                }
                uint32_t v23 = 0x100000000 * v21 >> 32;
                if (v23 < 0) {
                    v23 /= 2;
                    v23 += v23;
                }
                uint32_t v24 = 0x100000000 * v22 >> 32;
                if (v24 < 0) {
                    v24 /= 2;
                    v24 += v24;
                }
                uint32_t v25 = 0x100000000 * v23 >> 32;
                if (v25 < 0) {
                    v25 /= 2;
                    v25 += v25;
                }
                uint32_t v26 = 0x100000000 * v24 >> 32;
                if (v26 < 0) {
                    v26 /= 2;
                    v26 += v26;
                }
                uint32_t v27 = 0x100000000 * v25 >> 32;
                if (v27 < 0) {
                    v27 /= 2;
                    v27 += v27;
                }
                uint32_t v28 = 0x100000000 * v26 >> 32;
                if (v28 < 0) {
                    v28 /= 2;
                    v28 += v28;
                }
                uint32_t v29 = 0x100000000 * v27 >> 32;
                if (v29 < 0) {
                    v29 /= 2;
                    v29 += v29;
                }
                uint32_t v30 = 0x100000000 * v28 >> 32;
                if (v30 < 0) {
                    v30 /= 2;
                    v30 += v30;
                }
                uint32_t v31 = 0x100000000 * v29 >> 32;
                if (v31 < 0) {
                    v31 /= 2;
                    v31 += v31;
                }
                uint32_t v32 = 0x100000000 * v30 >> 32;
                if (v32 < 0) {
                    v32 /= 2;
                    v32 += v32;
                }
                uint32_t v33 = 0x100000000 * v31 >> 32;
                if (v33 < 0) {
                    v33 /= 2;
                    v33 += v33;
                }
                uint32_t v34 = 0x100000000 * v32 >> 32;
                if (v34 < 0) {
                    v34 /= 2;
                    v34 += v34;
                }
                uint32_t v35 = 0x100000000 * v33 >> 32;
                if (v35 < 0) {
                    v35 /= 2;
                    v35 += v35;
                }
                uint",0
"//FormAI DATASET v1.0 Category: Secure Password Generator ; Style: minimalist
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    // Set up the different character sets
    char lower[] = ""abcdefghijklmnopqrstuvwxyz"";
    char upper[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    char digits[] = ""0123456789"";
    char special[] = ""!#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"";

    // Prompt the user for password length
    int length;
    printf(""Enter desired password length: "");
    scanf(""%d"", &length);

    // Seed the random number generator
    srand(time(NULL));

    // Set up the password array
    char password[length];

    // Ensure password has at least one character from each set
    password[0] = lower[rand() % strlen(lower)];
    password[1] = upper[rand() % strlen(upper)];
    password[2] = digits[rand() % strlen(digits)];
    password[3] = special[rand() % strlen(special)];

    // Fill rest of password array with random characters from all sets
    for (int i = 4; i < length; i++) {
        int set = rand() % 4;
        switch (set) {
            case 0:
                password[i] = lower[rand() % strlen(lower)];
                break;
            case 1:
                password[i] = upper[rand() % strlen(upper)];
                break;
            case 2:
                password[i] = digits[rand() % strlen(digits)];
                break;
            case 3:
                password[i] = special[rand() % strlen(special)];
                break;
        }
    }

    // Randomize the order of the characters in the password
    for (int i = 0; i < length; i++) {
        int j = rand() % length;
        char temp = password[i];
        password[i] = password[j];
        password[j] = temp;
    }

    // Print the generated password
    printf(""Generated Password: %s\n"", password);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
void function_10c0(void);
int32_t function_10d0(char * format, ...);
void function_10e0(int32_t seed);
int32_t function_10f0(int32_t * timer);
int32_t function_1100(char * format, ...);
int32_t function_1110(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return strlen(s);
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(void) {
    // 0x10c0
    __stack_chk_fail();
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int32_t seed) {
    // 0x10e0
    srand(seed);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(int32_t * timer) {
    // 0x10f0
    return time(timer);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return scanf(format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(void) {
    // 0x1110
    return rand();
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g1;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g1 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x1749
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x121f
    int64_t str = 0x6867666564636261; // bp-152, 0x1248
    int64_t str2 = 0x4847464544434241; // bp-120, 0x1282
    int64_t str3 = 0x3736353433323130; // bp-163, 0x12ac
    int64_t str4 = 0x2928272625242321; // bp-88, 0x12d7
    printf(""Enter desired password length: "");
    int64_t v2; // bp-204, 0x1209
    scanf(""%d"", &v2);
    srand(time(NULL));
    int64_t v3 = 0x100000000 * v2 >> 32; // 0x1352
    int64_t v4 = v3; // bp-232, 0x1355
    int64_t v5 = 16 * (v3 + 15) / 16;
    int64_t v6; // bp-8, 0x1209
    int64_t v7 = &v6; // 0x120e
    int64_t v8 = (int64_t)&v4 - (v5 & -0x1000) - (v5 & 4080); // 0x13c2
    char * v9 = (char *)v8; // 0x13ea
    int32_t v10 = rand(); // 0x13f1
    int32_t len = strlen((char *)&str); // 0x1403
    int64_t v11 = v7 - 144; // 0x141c
    *v9 = *(char *)((int64_t)v10 % (int64_t)len + v11);
    int32_t v12 = rand(); // 0x142d
    int32_t len2 = strlen((char *)&str2); // 0x143c
    int64_t v13 = v7 - 112; // 0x1455
    char v14 = *(char *)((int64_t)v12 % (int64_t)len2 + v13); // 0x1455
    *(char *)(v8 | 1) = v14;
    int32_t v15 = rand(); // 0x1464
    int32_t len3 = strlen((char *)&str3); // 0x1476
    int64_t v16 = v7 - 155; // 0x148f
    char v17 = *(char *)((int64_t)v15 % (int64_t)len3 + v16); // 0x148f
    *(char *)(v8 | 2) = v17;
    int32_t v18 = rand(); // 0x14a1
    int32_t len4 = strlen((char *)&str4); // 0x14b0
    int64_t v19 = v7 - 80; // 0x14c9
    char v20 = *(char *)((int64_t)v18 % (int64_t)len4 + v19); // 0x14c9
    *(char *)(v8 | 3) = v20;
    int64_t v21 = v2 & 0xffffffff;
    int32_t v22 = 4; // 0x1670
    int64_t v23 = v21; // 0x1670
    if (v21 > 4) {
        int64_t v24 = 4;
        int32_t v25; // 0x161d
        int32_t len5; // 0x162c
        char v26; // 0x1645
        int32_t v27; // 0x15d6
        int32_t len6; // 0x15e8
        char v28; // 0x1601
        int32_t v29; // 0x1548
        int32_t len7; // 0x155a
        char v30; // 0x1573
        int32_t v31; // 0x1592
        int32_t len8; // 0x15a1
        char v32; // 0x15ba
        switch (v33 % 4) {
            case 3: {
                // 0x161d
                v25 = rand();
                len5 = strlen((char *)&str4);
                v26 = *(char *)((int64_t)v25 % (int64_t)len5 + v19);
                *(char *)(v24 + v8) = v26;
                // break -> 0x165d
                break;
            }
            case 2: {
                // 0x15d6
                v27 = rand();
                len6 = strlen((char *)&str3);
                v28 = *(char *)((int64_t)v27 % (int64_t)len6 + v16);
                *(char *)(v24 + v8) = v28;
                // break -> 0x165d
                break;
            }
            case 0: {
                // 0x1548
                v29 = rand();
                len7 = strlen((char *)&str);
                v30 = *(char *)((int64_t)v29 % (int64_t)len7 + v11);
                *(char *)(v24 + v8) = v30;
                // break -> 0x165d
                break;
            }
            case 1: {
                // 0x1592
                v31 = rand();
                len8 = strlen((char *)&str2);
                v32 = *(char *)((int64_t)v31 % (int64_t)len8 + v13);
                *(char *)(v24 + v8) = v32;
                // break -> 0x165d
                break;
            }
        }
        // 0x165d
        v22++;
        int64_t v34 = v2 & 0xffffffff;
        int64_t v35 = v22; // 0x1670
        v23 = v34;
        while (v34 > v35) {
            // 0x14e7
            v24 = v35;
            switch (v33 % 4) {
                case 3: {
                    // 0x161d
                    v25 = rand();
                    len5 = strlen((char *)&str4);
                    v26 = *(char *)((int64_t)v25 % (int64_t)len5 + v19);
                    *(char *)(v24 + v8) = v26;
                    // break -> 0x165d
                    break;
                }
                case 2: {
                    // 0x15d6
                    v27 = rand();
                    len6 = strlen((char *)&str3);
                    v28 = *(char *)((int64_t)v27 % (int64_t)len6 + v16);
                    *(char *)(v24 + v8) = v28;
                    // break -> 0x165d
                    break;
                }
                case 0: {
                    // 0x1548
                    v29 = rand();
                    len7 = strlen((char *)&str);
                    v30 = *(char *)((int64_t)v29 % (int64_t)len7 + v11);
                    *(char *)(v24 + v8) = v30;
                    // break -> 0x165d
                    break;
                }
                case 1: {
                    // 0x1592
                    v31 = rand();
                    len8 = strlen((char *)&str2);
                    v32 = *(char *)((int64_t)v31 % (int64_t)len8 + v13);
                    *(char *)(v24 + v8) = v32;
                    // break -> 0x165d
                    break;
                }
            }
            // 0x165d
            v22++;
            v34 = v2 & 0xffffffff;
            v35 = v22;
            v23 = v34;
        }
    }
    int32_t v36 = 0; // 0x1700
    if (v23 != 0) {
        int32_t v37 = rand(); // 0x1682
        char * v38 = (char *)v8; // 0x16a5
        char * v39 = (char *)((0x100000000 * ((0x100000000 * (int64_t)(v37 >> 31) | (int64_t)v37) % (v2 & 0xffffffff)) >> 32) + v8); // 0x16be
        *v38 = *v39;
        *v39 = *v38;
        v36++;
        int64_t v40 = v36; // 0x1700
        while ((v2 & 0xffffffff) > v40) {
            // 0x1682
            v37 = rand();
            v38 = (char *)(v40 + v8);
            v39 = (char *)((0x100000000 * ((0x100000000 * (int64_t)(v37 >> 31) | (int64_t)v37) % (v2 & 0xffffffff)) >> 32) + v8);
            *v38 = *v39;
            *v39 = *v38;
            v36++;
            v40 = v36;
        }
    }
    // 0x1702
    printf(""Generated Password: %s\n"", v9);
    int64_t result = 0; // 0x1735
    if (v1 != __readfsqword(40)) {
        // 0x1737
        __stack_chk_fail();
        result = &g2;
    }
    // 0x173c
    return result;
}

// Address range: 0x174c - 0x1759
int64_t _fini(void) {
    // 0x174c
    int64_t result; // 0x174c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            int len = 16;
            char * str = malloc(len);
            srand(time(NULL));
            int i;
            for (i = 0; i < len; i++) {
                str[i] = rand() % 65 + 97;
            }
            str[len - 1] = '\0';
            printf(""Generated Password: %s\n"", str);
            free(str);
            return 0;
        }

",0
"//FormAI DATASET v1.0 Category: Wireless Network Scanner ; Style: accurate
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define PORT 80
#define MAX_PACKET_SIZE 65535

// Struct to hold packet information
struct packet {
    struct sockaddr_in addr;
    int sock;
    char *packet_buf;
    int packet_len;
};

// Function to create raw socket and bind to address
int bind_raw_socket(int protocol) {
    int sock;
    if ((sock = socket(AF_INET, SOCK_RAW, protocol)) == -1) {
        perror(""Failed to create socket"");
        exit(1);
    }

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(PORT);

    if (bind(sock,(struct sockaddr *)&addr, sizeof(addr)) == -1) {
        perror(""Failed to bind socket"");
        exit(1);
    }

    return sock;
}

// Function to parse packet
void process_packet(struct packet *p) {
    // Extract the wireless network information
    char ssid[32];
    memset(ssid, 0, sizeof(ssid));
    memcpy(ssid, p->packet_buf + 26, *(p->packet_buf + 25));

    char bssid[18];
    memset(bssid, 0, sizeof(bssid));
    sprintf(bssid, ""%02x:%02x:%02x:%02x:%02x:%02x"",
        *(p->packet_buf + 36), *(p->packet_buf + 37),
        *(p->packet_buf + 38), *(p->packet_buf + 39),
        *(p->packet_buf + 40), *(p->packet_buf + 41));

    // Print the wireless network information
    char ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(p->addr.sin_addr), ip, INET_ADDRSTRLEN);
    printf(""SSID: %s, BSSID: %s, IP Address: %s\n"", ssid, bssid, ip);
}

// Function to receive packets
void receive_packets(int sock) {
    struct sockaddr_in addr;
    int len, n;
    char packet_buf[MAX_PACKET_SIZE];

    struct packet p;
    p.sock = sock;
    p.packet_buf = packet_buf;

    while (1) {
        len = sizeof(addr);
        memset(&addr, 0, len);
        memset(packet_buf, 0, MAX_PACKET_SIZE);
        n = recvfrom(sock, packet_buf, MAX_PACKET_SIZE, 0, (struct sockaddr *)&addr, (socklen_t *)&len);

        if (n == -1) {
            perror(""Failed to receive packet"");
            continue;
        }

        p.addr = addr;
        p.packet_len = n;

        if (fork() == 0) {
            // In child process, process packet and exit
            process_packet(&p);
            exit(0);
        } else {
            // In parent process, continue receiving packets
            wait(NULL);
        }
    }
}

int main() {
    printf(""Wireless Network Scanner started...\n"");

    // Create and bind raw socket to IP protocol 3 (IP protocol for ICMP)
    int sock = bind_raw_socket(3);

    // Receive packets
    receive_packets(sock);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t bind_raw_socket(int64_t protocol);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1130(int64_t * d);
char * function_1140(int32_t af, int64_t * cp, char * buf, int32_t len);
int32_t function_1150(char * s);
void function_1160(void);
int16_t function_1170(int16_t hostshort);
int32_t function_1180(char * format, ...);
int32_t function_1190(int32_t hostlong);
int64_t * function_11a0(int64_t * s, int32_t c, int32_t n);
int64_t * function_11b0(int64_t * dest, int64_t * src, int32_t n);
int32_t function_11c0(int32_t fd, int64_t * buf, int32_t n, int32_t flags, struct sockaddr * addr, int32_t * addr_len);
int32_t function_11d0(int32_t fd, struct sockaddr * addr, int32_t len);
void function_11e0(char * s);
int32_t function_11f0(char * s, char * format, ...);
void function_1200(int32_t status);
int32_t function_1210(int64_t stat_loc);
int32_t function_1220(void);
int32_t function_1230(int32_t domain, int32_t type, int32_t protocol);
int64_t process_packet(int64_t * a1);
int64_t receive_packets(int64_t sock);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1130 - 0x113b
void function_1130(int64_t * d) {
    // 0x1130
    __cxa_finalize(d);
}

// Address range: 0x1140 - 0x114b
char * function_1140(int32_t af, int64_t * cp, char * buf, int32_t len) {
    // 0x1140
    return inet_ntop(af, cp, buf, len);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * s) {
    // 0x1150
    return puts(s);
}

// Address range: 0x1160 - 0x116b
void function_1160(void) {
    // 0x1160
    __stack_chk_fail();
}

// Address range: 0x1170 - 0x117b
int16_t function_1170(int16_t hostshort) {
    // 0x1170
    return htons(hostshort);
}

// Address range: 0x1180 - 0x118b
int32_t function_1180(char * format, ...) {
    // 0x1180
    return printf(format);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t hostlong) {
    // 0x1190
    return htonl(hostlong);
}

// Address range: 0x11a0 - 0x11ab
int64_t * function_11a0(int64_t * s, int32_t c, int32_t n) {
    // 0x11a0
    return memset(s, c, n);
}

// Address range: 0x11b0 - 0x11bb
int64_t * function_11b0(int64_t * dest, int64_t * src, int32_t n) {
    // 0x11b0
    return memcpy(dest, src, n);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(int32_t fd, int64_t * buf, int32_t n, int32_t flags, struct sockaddr * addr, int32_t * addr_len) {
    // 0x11c0
    return recvfrom(fd, buf, n, flags, addr, addr_len);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x11d0
    return bind(fd, addr, len);
}

// Address range: 0x11e0 - 0x11eb
void function_11e0(char * s) {
    // 0x11e0
    perror(s);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(char * s, char * format, ...) {
    // 0x11f0
    return sprintf(s, format);
}

// Address range: 0x1200 - 0x120b
void function_1200(int32_t status) {
    // 0x1200
    exit(status);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int64_t stat_loc) {
    // 0x1210
    return wait(stat_loc);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(void) {
    // 0x1220
    return fork();
}

// Address range: 0x1230 - 0x123b
int32_t function_1230(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1230
    return socket(domain, type, protocol);
}

// Address range: 0x1240 - 0x1266
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1240
    int64_t v1; // 0x1240
    __libc_start_main(0x169d, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1270 - 0x1299
int64_t deregister_tm_clones(void) {
    // 0x1270
    return &g1;
}

// Address range: 0x12a0 - 0x12d9
int64_t register_tm_clones(void) {
    // 0x12a0
    return 0;
}

// Address range: 0x12e0 - 0x1319
int64_t __do_global_dtors_aux(void) {
    // 0x12e0
    if (*(char *)&g1 != 0) {
        // 0x1318
        int64_t result; // 0x12e0
        return result;
    }
    // 0x12ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1307
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1320 - 0x1329
int64_t frame_dummy(void) {
    // 0x1320
    return register_tm_clones();
}

// Address range: 0x1329 - 0x1401
int64_t bind_raw_socket(int64_t protocol) {
    int64_t v1 = __readfsqword(40); // 0x1338
    uint32_t sock_fd = socket(AF_INET, SOCK_RAW, (int32_t)protocol); // 0x1356
    if (sock_fd == -1) {
        // 0x1364
        perror(""Failed to create socket"");
        exit(1);
        // UNREACHABLE
    }
    // 0x137d
    int64_t addr; // bp-40, 0x1329
    memset(&addr, 0, 16);
    addr = 2;
    htonl(0);
    htons(80);
    if (bind(sock_fd, (struct sockaddr *)&addr, 16) == -1) {
        // 0x13cf
        perror(""Failed to bind socket"");
        exit(1);
        // UNREACHABLE
    }
    int64_t result = sock_fd; // 0x13f8
    if (v1 != __readfsqword(40)) {
        // 0x13fa
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13ff
    return result;
}

// Address range: 0x1401 - 0x155e
int64_t process_packet(int64_t * a1) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = __readfsqword(40); // 0x1411
    int64_t v3; // bp-56, 0x1401
    memset(&v3, 0, 32);
    int64_t * v4 = (int64_t *)(v1 + 24); // 0x143a
    int64_t v5 = *v4; // 0x143a
    char v6 = *(char *)(v5 + 25); // 0x1442
    memcpy(&v3, (int64_t *)(v5 + 26), (int32_t)v6);
    int64_t str; // bp-88, 0x1401
    memset(&str, 0, 18);
    int64_t v7 = *v4; // 0x147e
    char v8 = *(char *)(v7 + 41); // 0x1486
    char v9 = *(char *)(v7 + 40); // 0x1498
    char v10 = *(char *)(v7 + 39); // 0x14aa
    char v11 = *(char *)(v7 + 38); // 0x14bd
    char v12 = *(char *)(v7 + 37); // 0x14d0
    char v13 = *(char *)(v7 + 36); // 0x14e2
    sprintf((char *)&str, ""%02x:%02x:%02x:%02x:%02x:%02x"", (int32_t)v13, (int32_t)v12, (int32_t)v11, (int32_t)v10, (int32_t)v9, (int32_t)v8);
    int64_t address_str; // bp-104, 0x1401
    inet_ntop(AF_INET, (int64_t *)(v1 + 4), (char *)&address_str, 16);
    printf(""SSID: %s, BSSID: %s, IP Address: %s\n"", &v3, &str, &address_str);
    int64_t result = 0; // 0x1555
    if (v2 != __readfsqword(40)) {
        // 0x1557
        __stack_chk_fail();
        result = &g2;
    }
    // 0x155c
    return result;
}

// Address range: 0x155e - 0x169d
int64_t receive_packets(int64_t sock) {
    // 0x155e
    int64_t v1; // bp-8, 0x155e
    int64_t v2 = &v1; // 0x1566
    int64_t v3; // bp-65544, 0x155e
    while (v2 - 0x1000 != (int64_t)&v3) {
        // 0x156e
        v2 -= 0x1000;
    }
    // 0x157f
    __readfsqword(40);
    int64_t v4; // bp-65608, 0x155e
    while (true) {
        int32_t addr_len = 16; // bp-65632, 0x15b2
        int64_t addr; // bp-65624, 0x155e
        memset(&addr, 0, 16);
        int64_t buf; // bp-65560, 0x155e
        memset(&buf, 0, 0xffff);
        int32_t v5 = recvfrom((int32_t)sock, &buf, 0xffff, 0, (struct sockaddr *)&addr, &addr_len); // 0x161f
        if (v5 != -1) {
            // 0x1644
            v4 = addr;
            if (fork() == 0) {
                // break -> 0x1675
                break;
            }
            // 0x168e
            wait(0);
        } else {
            // 0x1633
            perror(""Failed to receive packet"");
        }
    }
    // 0x1675
    process_packet(&v4);
    exit(0);
    // UNREACHABLE
}

// Address range: 0x169d - 0x16d6
int main(int argc, char ** argv) {
    // 0x169d
    puts(""Wireless Network Scanner started..."");
    receive_packets(bind_raw_socket(3) & 0xffffffff);
    // UNREACHABLE
}

// Address range: 0x16d8 - 0x16e5
int64_t _fini(void) {
    // 0x16d8
    int64_t result; // 0x16d8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 28

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <arpa/inet.h>
        #include <netinet/in.h>
        #include <sys/socket.h>
        #include <sys/wait.h>
        #include <unistd.h>

        int main(int argc, char ** argv) {
            puts(""Wireless Network Scanner started..."");
            int sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
            if (sock == -1) {
                perror(""Failed to create socket"");
                exit(1);
            }
            struct sockaddr addr;
            memset(&addr, 0, 16);
            addr.sa_family = AF_INET;
            if (bind(sock, (struct sockaddr *)&addr, 16) == -1) {
                perror(""Failed to bind socket"");
                exit(1);
            }
            while (true) {
                int addr_len = 16;
                int buf[0xffff];
                int len = recvfrom(sock, buf, 0xffff, 0, (struct sockaddr *)&addr, &addr_len);
                if (len != -1) {
                    break;
                } else {
                    perror(""Failed to receive packet"");
                }
            }
            char str[18];
            inet_ntop(AF_INET, (int *)&addr.sa_data[2], str, 16);
            printf(""SSID: %s, BSSID: %s, IP Address: %s\n"", buf, str, inet_ntoa(((struct sockaddr_in *)&addr)->sin_addr));
            exit(0);
        }

",2
"//FormAI DATASET v1.0 Category: Queue Implementation ; Style: configurable
#include <stdio.h>
#include <stdlib.h>
#define MAXSIZE 10
typedef struct
{
    int front, rear;
    int capacity;
    int* array;
} Queue;

Queue* createQueue(int size)
{
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->capacity = size;
    queue->front = -1;
    queue->rear = -1;
    queue->array = (int*)malloc(sizeof(int) * size);
    return queue;
}

int isFull(Queue* queue)
{
    return queue->rear == queue->capacity - 1;
}

int isEmpty(Queue* queue)
{
    return queue->front == -1 && queue->rear == -1;
}

void enqueue(Queue* queue, int item)
{
    if (isFull(queue))
    {
        printf(""Queue is Full!\n"");
        return;
    }
    else if (isEmpty(queue))
    {
        queue->front = 0;
        queue->rear = 0;
    }
    else
    {
        queue->rear += 1;
    }
    queue->array[queue->rear] = item;
}

int dequeue(Queue* queue)
{
    if (isEmpty(queue))
    {
        printf(""Queue is Empty!\n"");
        return -1;
    }
    else if (queue->front == queue->rear)
    {
        int element = queue->array[queue->front];
        queue->front = -1;
        queue->rear = -1;
        return element;
    }
    else
    {
        int element = queue->array[queue->front];
        queue->front += 1;
        return element;
    }
}

void printQueue(Queue* queue)
{
    int i;
    printf(""["");
    for (i = queue->front; i <= queue->rear; i++)
    {
        printf(""%d "", queue->array[i]);
    }
    printf(""]\n"");
}

int main()
{
    Queue* queue = createQueue(MAXSIZE);
    enqueue(queue, 1);
    enqueue(queue, 2);
    enqueue(queue, 3);
    enqueue(queue, 4);
    enqueue(queue, 5);
    printf(""Queue: "");
    printQueue(queue);
    dequeue(queue);
    printf(""Queue after dequeue: "");
    printQueue(queue);
    enqueue(queue, 6);
    printf(""Queue after enqueue: "");
    printQueue(queue);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t createQueue(int64_t a1);
int64_t dequeue(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t enqueue(int64_t a1, int64_t a2);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
int32_t function_1090(char * s);
int32_t function_10a0(char * format, ...);
int64_t * function_10b0(int32_t size);
int64_t isEmpty(int64_t a1);
int64_t isFull(int64_t a1);
int64_t printQueue(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int64_t * function_10b0(int32_t size) {
    // 0x10b0
    return malloc(size);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x140a, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1207
int64_t createQueue(int64_t a1) {
    int32_t v1 = a1; // 0x11b5
    int64_t * mem = malloc(24); // 0x11bd
    int64_t result = (int64_t)mem; // 0x11bd
    *(int32_t *)(result + 8) = v1;
    *(int32_t *)mem = -1;
    *(int32_t *)(result + 4) = -1;
    *(int64_t *)(result + 16) = (int64_t)malloc(4 * v1);
    return result;
}

// Address range: 0x1207 - 0x122e
int64_t isFull(int64_t a1) {
    // 0x1207
    return *(int32_t *)(a1 + 4) == *(int32_t *)(a1 + 8) - 1;
}

// Address range: 0x122e - 0x125f
int64_t isEmpty(int64_t a1) {
    // 0x122e
    int64_t v1; // 0x122e
    if ((int32_t)v1 == -1) {
        // 0x1245
        if (*(int32_t *)(a1 + 4) == -1) {
            // 0x125d
            return 1;
        }
    }
    // 0x125d
    return 0;
}

// Address range: 0x125f - 0x12ea
int64_t enqueue(int64_t a1, int64_t a2) {
    // 0x125f
    if ((int32_t)isFull(a1) != 0) {
        // 0x12e8
        return puts(""Queue is Full!"");
    }
    // 0x1293
    int64_t v1; // 0x125f
    if ((int32_t)isEmpty(a1) == 0) {
        int32_t * v2 = (int32_t *)(a1 + 4);
        int32_t v3 = *v2 + 1; // 0x12c1
        *v2 = v3;
        v1 = 4 * (int64_t)v3;
    } else {
        // 0x12a3
        *(int32_t *)a1 = 0;
        *(int32_t *)(a1 + 4) = 0;
        v1 = 0;
    }
    int64_t v4 = 0x100000000 * a2 >> 32; // 0x126f
    *(int32_t *)(v1 + *(int64_t *)(a1 + 16)) = (int32_t)v4;
    // 0x12e8
    return v4 & 0xffffffff;
}

// Address range: 0x12ea - 0x1397
int64_t dequeue(int64_t a1) {
    // 0x12ea
    if ((int32_t)isEmpty(a1) != 0) {
        // 0x130a
        puts(""Queue is Empty!"");
        // 0x1395
        return -1;
    }
    // 0x1320
    int64_t v1; // 0x12ea
    int32_t v2 = v1;
    int32_t * v3 = (int32_t *)(a1 + 4); // 0x132a
    int32_t result = *(int32_t *)(*(int64_t *)(a1 + 16) + (0x100000000 * v1 >> 30));
    if (*v3 != v2) {
        // 0x1367
        *(int32_t *)a1 = v2 + 1;
    } else {
        // 0x1331
        *(int32_t *)a1 = -1;
        *v3 = -1;
    }
    // 0x1395
    return result;
}

// Address range: 0x1397 - 0x140a
int64_t printQueue(int64_t a1) {
    // 0x1397
    putchar(91);
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x13f0
    int64_t v2; // 0x1397
    int64_t v3 = 0x100000000 * v2 >> 32; // 0x13f6
    if (v3 > (int64_t)*v1) {
        // 0x13f8
        return puts(""]"");
    }
    int32_t v4 = v2; // 0x13e8
    printf(""%d "", (int64_t)*(int32_t *)(*(int64_t *)(a1 + 16) + 4 * v3));
    v4++;
    int64_t v5 = v4; // 0x13f6
    while (v5 <= (int64_t)*v1) {
        // 0x13bc
        printf(""%d "", (int64_t)*(int32_t *)(*(int64_t *)(a1 + 16) + 4 * v5));
        v4++;
        v5 = v4;
    }
    // 0x13f8
    return puts(""]"");
}

// Address range: 0x140a - 0x14fd
int main(int argc, char ** argv) {
    int64_t v1 = createQueue(10); // 0x141b
    enqueue(v1, 1);
    enqueue(v1, 2);
    enqueue(v1, 3);
    enqueue(v1, 4);
    enqueue(v1, 5);
    printf(""Queue: "");
    printQueue(v1);
    dequeue(v1);
    printf(""Queue after dequeue: "");
    printQueue(v1);
    enqueue(v1, 6);
    printf(""Queue after enqueue: "");
    printQueue(v1);
    return 0;
}

// Address range: 0x1500 - 0x150d
int64_t _fini(void) {
    // 0x1500
    int64_t result; // 0x1500
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 19

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int queue[10];
            int front = -1;
            int rear = -1;

            enqueue(queue, 1);
            enqueue(queue, 2);
            enqueue(queue, 3);
            enqueue(queue, 4);
            enqueue(queue, 5);
            printf(""Queue: "");
            printQueue(queue);
            dequeue(queue);
            printf(""Queue after dequeue: "");
            printQueue(queue);
            enqueue(queue, 6);
            printf(""Queue after enqueue: "");
            printQueue(queue);
            return 0;
        }

        void enqueue(int queue[], int data) {
            if (isFull(queue)) {
                printf(""Queue is Full!\n"");
                return;
            }
            if (isEmpty(queue)) {
                front = 0;
                rear = 0;
            } else {
                rear = (rear + 1) % 10;
            }
            queue[rear] = data;
        }

        int dequeue(int queue[]) {
            if (isEmpty(queue)) {
                printf(""Queue is Empty!\n"");
                return -1;
            }
            int data = queue[front];
            if (front == rear) {
                front = -1;
                rear = -1;
            } else {
                front = (front + 1) % 10;
            }
            return data;
        }

        void printQueue(int queue[]) {
            printf(""["");
            int i;
            for (i = front; i != rear; i = (i + 1) % 10) {
                printf(""%d "", queue[i]);
            }
            printf(""]"");
        }

        int isEmpty(int queue[]) {
            return front == -1;
        }

        int isFull(int queue[]) {
            return (rear + 1) % 10 == front;
        }


",2
"//FormAI DATASET v1.0 Category: Networking ; Style: multiplayer
// Multiplayer Tic Tac Toe game using C Networking

#include<stdio.h>
#include<stdlib.h>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<string.h>
#include<unistd.h>

#define PORT 8080

int socket_desc, client_sock, c, *new_sock;
struct sockaddr_in server, client;
char *client_message;
char board[3][3] = {{'1','2','3'},{'4','5','6'},{'7','8','9'}};
int turn = 1, choice, win;

// Function to print Tic Tac Toe board
void print_board(){
    printf(""\nTic Tac Toe\n\n"");
    printf(""Player 1 (X) - Player 2 (O)\n\n"");
    printf(""     |     |     \n"");
    printf(""  %c  |  %c  |  %c  \n"", board[0][0], board[0][1], board[0][2]);
    printf(""_____|_____|_____\n"");
    printf(""     |     |     \n"");
    printf(""  %c  |  %c  |  %c  \n"", board[1][0], board[1][1], board[1][2]);
    printf(""_____|_____|_____\n"");
    printf(""     |     |     \n"");
    printf(""  %c  |  %c  |  %c  \n"", board[2][0], board[2][1], board[2][2]);
    printf(""     |     |     \n\n"");
}

// Function to check the status of the game
int check_win(){
    if(board[0][0] == board[0][1] && board[0][1] == board[0][2]) return 1;
    else if(board[1][0] == board[1][1] && board[1][1] == board[1][2]) return 1;
    else if(board[2][0] == board[2][1] && board[2][1] == board[2][2]) return 1;
    else if(board[0][0] == board[1][0] && board[1][0] == board[2][0]) return 1;
    else if(board[0][1] == board[1][1] && board[1][1] == board[2][1]) return 1;
    else if(board[0][2] == board[1][2] && board[1][2] == board[2][2]) return 1;
    else if(board[0][0] == board[1][1] && board[1][1] == board[2][2]) return 1;
    else if(board[0][2] == board[1][1] && board[1][1] == board[2][0]) return 1;
    else if(board[0][0] != '1' && board[0][1] != '2' && board[0][2] != '3' && board[1][0] != '4' 
            && board[1][1] != '5' && board[1][2] != '6' && board[2][0] != '7' && board[2][1] 
            != '8' && board[2][2] != '9') return 0;
    else return -1;
}

// Function to handle player connection
void *handle_player(void *sock){
    int client_sock = *(int*)sock;
    int read_size;
    char *message, client_choice[2];

    while((read_size = recv(client_sock, client_choice, 2, 0)) > 0){
        choice = atoi(client_choice);
        if(turn == 1 && choice > 0 && choice < 10 && board[(choice-1)/3][(choice-1)%3] == (choice + '0')){
            board[(choice-1)/3][(choice-1)%3] = 'X';
            turn = 2;
            message = ""Your turn"";
            send(client_sock, message, strlen(message), 0);
            win = check_win();
            if(win == 1){
                printf(""Player 1 wins!\n"");
                exit(1);
            }
            else if(win == 0){
                printf(""Game draw!\n"");
                exit(1);
            }
        }
        else if(turn == 2 && choice > 0 && choice < 10 && board[(choice-1)/3][(choice-1)%3] == (choice + '0')){
            board[(choice-1)/3][(choice-1)%3] = 'O';
            turn = 1;
            message = ""Your turn"";
            send(client_sock, message, strlen(message), 0);
            win = check_win();
            if(win == 1){
                printf(""Player 2 wins!\n"");
                exit(1);
            }
            else if(win == 0){
                printf(""Game draw!\n"");
                exit(1);
            }
        }
        else{
            message = ""Invalid move"";
            send(client_sock, message, strlen(message), 0);
        }

        // Send updated board to both players
        print_board();
        send(client_sock, board, sizeof(board), 0);
        message = ""Waiting for other player"";
        send(client_sock, message, strlen(message), 0);
        memset(client_choice, 0, 2);
    }

    if(read_size == 0){
        puts(""Client disconnected"");
        fflush(stdout);
    }
    else if(read_size == -1){
        perror(""recv failed"");
    }

    close(client_sock);
    free(sock);

    return 0;
}

// Main function
int main(int argc, char *argv[]){
    socket_desc = socket(AF_INET, SOCK_STREAM, 0);
    if(socket_desc == -1){
        printf(""Could not create socket"");
    }

    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(PORT);

    if(bind(socket_desc, (struct sockaddr*)&server, sizeof(server)) < 0){
        perror(""bind failed. Error"");
        return 1;
    }
    puts(""Game server started. Waiting for players..."");

    listen(socket_desc, 2);

    c = sizeof(struct sockaddr_in);

    while((client_sock = accept(socket_desc, (struct sockaddr*)&client, (socklen_t*)&c))){
        puts(""Player connected"");

        pthread_t sniffer_thread;
        new_sock = malloc(1);
        *new_sock = client_sock;

        if(pthread_create(&sniffer_thread, NULL, handle_player, (void*)new_sock) > 0){
            perror(""could not create pthread"");
            return 1;
        }
    }   

    if(client_sock < 0){
        perror(""accept failed"");
        return 1;
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <netinet/in.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t check_win(void);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1170(int64_t * d);
void function_1180(int64_t * ptr);
int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11a0(char * s);
int32_t function_11b0(char * s);
void function_11c0(void);
int16_t function_11d0(int16_t hostshort);
int32_t function_11e0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11f0(char * format, ...);
int64_t * function_1200(int64_t * s, int32_t c, int32_t n);
int32_t function_1210(int32_t fd);
int64_t * function_1220(int32_t size);
int32_t function_1230(struct _IO_FILE * stream);
int32_t function_1240(int32_t fd, int32_t n);
int32_t function_1250(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1260(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
void function_1270(char * s);
int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_1290(char * nptr);
void function_12a0(int32_t status);
int32_t function_12b0(int32_t domain, int32_t type, int32_t protocol);
int64_t handle_player(int64_t a1);
int64_t print_board(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char g1 = 50; // 0x4011
char g2 = 51; // 0x4012
char g3 = 52; // 0x4013
char g4 = 53; // 0x4014
char g5 = 54; // 0x4015
char g6 = 55; // 0x4016
char g7 = 56; // 0x4017
char g8 = 57; // 0x4018
int32_t g9 = 1; // 0x401c
struct _IO_FILE * g10 = NULL; // 0x4020
char g11 = 0; // 0x4028
int32_t g12 = 0; // 0x4030
int32_t g13 = 0; // 0x4034
int32_t * g14 = NULL; // 0x4038
int64_t g15 = 0; // 0x4040
struct sockaddr * g16 = NULL; // 0x4050
int64_t g17 = 0; // 0x4052
int64_t g18 = 0; // 0x4054
struct sockaddr * g19 = NULL; // 0x4060
int128_t g20; // 0x4077
int32_t g21 = 0; // 0x4078
int32_t g22 = 0; // 0x407c
int32_t g23;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g23;
    }
    // 0x1016
    return result;
}

// Address range: 0x1170 - 0x117b
void function_1170(int64_t * d) {
    // 0x1170
    __cxa_finalize(d);
}

// Address range: 0x1180 - 0x118b
void function_1180(int64_t * ptr) {
    // 0x1180
    free(ptr);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1190
    return recv(fd, buf, n, flags);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(char * s) {
    // 0x11a0
    return puts(s);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(char * s) {
    // 0x11b0
    return strlen(s);
}

// Address range: 0x11c0 - 0x11cb
void function_11c0(void) {
    // 0x11c0
    __stack_chk_fail();
}

// Address range: 0x11d0 - 0x11db
int16_t function_11d0(int16_t hostshort) {
    // 0x11d0
    return htons(hostshort);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x11e0
    return send(fd, buf, n, flags);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(char * format, ...) {
    // 0x11f0
    return printf(format);
}

// Address range: 0x1200 - 0x120b
int64_t * function_1200(int64_t * s, int32_t c, int32_t n) {
    // 0x1200
    return memset(s, c, n);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int32_t fd) {
    // 0x1210
    return close(fd);
}

// Address range: 0x1220 - 0x122b
int64_t * function_1220(int32_t size) {
    // 0x1220
    return malloc(size);
}

// Address range: 0x1230 - 0x123b
int32_t function_1230(struct _IO_FILE * stream) {
    // 0x1230
    return fflush(stream);
}

// Address range: 0x1240 - 0x124b
int32_t function_1240(int32_t fd, int32_t n) {
    // 0x1240
    return listen(fd, n);
}

// Address range: 0x1250 - 0x125b
int32_t function_1250(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1250
    return bind(fd, addr, len);
}

// Address range: 0x1260 - 0x126b
int32_t function_1260(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x1260
    return pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x1270 - 0x127b
void function_1270(char * s) {
    // 0x1270
    perror(s);
}

// Address range: 0x1280 - 0x128b
int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x1280
    return accept(fd, addr, addr_len);
}

// Address range: 0x1290 - 0x129b
int32_t function_1290(char * nptr) {
    // 0x1290
    return atoi(nptr);
}

// Address range: 0x12a0 - 0x12ab
void function_12a0(int32_t status) {
    // 0x12a0
    exit(status);
}

// Address range: 0x12b0 - 0x12bb
int32_t function_12b0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x12b0
    return socket(domain, type, protocol);
}

// Address range: 0x12c0 - 0x12e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x12c0
    int64_t v1; // 0x12c0
    __libc_start_main(0x1b51, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x12f0 - 0x1319
int64_t deregister_tm_clones(void) {
    // 0x12f0
    return (int64_t)&g10;
}

// Address range: 0x1320 - 0x1359
int64_t register_tm_clones(void) {
    // 0x1320
    return 0;
}

// Address range: 0x1360 - 0x1399
int64_t __do_global_dtors_aux(void) {
    // 0x1360
    if (g11 != 0) {
        // 0x1398
        int64_t result; // 0x1360
        return result;
    }
    // 0x136d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x137b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1387
    g11 = 1;
    return result2;
}

// Address range: 0x13a0 - 0x13a9
int64_t frame_dummy(void) {
    // 0x13a0
    return register_tm_clones();
}

// Address range: 0x13a9 - 0x14c8
int64_t print_board(void) {
    // 0x13a9
    puts(""\nTic Tac Toe\n"");
    puts(""Player 1 (X) - Player 2 (O)\n"");
    puts(""     |     |     "");
    printf(""  %c  |  %c  |  %c  \n"", 49, g1, g2);
    puts(""_____|_____|_____"");
    puts(""     |     |     "");
    printf(""  %c  |  %c  |  %c  \n"", g3, g4, g5);
    puts(""_____|_____|_____"");
    puts(""     |     |     "");
    printf(""  %c  |  %c  |  %c  \n"", g6, g7, g8);
    return puts(""     |     |     \n"");
}

// Address range: 0x14c8 - 0x16ae
int64_t check_win(void) {
    // 0x14c8
    if (g1 == 49) {
        // 0x14e2
        if (g1 == g2) {
            // 0x16ac
            return 1;
        }
    }
    char v1 = g3; // 0x14fe
    char v2 = g4; // 0x1505
    if (v1 == v2) {
        // 0x1510
        if (v2 == g5) {
            // 0x16ac
            return 1;
        }
    }
    // 0x152c
    if (g6 == g7) {
        // 0x153e
        if (g7 == g8) {
            // 0x16ac
            return 1;
        }
    }
    if (v1 == 49 == v1 == g6) {
        // 0x16ac
        return 1;
    }
    if (g1 == v2 == v2 == g7) {
        // 0x16ac
        return 1;
    }
    // 0x15b6
    if (g2 == g5) {
        // 0x15c8
        if (g5 == g8) {
            // 0x16ac
            return 1;
        }
    }
    if (v2 != 49 || v2 != g8) {
        // 0x1612
        return v2 == g6 == g2 == v2 ? 1 : 0xffffffff;
    }
    // 0x16ac
    return 1;
}

// Address range: 0x16ae - 0x1b51
int64_t handle_player(int64_t a1) {
    int64_t v1 = __readfsqword(40); // 0x16be
    int64_t v2; // 0x16ae
    int32_t sock = v2;
    int64_t buf; // bp-18, 0x16ae
    int32_t v3 = recv(sock, &buf, 2, 0); // 0x1ad3
    int32_t v4 = v3; // 0x1adf
    bool v5 = v3 != 0; // 0x1adf
    int32_t v6; // 0x16ae
    int32_t str_as_i; // 0x16e2
    if (v3 >= 0 == (v3 != 0)) {
        while (true) {
          lab_0x16db:
            // 0x16db
            str_as_i = atoi((char *)&buf);
            g21 = str_as_i;
            v6 = str_as_i - 1;
            if (v6 > 8 | *(int32_t *)0x401c != 1) {
                goto lab_0x188b;
            } else {
                char * v7 = (char *)(3 * 0x100000000 * 0x55555556 * (int64_t)v6 / 0x100000000 / 0x100000000 + (int64_t)((int32_t)&g20 - (2 * ((int32_t)((int64_t)(0x55555556 * (int128_t)(int32_t)&g20) >> 32) - ((int32_t)&g20 >> 31)) + (int32_t)((int64_t)(0x55555556 * (int128_t)(int32_t)&g20) >> 32) - ((int32_t)&g20 >> 31))) + (int64_t)""123456789""); // 0x177c
                if (str_as_i + 48 != (int32_t)*v7) {
                    goto lab_0x188b;
                } else {
                    // 0x1793
                    *v7 = 88;
                    g9 = 2;
                    send(sock, (int64_t *)""Your turn"", strlen(""Your turn""), 0);
                    *(int32_t *)0x407c = (int32_t)check_win();
                    if (g22 == 1) {
                        // break -> 0x184b
                        break;
                    }
                    if (g22 == 0) {
                        // 0x1872
                        puts(""Game draw!"");
                        exit(1);
                        // UNREACHABLE
                    }
                    goto lab_0x1a58;
                }
            }
        }
        // 0x184b
        puts(""Player 1 wins!"");
        exit(1);
        // UNREACHABLE
    }
  lab_0x1ae5:
    // 0x1ae5
    if (v5) {
        // 0x1b0b
        if (v4 == -1) {
            // 0x1b11
            perror(""recv failed"");
        }
    } else {
        // 0x1aeb
        puts(""Client disconnected"");
        fflush(g10);
    }
    // 0x1b20
    close(sock);
    free((int64_t *)a1);
    int64_t result = 0; // 0x1b48
    if (v1 != __readfsqword(40)) {
        // 0x1b4a
        __stack_chk_fail();
        result = &g23;
    }
    // 0x1b4f
    return result;
  lab_0x188b:
    // 0x188b
    if (v6 > 8 || g9 != 2) {
        // 0x1a25
        send(sock, (int64_t *)""Invalid move"", strlen(""Invalid move""), 0);
        goto lab_0x1a58;
    } else {
        char * v8 = (char *)(3 * 0x100000000 * 0x55555556 * (int64_t)v6 / 0x100000000 / 0x100000000 + (int64_t)((int32_t)&g20 - (2 * ((int32_t)((int64_t)(0x55555556 * (int128_t)(int32_t)&g20) >> 32) - ((int32_t)&g20 >> 31)) + (int32_t)((int64_t)(0x55555556 * (int128_t)(int32_t)&g20) >> 32) - ((int32_t)&g20 >> 31))) + (int64_t)""123456789""); // 0x191a
        if (str_as_i + 48 != (int32_t)*v8) {
            // 0x1a25
            send(sock, (int64_t *)""Invalid move"", strlen(""Invalid move""), 0);
            goto lab_0x1a58;
        } else {
            // 0x1931
            *v8 = 79;
            g9 = 1;
            send(sock, (int64_t *)""Your turn"", strlen(""Your turn""), 0);
            int32_t v9 = check_win(); // 0x19d8
            g22 = v9;
            if (v9 == 1) {
                // 0x19e9
                puts(""Player 2 wins!"");
                exit(1);
                // UNREACHABLE
            }
            if (v9 == 0) {
                // 0x1a0c
                puts(""Game draw!"");
                exit(1);
                // UNREACHABLE
            }
            goto lab_0x1a58;
        }
    }
  lab_0x1a58:
    // 0x1a58
    print_board();
    send(sock, (int64_t *)""123456789"", 9, 0);
    send(sock, (int64_t *)""Waiting for other player"", strlen(""Waiting for other player""), 0);
    memset(&buf, 0, 2);
    int32_t v10 = recv(sock, &buf, 2, 0); // 0x1ad3
    v4 = v10;
    v5 = v10 != 0;
    if (v10 >= 0 != v10 != 0) {
        goto lab_0x1ae5;
    }
    goto lab_0x16db;
}

// Address range: 0x1b51 - 0x1d13
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1b64
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1b82
    g12 = sock_fd;
    if (sock_fd == -1) {
        // 0x1b98
        printf(""Could not create socket"");
    }
    // 0x1bac
    *(int16_t *)&g16 = 2;
    *(int32_t *)&g18 = 0;
    *(int16_t *)&g17 = htons(0x1f90);
    int64_t v2; // 0x1b51
    if (bind(g12, (struct sockaddr *)&g16, 16) >= 0) {
        // 0x1c09
        puts(""Game server started. Waiting for players..."");
        listen(g12, 2);
        *(int32_t *)&g14 = 16;
        int32_t accepted_sock_fd = accept(g12, (struct sockaddr *)&g19, (int32_t *)&g14); // 0x1cbf
        g13 = accepted_sock_fd;
        while (accepted_sock_fd != 0) {
            // 0x1c36
            puts(""Player connected"");
            int64_t * mem = malloc(1); // 0x1c4a
            g15 = (int64_t)mem;
            *(int32_t *)mem = g13;
            int64_t thread; // bp-24, 0x1b51
            uint32_t v3 = pthread_create((int32_t *)&thread, NULL, (int64_t * (*)(int64_t *))0x16ae, (int64_t *)g15); // 0x1c87
            if (v3 >= 1) {
                // 0x1c90
                perror(""could not create pthread"");
                v2 = 1;
                goto lab_0x1cfd;
            }
            accepted_sock_fd = accept(g12, (struct sockaddr *)&g19, (int32_t *)&g14);
            g13 = accepted_sock_fd;
        }
        // 0x1cd8
        v2 = 0;
        if (accepted_sock_fd < 0) {
            // 0x1ce2
            perror(""accept failed"");
            v2 = 1;
        }
    } else {
        // 0x1bf0
        perror(""bind failed. Error"");
        v2 = 1;
    }
    goto lab_0x1cfd;
  lab_0x1cfd:;
    int64_t result = v2; // 0x1d0a
    if (v1 != __readfsqword(40)) {
        // 0x1d0c
        __stack_chk_fail();
        result = &g23;
    }
    // 0x1d11
    return result;
}

// Address range: 0x1d14 - 0x1d21
int64_t _fini(void) {
    // 0x1d14
    int64_t result; // 0x1d14
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 32

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <pthread.h>
        #include <stdbool.h>
        #include <stdint.h>

        typedef int64_t int128_t;

        struct _IO_FILE {
            int32_t e0;
        };

        struct sockaddr {
            int64_t e0;
            char e1[14];
        };

        int64_t __do_global_dtors_aux(void);
        int64_t _fini(void);
        int64_t _init(void);
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
        int64_t check_win(void);
        int64_t deregister_tm_clones(void);
        int64_t frame_dummy(void);
        void function_1170(int64_t * d);
        void function_1180(int64_t * ptr);
        int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
        int32_t function_11a0(char * s);
        int32_t function_11b0(char * s);
        void function_11c0(void);
        int16_t function_11d0(int16_t hostshort);
        int32_t function_11e0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
        int32_t function_11f0(char * format, ...);
        int64_t * function_1200(int64_t * s, int32_t c, int32_t n);
        int32_t function_1210(int32_t fd);
        int64_t * function_1220(int32_t size);
        int32_t function_1230(struct _IO_FILE * stream);
        int32_t function_1240(int32_t fd, int32_t n);
        int32_t function_1250(int32_t fd, struct sockaddr * addr, int32_t len);
        int32_t function_1260(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
        void function_1270(char * s);
        int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
        int32_t function_1290(char * nptr);
        void function_12a0(int32_t status);
        int32_t function_12b0(int32_t domain, int32_t type, int32_t protocol);
        int64_t handle_player(int64_t a1);
        int64_t print_board(void);
        int64_t register_tm_clones(void);

        char g1 = 50; // 0x4011
        char g2 = 51; // 0x4012
        char g3 = 52; // 0x4013
        char g4 = 53; // 0x4014
        char g5 = 54; // 0x4015
        char g6 = 55; // 0x4016
        char g7 = 56; // 0x4017
        char g8 = 57; // 0x4018
        int32_t g9 = 1; // 0x401c
        struct _IO_FILE * g10 = NULL; // 0x4020
        char g11 = 0; // 0x4028
        int32_t g12 = 0; // 0x4030
        int32_t g13 = 0; // 0x4034
        int32_t * g14 = NULL; // 0x4038
        int64_t g15 = 0; // 0x4040
        struct sockaddr * g16 = NULL; // 0x4050
        int64_t g17 = 0; // 0x4052
        int64_t g18 = 0; // 0x4054
        struct sockaddr * g19 = NULL; // 0x4060
        int128_t g20; // 0x4077
        int32_t g21 = 0; // 0x4078
        int32_t g22 = 0; // 0x407c
        int32_t g23;

        void __cxa_finalize(int64_t * a1);
        void __gmon_start__(void);
        int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
        void __stack_chk_fail(void);

        int64_t _init(void) {
            int64_t result = 0; // 0x1012
            if (*(int64_t *)0x3fe8 != 0) {
                // 0x1014
                __gmon_start__();
                result = &g23;
            }
            // 0x1016
            return result;
        }

        void function_1170(int64_t * d) {
            // 0x1170
            __cxa_finalize(d);
        }

        void function_1180(int64_t * ptr) {
            // 0x1180
            free(ptr);
        }

        int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
            // 0x1190
            return recv(fd, buf, n, flags);
        }

        int32_t function_11a0(char * s) {
            // 0x11a0
            return puts(s);
        }

        int32_t function_11b0(char * s) {
            // 0x11b0
            return strlen(s);
        }

        void function_11c0(void) {
            // 0x11c0
            __stack_chk_fail();
        }

        int16_t function_11d0(int16_t hostshort) {
            // 0x11d0
            return htons(hostshort);
        }

        int32_t function_11e0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
            // 0x11e0
            return send(fd, buf, n, flags);
        }

        int32_t function_11f0(char * format, ...) {
            // 0x11f0
         ",0
"//FormAI DATASET v1.0 Category: Email Client ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

int main(void) {
  char email_address[MAX_BUFFER_SIZE], email_subject[MAX_BUFFER_SIZE], email_body[MAX_BUFFER_SIZE];

  printf(""Enter recipient email address: "");
  fgets(email_address, MAX_BUFFER_SIZE, stdin);

  printf(""Enter email subject: "");
  fgets(email_subject, MAX_BUFFER_SIZE, stdin);

  printf(""Enter email body: "");
  fgets(email_body, MAX_BUFFER_SIZE, stdin);

  printf(""Sending email to %s with subject '%s' and body '%s'... \n"", email_address, email_subject, email_body);

  printf(""Email sent successfully! \n"");

  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
char * function_10b0(char * s, int32_t n, struct _IO_FILE * stream);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
struct _IO_FILE * g2 = NULL; // 0x4010
char g3 = 0; // 0x4018
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g4;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
char * function_10b0(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x10b0
    return fgets(s, n, stream);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return (int64_t)&g2;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (g3 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    g3 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x12aa
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b8
    printf(""Enter recipient email address: "");
    int64_t str; // bp-3096, 0x11a9
    fgets((char *)&str, (int32_t)&g1, g2);
    printf(""Enter email subject: "");
    int64_t str2; // bp-2072, 0x11a9
    fgets((char *)&str2, (int32_t)&g1, g2);
    printf(""Enter email body: "");
    int64_t str3; // bp-1048, 0x11a9
    fgets((char *)&str3, (int32_t)&g1, g2);
    printf(""Sending email to %s with subject '%s' and body '%s'... \n"", &str, &str2, &str3);
    puts(""Email sent successfully! "");
    int64_t result = 0; // 0x12a1
    if (v1 != __readfsqword(40)) {
        // 0x12a3
        __stack_chk_fail();
        result = &g4;
    }
    // 0x12a8
    return result;
}

// Address range: 0x12ac - 0x12b9
int64_t _fini(void) {
    // 0x12ac
    int64_t result; // 0x12ac
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","nclude <stdio.h>

int main(int argc, char ** argv) {
    char * email;
    char * subject;
    char * body;
    printf(""Enter recipient email address: "");
    fgets(email, 100, stdin);
    printf(""Enter email subject: "");
    fgets(subject, 100, stdin);
    printf(""Enter email body: "");
    fgets(body, 100, stdin);
    printf(""Sending email to %s with subject '%s' and body '%s'... \n"", email, subject, body);
    puts(""Email sent successfully! "");
    return 0;
}

",2
"//FormAI DATASET v1.0 Category: Log analysis ; Style: innovative
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define MAX_LINE_LENGTH 1024

int main(int argc, char *argv[])
{

    if(argc < 2)
    {
        printf(""Usage: log_analysis <log_file>\n"");
        exit(1);
    }

    FILE *fp;
    char line[MAX_LINE_LENGTH];
    char *match = ""error"";
    int error_count = 0;

    fp = fopen(argv[1], ""r"");

    if(fp == NULL)
    {
        printf(""Could not open file\n"");
        exit(1);
    }

    while(fgets(line, MAX_LINE_LENGTH, fp) != NULL)
    {
        if(strstr(line, match) != NULL)
        {
            error_count++;
            printf(""%s"", line);
        }
    }

    printf(""Total Error Count: %d"", error_count);

    fclose(fp);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(char * s);
int32_t function_10d0(struct _IO_FILE * stream);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
char * function_1100(char * s, int32_t n, struct _IO_FILE * stream);
struct _IO_FILE * function_1110(char * filename, char * modes);
void function_1120(int32_t status);
char * function_1130(char * haystack, char * needle);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return puts(s);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(struct _IO_FILE * stream) {
    // 0x10d0
    return fclose(stream);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
char * function_1100(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1100
    return fgets(s, n, stream);
}

// Address range: 0x1110 - 0x111b
struct _IO_FILE * function_1110(char * filename, char * modes) {
    // 0x1110
    return fopen(filename, modes);
}

// Address range: 0x1120 - 0x112b
void function_1120(int32_t status) {
    // 0x1120
    exit(status);
}

// Address range: 0x1130 - 0x113b
char * function_1130(char * haystack, char * needle) {
    // 0x1130
    return strstr(haystack, needle);
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g2;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (*(char *)&g2 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x1381
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1245
    if ((int32_t)argc <= 1) {
        // 0x125d
        puts(""Usage: log_analysis <log_file>"");
        exit(1);
        // UNREACHABLE
    }
    struct _IO_FILE * file = fopen((char *)*(int64_t *)((int64_t)argv + 8), ""r""); // 0x12a9
    if (file == NULL) {
        // 0x12bf
        puts(""Could not open file"");
        exit(1);
        // UNREACHABLE
    }
    int32_t v2 = 0; // 0x1229
    uint32_t v3; // 0x1229
    while (true) {
        // 0x131b
        v3 = v2;
        int64_t str; // bp-1048, 0x1229
        if (fgets((char *)&str, (int32_t)&g1, file) == NULL) {
            // break (via goto) -> 0x133b
            goto lab_0x133b;
        }
        while (strstr((char *)&str, ""error"") == NULL) {
            // 0x131b
            if (fgets((char *)&str, (int32_t)&g1, file) == NULL) {
                // break (via goto) -> 0x133b
                goto lab_0x133b;
            }
        }
        // 0x12f6
        printf(""%s"", &str);
        v2 = v3 + 1;
    }
  lab_0x133b:
    // 0x133b
    printf(""Total Error Count: %d"", (int64_t)v3);
    fclose(file);
    int64_t result = 0; // 0x1378
    if (v1 != __readfsqword(40)) {
        // 0x137a
        __stack_chk_fail();
        result = &g3;
    }
    // 0x137f
    return result;
}

// Address range: 0x1384 - 0x1391
int64_t _fini(void) {
    // 0x1384
    int64_t result; // 0x1384
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            if (argc <= 1) {
                puts(""Usage: log_analysis <log_file>"");
                exit(1);
            }
            FILE * file = fopen(argv[1], ""r"");
            if (file == NULL) {
                puts(""Could not open file"");
                exit(1);
            }
            int count = 0;
            while (true) {
                char str[1024];
                if (fgets(str, 1024, file) == NULL) {
                    break;
                }
                while (strstr(str, ""error"") == NULL) {
                    if (fgets(str, 1024, file) == NULL) {
                        break;
                    }
                }
                printf(""%s"", str);
                count++;
            }
            printf(""Total Error Count: %d"", count);
            fclose(file);
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Warehouse Management System ; Style: complex
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Struct for products in inventory
typedef struct {
    int id;
    char name[20];
    int quantity;
    float price;
} Product;

// Function prototype
void displayMenu();
void displayInventory(Product products[], int numProducts);
void addProduct(Product products[], int *numProducts);
void removeProduct(Product products[], int *numProducts);
void updateProduct(Product products[], int numProducts, int id);

int main() {
    char choice = '0';
    int numProducts = 0;
    Product products[100];

    while(choice != '5') {
        displayMenu();
        printf(""Enter your choice: "");
        scanf("" %c"", &choice);

        switch(choice) {
            case '1':
                displayInventory(products, numProducts);
                break;
            case '2':
                addProduct(products, &numProducts);
                break;
            case '3':
                removeProduct(products, &numProducts);
                break;
            case '4':
                // Get product id to update
                printf(""Enter product ID to update: "");
                int id;
                scanf(""%d"", &id);
                updateProduct(products, numProducts, id);
                break;
            case '5':
                printf(""Goodbye!\n"");
                break;
            default:
                printf(""Invalid choice. Please enter a number from 1-5.\n"");
                break;
        }
    }
    
    return 0;
}

// Function definitions
void displayMenu() {
    printf(""\n=== Warehouse Management System ===\n"");
    printf(""1. Display Inventory\n"");
    printf(""2. Add Product\n"");
    printf(""3. Remove Product\n"");
    printf(""4. Update Product\n"");
    printf(""5. Exit\n"");
}

void displayInventory(Product products[], int numProducts) {
    printf(""\n=== Inventory ===\n"");
    printf(""ID\tName\tQuantity\tPrice\n"");
    printf(""--------------------------------------------\n"");
    for(int i = 0; i < numProducts; i++) {
        printf(""%d\t%s\t%d\t\t%.2f\n"", products[i].id, products[i].name, products[i].quantity, products[i].price);
    }
    if(numProducts == 0) {
        printf(""Inventory is empty.\n"");
    }
}

void addProduct(Product products[], int *numProducts) {
    Product newProduct;
    
    // Get product details from user
    printf(""Enter product name: "");
    scanf(""%s"", newProduct.name);
    printf(""Enter product quantity: "");
    scanf(""%d"", &newProduct.quantity);
    printf(""Enter product price: "");
    scanf(""%f"", &newProduct.price);

    // Assign product id and add to inventory
    newProduct.id = *numProducts + 1;
    products[*numProducts] = newProduct;
    *numProducts += 1;

    printf(""%s added to inventory.\n"", newProduct.name);
}

void removeProduct(Product products[], int *numProducts) {
    int removeId;
    int foundId = -1;

    // Get product id to remove
    printf(""Enter product ID to remove: "");
    scanf(""%d"", &removeId);

    // Find product id in inventory
    for(int i = 0; i < *numProducts; i++) {
        if(products[i].id == removeId) {
            foundId = i;
            break;
        }
    }

    // If product is found, remove it from inventory
    if(foundId != -1) {
        printf(""%s removed from inventory.\n"", products[foundId].name);
        for(int i = foundId; i < *numProducts - 1; i++) {
            products[i] = products[i + 1];
        }
        *numProducts -= 1;
    } else {
        printf(""Product not found in inventory.\n"");
    }
}

void updateProduct(Product products[], int numProducts, int id) {
    int foundId = -1;

    // Find product id in inventory
    for(int i = 0; i < numProducts; i++) {
        if(products[i].id == id) {
            foundId = i;
            break;
        }
    }

    // If product is found, update its details
    if(foundId != -1) {
        printf(""\nOld details:\n"");
        printf(""Name: %s\n"", products[foundId].name);
        printf(""Quantity: %d\n"", products[foundId].quantity);
        printf(""Price: %.2f\n"", products[foundId].price);

        // Get new product details from user
        printf(""\nEnter new details:\n"");
        printf(""Enter product name: "");
        scanf(""%s"", products[foundId].name);
        printf(""Enter product quantity: "");
        scanf(""%d"", &products[foundId].quantity);
        printf(""Enter product price: "");
        scanf(""%f"", &products[foundId].price);

        printf(""%s updated in inventory.\n"", products[foundId].name);

    } else {
        printf(""Product not found in inventory.\n"");
    }
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t addProduct(int64_t a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t displayInventory(int64_t a1, int64_t a2);
int64_t displayMenu(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);
int64_t removeProduct(int64_t a1, int64_t a2);
int64_t updateProduct(int64_t a1, int64_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xe1100000e2e; // 0x2080
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g2;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g2 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1343
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b8
    char v2 = 48; // bp-3233, 0x11c7
    displayMenu();
    printf(""Enter your choice: "");
    scanf("" %c"", &v2);
    int64_t v3 = (int64_t)v2 + 0xffffffcf; // 0x1223
    while ((int32_t)v3 >= 5) {
        // 0x1309
        puts(""Invalid choice. Please enter a number from 1-5."");
        if (v2 == 53) {
            // 0x1328
            if (v1 == __readfsqword(40)) {
                // 0x1341
                return 0;
            }
            // 0x133c
            __stack_chk_fail();
            // 0x1341
            return &g3;
        }
        displayMenu();
        printf(""Enter your choice: "");
        scanf("" %c"", &v2);
        v3 = (int64_t)v2 + 0xffffffcf;
    }
    int32_t v4 = *(int32_t *)((4 * v3 & 0x3fffffffc) + (int64_t)&g1); // 0x1240
    return (int64_t)v4 + (int64_t)&g1;
}

// Address range: 0x1343 - 0x13a8
int64_t displayMenu(void) {
    // 0x1343
    puts(""\n=== Warehouse Management System ==="");
    puts(""1. Display Inventory"");
    puts(""2. Add Product"");
    puts(""3. Remove Product"");
    puts(""4. Update Product"");
    return puts(""5. Exit"");
}

// Address range: 0x13a8 - 0x14a3
int64_t displayInventory(int64_t a1, int64_t a2) {
    // 0x13a8
    puts(""\n=== Inventory ==="");
    puts(""ID\tName\tQuantity\tPrice"");
    puts(""--------------------------------------------"");
    int32_t v1 = a2; // 0x1482
    int64_t v2 = 0; // 0x1485
    if (v1 > 0) {
        // 0x13f4
        v2 = a2 & 0xffffffff;
        int64_t v3 = 0;
        int128_t v4; // 0x13a8
        int128_t v5 = v4;
        int64_t v6 = 32 * v3 + a1; // 0x1404
        int128_t v7 = __asm_movss(*(int32_t *)(v6 + 28)); // 0x1407
        __asm_pxor(v5, v5);
        int128_t v8 = __asm_cvtss2sd(v7); // 0x1410
        int64_t v9 = __asm_movq(v8); // 0x1414
        uint32_t v10 = *(int32_t *)(v6 + 24); // 0x142c
        uint32_t v11 = *(int32_t *)v6; // 0x1459
        printf(""%d\t%s\t%d\t\t%.2f\n"", (int64_t)v11, (char *)(v6 + 4), (int64_t)v10, (float64_t)(int64_t)__asm_movq_1(v9));
        v3++;
        while (v3 != v2) {
            // 0x13f4
            v5 = v8;
            v6 = 32 * v3 + a1;
            v7 = __asm_movss(*(int32_t *)(v6 + 28));
            __asm_pxor(v5, v5);
            v8 = __asm_cvtss2sd(v7);
            v9 = __asm_movq(v8);
            v10 = *(int32_t *)(v6 + 24);
            v11 = *(int32_t *)v6;
            printf(""%d\t%s\t%d\t\t%.2f\n"", (int64_t)v11, (char *)(v6 + 4), (int64_t)v10, (float64_t)(int64_t)__asm_movq_1(v9));
            v3++;
        }
    }
    int64_t puts_rc = v2; // 0x148f
    if (v1 == 0) {
        // 0x1491
        puts_rc = puts(""Inventory is empty."");
    }
    // 0x14a0
    return puts_rc;
}

// Address range: 0x14a3 - 0x15e6
int64_t addProduct(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x14b7
    printf(""Enter product name: "");
    int64_t v2; // bp-52, 0x14a3
    scanf(""%s"", &v2);
    printf(""Enter product quantity: "");
    int64_t v3; // bp-32, 0x14a3
    scanf(""%d"", &v3);
    printf(""Enter product price: "");
    int64_t v4; // bp-28, 0x14a3
    scanf(""%f"", &v4);
    int64_t v5; // 0x14a3
    int64_t v6 = 0x100000000 * v5; // 0x1565
    int64_t v7 = (v6 >> 27) + a1; // 0x157e
    *(int64_t *)v7 = v6 + 0x100000000 >> 32;
    *(int64_t *)(v7 + 24) = v3;
    int64_t v8; // 0x14a3
    *(int32_t *)a2 = *(int32_t *)&v8 + 1;
    printf(""%s added to inventory.\n"", &v2);
    int64_t result = 0; // 0x15dd
    if (v1 != __readfsqword(40)) {
        // 0x15df
        __stack_chk_fail();
        result = &g3;
    }
    // 0x15e4
    return result;
}

// Address range: 0x15e6 - 0x174e
int64_t removeProduct(int64_t a1, int64_t a2) {
    int64_t v1 = __readfsqword(40); // 0x15fa
    printf(""Enter product ID to remove: "");
    int64_t v2; // bp-32, 0x15e6
    scanf(""%d"", &v2);
    int64_t v3; // 0x15e6
    int32_t v4 = v3;
    if (v4 == 0) {
        // 0x1728
        puts(""Product not found in inventory."");
        goto lab_0x1737;
    } else {
        int64_t v5 = 0; // 0x1679
        int32_t v6 = 0;
        while (*(int32_t *)(32 * v5 + a1) != (int32_t)v2) {
            int32_t v7 = v6 + 1; // 0x166c
            v5 = v7;
            if ((v3 & 0xffffffff) <= v5) {
                // 0x1728
                puts(""Product not found in inventory."");
                goto lab_0x1737;
            }
            v6 = v7;
        }
        if (v6 == -1) {
            // 0x1728
            puts(""Product not found in inventory."");
            goto lab_0x1737;
        } else {
            int64_t v8 = v6;
            printf(""%s removed from inventory.\n"", (char *)(a1 + 4 + 32 * v8));
            int32_t v9 = v4 - 1; // 0x170f
            int32_t v10 = v9; // 0x1715
            if (v8 < (int64_t)v9) {
                int64_t v11 = 32 * v8 + a1;
                *(int64_t *)v11 = *(int64_t *)(v11 + 32);
                *(int64_t *)(v11 + 8) = *(int64_t *)(v11 + 40);
                *(int64_t *)(v11 + 16) = *(int64_t *)(v11 + 48);
                *(int64_t *)(v11 + 24) = *(int64_t *)(v11 + 56);
                int32_t v12 = v6 + 1; // 0x1705
                int64_t v13; // 0x15e6
                int32_t v14 = *(int32_t *)&v13 - 1; // 0x170f
                int64_t v15 = v12; // 0x1715
                int32_t v16 = v12; // 0x1715
                v10 = v14;
                while (v15 < (int64_t)v14) {
                    // 0x16bb
                    v11 = 32 * v15 + a1;
                    *(int64_t *)v11 = *(int64_t *)(v11 + 32);
                    *(int64_t *)(v11 + 8) = *(int64_t *)(v11 + 40);
                    *(int64_t *)(v11 + 16) = *(int64_t *)(v11 + 48);
                    *(int64_t *)(v11 + 24) = *(int64_t *)(v11 + 56);
                    v12 = v16 + 1;
                    v14 = *(int32_t *)&v13 - 1;
                    v15 = v12;
                    v16 = v12;
                    v10 = v14;
                }
            }
            // 0x1717
            *(int32_t *)a2 = v10;
            goto lab_0x1737;
        }
    }
  lab_0x1737:;
    int64_t result = 0; // 0x1745
    if (v1 != __readfsqword(40)) {
        // 0x1747
        __stack_chk_fail();
        result = &g3;
    }
    // 0x174c
    return result;
}

// Address range: 0x174e - 0x196a
int64_t updateProduct(int64_t a1, int64_t a2, int32_t a3) {
    // 0x174e
    int128_t v1; // 0x174e
    int128_t v2 = v1;
    uint32_t v3 = (int32_t)a2; // 0x179d
    if (v3 <= 0) {
        // 0x1967
        return puts(""Product not found in inventory."");
    }
    int32_t v4 = 0;
    int64_t v5 = 32 * (int64_t)v4 + a1;
    while (*(int32_t *)v5 != a3) {
        int32_t v6 = v4 + 1; // 0x1796
        if (v6 >= v3) {
            return puts(""Product not found in inventory."");
        }
        v4 = v6;
        v5 = 32 * (int64_t)v4 + a1;
    }
    if (v4 == -1) {
      lab_0x1958:
        // 0x1967
        return puts(""Product not found in inventory."");
    }
    // 0x17ac
    puts(""\nOld details:"");
    int64_t v7 = v5 + 4; // 0x17ce
    char * v8 = (char *)v7; // 0x17e4
    printf(""Name: %s\n"", v8);
    int64_t v9 = v5 + 24; // 0x17fc
    printf(""Quantity: %d\n"", (int64_t)*(int32_t *)v9);
    int64_t v10 = v5 + 28; // 0x1828
    int128_t v11 = __asm_movss(*(int32_t *)v10); // 0x1828
    __asm_pxor(v2, v2);
    printf(""Price: %.2f\n"", (float64_t)(int64_t)__asm_movq_1(__asm_movq(__asm_cvtss2sd(v11))));
    puts(""\nEnter new details:"");
    printf(""Enter product name: "");
    scanf(""%s"", (char **)v7);
    printf(""Enter product quantity: "");
    scanf(""%d"", (int64_t *)v9);
    printf(""Enter product price: "");
    scanf(""%f"", (float64_t *)v10);
    // 0x1967
    return printf(""%s updated in inventory.\n"", v8);
}

// Address range: 0x196c - 0x1979
int64_t _fini(void) {
    // 0x196c
    int64_t result; // 0x196c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <stdint.h>
        #include <math.h>
        #include <stdarg.h>
        #include <assert.h>
        #include <time.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <pthread.h>
        #include <signal.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <ctype.h>
        #include <locale.h>
        #include <wchar.h>
        #include <iconv.h>
        #include <dlfcn.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/resource.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <pthread.h>
        #include <signal.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <ctype.h>
        #include <locale.h>
        #include <wchar.h>
        #include <iconv.h>
        #include <dlfcn.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/resource.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <pthread.h>
        #include <signal.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <ctype.h>
        #include <locale.h>
        #include <wchar.h>
        #include <iconv.h>
        #include <dlfcn.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/resource.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <pthread.h>
        #include <signal.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <ctype.h>
        #include <locale.h>
        #include <wchar.h>
        #include <iconv.h>
        #include <dlfcn.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/resource.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <pthread.h>
        #include <signal.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <ctype.h>
        #include <locale.h>
        #include <wchar.h>
        #include <iconv.h>
        #include <dlfcn.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/resource.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>
        #include <netdb.h>
        #include <pthread.h>
        #include <signal.h>
        #include <setjmp.h>
        #include <errno.h>
        #include <ctype.h>
        #include <locale.h>
        #include <wchar.h>
        #include <iconv.h>
        #include <dlfcn.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/resource.h>
        #include <sys/time.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <unistd.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/resource.h>
        #include <sys/ptrace.h>
        #include <sys/prctl.h>
        #include <sys/uio.h>
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <ar",0
"//FormAI DATASET v1.0 Category: Arithmetic ; Style: retro
#include <stdio.h> //Include standard I/O header file

int main() //Start main function
{
    int num1, num2, result; //Declare integer variables

    printf(""Enter the first number: ""); //Output prompt for user input
    scanf(""%d"", &num1); //Accept user input

    printf(""Enter the second number: ""); //Output prompt for user input
    scanf(""%d"", &num2); //Accept user input

    result = num1 + num2; //Add two numbers and store in result variable

    printf(""The sum of %d and %d is %d\n"", num1, num2, result); //Output the result of addition

    result = num1 - num2; //Subtract one number from another and store in result variable

    printf(""The difference between %d and %d is %d\n"", num1, num2, result); //Output the result of subtraction

    result = num1 * num2; //Multiply two numbers and store in result variable

    printf(""The product of %d and %d is %d\n"", num1, num2, result); //Output the result of multiplication

    result = num1 / num2; //Divide one number by another and store in result variable

    printf(""The quotient of %d divided by %d is %d\n"", num1, num2, result); //Output the result of division

    result = num1 % num2; //Calculate the modulus of two numbers and store in result variable

    printf(""The remainder of %d divided by %d is %d\n"", num1, num2, result); //Output the remainder

    return 0; //Return 0 to end the program
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
void function_1070(void);
int32_t function_1080(char * format, ...);
int32_t function_1090(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
void function_1070(void) {
    // 0x1070
    __stack_chk_fail();
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * format, ...) {
    // 0x1080
    return printf(format);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * format, ...) {
    // 0x1090
    return scanf(format);
}

// Address range: 0x10a0 - 0x10c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10a0
    int64_t v1; // 0x10a0
    __libc_start_main(0x1189, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10d0 - 0x10f9
int64_t deregister_tm_clones(void) {
    // 0x10d0
    return &g1;
}

// Address range: 0x1100 - 0x1139
int64_t register_tm_clones(void) {
    // 0x1100
    return 0;
}

// Address range: 0x1140 - 0x1179
int64_t __do_global_dtors_aux(void) {
    // 0x1140
    if (*(char *)&g1 != 0) {
        // 0x1178
        int64_t result; // 0x1140
        return result;
    }
    // 0x114d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x115b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1167
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1180 - 0x1189
int64_t frame_dummy(void) {
    // 0x1180
    return register_tm_clones();
}

// Address range: 0x1189 - 0x12f2
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1195
    printf(""Enter the first number: "");
    int64_t v2; // bp-28, 0x1189
    scanf(""%d"", &v2);
    printf(""Enter the second number: "");
    int64_t v3; // bp-24, 0x1189
    scanf(""%d"", &v3);
    int64_t v4 = v2;
    int64_t v5 = v3;
    printf(""The sum of %d and %d is %d\n"", v4 & 0xffffffff, v5 & 0xffffffff, v5 + v4 & 0xffffffff);
    int64_t v6 = v2;
    int64_t v7 = v3;
    printf(""The difference between %d and %d is %d\n"", v6 & 0xffffffff, v7 & 0xffffffff, v6 - v7 & 0xffffffff);
    int64_t v8 = v2; // 0x1256
    int64_t v9 = v3;
    printf(""The product of %d and %d is %d\n"", v8 & 0xffffffff, v9 & 0xffffffff, (0x100000000 * v9 >> 32) * (0x100000000 * v8 >> 32) & 0xffffffff);
    int64_t v10 = v2 & 0xffffffff; // 0x1288
    int64_t v11 = v3 & 0xffffffff; // 0x1288
    printf(""The quotient of %d divided by %d is %d\n"", v10, v11, (0x100000000 * (int64_t)((int32_t)v2 >> 31) | v10) / v11 & 0xffffffff);
    int64_t v12 = v2 & 0xffffffff; // 0x12b3
    int64_t v13 = v3 & 0xffffffff; // 0x12b3
    printf(""The remainder of %d divided by %d is %d\n"", v12, v13, (0x100000000 * (int64_t)((int32_t)v2 >> 31) | v12) % v13 & 0xffffffff);
    int64_t result = 0; // 0x12e9
    if (v1 != __readfsqword(40)) {
        // 0x12eb
        __stack_chk_fail();
        result = &g2;
    }
    // 0x12f0
    return result;
}

// Address range: 0x12f4 - 0x1301
int64_t _fini(void) {
    // 0x12f4
    int64_t result; // 0x12f4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 12

","      #include <stdio.h>
        int main(int argc, char ** argv) {
            int a1, a2, a3, a4, a5, a6;
            printf(""Enter the first number: "");
            scanf(""%d"", &a1);
            printf(""Enter the second number: "");
            scanf(""%d"", &a2);
            int a3 = a1 + a2;
            int a4 = a1 - a2;
            int a5 = a1 * a2;
            int a6 = a1 / a2;
            int a7 = a1 % a2;
            printf(""The sum of %d and %d is %d\n"", a1, a2, a3);
            printf(""The difference between %d and %d is %d\n"", a1, a2, a4);
            printf(""The product of %d and %d is %d\n"", a1, a2, a5);
            printf(""The quotient of %d divided by %d is %d\n"", a1, a2, a6);
            printf(""The remainder of %d divided by %d is %d\n"", a1, a2, a7);
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Wireless Network Scanner ; Style: excited
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <net/if.h>

#define WLAN_INTERFACE_NAME ""wlan0""

int main(int argc, char **argv) {

    printf(""Welcome to C Wireless Network Scanner!\n"");
    printf(""==================================================\n"");

    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        printf(""Error: Could not create socket: %s\n"", strerror(errno));
        return 1;
    }

    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, WLAN_INTERFACE_NAME, sizeof(ifr.ifr_name) - 1);

    if (ioctl(sock, SIOCGIFFLAGS, &ifr) < 0) {
        printf(""Error: Could not get interface flags: %s\n"", strerror(errno));
        close(sock);
        return 1;
    }

    ifr.ifr_flags |= IFF_UP;
    if (ioctl(sock, SIOCSIFFLAGS, &ifr) < 0) {
        printf(""Error: Could not bring up interface: %s\n"", strerror(errno));
        close(sock);
        return 1;
    }

    if (ioctl(sock, SIOCGIFADDR, &ifr) < 0) {
        printf(""Error: Could not get interface address: %s\n"", strerror(errno));
        close(sock);
        return 1;
    }

    printf(""Wireless Network Scanner is running on %s.\n"", inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
    printf(""Scanning...\n"");

    // TODO: Implement network scanning

    printf(""Done.\n"");

    close(sock);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct in_addr {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10e0(int64_t * d);
int32_t * function_10f0(void);
char * function_1100(char * dest, char * src, int32_t n);
int32_t function_1110(char * s);
char * function_1120(struct in_addr in);
void function_1130(void);
int32_t function_1140(char * format, ...);
int64_t * function_1150(int64_t * s, int32_t c, int32_t n);
int32_t function_1160(int32_t fd, int32_t request, ...);
int32_t function_1170(int32_t fd);
char * function_1180(int32_t errnum);
int32_t function_1190(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int64_t * d) {
    // 0x10e0
    __cxa_finalize(d);
}

// Address range: 0x10f0 - 0x10fb
int32_t * function_10f0(void) {
    // 0x10f0
    return __errno_location();
}

// Address range: 0x1100 - 0x110b
char * function_1100(char * dest, char * src, int32_t n) {
    // 0x1100
    return strncpy(dest, src, n);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s) {
    // 0x1110
    return puts(s);
}

// Address range: 0x1120 - 0x112b
char * function_1120(struct in_addr in) {
    // 0x1120
    return inet_ntoa(in);
}

// Address range: 0x1130 - 0x113b
void function_1130(void) {
    // 0x1130
    __stack_chk_fail();
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return printf(format);
}

// Address range: 0x1150 - 0x115b
int64_t * function_1150(int64_t * s, int32_t c, int32_t n) {
    // 0x1150
    return memset(s, c, n);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(int32_t fd, int32_t request, ...) {
    // 0x1160
    return ioctl(fd, request);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(int32_t fd) {
    // 0x1170
    return close(fd);
}

// Address range: 0x1180 - 0x118b
char * function_1180(int32_t errnum) {
    // 0x1180
    return strerror(errnum);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1190
    return socket(domain, type, protocol);
}

// Address range: 0x11a0 - 0x11c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x11a0
    int64_t v1; // 0x11a0
    __libc_start_main(0x1289, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x11d0 - 0x11f9
int64_t deregister_tm_clones(void) {
    // 0x11d0
    return &g1;
}

// Address range: 0x1200 - 0x1239
int64_t register_tm_clones(void) {
    // 0x1200
    return 0;
}

// Address range: 0x1240 - 0x1279
int64_t __do_global_dtors_aux(void) {
    // 0x1240
    if (*(char *)&g1 != 0) {
        // 0x1278
        int64_t result; // 0x1240
        return result;
    }
    // 0x124d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x125b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1267
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1280 - 0x1289
int64_t frame_dummy(void) {
    // 0x1280
    return register_tm_clones();
}

// Address range: 0x1289 - 0x14b9
int main(int argc, char ** argv) {
    struct in_addr in; // 0x145a
    int64_t v1 = __readfsqword(40); // 0x129c
    puts(""Welcome to C Wireless Network Scanner!"");
    puts(""=================================================="");
    int32_t sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP); // 0x12d8
    int64_t v2; // 0x1289
    if (sock_fd >= 0) {
        // 0x1315
        int64_t str; // bp-56, 0x1289
        memset(&str, 0, 40);
        strncpy((char *)&str, ""wlan0"", 15);
        if (ioctl(sock_fd, 0x8913) >= 0) {
            // 0x139b
            if (ioctl(sock_fd, 0x8914) >= 0) {
                // 0x13fb
                if (ioctl(sock_fd, 0x8915) >= 0) {
                    // 0x144d
                    in = (struct {int32_t e0;}){
                        .e0 = 0
                    };
                    int32_t v3; // 0x1289
                    in.e0 = v3;
                    printf(""Wireless Network Scanner is running on %s.\n"", inet_ntoa(in));
                    puts(""Scanning..."");
                    puts(""Done."");
                    close(sock_fd);
                    v2 = 0;
                } else {
                    // 0x1417
                    printf(""Error: Could not get interface address: %s\n"", strerror(*__errno_location()));
                    close(sock_fd);
                    v2 = 1;
                }
            } else {
                // 0x13c2
                printf(""Error: Could not bring up interface: %s\n"", strerror(*__errno_location()));
                close(sock_fd);
                v2 = 1;
            }
        } else {
            // 0x1362
            printf(""Error: Could not get interface flags: %s\n"", strerror(*__errno_location()));
            close(sock_fd);
            v2 = 1;
        }
    } else {
        // 0x12e6
        printf(""Error: Could not create socket: %s\n"", strerror(*__errno_location()));
        v2 = 1;
    }
    int64_t result = v2; // 0x14b0
    if (v1 != __readfsqword(40)) {
        // 0x14b2
        __stack_chk_fail();
        result = &g2;
    }
    // 0x14b7
    return result;
}

// Address range: 0x14bc - 0x14c9
int64_t _fini(void) {
    // 0x14bc
    int64_t result; // 0x14bc
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 20

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <arpa/inet.h>
        #include <errno.h>
        #include <sys/socket.h>
        #include <unistd.h>
        #include <stropts.h>

        int main(int argc, char ** argv) {
            struct in_addr in;
            int sock_fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
            if (sock_fd >= 0) {
                char str[15];
                memset(&str, 0, 40);
                strncpy(str, ""wlan0"", 15);
                if (ioctl(sock_fd, 0x8913) >= 0) {
                    if (ioctl(sock_fd, 0x8914) >= 0) {
                        if (ioctl(sock_fd, 0x8915) >= 0) {
                            in = (struct {int32_t e0;}){
                                .e0 = 0
                            };
                            int32_t v3;
                            in.e0 = v3;
                            printf(""Wireless Network Scanner is running on %s.\n"", inet_ntoa(in));
                            puts(""Scanning..."");
                            puts(""Done."");
                            close(sock_fd);
                        } else {
                            printf(""Error: Could not get interface address: %s\n"", strerror(*__errno_location()));
                            close(sock_fd);
                        }
                    } else {
                        printf(""Error: Could not bring up interface: %s\n"", strerror(*__errno_location()));
                        close(sock_fd);
                    }
                } else {
                    printf(""Error: Could not get interface flags: %s\n"", strerror(*__errno_location()));
                    close(sock_fd);
                }
            } else {
                printf(""Error: Could not create socket: %s\n"", strerror(*__errno_location()));
            }
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Simple HTTP Proxy ; Style: asynchronous
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BACKLOG 10 // Number of connections allowed to queue up
#define MAX_DATA_SIZE 1024 // Maximum number of bytes for data

// Function to handle error messages
void error(char *msg) {
    perror(msg);
    exit(1);
}

// Function to send data from one socket to another
void send_data(int from_fd, int to_fd) {
    char buffer[MAX_DATA_SIZE];
    ssize_t bytes_read = recv(from_fd, buffer, MAX_DATA_SIZE, 0);
    if (bytes_read <= 0) {
        return;
    }
    send(to_fd, buffer, bytes_read, 0);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        error(""Usage: ./proxy <local port> <remote host>"");
    }

    int local_port = atoi(argv[1]); // The port the proxy will listen on
    char *remote_host = argv[2]; // The host name the proxy will connect to
    int remote_port = 80; // The default port for HTTP

    // Resolve the remote host name to an IP address
    struct hostent *he = gethostbyname(remote_host);
    if (!he) {
        error(""Could not resolve hostname."");
    }
    char *remote_ip = inet_ntoa(*((struct in_addr *)he->h_addr));

    // Define the local address structure for the proxy
    struct sockaddr_in local_addr;
    local_addr.sin_family = AF_INET; // IPv4
    local_addr.sin_port = htons(local_port); // Convert the port number to network byte order
    local_addr.sin_addr.s_addr = INADDR_ANY; // Listen on all available interfaces
    memset(local_addr.sin_zero, '\0', sizeof local_addr.sin_zero);

    // Create the socket for the proxy to listen on
    int local_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (local_fd == -1) {
        error(""Could not create local socket."");
    }

    // Make the socket reusable
    int reuseaddr = 1;
    if (setsockopt(local_fd, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(int)) == -1) {
        error(""Could not make local socket reusable."");
    }

    // Bind the socket to the local address
    if (bind(local_fd, (struct sockaddr *)&local_addr, sizeof local_addr) == -1) {
        error(""Could not bind local socket."");
    }

    // Start listening for incoming connections
    if (listen(local_fd, BACKLOG) == -1) {
        error(""Could not listen on local socket."");
    }

    while (1) { // Continue running until exited
        struct sockaddr_in remote_addr;
        socklen_t sin_size = sizeof remote_addr;

        // Accept an incoming connection
        int client_fd = accept(local_fd, (struct sockaddr *)&remote_addr, &sin_size);
        if (client_fd == -1) {
            error(""Could not accept client socket."");
        }

        if (fork() == 0) { // Child process
            close(local_fd); // Close the listening socket in the child process

            // Define the remote address structure for the proxy to connect to
            remote_addr.sin_family = AF_INET;
            remote_addr.sin_port = htons(remote_port);
            remote_addr.sin_addr.s_addr = inet_addr(remote_ip);
            memset(remote_addr.sin_zero, '\0', sizeof remote_addr.sin_zero);

            // Create a socket for the proxy to connect to the remote server
            int remote_fd = socket(AF_INET, SOCK_STREAM, 0);
            if (remote_fd == -1) {
                error(""Could not create remote socket."");
            }

            // Connect to the remote server
            if (connect(remote_fd, (struct sockaddr *)&remote_addr, sizeof remote_addr) == -1) {
                error(""Could not connect to remote server."");
            }

            // Set the sockets to non-blocking mode
            fcntl(client_fd, F_SETFL, O_NONBLOCK);
            fcntl(remote_fd, F_SETFL, O_NONBLOCK);

            fd_set fds; // File descriptor set
            int max_fd = (client_fd > remote_fd ? client_fd : remote_fd) + 1; // Maximum file descriptor value plus 1

            while (1) { // Continue running until the connection is closed
                // Clear the file descriptor set and add the sockets to it
                FD_ZERO(&fds);
                FD_SET(client_fd, &fds);
                FD_SET(remote_fd, &fds);

                // Wait for activity on the sockets
                int activity = select(max_fd, &fds, NULL, NULL, NULL);
                if (activity == -1) {
                    error(""Error in select."");
                }

                if (FD_ISSET(client_fd, &fds)) { // Client has data to send
                    send_data(client_fd, remote_fd);
                }

                if (FD_ISSET(remote_fd, &fds)) { // Remote server has data to send
                    send_data(remote_fd, client_fd);
                }
            }

            close(remote_fd);
            close(client_fd);
            exit(0);
        }

        close(client_fd); // Close the client socket in the parent process
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

struct timeval {
    int64_t e0;
    int64_t e1;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t error(int64_t str);
int64_t frame_dummy(void);
void function_1180(int64_t * d);
int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_11a0(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t optlen);
int32_t function_11b0(int32_t fd, int32_t cmd, ...);
char * function_11c0(struct in_addr in);
void function_11d0(void);
int16_t function_11e0(int16_t hostshort);
int32_t function_11f0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int64_t * function_1200(int64_t * s, int32_t c, int32_t n);
int32_t function_1210(int32_t fd);
int32_t function_1220(char * cp);
struct hostent * function_1230(char * name);
int32_t function_1240(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout);
int32_t function_1250(int32_t fd, int32_t n);
int32_t function_1260(int32_t fd, struct sockaddr * addr, int32_t len);
void function_1270(char * s);
int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t * addr_len);
int32_t function_1290(char * nptr);
void function_12a0(int32_t status);
int32_t function_12b0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_12c0(void);
int32_t function_12d0(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);
int64_t send_data(int64_t sock, int64_t sock2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
int64_t g2 = 0; // 0x4010
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x1180 - 0x118b
void function_1180(int64_t * d) {
    // 0x1180
    __cxa_finalize(d);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1190
    return recv(fd, buf, n, flags);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(int32_t fd, int32_t level, int32_t optname, int64_t * optval, int32_t optlen) {
    // 0x11a0
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(int32_t fd, int32_t cmd, ...) {
    // 0x11b0
    return fcntl(fd, cmd);
}

// Address range: 0x11c0 - 0x11cb
char * function_11c0(struct in_addr in) {
    // 0x11c0
    return inet_ntoa(in);
}

// Address range: 0x11d0 - 0x11db
void function_11d0(void) {
    // 0x11d0
    __stack_chk_fail();
}

// Address range: 0x11e0 - 0x11eb
int16_t function_11e0(int16_t hostshort) {
    // 0x11e0
    return htons(hostshort);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x11f0
    return send(fd, buf, n, flags);
}

// Address range: 0x1200 - 0x120b
int64_t * function_1200(int64_t * s, int32_t c, int32_t n) {
    // 0x1200
    return memset(s, c, n);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int32_t fd) {
    // 0x1210
    return close(fd);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(char * cp) {
    // 0x1220
    return inet_addr(cp);
}

// Address range: 0x1230 - 0x123b
struct hostent * function_1230(char * name) {
    // 0x1230
    return gethostbyname(name);
}

// Address range: 0x1240 - 0x124b
int32_t function_1240(int32_t nfds, struct _TYPEDEF_fd_set * readfds, struct _TYPEDEF_fd_set * writefds, struct _TYPEDEF_fd_set * exceptfds, struct timeval * timeout) {
    // 0x1240
    return select(nfds, readfds, writefds, exceptfds, timeout);
}

// Address range: 0x1250 - 0x125b
int32_t function_1250(int32_t fd, int32_t n) {
    // 0x1250
    return listen(fd, n);
}

// Address range: 0x1260 - 0x126b
int32_t function_1260(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1260
    return bind(fd, addr, len);
}

// Address range: 0x1270 - 0x127b
void function_1270(char * s) {
    // 0x1270
    perror(s);
}

// Address range: 0x1280 - 0x128b
int32_t function_1280(int32_t fd, struct sockaddr * addr, int32_t * addr_len) {
    // 0x1280
    return accept(fd, addr, addr_len);
}

// Address range: 0x1290 - 0x129b
int32_t function_1290(char * nptr) {
    // 0x1290
    return atoi(nptr);
}

// Address range: 0x12a0 - 0x12ab
void function_12a0(int32_t status) {
    // 0x12a0
    exit(status);
}

// Address range: 0x12b0 - 0x12bb
int32_t function_12b0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x12b0
    return connect(fd, addr, len);
}

// Address range: 0x12c0 - 0x12cb
int32_t function_12c0(void) {
    // 0x12c0
    return fork();
}

// Address range: 0x12d0 - 0x12db
int32_t function_12d0(int32_t domain, int32_t type, int32_t protocol) {
    // 0x12d0
    return socket(domain, type, protocol);
}

// Address range: 0x12e0 - 0x1306
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x12e0
    int64_t v1; // 0x12e0
    __libc_start_main(0x1481, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1310 - 0x1339
int64_t deregister_tm_clones(void) {
    // 0x1310
    return &g2;
}

// Address range: 0x1340 - 0x1379
int64_t register_tm_clones(void) {
    // 0x1340
    return 0;
}

// Address range: 0x1380 - 0x13b9
int64_t __do_global_dtors_aux(void) {
    // 0x1380
    if (*(char *)&g2 != 0) {
        // 0x13b8
        int64_t result; // 0x1380
        return result;
    }
    // 0x138d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x139b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x13a7
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x13c0 - 0x13c9
int64_t frame_dummy(void) {
    // 0x13c0
    return register_tm_clones();
}

// Address range: 0x13c9 - 0x13ef
int64_t error(int64_t str) {
    // 0x13c9
    perror((char *)str);
    exit(1);
    return &g3;
}

// Address range: 0x13ef - 0x1481
int64_t send_data(int64_t sock, int64_t sock2) {
    int64_t v1 = __readfsqword(40); // 0x140a
    int64_t buf; // bp-1048, 0x13ef
    uint32_t length = recv((int32_t)sock, &buf, (int32_t)&g1, 0); // 0x1432
    if (length >= 1) {
        // 0x1448
        send((int32_t)sock2, &buf, length, 0);
    }
    int64_t result = 0; // 0x1478
    if (v1 != __readfsqword(40)) {
        // 0x147a
        __stack_chk_fail();
        result = &g3;
    }
    // 0x147f
    return result;
}

// Address range: 0x1481 - 0x197d
int main(int argc, char ** argv) {
    struct in_addr in; // 0x153b
    // 0x1481
    __readfsqword(40);
    if ((int32_t)argc != 3) {
        // 0x14b5
        error((int64_t)""Usage: ./proxy <local port> <remote host>"");
        // UNREACHABLE
    }
    int64_t v1 = (int64_t)argv; // 0x14c4
    int32_t str_as_i = atoi((char *)*(int64_t *)(v1 + 8)); // 0x14d5
    struct hostent * v2 = gethostbyname((char *)*(int64_t *)(v1 + 16)); // 0x1506
    if (v2 == NULL) {
        // 0x151c
        error((int64_t)""Could not resolve hostname."");
        // UNREACHABLE
    }
    int64_t v3 = *(int64_t *)*(int64_t *)((int64_t)v2 + 24); // 0x1536
    in = (struct {int32_t e0;}){
        .e0 = 0
    };
    in.e0 = *(int32_t *)v3;
    char * cp = inet_ntoa(in); // 0x153b
    int16_t addr = 2; // bp-184, 0x1547
    htons((int16_t)str_as_i);
    int64_t v4; // bp-176, 0x1481
    memset(&v4, 0, 8);
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x159d
    if (sock_fd == -1) {
        // 0x15b1
        error((int64_t)""Could not create local socket."");
        // UNREACHABLE
    }
    int32_t option_value = 1; // bp-256, 0x15c0
    if (setsockopt(sock_fd, SO_DEBUG, 2, (int64_t *)&option_value, 4) == -1) {
        // 0x15f6
        error((int64_t)""Could not make local socket reusable."");
        // UNREACHABLE
    }
    // 0x1605
    if (bind(sock_fd, (struct sockaddr *)&addr, 16) == -1) {
        // 0x1626
        error((int64_t)""Could not bind local socket."");
        // UNREACHABLE
    }
    // 0x1635
    if (listen(sock_fd, 10) == -1) {
        // 0x164c
        error((int64_t)""Could not listen on local socket."");
        // UNREACHABLE
    }
    int32_t addr_len = 16; // bp-252, 0x165b
    int64_t addr2; // bp-168, 0x1481
    int32_t accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x167e
    if (accepted_sock_fd == -1) {
        // 0x1692
        error((int64_t)""Could not accept client socket."");
        // UNREACHABLE
    }
    uint32_t fd = accepted_sock_fd;
    while (fork() != 0) {
        // 0x196b
        close(fd);
        addr_len = 16;
        int32_t accepted_sock_fd2 = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len); // 0x167e
        if (accepted_sock_fd2 == -1) {
            // 0x1692
            error((int64_t)""Could not accept client socket."");
            // UNREACHABLE
        }
        fd = accepted_sock_fd2;
    }
    // 0x16ae
    close(sock_fd);
    addr2 = 2;
    htons(80);
    inet_addr(cp);
    int64_t v5; // bp-160, 0x1481
    memset(&v5, 0, 8);
    uint32_t sock_fd2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x171c
    if (sock_fd2 == -1) {
        // 0x1730
        error((int64_t)""Could not create remote socket."");
        // UNREACHABLE
    }
    // 0x173f
    if (connect(sock_fd2, (struct sockaddr *)&addr2, 16) == -1) {
        // 0x1760
        error((int64_t)""Could not connect to remote server."");
        // UNREACHABLE
    }
    // 0x176f
    fcntl(fd, F_SETFL);
    fcntl(sock_fd2, F_SETFL);
    int32_t v6 = sock_fd2 - fd; // 0x17b3
    int32_t nfds = (v6 < 0 == ((v6 ^ sock_fd2) & (sock_fd2 ^ fd)) < 0 ? sock_fd2 : fd) + 1; // 0x17b8
    int32_t v7 = (fd < 0 ? fd + 63 : fd) / 64;
    int64_t v8; // bp-8, 0x1481
    int64_t v9 = (int64_t)&v8 - 144;
    int64_t * v10 = (int64_t *)(8 * (int64_t)v7 + v9);
    uint32_t v11 = fd % 64;
    int64_t v12 = v11 == 0 ? 1 : 1 << (int64_t)v11;
    int32_t v13 = (sock_fd2 < 0 ? sock_fd2 + 63 : sock_fd2) / 64; // 0x1850
    int64_t * v14 = (int64_t *)(8 * (int64_t)v13 + v9); // 0x1858
    uint32_t v15 = sock_fd2 % 64;
    int64_t v16 = v15 == 0 ? 1 : 1 << (int64_t)v15;
    int64_t v17 = sock_fd2;
    int64_t v18 = fd;
    int64_t readfds; // bp-152, 0x1481
    for (int64_t i = 0; i < 16; i++) {
        // 0x17db
        *(int64_t *)(8 * i + (int64_t)&readfds) = 0;
    }
    // 0x1800
    *(int64_t *)((0x100000000 * (int64_t)v7 >> 29) + v9) = *v10 | v12;
    *(int64_t *)((0x100000000 * (int64_t)v13 >> 29) + v9) = *v14 | v16;
    while (select(nfds, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, NULL) != -1) {
        // 0x18c6
        if ((*v10 & v12) != 0) {
            // 0x18ff
            send_data(v18, v17);
        }
        // 0x1914
        if ((*v14 & v16) != 0) {
            // 0x1951
            send_data(v17, v18);
        }
        for (int64_t i = 0; i < 16; i++) {
            // 0x17db
            *(int64_t *)(8 * i + (int64_t)&readfds) = 0;
        }
        // 0x1800
        *(int64_t *)((0x100000000 * (int64_t)v7 >> 29) + v9) = *v10 | v12;
        *(int64_t *)((0x100000000 * (int64_t)v13 >> 29) + v9) = *v14 | v16;
    }
    // 0x18b7
    error((int64_t)""Error in select."");
    // UNREACHABLE
}

// Address range: 0x1980 - 0x198d
int64_t _fini(void) {
    // 0x1980
    int64_t result; // 0x1980
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 32

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <arpa/inet.h>
        #include <fcntl.h>
        #include <netdb.h>
        #include <netinet/in.h>
        #include <sys/select.h>
        #include <sys/socket.h>
        #include <unistd.h>

        int main(int argc, char ** argv) {
            struct in_addr in;
            if ((int32_t)argc != 3) {
                error(""Usage: ./proxy <local port> <remote host>"");
            }
            int64_t v1 = (int64_t)argv;
            int32_t str_as_i = atoi((char *)*(int64_t *)(v1 + 8));
            struct hostent * v2 = gethostbyname((char *)*(int64_t *)(v1 + 16));
            if (v2 == NULL) {
                error(""Could not resolve hostname."");
            }
            int64_t v3 = *(int64_t *)*(int64_t *)((int64_t)v2 + 24);
            in = (struct {int32_t e0;}){
                .e0 = 0
            };
            in.e0 = *(int32_t *)v3;
            char * cp = inet_ntoa(in);
            int16_t addr = 2;
            htons((int16_t)str_as_i);
            int64_t v4;
            memset(&v4, 0, 8);
            int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            if (sock_fd == -1) {
                error(""Could not create local socket."");
            }
            int32_t option_value = 1;
            if (setsockopt(sock_fd, SO_DEBUG, 2, (int64_t *)&option_value, 4) == -1) {
                error(""Could not make local socket reusable."");
            }
            if (bind(sock_fd, (struct sockaddr *)&addr, 16) == -1) {
                error(""Could not bind local socket."");
            }
            if (listen(sock_fd, 10) == -1) {
                error(""Could not listen on local socket."");
            }
            int32_t addr_len = 16;
            int64_t addr2;
            int32_t accepted_sock_fd = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len);
            if (accepted_sock_fd == -1) {
                error(""Could not accept client socket."");
            }
            uint32_t fd = accepted_sock_fd;
            while (fork() != 0) {
                close(fd);
                addr_len = 16;
                int32_t accepted_sock_fd2 = accept(sock_fd, (struct sockaddr *)&addr2, &addr_len);
                if (accepted_sock_fd2 == -1) {
                    error(""Could not accept client socket."");
                }
                fd = accepted_sock_fd2;
            }
            close(sock_fd);
            addr2 = 2;
            htons(80);
            inet_addr(cp);
            int64_t v5;
            memset(&v5, 0, 8);
            uint32_t sock_fd2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
            if (sock_fd2 == -1) {
                error(""Could not create remote socket."");
            }
            if (connect(sock_fd2, (struct sockaddr *)&addr2, 16) == -1) {
                error(""Could not connect to remote server."");
            }
            fcntl(fd, F_SETFL);
            fcntl(sock_fd2, F_SETFL);
            int32_t v6 = sock_fd2 - fd;
            int32_t nfds = (v6 < 0 == ((v6 ^ sock_fd2) & (sock_fd2 ^ fd)) < 0 ? sock_fd2 : fd) + 1;
            int32_t v7 = (fd < 0 ? fd + 63 : fd) / 64;
            int64_t v8;
            int64_t v9 = (int64_t)&v8 - 144;
            int64_t * v10 = (int64_t *)(8 * (int64_t)v7 + v9);
            uint32_t v11 = fd % 64;
            int64_t v12 = v11 == 0 ? 1 : 1 << (int64_t)v11;
            int32_t v13 = (sock_fd2 < 0 ? sock_fd2 + 63 : sock_fd2) / 64;
            int64_t * v14 = (int64_t *)(8 * (int64_t)v13 + v9);
            uint32_t v15 = sock_fd2 % 64;
            int64_t v16 = v15 == 0 ? 1 : 1 << (int64_t)v15;
            int64_t v17 = sock_fd2;
            int64_t v18 = fd;
            int64_t readfds;
            for (int64_t i = 0; i < 16; i++) {
                *(int64_t *)(8 * i + (int64_t)&readfds) = 0;
            }
            *(int64_t *)((0x100000000 * (int64_t)v7 >> 29) + v9) = *v10 | v12;
            *(int64_t *)((0x100000000 * (int64_t)v13 >> 29) + v9) = *v14 | v16;
            while (select(nfds, (struct _TYPEDEF_fd_set *)&readfds, NULL, NULL, NULL) != -1) {
                if ((*v10 & v12) != 0) {
                    send_data(v18, v17);
                }
                if ((*v14 & v16) != 0) {
                    send_data(v17, v18);
                }
                for (int64_t i = 0; i < 16; i++) {
                    *(int64_t *)(8 * i + (int64_t)&readfds) = 0;
                }
                *(int64_t *)((0x100000000 * (int64_t)v7 >> 29) + v9) = *v10 | v12;
                *(int64_t *)((0x100000000 * (int64_t)v13 >> 29) + v9) = *v14 | v16;
            }
            error(""Error in select."");
        }

        int64_t send_data(int64_t sock, int64_t sock2) {
            int64_t buf;
            uint32_t length = recv((int32_t)sock, &buf, (int32_t)&g1, 0);
            if (length >= 1) {
                send((int32_t)sock2, &buf, length, 0);
            }
            int64_t resu",1
"//FormAI DATASET v1.0. Category: Bitwise operations ; Style: statistical
#include <stdio.h>

int main() {
    printf(""Welcome to the Bitwise Operations Program!\n"");
    printf(""This program takes two numbers and performs bitwise operations on them.\n\n"");
    
    int num1, num2;
    printf(""Please enter the first number: "");
    scanf(""%d"", &num1);
    printf(""Please enter the second number: "");
    scanf(""%d"", &num2);
    
    int andResult = num1 & num2;
    printf(""\nBitwise AND Operation:\n"");
    printf(""%d & %d = %d\n\n"", num1, num2, andResult);
    
    int orResult = num1 | num2;
    printf(""Bitwise OR Operation:\n"");
    printf(""%d | %d = %d\n\n"", num1, num2, orResult);
    
    int xorResult = num1 ^ num2;
    printf(""Bitwise XOR Operation:\n"");
    printf(""%d ^ %d = %d\n\n"", num1, num2, xorResult);
    
    int leftShiftResult = num1 << 2;
    printf(""Bitwise Left Shift Operation:\n"");
    printf(""%d << 2 = %d\n\n"", num1, leftShiftResult);
    
    int rightShiftResult = num2 >> 3;
    printf(""Bitwise Right Shift Operation:\n"");
    printf(""%d >> 3 = %d\n\n"", num2, rightShiftResult);
    
    int onesComplementResult1 = ~num1;
    printf(""Ones Complement Operation on First Number:\n"");
    printf(""~%d = %d\n\n"", num1, onesComplementResult1);
    
    int onesComplementResult2 = ~num2;
    printf(""Ones Complement Operation on Second Number:\n"");
    printf(""~%d = %d\n\n"", num2, onesComplementResult2);
    
    printf(""Thanks for using the Bitwise Operations Program! Goodbye!\n"");
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x13e3
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    puts(""Welcome to the Bitwise Operations Program!"");
    puts(""This program takes two numbers and performs bitwise operations on them.\n"");
    printf(""Please enter the first number: "");
    int64_t v2; // bp-52, 0x11a9
    scanf(""%d"", &v2);
    printf(""Please enter the second number: "");
    int64_t v3; // bp-48, 0x11a9
    scanf(""%d"", &v3);
    puts(""\nBitwise AND Operation:"");
    printf(""%d & %d = %d\n\n"", v2 & 0xffffffff, v3 & 0xffffffff, v2 & 0xffffffff & v3);
    puts(""Bitwise OR Operation:"");
    printf(""%d | %d = %d\n\n"", v2 & 0xffffffff, v3 & 0xffffffff, (v3 | v2) & 0xffffffff);
    puts(""Bitwise XOR Operation:"");
    printf(""%d ^ %d = %d\n\n"", v2 & 0xffffffff, v3 & 0xffffffff, (v3 ^ v2) & 0xffffffff);
    puts(""Bitwise Left Shift Operation:"");
    printf(""%d << 2 = %d\n\n"", v2 & 0xffffffff, 4 * v2 & 0xfffffffc);
    puts(""Bitwise Right Shift Operation:"");
    printf(""%d >> 3 = %d\n\n"", v3 & 0xffffffff, (int64_t)((int32_t)v3 >> 3));
    puts(""Ones Complement Operation on First Number:"");
    printf(""~%d = %d\n\n"", v2 & 0xffffffff, v2 & 0xffffffff ^ 0xffffffff);
    puts(""Ones Complement Operation on Second Number:"");
    printf(""~%d = %d\n\n"", v3 & 0xffffffff, v3 & 0xffffffff ^ 0xffffffff);
    puts(""Thanks for using the Bitwise Operations Program! Goodbye!"");
    int64_t result = 0; // 0x13da
    if (v1 != __readfsqword(40)) {
        // 0x13dc
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13e1
    return result;
}

// Address range: 0x13e4 - 0x13f1
int64_t _fini(void) {
    // 0x13e4
    int64_t result; // 0x13e4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to the Bitwise Operations Program!"");
            puts(""This program takes two numbers and performs bitwise operations on them.\n"");
            printf(""Please enter the first number: "");
            int v1;
            scanf(""%d"", &v1);
            printf(""Please enter the second number: "");
            int v2;
            scanf(""%d"", &v2);
            puts(""\nBitwise AND Operation:"");
            printf(""%d & %d = %d\n\n"", v1, v2, v1 & v2);
            puts(""Bitwise OR Operation:"");
            printf(""%d | %d = %d\n\n"", v1, v2, v1 | v2);
            puts(""Bitwise XOR Operation:"");
            printf(""%d ^ %d = %d\n\n"", v1, v2, v1 ^ v2);
            puts(""Bitwise Left Shift Operation:"");
            printf(""%d << 2 = %d\n\n"", v1, v1 << 2);
            puts(""Bitwise Right Shift Operation:"");
            printf(""%d >> 3 = %d\n\n"", v2, v2 >> 3);
            puts(""Ones Complement Operation on First Number:"");
            printf(""~%d = %d\n\n"", v1, ~v1);
            puts(""Ones Complement Operation on Second Number:"");
            printf(""~%d = %d\n\n"", v2, ~v2);
            puts(""Thanks for using the Bitwise Operations Program! Goodbye!"");
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Movie Rating System ; Style: visionary
#include <stdio.h>
#include <stdlib.h>

// Define a struct for movies
struct movie {
    char title[50];
    int releasedYear;
    char director[50];
    char genre[20];
    float rating;
};

// Declare functions
void printMovie(struct movie m);
void rateMovie(struct movie *m, float rating);
void getTopRatedMovies(struct movie m[], int size);
void getMoviesByGenre(struct movie m[], int size, char *genre);
int compareByRating(const void *a, const void *b);

// Main function
int main() {
    int option;
    int numMovies = 5;
    struct movie allMovies[numMovies];
    allMovies[0] = (struct movie){""The Godfather"", 1972, ""Francis Ford Coppola"", ""Crime, Drama"", 9.2};
    allMovies[1] = (struct movie){""The Dark Knight"", 2008, ""Christopher Nolan"", ""Action, Crime, Drama"", 9.0};
    allMovies[2] = (struct movie){""The Shawshank Redemption"", 1994, ""Frank Darabont"", ""Drama"", 9.3};
    allMovies[3] = (struct movie){""Pulp Fiction"", 1994, ""Quentin Tarantino"", ""Crime, Drama"", 8.9};
    allMovies[4] = (struct movie){""The Matrix"", 1999, ""The Wachowski Brothers"", ""Action, Sci-Fi"", 8.7};

    do {
        printf(""Welcome to the C Movie Rating System!\n\n"");
        printf(""1. View all movies\n"");
        printf(""2. Rate a movie\n"");
        printf(""3. Get top rated movies\n"");
        printf(""4. Get movies by genre\n"");
        printf(""5. Exit\n\n"");
        printf(""Select an option: "");
        scanf(""%d"", &option);

        switch (option) {
            case 1:
                // View all movies
                for (int i = 0; i < numMovies; i++) {
                    printMovie(allMovies[i]);
                }
                break;
            case 2:
                // Rate a movie
                printf(""\nEnter the title of the movie you want to rate: "");
                char title[50];
                scanf(""%s"", title);
                for (int i = 0; i < numMovies; i++) {
                    if (strcmp(allMovies[i].title, title) == 0) {
                        printf(""Enter your rating (out of 10): "");
                        float rating;
                        scanf(""%f"", &rating);
                        rateMovie(&allMovies[i], rating);
                        printf(""\nThank you for rating the movie!\n\n"");
                        break;
                    } else if (i == numMovies - 1) {
                        printf(""\nMovie not found.\n\n"");
                    }
                }
                break;
            case 3:
                // Get top rated movies
                getTopRatedMovies(allMovies, numMovies);
                break;
            case 4:
                // Get movies by genre
                printf(""\nEnter a genre: "");
                char genre[20];
                scanf(""%s"", genre);
                getMoviesByGenre(allMovies, numMovies, genre);
                break;
            case 5:
                // Exit
                printf(""\nThank you for using the C Movie Rating System! Goodbye!\n"");
                break;
            default:
                printf(""\nInvalid option. Please try again.\n\n"");
        }
    } while (option != 5);

    return 0;
}

void printMovie(struct movie m) {
    printf(""\nTitle: %s\nReleased year: %d\nDirector: %s\nGenre: %s\nRating: %.1f\n"", m.title, m.releasedYear, m.director, m.genre, m.rating);
}

void rateMovie(struct movie *m, float rating) {
    m->rating = rating;
}

void getTopRatedMovies(struct movie m[], int size) {
    printf(""\nTop rated movies:\n"");
    qsort(m, size, sizeof(struct movie), compareByRating);
    for (int i = 0; i < size; i++) {
        printf(""%d. %s\n"", i + 1, m[i].title);
    }
    printf(""\n"");
}

void getMoviesByGenre(struct movie m[], int size, char *genre) {
    printf(""\nMovies in the %s genre:\n"", genre);
    for (int i = 0; i < size; i++) {
        if (strstr(m[i].genre, genre) != NULL) {
            printf(""%d. %s\n"", i + 1, m[i].title);
        }
    }
    printf(""\n"");
}

int compareByRating(const void *a, const void *b) {
    struct movie *movieA = (struct movie *)a;
    struct movie *movieB = (struct movie *)b;
    if (movieA->rating > movieB->rating) {
        return -1;
    } else if (movieA->rating < movieB->rating) {
        return 1;
    } else {
        return 0;
    }
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t compareByRating(int64_t a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(int32_t c);
int32_t function_10d0(char * s);
void function_10e0(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
void function_10f0(void);
int32_t function_1100(char * format, ...);
int32_t function_1110(char * s1, char * s2);
int32_t function_1120(char * format, ...);
char * function_1130(char * haystack, char * needle);
int64_t getMoviesByGenre(int64_t a1, int64_t a2, int64_t a3);
int64_t getTopRatedMovies(int64_t base, int64_t a2);
int64_t printMovie(int64_t a1);
int64_t rateMovie(int64_t result);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0x863000005d2; // 0x21ac
int64_t g2 = 0; // 0x4010
int64_t g3 = 0x700000000; // 0x7b4
int64_t g4 = 0x7000000000000; // 0x7ca
int64_t g5 = 0xa0000000700; // 0x7cf
int64_t g6 = 0; // 0x7d8
int32_t g7;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g7;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t c) {
    // 0x10c0
    return putchar(c);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
    // 0x10e0
    qsort(base, nmemb, size, compar);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(void) {
    // 0x10f0
    __stack_chk_fail();
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return printf(format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s1, char * s2) {
    // 0x1110
    return strcmp(s1, s2);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * format, ...) {
    // 0x1120
    return scanf(format);
}

// Address range: 0x1130 - 0x113b
char * function_1130(char * haystack, char * needle) {
    // 0x1130
    return strstr(haystack, needle);
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g2;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (*(char *)&g2 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    *(char *)&g2 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x1c1d
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x123b
    int64_t v2; // bp-280, 0x1229
    int64_t v3 = (int64_t)&v2 - 669 & -8; // 0x1359
    *(int64_t *)v3 = 0x66646f4720656854;
    *(int64_t *)(v3 + 8) = 0x7265687461;
    *(int64_t *)(v3 + 16) = 0;
    *(int64_t *)(v3 + 24) = 0;
    *(int64_t *)(v3 + 32) = 0;
    *(int64_t *)(v3 + 40) = 0;
    *(int16_t *)(v3 + 48) = 0;
    *(int32_t *)(v3 + 52) = (int32_t)&g3;
    *(int64_t *)(v3 + 56) = 0x207369636e617246;
    *(int64_t *)(v3 + 64) = 0x706f432064726f46;
    *(int64_t *)(v3 + 72) = 0x616c6f70;
    *(int64_t *)(v3 + 80) = 0;
    *(int64_t *)(v3 + 88) = 0;
    *(int64_t *)(v3 + 96) = 0;
    *(int16_t *)(v3 + 104) = 0;
    *(int64_t *)(v3 + 106) = 0x44202c656d697243;
    *(int64_t *)(v3 + 114) = 0x616d6172;
    *(int32_t *)(v3 + 122) = 0;
    *(int32_t *)(v3 + 128) = (int32_t)__asm_movss_1(__asm_movss(0x41133333));
    *(int64_t *)(v3 + 132) = 0x6b72614420656854;
    *(int64_t *)(v3 + 140) = 0x746867696e4b20;
    *(int64_t *)(v3 + 148) = 0;
    *(int64_t *)(v3 + 156) = 0;
    *(int64_t *)(v3 + 164) = 0;
    *(int64_t *)(v3 + 172) = 0;
    *(int16_t *)(v3 + 180) = 0;
    *(int32_t *)(v3 + 184) = (int32_t)&g6;
    *(int64_t *)(v3 + 188) = 0x706f747369726843;
    *(int64_t *)(v3 + 196) = 0x616c6f4e20726568;
    *(int64_t *)(v3 + 204) = 110;
    *(int64_t *)(v3 + 212) = 0;
    *(int64_t *)(v3 + 220) = 0;
    *(int64_t *)(v3 + 228) = 0;
    *(int16_t *)(v3 + 236) = 0;
    *(int64_t *)(v3 + 238) = 0x202c6e6f69746341;
    *(int64_t *)(v3 + 246) = 0x44202c656d697243;
    *(int32_t *)(v3 + 254) = 0x616d6172;
    *(int32_t *)(v3 + 260) = (int32_t)__asm_movss_1(__asm_movss(0x41100000));
    *(int64_t *)(v3 + 264) = 0x7761685320656854;
    *(int64_t *)(v3 + 272) = 0x6552206b6e616873;
    *(int64_t *)(v3 + 280) = 0x6e6f6974706d6564;
    *(int64_t *)(v3 + 288) = 0;
    *(int64_t *)(v3 + 296) = 0;
    *(int64_t *)(v3 + 304) = 0;
    *(int16_t *)(v3 + 312) = 0;
    *(int32_t *)(v3 + 316) = (int32_t)&g4;
    *(int64_t *)(v3 + 320) = 0x6144206b6e617246;
    *(int64_t *)(v3 + 328) = 0x746e6f626172;
    *(int64_t *)(v3 + 336) = 0;
    *(int64_t *)(v3 + 344) = 0;
    *(int64_t *)(v3 + 352) = 0;
    *(int64_t *)(v3 + 360) = 0;
    *(int16_t *)(v3 + 368) = 0;
    *(int64_t *)(v3 + 370) = 0x616d617244;
    *(int64_t *)(v3 + 378) = 0;
    *(int32_t *)(v3 + 386) = 0;
    *(int32_t *)(v3 + 392) = (int32_t)__asm_movss_1(__asm_movss(0x4114cccd));
    *(int64_t *)(v3 + 396) = 0x63694620706c7550;
    *(int64_t *)(v3 + 404) = 0x6e6f6974;
    *(int64_t *)(v3 + 412) = 0;
    *(int64_t *)(v3 + 420) = 0;
    *(int64_t *)(v3 + 428) = 0;
    *(int64_t *)(v3 + 436) = 0;
    *(int16_t *)(v3 + 444) = 0;
    *(int32_t *)(v3 + 448) = (int32_t)&g4;
    *(int64_t *)(v3 + 452) = 0x206e69746e657551;
    *(int64_t *)(v3 + 460) = 0x6e69746e61726154;
    *(int64_t *)(v3 + 468) = 111;
    *(int64_t *)(v3 + 476) = 0;
    *(int64_t *)(v3 + 484) = 0;
    *(int64_t *)(v3 + 492) = 0;
    *(int16_t *)(v3 + 500) = 0;
    *(int64_t *)(v3 + 502) = 0x44202c656d697243;
    *(int64_t *)(v3 + 510) = 0x616d6172;
    *(int32_t *)(v3 + 518) = 0;
    *(int32_t *)(v3 + 524) = (int32_t)__asm_movss_1(__asm_movss(0x410e6666));
    *(int64_t *)(v3 + 528) = 0x7274614d20656854;
    *(int64_t *)(v3 + 536) = 0x7869;
    *(int64_t *)(v3 + 544) = 0;
    *(int64_t *)(v3 + 552) = 0;
    *(int64_t *)(v3 + 560) = 0;
    *(int64_t *)(v3 + 568) = 0;
    *(int16_t *)(v3 + 576) = 0;
    *(int32_t *)(v3 + 580) = (int32_t)&g5;
    *(int64_t *)(v3 + 584) = 0x6863615720656854;
    *(int64_t *)(v3 + 592) = 0x724220696b73776f;
    *(int64_t *)(v3 + 600) = 0x73726568746f;
    *(int64_t *)(v3 + 608) = 0;
    *(int64_t *)(v3 + 616) = 0;
    *(int64_t *)(v3 + 624) = 0;
    *(int16_t *)(v3 + 632) = 0;
    *(int64_t *)(v3 + 634) = 0x202c6e6f69746341;
    *(int64_t *)(v3 + 642) = 0x69462d696353;
    *(int32_t *)(v3 + 650) = 0;
    int64_t v4 = __asm_movss_1(__asm_movss(*(int32_t *)0x2250)); // 0x1882
    *(int32_t *)(v3 + 656) = (int32_t)v4;
    puts(""Welcome to the C Movie Rating System!\n"");
    puts(""1. View all movies"");
    puts(""2. Rate a movie"");
    puts(""3. Get top rated movies"");
    puts(""4. Get movies by genre"");
    puts(""5. Exit\n"");
    printf(""Select an option: "");
    int64_t v5; // bp-268, 0x1229
    scanf(""%d"", &v5);
    while ((int32_t)v5 >= 6) {
        // 0x1bda
        puts(""\nInvalid option. Please try again.\n"");
        if ((int32_t)v5 == 5) {
            // 0x1bf8
            if (v1 == __readfsqword(40)) {
                // 0x1c14
                return 0;
            }
            // 0x1c0f
            __stack_chk_fail();
            // 0x1c14
            return &g7;
        }
        puts(""Welcome to the C Movie Rating System!\n"");
        puts(""1. View all movies"");
        puts(""2. Rate a movie"");
        puts(""3. Get top rated movies"");
        puts(""4. Get movies by genre"");
        puts(""5. Exit\n"");
        printf(""Select an option: "");
        scanf(""%d"", &v5);
    }
    int32_t v6 = *(int32_t *)((4 * v5 & 0x3fffffffc) + (int64_t)&g1); // 0x1936
    return (int64_t)v6 + (int64_t)&g1;
}

// Address range: 0x1c1d - 0x1c6d
int64_t printMovie(int64_t a1) {
    // 0x1c1d
    int128_t v1; // 0x1c1d
    int128_t v2 = v1;
    int32_t v3; // 0x1c1d
    int128_t v4 = __asm_movss(v3); // 0x1c25
    __asm_pxor(v2, v2);
    int128_t v5 = __asm_movq_2(__asm_movq(__asm_cvtss2sd(v4))); // 0x1c45
    int64_t v6; // bp+114, 0x1c1d
    int64_t v7; // bp+64, 0x1c1d
    int64_t v8; // 0x1c1d
    int32_t chars_printed = printf(""\nTitle: %s\nReleased year: %d\nDirector: %s\nGenre: %s\nRating: %.1f\n"", &v8, a1 & 0xffffffff, &v7, &v6, (float64_t)(int64_t)v5); // 0x1c65
    return chars_printed;
}

// Address range: 0x1c6d - 0x1c92
int64_t rateMovie(int64_t result) {
    // 0x1c6d
    int128_t v1; // 0x1c6d
    int64_t v2 = __asm_movss_1(v1); // 0x1c79
    *(int32_t *)(result + 128) = (int32_t)__asm_movss_1(__asm_movss((int32_t)v2));
    return result;
}

// Address range: 0x1c92 - 0x1d34
int64_t getTopRatedMovies(int64_t base, int64_t a2) {
    uint32_t nmemb = (int32_t)a2; // 0x1ca2
    puts(""\nTop rated movies:"");
    qsort((int64_t *)base, nmemb, 132, (int32_t (*)(int64_t *, int64_t *))0x1dfb);
    if (nmemb <= 0) {
        // 0x1d27
        return putchar(10);
    }
    int64_t v1 = 0;
    int64_t v2 = v1 + 1;
    printf(""%d. %s\n"", v2, (char *)(132 * v1 + base));
    while (v2 != (a2 & 0xffffffff)) {
        // 0x1cde
        v1 = v2;
        v2 = v1 + 1;
        printf(""%d. %s\n"", v2, (char *)(132 * v1 + base));
    }
    // 0x1d27
    return putchar(10);
}

// Address range: 0x1d34 - 0x1dfb
int64_t getMoviesByGenre(int64_t a1, int64_t a2, int64_t a3) {
    char * str = (char *)a3; // 0x1d61
    printf(""\nMovies in the %s genre:\n"", str);
    if ((int32_t)a2 <= 0) {
        // 0x1dee
        return putchar(10);
    }
    int64_t v1 = 0;
    int64_t v2 = 132 * v1 + a1; // 0x1d8a
    v1++;
    if (strstr((char *)(v2 + 106), str) != NULL) {
        // 0x1da5
        printf(""%d. %s\n"", v1, (char *)v2);
    }
    while (v1 != (a2 & 0xffffffff)) {
        // 0x1d6f
        v2 = 132 * v1 + a1;
        v1++;
        if (strstr((char *)(v2 + 106), str) != NULL) {
            // 0x1da5
            printf(""%d. %s\n"", v1, (char *)v2);
        }
    }
    // 0x1dee
    return putchar(10);
}

// Address range: 0x1dfb - 0x1e6a
int64_t compareByRating(int64_t a1, int64_t a2) {
    int32_t * v1 = (int32_t *)(a1 + 128); // 0x1e1f
    int128_t v2 = __asm_movss(*v1); // 0x1e1f
    int32_t * v3 = (int32_t *)(a2 + 128); // 0x1e2b
    __asm_comiss(v2, __asm_movss(*v3));
    int64_t result = 0xffffffff; // 0x1e36
    bool v4; // 0x1dfb
    if (v4 || v4) {
        // 0x1e3f
        __asm_comiss(__asm_movss(*v3), __asm_movss(*v1));
        result = 0;
    }
    // 0x1e68
    return result;
}

// Address range: 0x1e6c - 0x1e79
int64_t _fini(void) {
    // 0x1e6c
    int64_t result; // 0x1e6c
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 22

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        // ---------------- Integer Types Definitions -----------------

        typedef int64_t int128_t;

        // ----------------- Float Types Definitions ------------------

        typedef double float64_t;

        // ------------------- Function Prototypes --------------------

        int64_t __do_global_dtors_aux(void);
        int64_t _fini(void);
        int64_t _init(void);
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
        int64_t compareByRating(int64_t a1, int64_t a2);
        int64_t deregister_tm_clones(void);
        int64_t frame_dummy(void);
        void function_10b0(int64_t * d);
        int32_t function_10c0(int32_t c);
        int32_t function_10d0(char * s);
        void function_10e0(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *));
        void function_10f0(void);
        int32_t function_1100(char * format, ...);
        int32_t function_1110(char * s1, char * s2);
        int32_t function_1120(char * format, ...);
        char * function_1130(char * haystack, char * needle);
        int64_t getMoviesByGenre(int64_t a1, int64_t a2, int64_t a3);
        int64_t getTopRatedMovies(int64_t base, int64_t a2);
        int64_t printMovie(int64_t a1);
        int64_t rateMovie(int64_t result);
        int64_t register_tm_clones(void);

        // --------------------- Global Variables ---------------------

        int64_t g1 = -0x863000005d2; // 0x21ac
        int64_t g2 = 0; // 0x4010
        int64_t g3 = 0x700000000; // 0x7b4
        int64_t g4 = 0x7000000000000; // 0x7ca
        int64_t g5 = 0xa0000000700; // 0x7cf
        int64_t g6 = 0; // 0x7d8
        int32_t g7;

        // ------- Dynamically Linked Functions Without Header --------

        void __cxa_finalize(int64_t * a1);
        void __gmon_start__(void);
        int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
        void __stack_chk_fail(void);

        // ------------------------ Functions -------------------------

        // Address range: 0x1000 - 0x101b
        int64_t _init(void) {
            int64_t result = 0; // 0x1012
            if (*(int64_t *)0x3fe8 != 0) {
                // 0x1014
                __gmon_start__();
                result = &g7;
            }
            // 0x1016
            return result;
        }

        // Address range: 0x10b0 - 0x10bb
        void function_10b0(int64_t * d) {
            // 0x10b0
            __cxa_finalize(d);
        }

        // Address range: 0x10c0 - 0x10cb
        int32_t function_10c0(int32_t c) {
            // 0x10c0
            return putchar(c);
        }

        // Address range: 0x10d0 - 0x10db
        int32_t function_10d0(char * s) {
            // 0x10d0
            return puts(s);
        }

        // Address range: 0x10e0 - 0x10eb
        void function_10e0(int64_t * base, int32_t nmemb, int32_t size, int32_t (*compar)(int64_t *, int64_t *)) {
            // 0x10e0
            qsort(base, nmemb, size, compar);
        }

        // Address range: 0x10f0 - 0x10fb
        void function_10f0(void) {
            // 0x10f0
            __stack_chk_fail();
        }

        // Address range: 0x1100 - 0x110b
        int32_t function_1100(char * format, ...) {
            // 0x1100
            return printf(format);
        }

        // Address range: 0x1110 - 0x111b
        int32_t function_1110(char * s1, char * s2) {
            // 0x1110
            return strcmp(s1, s2);
        }

        // Address range: 0x1120 - 0x112b
        int32_t function_1120(char * format, ...) {
            // 0x1120
            return scanf(format);
        }

        // Address range: 0x1130 - 0x113b
        char * function_1130(char * haystack, char * needle) {
            // 0x1130
            return strstr(haystack, needle);
        }

        // Address range: 0x1140 - 0x1166
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            // 0x1140
            int64_t v1; // 0x1140
            __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
            __asm_hlt();
            // UNREACHABLE
        }

        // Address range: 0x1170 - 0x1199
        int64_t deregister_tm_clones(void) {
            // 0x1170
            return &g2;
        }

        // Address range: 0x11a0 - 0x11d9
        int64_t register_tm_clones(void) {
            // 0x11a0
            return 0;
        }

        // Address range: 0x11e0 - 0x1219
        int64_t __do_global_dtors_aux(void) {
            // 0x11e0
            if (*(char *",0
"//FormAI DATASET v1.0 Category: Threading Library Implementation ; Style: realistic
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define NUM_THREADS 10

void *PrintHello(void *thread_id) {
    int tid = *(int*) thread_id;
    printf(""Thread %d: Hello, World!\n"", tid);
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    pthread_t threads[NUM_THREADS];
    int rc;
    int t;
    for(t=0; t<NUM_THREADS; t++) {
        printf(""Creating thread %d\n"", t);
        rc = pthread_create(&threads[t], NULL, PrintHello, (void *)&t);
        if (rc) {
            printf(""ERROR; return code from pthread_create() is %d\n"", rc);
            exit(-1);
        }
    }
    pthread_exit(NULL);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * format, ...);
void function_1090(int64_t * retval);
int32_t function_10a0(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg);
void function_10b0(int32_t status);
int64_t PrintHello(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * format, ...) {
    // 0x1080
    return printf(format);
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * retval) {
    // 0x1090
    pthread_exit(retval);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(int32_t * newthread, int64_t * attr, int64_t * (*start_routine)(int64_t *), int64_t * arg) {
    // 0x10a0
    return pthread_create(newthread, attr, start_routine, arg);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int32_t status) {
    // 0x10b0
    exit(status);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11e5, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x11e5
int64_t PrintHello(int64_t a1) {
    // 0x11a9
    int64_t v1; // 0x11a9
    printf(""Thread %d: Hello, World!\n"", v1 & 0xffffffff);
    pthread_exit(NULL);
    return &g2;
}

// Address range: 0x11e5 - 0x12a0
int main(int argc, char ** argv) {
    // 0x11e5
    __readfsqword(40);
    int32_t thread_func_arg = 0;
    int64_t v1; // bp-104, 0x11e5
    int64_t v2 = &v1;
    printf(""Creating thread %d\n"", (int64_t)0);
    uint32_t v3 = pthread_create((int32_t *)(8 * (int64_t)thread_func_arg + v2), NULL, (int64_t * (*)(int64_t *))0x11a9, (int64_t *)&thread_func_arg); // 0x1250
    while (v3 == 0) {
        int32_t v4 = thread_func_arg + 1; // 0x1284
        thread_func_arg = v4;
        if (v4 >= 10) {
            // 0x1296
            pthread_exit(NULL);
            return &g2;
        }
        printf(""Creating thread %d\n"", (int64_t)v4);
        v3 = pthread_create((int32_t *)(8 * (int64_t)thread_func_arg + v2), NULL, (int64_t * (*)(int64_t *))0x11a9, (int64_t *)&thread_func_arg);
    }
    // 0x125e
    printf(""ERROR; return code from pthread_create() is %d\n"", (int64_t)v3);
    exit(-1);
    // UNREACHABLE
}

// Address range: 0x12a0 - 0x12ad
int64_t _fini(void) {
    // 0x12a0
    int64_t result; // 0x12a0
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 14

","      #include <stdio.h>
        #include <stdlib.h>
        #include <pthread.h>

        void *thread_func(void *arg)
        {
            int thread_id = (int)arg;
            printf(""Thread %d: Hello, World!\n"", thread_id);
            pthread_exit(NULL);
            return NULL;
        }

        int main(int argc, char **argv)
        {
            int thread_func_arg = 0;
            int i;
            pthread_t thread[10];

            for (i = 0; i < 10; i++)
            {
                printf(""Creating thread %d\n"", i);
                pthread_create(&thread[i], NULL, thread_func, (void *)thread_func_arg);
                thread_func_arg++;
            }

            for (i = 0; i < 10; i++)
            {
                pthread_join(thread[i], NULL);
            }

            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Data structures visualization ; Style: ultraprecise
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
    int value;
    struct node* next;
} Node;

typedef struct linked_list {
    Node* head;
    int length;
} LinkedList;

void init(LinkedList* list) {
    list->head = NULL;
    list->length = 0;
}

void insert(LinkedList* list, int value) {
    Node* new_node = (Node*) malloc(sizeof(Node));
    new_node->value = value;
    new_node->next = list->head;
    list->head = new_node;
    list->length++;
}

int delete(LinkedList* list, int value) {
    if (list->length == 0) {
        return 0;
    }

    Node* current_node = list->head;
    Node* prev_node = NULL;

    while (current_node != NULL) {
        if (current_node->value == value) {
            if (prev_node == NULL) {
                list->head = current_node->next;
            } else {
                prev_node->next = current_node->next;
            }
            free(current_node);
            list->length--;
            return 1;
        }

        prev_node = current_node;
        current_node = current_node->next;
    }

    return 0;
}

void print_list(LinkedList* list) {
    Node* current_node = list->head;
    printf(""[ "");

    while (current_node != NULL) {
        printf(""%d "", current_node->value);
        current_node = current_node->next;
    }

    printf(""]\n"");
}

int main() {
    LinkedList list;
    init(&list);

    insert(&list, 3);
    insert(&list, 12);
    insert(&list, 7);
    insert(&list, 1);

    printf(""Initial list: "");
    print_list(&list);

    delete(&list, 7);

    printf(""After deleting 7: "");
    print_list(&list);

    delete(&list, 15);

    printf(""After deleting 15 (which doesn't exist): "");
    print_list(&list);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t delete(int64_t * a1, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1080(int64_t * d);
void function_1090(int64_t * ptr);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
int64_t * function_10d0(int32_t size);
int64_t init(int64_t * a1);
int64_t insert(int64_t * a1, int64_t a2);
int64_t print_list(int64_t * a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * d) {
    // 0x1080
    __cxa_finalize(d);
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * ptr) {
    // 0x1090
    free(ptr);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
int64_t * function_10d0(int32_t size) {
    // 0x10d0
    return malloc(size);
}

// Address range: 0x10e0 - 0x1106
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10e0
    int64_t v1; // 0x10e0
    __libc_start_main(0x136e, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1110 - 0x1139
int64_t deregister_tm_clones(void) {
    // 0x1110
    return &g1;
}

// Address range: 0x1140 - 0x1179
int64_t register_tm_clones(void) {
    // 0x1140
    return 0;
}

// Address range: 0x1180 - 0x11b9
int64_t __do_global_dtors_aux(void) {
    // 0x1180
    if (*(char *)&g1 != 0) {
        // 0x11b8
        int64_t result; // 0x1180
        return result;
    }
    // 0x118d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x119b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11a7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11c0 - 0x11c9
int64_t frame_dummy(void) {
    // 0x11c0
    return register_tm_clones();
}

// Address range: 0x11c9 - 0x11ee
int64_t init(int64_t * a1) {
    int64_t result = (int64_t)a1;
    *a1 = 0;
    *(int32_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x11ee - 0x1246
int64_t insert(int64_t * a1, int64_t a2) {
    int64_t result = (int64_t)a1;
    int64_t * mem = malloc(16); // 0x1206
    int64_t v1 = (int64_t)mem; // 0x1206
    *(int32_t *)mem = (int32_t)a2;
    *(int64_t *)(v1 + 8) = 16;
    *a1 = v1;
    int32_t * v2 = (int32_t *)(result + 8); // 0x1236
    *v2 = *v2 + 1;
    return result;
}

// Address range: 0x1246 - 0x12fc
int64_t delete(int64_t * a1, int64_t a2) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = v1 + 8;
    int32_t * v3 = (int32_t *)v2; // 0x125d
    if (a1 == NULL | *v3 == 0) {
        // 0x12fa
        return 0;
    }
    int32_t v4 = a2; // 0x1289
    int64_t v5; // 0x1246
    int64_t v6; // 0x1246
    int64_t v7; // 0x12e6
    if (*(int32_t *)a1 == v4) {
        // 0x128e
        v6 = *(int64_t *)v2;
        v7 = v1;
        goto lab_0x1295;
      lab_0x1295:
        // 0x1295
        *a1 = v6;
        v5 = v7;
        goto lab_0x12b6;
      lab_0x12b6:
        // 0x12b6
        free((int64_t *)v5);
        *v3 = *v3 - 1;
        // 0x12fa
        return 1;
    }
    int64_t v8 = v1;
    v7 = *(int64_t *)(v8 + 8);
    while (v7 != 0) {
        // 0x1283
        if (*(int32_t *)v7 == v4) {
            // 0x128e
            v6 = *(int64_t *)(v7 + 8);
            if (v8 != 0) {
                // 0x12a6
                *(int64_t *)(v8 + 8) = v6;
                v5 = v7;
                goto lab_0x12b6;
            } else {
                goto lab_0x1295;
            }
        }
        v8 = v7;
        v7 = *(int64_t *)(v8 + 8);
    }
    // 0x12fa
    return 0;
}

// Address range: 0x12fc - 0x136e
int64_t print_list(int64_t * a1) {
    // 0x12fc
    printf(""[ "");
    if (a1 == NULL) {
        // 0x135c
        return puts(""]"");
    }
    int64_t v1 = (int64_t)a1; // 0x134d
    printf(""%d "", (int64_t)*(int32_t *)v1);
    v1 += 8;
    while (v1 != 0) {
        // 0x132d
        printf(""%d "", (int64_t)*(int32_t *)v1);
        v1 += 8;
    }
    // 0x135c
    return puts(""]"");
}

// Address range: 0x136e - 0x1476
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x137a
    int64_t v2; // bp-40, 0x136e
    init(&v2);
    insert(&v2, 3);
    insert(&v2, 12);
    insert(&v2, 7);
    insert(&v2, 1);
    printf(""Initial list: "");
    print_list(&v2);
    delete(&v2, 7);
    printf(""After deleting 7: "");
    print_list(&v2);
    delete(&v2, 15);
    printf(""After deleting 15 (which doesn't exist): "");
    print_list(&v2);
    int64_t result = 0; // 0x146d
    if (v1 != __readfsqword(40)) {
        // 0x146f
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1474
    return result;
}

// Address range: 0x1478 - 0x1485
int64_t _fini(void) {
    // 0x1478
    int64_t result; // 0x1478
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int * list = NULL;
            int size = 0;

            list = (int *) malloc(sizeof(int));
            *list = 3;
            size++;

            list = (int *) malloc(sizeof(int));
            *list = 12;
            size++;

            list = (int *) malloc(sizeof(int));
            *list = 7;
            size++;

            list = (int *) malloc(sizeof(int));
            *list = 1;
            size++;

            printf(""Initial list: "");
            print_list(list);

            delete(list, 7);
            printf(""After deleting 7: "");
            print_list(list);

            delete(list, 15);
            printf(""After deleting 15 (which doesn't exist): "");
            print_list(list);

            return 0;
        }

        void print_list(int * list) {
            if (list == NULL) {
                printf(""]"");
                return;
            }
            printf(""%d "", *list);
            list++;
            while (list != NULL) {
                printf(""%d "", *list);
                list++;
            }
            printf(""]"");
        }

        void delete(int * list, int value) {
            if (list == NULL) {
                return;
            }
            if (*list == value) {
                int * next = list + 1;
                free(list);
                list = next;
                return;
            }
            delete(list + 1, value);
        }


",1
"//FormAI DATASET v1.0 Category: Online Examination System ; Style: thoughtful
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>

int main() {
    char name[20],ans;
    int choice,mark=0,i;
    time_t t;

    printf(""Enter your name: "");
    scanf(""%s"",name);

    printf(""\nWelcome to the Online Examination System, %s!\n"", name);
 
    printf(""\nRules: \n1. There are 10 multiple choice questions.\n2. Each question carries 10 marks.\n3. Answer the questions by typing the corresponding option (a, b, c, or d).\n""); 

    printf(""\nAre you ready to start the exam? (Y/N): "");
    scanf("" %c"", &ans);

    if(ans=='Y' || ans=='y') {
        printf(""\nLet's start the exam!\n"");

        srand((unsigned) time(&t));

        for(i=1;i<=10;i++) {
            choice=rand()%4+1;

            printf(""\nQuestion %d:\n"", i);
        
            switch(choice) {
                case 1:
                    printf(""What is the capital of India?\n"");
                    printf(""a) Delhi\nb) Mumbai\nc) Chennai\nd) Kolkata\n"");
                    if(getchar()=='a')
                        mark+=10;
                    break;
                case 2:
                    printf(""What is the largest planet in our solar system?\n"");
                    printf(""a) Mercury\nb) Venus\nc) Jupiter\nd) Saturn\n"");
                    if(getchar()=='c')
                        mark+=10;
                    break;
                case 3:
                    printf(""Who invented the telephone?\n"");
                    printf(""a) Thomas Edison\nb) Alexander Graham Bell\nc) Isaac Newton\nd) Albert Einstein\n"");
                    if(getchar()=='b')
                        mark+=10;
                    break;
                case 4:
                    printf(""Which country won the FIFA World Cup 2018?\n"");
                    printf(""a) Brazil\nb) Germany\nc) France\nd) Argentina\n"");
                    if(getchar()=='c')
                        mark+=10;
                    break;
            }
        }
        printf(""\nCongratulations, %s! You have completed the exam!\n"", name);
        printf(""\nYour final score is %d/100.\n"", mark);
    } 
    else {
        printf(""\nGoodbye!\n"");
        exit(0);
    }
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10c0(int64_t * d);
int32_t function_10d0(char * s);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
void function_1100(int32_t seed);
int32_t function_1110(void);
int32_t function_1120(int32_t * timer);
int32_t function_1130(char * format, ...);
void function_1140(int32_t status);
int32_t function_1150(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10c0 - 0x10cb
void function_10c0(int64_t * d) {
    // 0x10c0
    __cxa_finalize(d);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
void function_1100(int32_t seed) {
    // 0x1100
    srand(seed);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(void) {
    // 0x1110
    return getchar();
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(int32_t * timer) {
    // 0x1120
    return time(timer);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(char * format, ...) {
    // 0x1130
    return scanf(format);
}

// Address range: 0x1140 - 0x114b
void function_1140(int32_t status) {
    // 0x1140
    exit(status);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(void) {
    // 0x1150
    return rand();
}

// Address range: 0x1160 - 0x1186
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1160
    int64_t v1; // 0x1160
    __libc_start_main(0x1249, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1190 - 0x11b9
int64_t deregister_tm_clones(void) {
    // 0x1190
    return &g1;
}

// Address range: 0x11c0 - 0x11f9
int64_t register_tm_clones(void) {
    // 0x11c0
    return 0;
}

// Address range: 0x1200 - 0x1239
int64_t __do_global_dtors_aux(void) {
    // 0x1200
    if (*(char *)&g1 != 0) {
        // 0x1238
        int64_t result; // 0x1200
        return result;
    }
    // 0x120d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x121b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1227
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1240 - 0x1249
int64_t frame_dummy(void) {
    // 0x1240
    return register_tm_clones();
}

// Address range: 0x1249 - 0x14da
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1255
    printf(""Enter your name: "");
    int64_t v2; // bp-40, 0x1249
    scanf(""%s"", &v2);
    printf(""\nWelcome to the Online Examination System, %s!\n"", &v2);
    puts(""\nRules: \n1. There are 10 multiple choice questions.\n2. Each question carries 10 marks.\n3. Answer the questions by typing the corresponding option (a, b, c, or d)."");
    printf(""\nAre you ready to start the exam? (Y/N): "");
    char v3; // bp-61, 0x1249
    scanf("" %c"", &v3);
    char v4 = v3; // 0x12f3
    if (v4 != 89 == (v4 != 121)) {
        // 0x14ba
        puts(""\nGoodbye!"");
        exit(0);
        // UNREACHABLE
    }
    // 0x1307
    puts(""\nLet's start the exam!"");
    int64_t t; // bp-48, 0x1249
    srand(time((int32_t *)&t));
    int32_t v5 = 0;
    for (int64_t i = 1; i < 11; i++) {
        int32_t v6 = v5;
        int32_t v7 = rand() % 4; // 0x1343
        printf(""\nQuestion %d:\n"", i);
        int32_t v8; // 0x1249
        if (v7 == 3) {
            // 0x142a
            puts(""Which country won the FIFA World Cup 2018?"");
            puts(""a) Brazil\nb) Germany\nc) France\nd) Argentina"");
            v8 = getchar() != 99 ? v6 : v6 + 10;
        } else {
            int32_t v9 = v7 + 1; // 0x1345
            if (v9 == 3) {
                // 0x13fc
                puts(""Who invented the telephone?"");
                puts(""a) Thomas Edison\nb) Alexander Graham Bell\nc) Isaac Newton\nd) Albert Einstein"");
                v8 = getchar() != 98 ? v6 : v6 + 10;
            } else {
                if (v7 == 0) {
                    // 0x1399
                    puts(""What is the capital of India?"");
                    puts(""a) Delhi\nb) Mumbai\nc) Chennai\nd) Kolkata"");
                    v8 = getchar() != 97 ? v6 : v6 + 10;
                } else {
                    // 0x138e
                    v8 = v6;
                    if (v9 == 2) {
                        // 0x13ce
                        puts(""What is the largest planet in our solar system?"");
                        puts(""a) Mercury\nb) Venus\nc) Jupiter\nd) Saturn"");
                        v8 = getchar() != 99 ? v6 : v6 + 10;
                    }
                }
            }
        }
        // 0x1462
        v5 = v8;
    }
    // 0x1470
    printf(""\nCongratulations, %s! You have completed the exam!\n"", &v2);
    printf(""\nYour final score is %d/100.\n"", (int64_t)v5);
    int64_t result = 0; // 0x14b6
    if (v1 != __readfsqword(40)) {
        // 0x14d3
        __stack_chk_fail();
        result = &g2;
    }
    // 0x14d8
    return result;
}

// Address range: 0x14dc - 0x14e9
int64_t _fini(void) {
    // 0x14dc
    int64_t result; // 0x14dc
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            int score = 0;
            srand(time(NULL));
            printf(""Enter your name: "");
            char name[100];
            scanf(""%s"", &name);
            printf(""\nWelcome to the Online Examination System, %s!\n"", &name);
            puts(""\nRules: \n1. There are 10 multiple choice questions.\n2. Each question carries 10 marks.\n3. Answer the questions by typing the corresponding option (a, b, c, or d)."");
            printf(""\nAre you ready to start the exam? (Y/N): "");
            char answer;
            scanf("" %c"", &answer);
            if (answer != 'Y' && answer != 'y') {
                puts(""\nGoodbye!"");
                exit(0);
            }
            puts(""\nLet's start the exam!"");
            for (int i = 1; i < 11; i++) {
                int correct_answer = rand() % 4;
                printf(""\nQuestion %d:\n"", i);
                if (correct_answer == 3) {
                    puts(""Which country won the FIFA World Cup 2018?"");
                    puts(""a) Brazil\nb) Germany\nc) France\nd) Argentina"");
                    char answer;
                    scanf("" %c"", &answer);
                    if (answer == 'a') {
                        score += 10;
                    }
                } else if (correct_answer == 2) {
                    puts(""Who invented the telephone?"");
                    puts(""a) Thomas Edison\nb) Alexander Graham Bell\nc) Isaac Newton\nd) Albert Einstein"");
                    char answer;
                    scanf("" %c"", &answer);
                    if (answer == 'b') {
                        score += 10;
                    }
                } else if (correct_answer == 1) {
                    puts(""What is the capital of India?"");
                    puts(""a) Delhi\nb) Mumbai\nc) Chennai\nd) Kolkata"");
                    char answer;
                    scanf("" %c"", &answer);
                    if (answer == 'c') {
                        score += 10;
                    }
                } else {
                    puts(""What is the largest planet in our solar system?"");
                    puts(""a) Mercury\nb) Venus\nc) Jupiter\nd) Saturn"");
                    char answer;
                    scanf("" %c"", &answer);
                    if (answer == 'd') {
                        score += 10;
                    }
                }
            }
            printf(""\nCongratulations, %s! You have completed the exam!\n"", &name);
            printf(""\nYour final score is %d/100.\n"", score);
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Color Code Converter ; Style: Ken Thompson
#include <stdio.h>
#include <string.h>

int main()
{
    // Welcome message
    printf(""Welcome to the C Color Code Converter!\n\n"");

    // Initialize variables
    char color[7]; // Stores the hex color code entered by user
    char r[3], g[3], b[3]; // Stores the rgb values after conversion
    int r_int, g_int, b_int; // Stores the integer value of rgb

    // Loop until user enters valid hex color code
    do {
        // Prompt user to enter hex color code
        printf(""Please enter a hex color code (eg: #FFA500): "");
        scanf(""%s"", color);

        // Check if hex color code is valid
        if (color[0] != '#' || strlen(color) != 7) {
            printf(""Invalid hex color code. Please try again.\n"");
        }
    } while (color[0] != '#' || strlen(color) != 7);

    // Convert hex color code to rgb values
    sscanf(color, ""#%2hhx%2hhx%2hhx"", &r_int, &g_int, &b_int);

    // Convert integer values to string
    sprintf(r, ""%d"", r_int);
    sprintf(g, ""%d"", g_int);
    sprintf(b, ""%d"", b_int);

    // Print the converted rgb values
    printf(""\nRGB values: %s, %s, %s\n"", r, g, b);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
int32_t function_10b0(char * s);
int32_t function_10c0(char * s);
void function_10d0(void);
int32_t function_10e0(char * format, ...);
int32_t function_10f0(char * s, char * format, ...);
int32_t function_1100(char * format, ...);
int32_t function_1110(char * s, char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return strlen(s);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(void) {
    // 0x10d0
    __stack_chk_fail();
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return printf(format);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * s, char * format, ...) {
    // 0x10f0
    return sscanf(s, format);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(char * format, ...) {
    // 0x1100
    return scanf(format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s, char * format, ...) {
    // 0x1110
    return sprintf(s, format);
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1209, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g1;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g1 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x1364
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1215
    puts(""Welcome to the C Color Code Converter!\n"");
    char str; // bp-23, 0x1209
    while (true) {
      lab_0x1233:
        // 0x1233
        printf(""Please enter a hex color code (eg: #FFA500): "");
        scanf(""%s"", &str);
        if (str != 35) {
            // 0x127c
            puts(""Invalid hex color code. Please try again."");
            goto lab_0x128b;
        } else {
            // 0x126a
            if (strlen(&str) == 7) {
                goto lab_0x128b;
            } else {
                // 0x127c
                puts(""Invalid hex color code. Please try again."");
                goto lab_0x128b;
            }
        }
    }
  lab_0x12a5:;
    // 0x12a5
    int32_t v2; // bp-36, 0x1209
    int32_t v3; // bp-40, 0x1209
    int32_t v4; // bp-44, 0x1209
    sscanf(&str, ""#%2hhx%2hhx%2hhx"", &v4, &v3, &v2);
    int64_t str2; // bp-32, 0x1209
    sprintf((char *)&str2, ""%d"", (int64_t)v4);
    int64_t str3; // bp-29, 0x1209
    sprintf((char *)&str3, ""%d"", (int64_t)v3);
    int64_t str4; // bp-26, 0x1209
    sprintf((char *)&str4, ""%d"", (int64_t)v2);
    printf(""\nRGB values: %s, %s, %s\n"", &str2, &str3, &str4);
    int64_t result = 0; // 0x135b
    if (v1 != __readfsqword(40)) {
        // 0x135d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1362
    return result;
  lab_0x128b:
    // 0x128b
    if (str == 35) {
        // 0x1293
        if (strlen(&str) == 7) {
            // break -> 0x12a5
            goto lab_0x12a5;
        }
    }
    goto lab_0x1233;
}

// Address range: 0x1364 - 0x1371
int64_t _fini(void) {
    // 0x1364
    int64_t result; // 0x1364
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 16

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to the C Color Code Converter!\n"");
            char str;
            while (true) {
                printf(""Please enter a hex color code (eg: #FFA500): "");
                scanf(""%s"", &str);
                if (str != '#') {
                    puts(""Invalid hex color code. Please try again."");
                    continue;
                } else {
                    if (strlen(&str) == 7) {
                        break;
                    } else {
                        puts(""Invalid hex color code. Please try again."");
                        continue;
                    }
                }
            }
            int v2;
            int v3;
            int v4;
            sscanf(&str, ""#%2hhx%2hhx%2hhx"", &v4, &v3, &v2);
            int str2;
            sprintf((char *)&str2, ""%d"", (int64_t)v4);
            int str3;
            sprintf((char *)&str3, ""%d"", (int64_t)v3);
            int str4;
            sprintf((char *)&str4, ""%d"", (int64_t)v2);
            printf(""\nRGB values: %s, %s, %s\n"", &str2, &str3, &str4);
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Memory Game ; Style: relaxed
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROWS 4
#define COLS 4

void initialize_board(int board[ROWS][COLS]);
void print_board(int board[ROWS][COLS], int revealed[ROWS][COLS]);
void shuffle(int arr[], int size);
int check_win(int revealed[ROWS][COLS]);

int main() {
    int board[ROWS][COLS];
    int revealed[ROWS][COLS] = {0};
    int num_moves = 0;
    int first_choice_row, first_choice_col, second_choice_row, second_choice_col;
    initialize_board(board);
    srand(time(NULL));
    shuffle((int *)board, ROWS*COLS);
    printf(""Welcome to the Memory Game!\n"");
    while (1) {
        print_board(board, revealed);
        printf(""Please enter the row and column of your first choice: "");
        scanf(""%d %d"", &first_choice_row, &first_choice_col);
        if (revealed[first_choice_row][first_choice_col]) {
            printf(""This tile has already been revealed, please choose another one.\n"");
            continue;
        }
        revealed[first_choice_row][first_choice_col] = 1;
        print_board(board, revealed);
        printf(""Please enter the row and column of your second choice: "");
        scanf(""%d %d"", &second_choice_row, &second_choice_col);
        if (revealed[second_choice_row][second_choice_col]) {
            printf(""This tile has already been revealed, please choose another one.\n"");
            revealed[first_choice_row][first_choice_col] = 0;
            continue;
        }
        num_moves++;
        revealed[second_choice_row][second_choice_col] = 1;
        print_board(board, revealed);
        if (board[first_choice_row][first_choice_col] != board[second_choice_row][second_choice_col]) {
            printf(""Sorry, these tiles do not match.\n"");
            revealed[first_choice_row][first_choice_col] = revealed[second_choice_row][second_choice_col] = 0;
        } else {
            printf(""Congratulations, you have found a match!\n"");
        }
        if (check_win(revealed)) {
            printf(""You win! It took you %d moves.\n"", num_moves);
            exit(0);
        }
    }
    return 0;
}

void initialize_board(int board[ROWS][COLS]) {
    int i, j;
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            board[i][j] = (i*COLS+j)/2;
        }
    }
}

void print_board(int board[ROWS][COLS], int revealed[ROWS][COLS]) {
    int i, j;
    printf(""\n"");
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            if (revealed[i][j]) {
                printf(""%2d "", board[i][j]);
            } else {
                printf(""## "");
            }
        }
        printf(""\n"");
    }
    printf(""\n"");
}

void shuffle(int arr[], int size) {
    int i, j, temp;
    for (i = size-1; i > 0; i--) {
        j = rand() % (i+1);
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

int check_win(int revealed[ROWS][COLS]) {
    int i, j;
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            if (!revealed[i][j]) {
                return 0;
            }
        }
    }
    return 1;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t check_win(int64_t * a1);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(int32_t c);
int32_t function_10d0(char * s);
int32_t function_10e0(char * format, ...);
void function_10f0(int32_t seed);
int32_t function_1100(int32_t * timer);
int32_t function_1110(char * format, ...);
void function_1120(int32_t status);
int32_t function_1130(void);
int64_t initialize_board(int64_t * a1);
int64_t print_board(int64_t * a1, int64_t * a2);
int64_t register_tm_clones(void);
int64_t shuffle(int64_t * a1, int64_t a2);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t c) {
    // 0x10c0
    return putchar(c);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(char * format, ...) {
    // 0x10e0
    return printf(format);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(int32_t seed) {
    // 0x10f0
    srand(seed);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(int32_t * timer) {
    // 0x1100
    return time(timer);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * format, ...) {
    // 0x1110
    return scanf(format);
}

// Address range: 0x1120 - 0x112b
void function_1120(int32_t status) {
    // 0x1120
    exit(status);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(void) {
    // 0x1130
    return rand();
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g1;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (*(char *)&g1 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x1546
int main(int argc, char ** argv) {
    // 0x1229
    int64_t v1; // bp-8, 0x1229
    int64_t v2 = &v1; // 0x122e
    __readfsqword(40);
    int64_t v3 = 0; // bp-88, 0x1247
    int64_t v4; // bp-152, 0x1229
    initialize_board(&v4);
    srand(time(NULL));
    shuffle(&v4, 16);
    puts(""Welcome to the Memory Game!"");
    int64_t v5 = v2 - 80;
    int64_t v6 = v2 - 144;
    int32_t v7 = 0; // 0x12cf
    int64_t v8; // bp-160, 0x1229
    int64_t v9; // bp-164, 0x1229
    int64_t v10; // bp-168, 0x1229
    int64_t v11; // bp-172, 0x1229
    int32_t * v12; // 0x1229
    int32_t * v13; // 0x133b
    while (true) {
        // 0x12d4
        print_board(&v4, &v3);
        printf(""Please enter the row and column of your first choice: "");
        scanf(""%d %d"", &v11, &v10);
        v13 = (int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v5);
        if (*v13 == 0) {
            // 0x1357
            *v13 = 1;
            print_board(&v4, &v3);
            printf(""Please enter the row and column of your second choice: "");
            scanf(""%d %d"", &v9, &v8);
            v12 = (int32_t *)(4 * ((0x100000000 * v8 >> 32) + (0x100000000 * v9 >> 30)) + v5);
            if (*v12 == 0) {
                // break -> 0x141a
                break;
            }
            // 0x13e6
            puts(""This tile has already been revealed, please choose another one."");
            *(int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v5) = 0;
        } else {
            // 0x1343
            puts(""This tile has already been revealed, please choose another one."");
        }
    }
    // 0x141a
    *v12 = 1;
    print_board(&v4, &v3);
    int32_t v14 = *(int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v6); // 0x146f
    int32_t v15 = *(int32_t *)(4 * ((0x100000000 * v8 >> 32) + (0x100000000 * v9 >> 30)) + v6); // 0x148e
    if (v14 == v15) {
        // 0x14f8
        puts(""Congratulations, you have found a match!"");
    } else {
        // 0x1499
        puts(""Sorry, these tiles do not match."");
        *(int32_t *)(4 * ((0x100000000 * v8 >> 32) + (0x100000000 * v9 >> 30)) + v5) = 0;
        *(int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v5) = 0;
    }
    // 0x1507
    v7++;
    while ((int32_t)check_win(&v3) == 0) {
        // 0x12d4
        while (true) {
            // 0x12d4
            print_board(&v4, &v3);
            printf(""Please enter the row and column of your first choice: "");
            scanf(""%d %d"", &v11, &v10);
            v13 = (int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v5);
            if (*v13 == 0) {
                // 0x1357
                *v13 = 1;
                print_board(&v4, &v3);
                printf(""Please enter the row and column of your second choice: "");
                scanf(""%d %d"", &v9, &v8);
                v12 = (int32_t *)(4 * ((0x100000000 * v8 >> 32) + (0x100000000 * v9 >> 30)) + v5);
                if (*v12 == 0) {
                    // break -> 0x141a
                    break;
                }
                // 0x13e6
                puts(""This tile has already been revealed, please choose another one."");
                *(int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v5) = 0;
            } else {
                // 0x1343
                puts(""This tile has already been revealed, please choose another one."");
            }
        }
        // 0x141a
        *v12 = 1;
        print_board(&v4, &v3);
        v14 = *(int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v6);
        v15 = *(int32_t *)(4 * ((0x100000000 * v8 >> 32) + (0x100000000 * v9 >> 30)) + v6);
        if (v14 == v15) {
            // 0x14f8
            puts(""Congratulations, you have found a match!"");
        } else {
            // 0x1499
            puts(""Sorry, these tiles do not match."");
            *(int32_t *)(4 * ((0x100000000 * v8 >> 32) + (0x100000000 * v9 >> 30)) + v5) = 0;
            *(int32_t *)(4 * ((0x100000000 * v10 >> 32) + (0x100000000 * v11 >> 30)) + v5) = 0;
        }
        // 0x1507
        v7++;
    }
    // 0x151b
    printf(""You win! It took you %d moves.\n"", (int64_t)v7);
    exit(0);
    // UNREACHABLE
}

// Address range: 0x1546 - 0x15b2
int64_t initialize_board(int64_t * a1) {
    for (int64_t i = 0; i < 4; i++) {
        int64_t v1 = 16 * i + (int64_t)a1; // 0x1584
        for (int64_t j = 0; j < 4; j++) {
            int32_t v2 = j + 4 * i;
            *(int32_t *)(v1 + 4 * j) = (int32_t)(v2 < 0) + v2 >> 1;
        }
    }
    // 0x15ae
    return 3;
}

// Address range: 0x15b2 - 0x167a
int64_t print_board(int64_t * a1, int64_t * a2) {
    // 0x15b2
    putchar(10);
    for (int64_t i = 0; i < 4; i++) {
        for (int64_t j = 0; j < 4; j++) {
            int64_t v1 = 4 * j + 16 * i;
            if (*(int32_t *)(v1 + (int64_t)a2) == 0) {
                // 0x1637
                printf(""## "");
            } else {
                // 0x1604
                printf(""%2d "", (int64_t)*(int32_t *)(v1 + (int64_t)a1));
            }
        }
        // 0x1655
        putchar(10);
    }
    // 0x166d
    return putchar(10);
}

// Address range: 0x167a - 0x1716
int64_t shuffle(int64_t * a1, int64_t a2) {
    int64_t v1 = (int64_t)a1;
    int64_t v2 = a2 + 0xffffffff; // 0x1690
    int32_t v3 = v2; // 0x1693
    if (v3 >= 0 != v3 != 0) {
        // 0x1712
        return v2 & 0xffffffff;
    }
    int32_t v4 = v3; // 0x1710
    int32_t v5 = rand(); // 0x1698
    int32_t * v6 = (int32_t *)(4 * (int64_t)v4 + v1); // 0x16bd
    uint32_t result = *v6; // 0x16bd
    int32_t * v7 = (int32_t *)((0x100000000 * ((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % (int64_t)(v4 + 1)) >> 30) + v1); // 0x16eb
    *v6 = *v7;
    *v7 = result;
    v4--;
    while (v4 >= 0 == (v4 != 0)) {
        // 0x1698
        v5 = rand();
        v6 = (int32_t *)(4 * (int64_t)v4 + v1);
        result = *v6;
        v7 = (int32_t *)((0x100000000 * ((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % (int64_t)(v4 + 1)) >> 30) + v1);
        *v6 = *v7;
        *v7 = result;
        v4--;
    }
    // 0x1712
    return result;
}

// Address range: 0x1716 - 0x1775
int64_t check_win(int64_t * a1) {
    int32_t v1 = 0; // 0x1764
    int64_t v2 = 16 * (int64_t)v1 + (int64_t)a1; // 0x1744
    int64_t result; // 0x1716
    for (int32_t i = 0; i < 4; i++) {
        // 0x1734
        result = 0;
        if (*(int32_t *)(v2 + 4 * (int64_t)i) == 0) {
            return result;
        }
    }
    // 0x1764
    v1++;
    result = 1;
    while (v1 < 4) {
        // 0x175e
        v2 = 16 * (int64_t)v1 + (int64_t)a1;
        for (int32_t i = 0; i < 4; i++) {
            // 0x1734
            result = 0;
            if (*(int32_t *)(v2 + 4 * (int64_t)i) == 0) {
                return result;
            }
        }
        // 0x1764
        v1++;
        result = 1;
    }
  lab_0x1773:
    // 0x1773
    return result;
}

// Address range: 0x1778 - 0x1785
int64_t _fini(void) {
    // 0x1778
    int64_t result; // 0x1778
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 21

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            int board[16];
            int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;
            int moves = 0;
            int win = 0;
            int row, col;
            int tile;
            int tile1, tile2;

            srand(time(NULL));
            for (i = 0; i < 16; i++) {
                board[i] = i;
            }
            shuffle(board, 16);
            puts(""Welcome to the Memory Game!"");
            while (win == 0) {
                print_board(board);
                printf(""Please enter the row and column of your first choice: "");
                scanf(""%d %d"", &row, &col);
                tile = board[row * 4 + col];
                if (board[row * 4 + col] == 0) {
                    printf(""This tile has already been revealed, please choose another one.\n"");
                } else {
                    board[row * 4 + col] = 0;
                    printf(""Please enter the row and column of your second choice: "");
                    scanf(""%d %d"", &row, &col);
                    tile1 = board[row * 4 + col];
                    if (board[row * 4 + col] == 0) {
                        printf(""This tile has already been revealed, please choose another one.\n"");
                    } else {
                        board[row * 4 + col] = 0;
                        if (tile == tile1) {
                            puts(""Congratulations, you have found a match!"");
                            win = 1;
                        } else {
                            puts(""Sorry, these tiles do not match."");
                            board[row * 4 + col] = tile;
                            board[row * 4 + col] = 0;
                        }
                    }
                }
                moves++;
            }
            printf(""You win! It took you %d moves.\n"", moves);
            return 0;
        }

        void print_board(int board[]) {
            int i, j;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    if (board[i * 4 + j] == 0) {
                        printf(""## "");
                    } else {
                        printf(""%2d "", board[i * 4 + j]);
                    }
                }
                printf(""\n"");
            }
        }

        int shuffle(int board[], int size) {
            int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;
            int temp;
            for (i = 0; i < size; i++) {
                j = rand() % (size - i);
                temp = board[i];
                board[i] = board[j];
                board[j] = temp;
            }
            return 0;
        }

        int check_win(int board[]) {
            int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;
            int win = 1;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    if (board[i * 4 + j] == 0) {
                        win = 0;
                    }
                }
            }
            return win;
        }


",2
"//FormAI DATASET v1.0 Category: Binary search trees ; Style: rigorous
#include<stdio.h>
#include<stdlib.h>

struct node{
    int key;
    struct node *left, *right;
};

struct node *newNode(int item){
    struct node *temp = (struct node*)malloc(sizeof(struct node));
    temp->key = item;
    temp->left = temp->right = NULL;
    return temp;
};

void inorder(struct node *root){
    if(root != NULL){
        inorder(root->left);
        printf(""%d "", root->key);
        inorder(root->right);
    }
}

struct node* insert(struct node* node, int key){

    if(node == NULL) return newNode(key);

    if(key < node->key) node->left = insert(node->left, key);
    
    else if(key > node->key) node->right = insert(node->right, key);

    return node;
}

struct node * minValueNode(struct node* node){
    struct node* current = node;

    while(current && current->left != NULL)
        current = current->left;
    return current;
}

struct node* deleteNode(struct node* root, int key){
    if(root==NULL) return root;

    if(key < root->key) root->left = deleteNode(root->left, key);
    
    else if(key > root->key) root->right = deleteNode(root->right, key);
    
    else{
        if(root->left == NULL){
            struct node *temp = root->right;
            free(root);
            return temp;
        }
        else if(root->right == NULL){
            struct node *temp = root->left;
            free(root);
            return temp;
        }

        struct node* temp = minValueNode(root->right);

        root->key = temp->key;

        root->right = deleteNode(root->right, temp->key);
    }
    return root;
}

int main(){
    struct node *root = NULL;

    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);

    printf(""Inorder traversal of the given tree: \n"");
    inorder(root);

    printf(""\nDelete 20\n"");
    root = deleteNode(root, 20);
    printf(""Inorder traversal of the modified tree: \n"");
    inorder(root);

    printf(""\nDelete 30\n"");
    root = deleteNode(root, 30);
    printf(""Inorder traversal of the modified tree: \n"");
    inorder(root);

    printf(""\nDelete 50\n"");
    root = deleteNode(root, 50);
    printf(""Inorder traversal of the modified tree: \n"");
    inorder(root);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deleteNode(int64_t result, int64_t a2);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
void function_1080(int64_t * ptr);
int32_t function_1090(char * s);
int32_t function_10a0(char * format, ...);
int64_t * function_10b0(int32_t size);
int64_t inorder(int64_t a1);
int64_t insert(int64_t result, int64_t a2);
int64_t minValueNode(int64_t a1);
int64_t newNode(int64_t a1);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
void function_1080(int64_t * ptr) {
    // 0x1080
    free(ptr);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * s) {
    // 0x1090
    return puts(s);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int64_t * function_10b0(int32_t size) {
    // 0x10b0
    return malloc(size);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x141a, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x11f1
int64_t newNode(int64_t a1) {
    int64_t * mem = malloc(24); // 0x11bd
    int64_t result = (int64_t)mem; // 0x11bd
    *(int32_t *)mem = (int32_t)a1;
    *(int64_t *)(result + 16) = 0;
    *(int64_t *)(result + 8) = 0;
    return result;
}

// Address range: 0x11f1 - 0x1247
int64_t inorder(int64_t a1) {
    // 0x11f1
    int64_t result; // 0x11f1
    if (a1 != 0) {
        // 0x1208
        inorder(*(int64_t *)(a1 + 8));
        int64_t v1; // 0x11f1
        printf(""%d "", v1 & 0xffffffff);
        result = inorder(*(int64_t *)(a1 + 16));
    }
    // 0x1244
    return result;
}

// Address range: 0x1247 - 0x12c5
int64_t insert(int64_t result, int64_t a2) {
    int64_t v1 = 0x100000000 * a2 >> 32; // 0x1257
    if (result == 0) {
        // 0x12c3
        return newNode(v1 & 0xffffffff);
    }
    // 0x126d
    int64_t v2; // 0x1247
    int64_t v3 = v2 & 0xffffffff; // 0x1271
    if (v1 < v3) {
        int64_t * v4 = (int64_t *)(result + 8); // 0x127c
        *v4 = insert(*v4, v1 & 0xffffffff);
        // 0x12c3
        return result;
    }
    // 0x1297
    if (v1 > v3) {
        int64_t * v5 = (int64_t *)(result + 16); // 0x12a6
        *v5 = insert(*v5, v1 & 0xffffffff);
    }
    // 0x12c3
    return result;
}

// Address range: 0x12c5 - 0x1301
int64_t minValueNode(int64_t a1) {
    int64_t result = a1;
    while (result != 0) {
        int64_t v1 = *(int64_t *)(result + 8); // 0x12f2
        if (v1 == 0) {
            // break -> 0x12fb
            break;
        }
        result = v1;
    }
    // 0x12fb
    return result;
}

// Address range: 0x1301 - 0x141a
int64_t deleteNode(int64_t result, int64_t a2) {
    // 0x1301
    if (result == 0) {
        // 0x1418
        return result;
    }
    int64_t v1 = 0x100000000 * a2 >> 32; // 0x1311
    int64_t v2; // 0x1301
    int64_t v3 = v2 & 0xffffffff; // 0x1328
    if (v1 < v3) {
        int64_t * v4 = (int64_t *)(result + 8); // 0x1333
        *v4 = deleteNode(*v4, v1 & 0xffffffff);
        // 0x1418
        return result;
    }
    if (v1 > v3) {
        int64_t * v5 = (int64_t *)(result + 16); // 0x1360
        *v5 = deleteNode(*v5, v1 & 0xffffffff);
        // 0x1418
        return result;
    }
    int64_t v6 = *(int64_t *)(result + 8); // 0x1382
    int64_t * v7 = (int64_t *)(result + 16);
    int64_t result2 = *v7;
    if (v6 == 0) {
        // 0x138b
        free((int64_t *)result);
        // 0x1418
        return result2;
    }
    int64_t result3; // 0x1301
    if (result2 != 0) {
        int32_t * v8 = (int32_t *)minValueNode(result2); // 0x13ec
        *(int32_t *)result = *v8;
        *v7 = deleteNode(*v7, (int64_t)*v8);
        result3 = result;
    } else {
        // 0x13b6
        free((int64_t *)result);
        result3 = v6;
    }
    // 0x1418
    return result3;
}

// Address range: 0x141a - 0x1588
int main(int argc, char ** argv) {
    int64_t v1 = insert(0, 50); // 0x143a
    insert(v1, 30);
    insert(v1, 20);
    insert(v1, 40);
    insert(v1, 70);
    insert(v1, 60);
    insert(v1, 80);
    puts(""Inorder traversal of the given tree: "");
    inorder(v1);
    puts(""\nDelete 20"");
    int64_t v2 = deleteNode(v1, 20); // 0x14df
    puts(""Inorder traversal of the modified tree: "");
    inorder(v2);
    puts(""\nDelete 30"");
    int64_t v3 = deleteNode(v2, 30); // 0x151e
    puts(""Inorder traversal of the modified tree: "");
    inorder(v3);
    puts(""\nDelete 50"");
    int64_t v4 = deleteNode(v3, 50); // 0x155d
    puts(""Inorder traversal of the modified tree: "");
    inorder(v4);
    return 0;
}

// Address range: 0x1588 - 0x1595
int64_t _fini(void) {
    // 0x1588
    int64_t result; // 0x1588
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            int64_t v1 = insert(0, 50);
            insert(v1, 30);
            insert(v1, 20);
            insert(v1, 40);
            insert(v1, 70);
            insert(v1, 60);
            insert(v1, 80);
            puts(""Inorder traversal of the given tree: "");
            inorder(v1);
            puts(""\nDelete 20"");
            int64_t v2 = deleteNode(v1, 20);
            puts(""Inorder traversal of the modified tree: "");
            inorder(v2);
            puts(""\nDelete 30"");
            int64_t v3 = deleteNode(v2, 30);
            puts(""Inorder traversal of the modified tree: "");
            inorder(v3);
            puts(""\nDelete 50"");
            int64_t v4 = deleteNode(v3, 50);
            puts(""Inorder traversal of the modified tree: "");
            inorder(v4);
            return 0;
        }

        int64_t insert(int64_t result, int64_t a2) {
            int64_t v1 = 0x100000000 * a2 >> 32;
            if (result == 0) {
                return newNode(v1 & 0xffffffff);
            }
            int64_t v2;
            int64_t v3 = v2 & 0xffffffff;
            if (v1 < v3) {
                int64_t * v4 = (int64_t *)(result + 8);
                *v4 = insert(*v4, v1 & 0xffffffff);
                return result;
            }
            if (v1 > v3) {
                int64_t * v5 = (int64_t *)(result + 16);
                *v5 = insert(*v5, v1 & 0xffffffff);
            }
            return result;
        }

        int64_t deleteNode(int64_t result, int64_t a2) {
            int64_t v1 = 0x100000000 * a2 >> 32;
            if (result == 0) {
                return result;
            }
            int64_t v2;
            int64_t v3 = v2 & 0xffffffff;
            if (v1 < v3) {
                int64_t * v4 = (int64_t *)(result + 8);
                *v4 = deleteNode(*v4, v1 & 0xffffffff);
                return result;
            }
            if (v1 > v3) {
                int64_t * v5 = (int64_t *)(result + 16);
                *v5 = deleteNode(*v5, v1 & 0xffffffff);
            }
            int64_t v6 = *(int64_t *)(result + 8);
            int64_t * v7 = (int64_t *)(result + 16);
            int64_t result2 = *v7;
            if (v6 == 0) {
                free((int64_t *)result);
                return result2;
            }
            int32_t * v8 = (int32_t *)minValueNode(result2);
            *(int32_t *)result = *v8;
            *v7 = deleteNode(*v7, (int64_t)*v8);
            return result;
        }

        int64_t minValueNode(int64_t a1) {
            int64_t result = a1;
            while (result != 0) {
                int64_t v1 = *(int64_t *)(result + 8);
                if (v1 == 0) {
                    break;
                }
                result = v1;
            }
            return result;
        }

        int64_t newNode(int64_t a1) {
            int64_t * mem = malloc(24);
            int64_t result = (int64_t)mem;
            *(int32_t *)mem = (int32_t)a1;
            *(int64_t *)(result + 16) = 0;
            *(int64_t *)(result + 8) = 0;
            return result;
        }

        int64_t inorder(int64_t a1) {
            int64_t result;
            if (a1 != 0) {
                inorder(*(int64_t *)(a1 + 8));
                int64_t v1;
                printf(""%d "", v1 & 0xffffffff);
                result = inorder(*(int64_t *)(a1 + 16));
            }
            return result;
        }


",1
"//FormAI DATASET v1.0 Category: Building a HTTP Client ; Style: expert-level
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>

#define MAX_BUFFER_SIZE 1024

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf(""Usage: %s <url>\n"", argv[0]);
        return 1;
    }

    // Parse the URL into host and path
    char* url = argv[1];
    char* host = NULL;
    char* path = NULL;
    char* http_version = ""HTTP/1.1"";
    int port = 80;

    if (strncmp(url, ""http://"", 7) == 0) {
        url += 7;
    }

    host = url;

    char* slash_ptr = strchr(url, '/');
    if (slash_ptr != NULL) {
        *slash_ptr = '\0';
        path = slash_ptr + 1;
    } else {
        path = """";
    }

    // Prepare the request message
    char request_message[MAX_BUFFER_SIZE];
    sprintf(request_message, ""GET /%s %s\r\nHost: %s\r\nConnection: close\r\n\r\n"", path, http_version, host);

    // Create a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        printf(""Error opening socket\n"");
        return 1;
    }

    // Resolve the host name
    struct hostent *server = gethostbyname(host);
    if (server == NULL) {
        printf(""Error resolving host name\n"");
        return 1;
    }

    // Prepare the address structure
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);

    // Connect to the server
    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
        printf(""Error connecting to server\n"");
        return 1;
    }

    // Send the request message
    if (send(sockfd, request_message, strlen(request_message), 0) < 0) {
        printf(""Error sending request message\n"");
        return 1;
    }

    // Receive and print the response message
    char response_message[MAX_BUFFER_SIZE];
    int total_bytes_received = 0;
    int num_bytes_received = 0;

    do {
        num_bytes_received = recv(sockfd, response_message + total_bytes_received, MAX_BUFFER_SIZE - total_bytes_received, 0);
        if (num_bytes_received < 0) {
            printf(""Error receiving response message\n"");
            return 1;
        }
        total_bytes_received += num_bytes_received;
    } while (num_bytes_received > 0);

    printf(""%s"", response_message);

    // Close the socket
    close(sockfd);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <netdb.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct hostent {
    char * e0;
    char ** e1;
    int32_t e2;
    int32_t e3;
    char ** e4;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1130(int64_t * d);
int32_t function_1140(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
int32_t function_1150(char * s1, char * s2, int32_t n);
int32_t function_1160(char * s);
int32_t function_1170(char * s);
void function_1180(void);
int16_t function_1190(int16_t hostshort);
int32_t function_11a0(int32_t fd, int64_t * buf, int32_t n, int32_t flags);
char * function_11b0(char * s, int32_t c);
int32_t function_11c0(char * format, ...);
int64_t * function_11d0(int64_t * s, int32_t c, int32_t n);
int32_t function_11e0(int32_t fd);
struct hostent * function_11f0(char * name);
int64_t * function_1200(int64_t * dest, int64_t * src, int32_t n);
int32_t function_1210(char * s, char * format, ...);
int32_t function_1220(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1230(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x202a
int32_t g2 = 0; // 0x400
int64_t g3 = 0; // 0x4010
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g4;
    }
    // 0x1016
    return result;
}

// Address range: 0x1130 - 0x113b
void function_1130(int64_t * d) {
    // 0x1130
    __cxa_finalize(d);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x1140
    return recv(fd, buf, n, flags);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * s1, char * s2, int32_t n) {
    // 0x1150
    return strncmp(s1, s2, n);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(char * s) {
    // 0x1160
    return puts(s);
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(char * s) {
    // 0x1170
    return strlen(s);
}

// Address range: 0x1180 - 0x118b
void function_1180(void) {
    // 0x1180
    __stack_chk_fail();
}

// Address range: 0x1190 - 0x119b
int16_t function_1190(int16_t hostshort) {
    // 0x1190
    return htons(hostshort);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(int32_t fd, int64_t * buf, int32_t n, int32_t flags) {
    // 0x11a0
    return send(fd, buf, n, flags);
}

// Address range: 0x11b0 - 0x11bb
char * function_11b0(char * s, int32_t c) {
    // 0x11b0
    return strchr(s, c);
}

// Address range: 0x11c0 - 0x11cb
int32_t function_11c0(char * format, ...) {
    // 0x11c0
    return printf(format);
}

// Address range: 0x11d0 - 0x11db
int64_t * function_11d0(int64_t * s, int32_t c, int32_t n) {
    // 0x11d0
    return memset(s, c, n);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(int32_t fd) {
    // 0x11e0
    return close(fd);
}

// Address range: 0x11f0 - 0x11fb
struct hostent * function_11f0(char * name) {
    // 0x11f0
    return gethostbyname(name);
}

// Address range: 0x1200 - 0x120b
int64_t * function_1200(int64_t * dest, int64_t * src, int32_t n) {
    // 0x1200
    return memcpy(dest, src, n);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(char * s, char * format, ...) {
    // 0x1210
    return sprintf(s, format);
}

// Address range: 0x1220 - 0x122b
int32_t function_1220(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1220
    return connect(fd, addr, len);
}

// Address range: 0x1230 - 0x123b
int32_t function_1230(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1230
    return socket(domain, type, protocol);
}

// Address range: 0x1240 - 0x1266
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1240
    int64_t v1; // 0x1240
    __libc_start_main(0x1329, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1270 - 0x1299
int64_t deregister_tm_clones(void) {
    // 0x1270
    return &g3;
}

// Address range: 0x12a0 - 0x12d9
int64_t register_tm_clones(void) {
    // 0x12a0
    return 0;
}

// Address range: 0x12e0 - 0x1319
int64_t __do_global_dtors_aux(void) {
    // 0x12e0
    if (*(char *)&g3 != 0) {
        // 0x1318
        int64_t result; // 0x12e0
        return result;
    }
    // 0x12ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1307
    *(char *)&g3 = 1;
    return result2;
}

// Address range: 0x1320 - 0x1329
int64_t frame_dummy(void) {
    // 0x1320
    return register_tm_clones();
}

// Address range: 0x1329 - 0x16ac
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1345
    int64_t v2; // 0x1329
    if ((int32_t)argc == 2) {
        int64_t v3 = *(int64_t *)((int64_t)argv + 8); // 0x138f
        char * str = (char *)v3;
        char * str2 = strncmp(str, ""http://"", 7) != 0 ? str : (char *)(v3 + 7);
        char * found_char_pos = strchr(str2, 47); // 0x140f
        char * v4 = (char *)&g1; // 0x1423
        if (found_char_pos != NULL) {
            // 0x1425
            *found_char_pos = 0;
            v4 = (char *)((int64_t)found_char_pos + 1);
        }
        // 0x1451
        int64_t str3; // bp-2072, 0x1329
        sprintf((char *)&str3, ""GET /%s %s\r\nHost: %s\r\nConnection: close\r\n\r\n"", v4, ""HTTP/1.1"", str2);
        int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1493
        if (sock_fd >= 0) {
            struct hostent * v5 = gethostbyname(str2); // 0x14ca
            if (v5 != NULL) {
                int64_t v6 = (int64_t)v5; // 0x14ca
                int64_t addr; // bp-2088, 0x1329
                memset(&addr, 0, 16);
                addr = 2;
                htons(80);
                int64_t v7 = *(int64_t *)*(int64_t *)(v6 + 24); // 0x154a
                int64_t v8; // bp-2084, 0x1329
                memcpy(&v8, (int64_t *)v7, *(int32_t *)(v6 + 20));
                if (connect(sock_fd, (struct sockaddr *)&addr, 16) >= 0) {
                    // 0x159c
                    if (send(sock_fd, &str3, strlen((char *)&str3), 0) >= 0) {
                        // 0x15f9
                        int64_t v9; // bp-1048, 0x1329
                        int64_t v10 = &v9; // 0x160f
                        int32_t v11 = 0;
                        int32_t v12 = recv(sock_fd, (int64_t *)((int64_t)v11 + v10), (int32_t)&g2 - v11, 0); // 0x1627
                        while (v12 >= 0) {
                            // 0x1651
                            if (v12 == 0) {
                                // 0x1666
                                printf(""%s"", &v9);
                                close(sock_fd);
                                v2 = 0;
                                goto lab_0x1696;
                            }
                            v11 += v12;
                            v12 = recv(sock_fd, (int64_t *)((int64_t)v11 + v10), (int32_t)&g2 - v11, 0);
                        }
                        // 0x163b
                        puts(""Error receiving response message"");
                        v2 = 1;
                    } else {
                        // 0x15cc
                        puts(""Error sending request message"");
                        v2 = 1;
                    }
                } else {
                    // 0x1583
                    puts(""Error connecting to server"");
                    v2 = 1;
                }
            } else {
                // 0x14e0
                puts(""Error resolving host name"");
                v2 = 1;
            }
        } else {
            // 0x14a7
            puts(""Error opening socket"");
            v2 = 1;
        }
    } else {
        // 0x135d
        printf(""Usage: %s <url>\n"", argv);
        v2 = 1;
    }
    goto lab_0x1696;
  lab_0x1696:;
    int64_t result = v2; // 0x16a3
    if (v1 != __readfsqword(40)) {
        // 0x16a5
        __stack_chk_fail();
        result = &g4;
    }
    // 0x16aa
    return result;
}

// Address range: 0x16ac - 0x16b9
int64_t _fini(void) {
    // 0x16ac
    int64_t result; // 0x16ac
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 25

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <netdb.h>
        #include <netinet/in.h>
        #include <sys/socket.h>
        #include <arpa/inet.h>

        int main(int argc, char ** argv) {
            if (argc == 2) {
                char * str = argv[1];
                char * str2 = strncmp(str, ""http://"", 7) != 0 ? str : str + 7;
                char * found_char_pos = strchr(str2, 47);
                char * v4 = (char *)&g1;
                if (found_char_pos != NULL) {
                    *found_char_pos = 0;
                    v4 = found_char_pos + 1;
                }
                char str3[1024];
                sprintf(str3, ""GET /%s %s\r\nHost: %s\r\nConnection: close\r\n\r\n"", v4, ""HTTP/1.1"", str2);
                int sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
                if (sock_fd >= 0) {
                    struct hostent * v5 = gethostbyname(str2);
                    if (v5 != NULL) {
                        int64_t v6 = (int64_t)v5;
                        int64_t addr;
                        memset(&addr, 0, 16);
                        addr = 2;
                        htons(80);
                        int64_t v7 = *(int64_t *)*(int64_t *)(v6 + 24);
                        int64_t v8;
                        memcpy(&v8, (int64_t *)v7, *(int32_t *)(v6 + 20));
                        if (connect(sock_fd, (struct sockaddr *)&addr, 16) >= 0) {
                            if (send(sock_fd, &str3, strlen(str3), 0) >= 0) {
                                int64_t v9;
                                int64_t v10 = &v9;
                                int32_t v11 = 0;
                                int32_t v12 = recv(sock_fd, (int64_t *)((int64_t)v11 + v10), (int32_t)&g2 - v11, 0);
                                while (v12 >= 0) {
                                    if (v12 == 0) {
                                        printf(""%s"", &v9);
                                        close(sock_fd);
                                        return 0;
                                    }
                                    v11 += v12;
                                    v12 = recv(sock_fd, (int64_t *)((int64_t)v11 + v10), (int32_t)&g2 - v11, 0);
                                }
                                puts(""Error receiving response message"");
                                return 1;
                            } else {
                                puts(""Error sending request message"");
                                return 1;
                            }
                        } else {
                            puts(""Error connecting to server"");
                            return 1;
                        }
                    } else {
                        puts(""Error resolving host name"");
                        return 1;
                    }
                } else {
                    puts(""Error opening socket"");
                    return 1;
                }
            } else {
                printf(""Usage: %s <url>\n"", argv);
                return 1;
            }
        }

",1
"//FormAI DATASET v1.0. Category: Pattern printing ; Style: minimalist
#include <stdio.h>

int main() {
    int height, width, i, j;
    printf(""Enter height of pattern (must be an odd number): "");
    scanf(""%d"", &height);
    width = height;
 
    for(i = 0; i < height; i++) {
        for(j = 0; j < width; j++) {
            if(i == (height / 2) || j == (width / 2)) { // Center of the pattern
                printf(""*"");
            } 
            else if(i == (j + 1) || (i + 1) == j) { // Diagonal
                printf(""*"");
            } 
            else if(i == 0 && j <= (width / 2) || j == 0 && i >= (height / 2)) { // Top half and left side
                printf(""*"");
            }
            else if(i == (height - 1) && j >= (width / 2) || j == (width - 1) && i <= (height / 2)) { // Bottom half and right side
                printf(""*"");
            } 
            else {
                printf("" "");
            }
        }
        printf(""\n"");
    }
    
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1334
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    printf(""Enter height of pattern (must be an odd number): "");
    int64_t v2; // bp-32, 0x11a9
    scanf(""%d"", &v2);
    int64_t v3 = v2 & 0xffffffff; // 0x130d
    int64_t v4; // 0x11a9
    int64_t v5; // 0x11a9
    int64_t v6; // 0x11a9
    uint64_t v7; // 0x11a9
    uint32_t v8; // 0x11a9
    int32_t v9; // 0x11a9
    uint32_t v10; // 0x11a9
    int64_t v11; // 0x11a9
    uint64_t v12; // 0x11a9
    int64_t v13; // 0x11a9
    if (v3 != 0) {
        int32_t v14 = v2; // 0x11f3
        v12 = (int64_t)((int32_t)(v14 < 0) + v14 >> 1);
        v13 = v2 + 0xffffffff & 0xffffffff;
        int64_t v15 = 0; // 0x11a9
        int32_t v16 = 0; // 0x11a9
        while (true) {
            // 0x12f3
            v8 = v16;
            int32_t v17 = v8 + 1;
            if (v14 > 0) {
                // 0x1211
                v4 = v15;
                int64_t v18 = v17;
                int64_t v19 = v8;
                v6 = 0;
                while (true) {
                  lab_0x1211:
                    // 0x1211
                    v7 = v6;
                    v9 = v2;
                    v10 = (int32_t)(v9 < 0) + v9 >> 1;
                    if (v7 != v12 == (v8 != v10)) {
                        // 0x1242
                        v11 = v7 + 1;
                        if (v11 != v19 == (v7 != v18)) {
                            if (v8 != 0) {
                                if (v7 != 0 || v4 < (int64_t)v10) {
                                    goto lab_0x12a1;
                                } else {
                                    // 0x1295
                                    putchar(42);
                                    v5 = v11;
                                    goto lab_0x12ef;
                                }
                            } else {
                                if (v7 > v12) {
                                    goto lab_0x12a1;
                                } else {
                                    // 0x1295
                                    putchar(42);
                                    v5 = v11;
                                    goto lab_0x12ef;
                                }
                            }
                        } else {
                            // 0x1258
                            putchar(42);
                            v5 = v11;
                            goto lab_0x12ef;
                        }
                    } else {
                        // 0x1233
                        putchar(42);
                        v5 = v7 + 1;
                        goto lab_0x12ef;
                    }
                }
            }
          lab_0x12ff:
            // 0x12ff
            putchar(10);
            int64_t v20 = v17; // 0x1313
            v15 = v20;
            v16 = v17;
            if ((v2 & 0xffffffff) <= v20) {
                // break -> 0x1319
                break;
            }
        }
    }
    int64_t result = 0; // 0x132b
    if (v1 != __readfsqword(40)) {
        // 0x132d
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1332
    return result;
  lab_0x12ef:;
    int64_t v21 = v5;
    if (v21 == v3) {
        // break -> 0x12ff
        goto lab_0x12ff;
    }
    // 0x12ef
    v6 = v21;
    goto lab_0x1211;
  lab_0x12a1:
    if (v7 < v12 || v8 != v9 - 1) {
        if (v7 != v13 || v4 > (int64_t)v10) {
            // 0x12e5
            putchar(32);
            v5 = v11;
            goto lab_0x12ef;
        } else {
            // 0x12d9
            putchar(42);
            v5 = v11;
            goto lab_0x12ef;
        }
    } else {
        // 0x12d9
        putchar(42);
        v5 = v11;
        goto lab_0x12ef;
    }
}

// Address range: 0x1334 - 0x1341
int64_t _fini(void) {
    // 0x1334
    int64_t result; // 0x1334
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>
        #include <stdbool.h>

        int main(int argc, char ** argv) {
            int height;
            printf(""Enter height of pattern (must be an odd number): "");
            scanf(""%d"", &height);
            int width = height;
            int pattern[height][width];
            int i, j;
            for (i = 0; i < height; i++) {
                for (j = 0; j < width; j++) {
                    pattern[i][j] = 0;
                }
            }
            for (i = 0; i < height; i++) {
                for (j = 0; j < width; j++) {
                    if (i == 0 || i == height - 1 || j == 0 || j == width - 1) {
                        pattern[i][j] = 1;
                    }
                }
            }
            for (i = 1; i < height - 1; i++) {
                for (j = 1; j < width - 1; j++) {
                    if (pattern[i][j] == 0) {
                        if (pattern[i - 1][j] == 1 && pattern[i + 1][j] == 1 && pattern[i][j - 1] == 1 && pattern[i][j + 1] == 1) {
                            pattern[i][j] = 1;
                        }
                    }
                }
            }
            for (i = 0; i < height; i++) {
                for (j = 0; j < width; j++) {
                    if (pattern[i][j] == 1) {
                        printf(""*"");
                    } else {
                        printf("" "");
                    }
                }
                printf(""\n"");
            }
            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Spam Detection System ; Style: Cryptic
#include <stdio.h>
#include <string.h>

// Function to detect spam words in a given sentence
void spamDetector(char sentence[])
{
    char spamWords[][20] = {""buy"", ""discount"", ""free"", ""money"", ""offer"", 
                            ""win"", ""prize"", ""limited"", ""opportunity"", ""cash""};

    int count = 0;

    // Removing punctuations and converting the sentence to lowercase
    for(int i = 0; i < strlen(sentence); i++)
    {
        if(sentence[i] == ',' || sentence[i] == '.' || sentence[i] == '!' || sentence[i] == '?')
        {
            sentence[i] = ' ';
        }

        else
        {
            sentence[i] = tolower(sentence[i]);
        }
    }

    // Counting the number of spam words present in the sentence
    char *token = strtok(sentence, "" "");

    while(token != NULL)
    {
        for(int i = 0; i < 10; i++)
        {
            if(strcmp(token, spamWords[i]) == 0)
            {
                count++;
            }
        }

        token = strtok(NULL, "" "");
    }

    // Printing the result based on the number of spam words
    if(count == 0)
    {
        printf(""No spam detected.\n"");
    }

    else if(count == 1)
    {
        printf(""1 spam word detected.\n"");
    }

    else
    {
        printf(""%d spam words detected.\n"", count);
    }
}

int main()
{
    char str[100];

    printf(""Enter a sentence: "");
    fgets(str, 100, stdin);

    // Removing the newline character at the end of the sentence
    str[strlen(str)-1] = '\0';

    spamDetector(str);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(char * s);
int32_t function_10d0(char * s);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
char * function_1100(char * s, int32_t n, struct _IO_FILE * stream);
int32_t function_1110(char * s1, char * s2);
int32_t function_1120(int32_t c);
char * function_1130(char * s, char * delim);
int64_t register_tm_clones(void);
int64_t spamDetector(int64_t * str);

// --------------------- Global Variables ---------------------

struct _IO_FILE * g1 = NULL; // 0x4010
char g2 = 0; // 0x4018
int32_t g3;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g3;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * s) {
    // 0x10c0
    return puts(s);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return strlen(s);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
char * function_1100(char * s, int32_t n, struct _IO_FILE * stream) {
    // 0x1100
    return fgets(s, n, stream);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s1, char * s2) {
    // 0x1110
    return strcmp(s1, s2);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(int32_t c) {
    // 0x1120
    return tolower(c);
}

// Address range: 0x1130 - 0x113b
char * function_1130(char * s, char * delim) {
    // 0x1130
    return strtok(s, delim);
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x158e, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return (int64_t)&g1;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (g2 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    g2 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x158e
int64_t spamDetector(int64_t * str) {
    int64_t v1 = __readfsqword(40); // 0x1240
    int64_t v2 = 0x797562; // bp-232, 0x124f
    int32_t v3 = 0; // 0x147b
    char v4; // 0x1229
    char * v5; // 0x13b5
    if (strlen((char *)str) != 0) {
        while (true) {
          lab_0x13a2:
            // 0x13a2
            v5 = (char *)((int64_t)v3 + (int64_t)str);
            char c = *v5; // 0x13b5
            v4 = 32;
            switch (c) {
                case 44: {
                    goto lab_0x1459;
                }
                case 46: {
                    goto lab_0x1459;
                }
                case 33: {
                    goto lab_0x1459;
                }
                default: {
                    // 0x13f0
                    v4 = 32;
                    if (c != 63) {
                        // 0x1422
                        v4 = tolower((int32_t)c);
                    }
                    goto lab_0x1459;
                }
            }
        }
    }
  lab_0x1481:;
    char * next_token = strtok((char *)str, "" ""); // 0x1495
    if (next_token != NULL) {
        int64_t v6 = &v2; // 0x14af
        int64_t v7 = 0;
        int32_t v8 = strcmp(next_token, (char *)(20 * v7 + v6)) == 0;
        v7++;
        int32_t v9 = v8; // 0x14fc
        while (v7 != 10) {
            // 0x14af
            v8 = v9 + (int32_t)(strcmp(next_token, (char *)(20 * v7 + v6)) == 0);
            v7++;
            v9 = v8;
        }
        char * next_token2 = strtok(NULL, "" ""); // 0x150d
        int32_t v10 = v8; // 0x1521
        while (next_token2 != NULL) {
            // 0x14f5
            v7 = 0;
            v8 = v10 + (int32_t)(strcmp(next_token2, (char *)(20 * v7 + v6)) == 0);
            v7++;
            v9 = v8;
            while (v7 != 10) {
                // 0x14af
                v8 = v9 + (int32_t)(strcmp(next_token2, (char *)(20 * v7 + v6)) == 0);
                v7++;
                v9 = v8;
            }
            // 0x14fe
            next_token2 = strtok(NULL, "" "");
            v10 = v8;
        }
        if (v8 != 0) {
            if (v8 != 1) {
                // 0x1557
                printf(""%d spam words detected.\n"", (int64_t)v8);
            } else {
                // 0x1546
                puts(""1 spam word detected."");
            }
            goto lab_0x1573;
        } else {
            // 0x152c
            puts(""No spam detected."");
            goto lab_0x1573;
        }
    } else {
        // 0x152c
        puts(""No spam detected."");
        goto lab_0x1573;
    }
  lab_0x1459:
    // 0x1459
    *v5 = v4;
    v3++;
    if (v3 >= strlen((char *)str)) {
        // break -> 0x1481
        goto lab_0x1481;
    }
    goto lab_0x13a2;
  lab_0x1573:;
    int64_t result = 0; // 0x1581
    if (v1 != __readfsqword(40)) {
        // 0x1583
        __stack_chk_fail();
        result = &g3;
    }
    // 0x1588
    return result;
}

// Address range: 0x158e - 0x1611
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x159a
    printf(""Enter a sentence: "");
    int64_t str; // bp-120, 0x158e
    fgets((char *)&str, 100, g1);
    int32_t len = strlen((char *)&str); // 0x15dc
    int64_t v2; // bp-8, 0x158e
    *(char *)((int64_t)&v2 - 113 + (int64_t)len) = 0;
    spamDetector(&str);
    int64_t result = 0; // 0x1608
    if (v1 != __readfsqword(40)) {
        // 0x160a
        __stack_chk_fail();
        result = &g3;
    }
    // 0x160f
    return result;
}

// Address range: 0x1614 - 0x1621
int64_t _fini(void) {
    // 0x1614
    int64_t result; // 0x1614
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            char str[100];
            printf(""Enter a sentence: "");
            fgets(str, 100, stdin);
            int len = strlen(str);
            char * next_token = strtok(str, "" "");
            int count = 0;
            while (next_token != NULL) {
                int i = 0;
                while (i < 10) {
                    if (strcmp(next_token, (char *)(20 * i + &count)) == 0) {
                        count++;
                    }
                    i++;
                }
                next_token = strtok(NULL, "" "");
            }
            if (count != 0) {
                if (count != 1) {
                    printf(""%d spam words detected.\n"", count);
                } else {
                    puts(""1 spam word detected."");
                }
            } else {
                puts(""No spam detected."");
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Building a FTP Client ; Style: scientific
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define MAX_COMMAND_LENGTH 1024
#define MAX_RESPONSE_LENGTH 4096
#define MAX_FILENAME_LENGTH 256

int connect_to_server(const char *hostname, const char *port);
bool send_command(int sockfd, const char *command, char *response, size_t max_response_len);
bool receive_data(int sockfd, const char *filename);

int main(int argc, char *argv[]) {
    if (argc != 4) {
        fprintf(stderr, ""Usage: %s <hostname> <port> <filename>\n"", argv[0]);
        return 1;
    }

    const char *hostname = argv[1];
    const char *port = argv[2];
    const char *filename = argv[3];

    int sockfd = connect_to_server(hostname, port);
    if (sockfd < 0) {
        fprintf(stderr, ""Failed to connect to server\n"");
        return 1;
    }

    char response[MAX_RESPONSE_LENGTH];
    if (!send_command(sockfd, ""USER anonymous\r\n"", response, sizeof(response))) {
        fprintf(stderr, ""Failed to send USER command\n"");
        return 1;
    }

    if (!send_command(sockfd, ""PASS guest\r\n"", response, sizeof(response))) {
        fprintf(stderr, ""Failed to send PASS command\n"");
        return 1;
    }

    char command[MAX_COMMAND_LENGTH];
    snprintf(command, sizeof(command), ""RETR %s\r\n"", filename);
    if (!send_command(sockfd, command, response, sizeof(response))) {
        fprintf(stderr, ""Failed to send RETR command\n"");
        return 1;
    }

    if (!receive_data(sockfd, filename)) {
        fprintf(stderr, ""Failed to receive data\n"");
        return 1;
    }

    close(sockfd);
    return 0;
}

int connect_to_server(const char *hostname, const char *port) {
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    struct addrinfo *result;
    if (getaddrinfo(hostname, port, &hints, &result) != 0) {
        return -1;
    }

    int sockfd = -1;
    struct addrinfo *rp;
    for (rp = result; rp != NULL; rp = rp->ai_next) {
        sockfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (sockfd == -1) {
            continue;
        }

        if (connect(sockfd, rp->ai_addr, rp->ai_addrlen) != -1) {
            break;
        }

        close(sockfd);
    }

    freeaddrinfo(result);
    return sockfd;
}

bool send_command(int sockfd, const char *command, char *response, size_t max_response_len) {
    if (write(sockfd, command, strlen(command)) == -1) {
        return false;
    }

    ssize_t num_bytes = read(sockfd, response, max_response_len);
    if (num_bytes == -1) {
        return false;
    }

    response[num_bytes] = '\0';
    return true;
}

bool receive_data(int sockfd, const char *filename) {
    FILE *output_file = fopen(filename, ""wb"");
    if (output_file == NULL) {
        return false;
    }

    char buffer[MAX_FILENAME_LENGTH];
    ssize_t num_bytes;
    while ((num_bytes = read(sockfd, buffer, sizeof(buffer))) > 0) {
        if (fwrite(buffer, 1, num_bytes, output_file) != num_bytes) {
            fclose(output_file);
            return false;
        }
    }

    fclose(output_file);
    return num_bytes == 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <netdb.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct addrinfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct sockaddr * e5;
    char * e6;
    struct addrinfo * e7;
};

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t connect_to_server(int64_t node, int64_t service);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1120(int64_t * d);
int32_t function_1130(int32_t fd, int64_t * buf, int32_t n);
int32_t function_1140(struct _IO_FILE * stream);
int32_t function_1150(char * s);
void function_1160(void);
int32_t function_1170(char * s, int32_t maxlen, char * format, ...);
int64_t * function_1180(int64_t * s, int32_t c, int32_t n);
int32_t function_1190(int32_t fd);
int32_t function_11a0(int32_t fd, int64_t * buf, int32_t nbytes);
int32_t function_11b0(struct _IO_FILE * stream, char * format, ...);
struct _IO_FILE * function_11c0(char * filename, char * modes);
int32_t function_11d0(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_11e0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
int32_t function_11f0(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai);
void function_1200(struct addrinfo * ai);
int32_t function_1210(int32_t domain, int32_t type, int32_t protocol);
int64_t receive_data(int64_t fd, int64_t file_path);
int64_t register_tm_clones(void);
int64_t send_command(int64_t a1, char * str, int64_t * buf, int64_t nbyte);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x400
struct _IO_FILE * g2 = NULL; // 0x4020
char g3 = 0; // 0x4028
int32_t g4;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g4;
    }
    // 0x1016
    return result;
}

// Address range: 0x1120 - 0x112b
void function_1120(int64_t * d) {
    // 0x1120
    __cxa_finalize(d);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(int32_t fd, int64_t * buf, int32_t n) {
    // 0x1130
    return write(fd, buf, n);
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(struct _IO_FILE * stream) {
    // 0x1140
    return fclose(stream);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * s) {
    // 0x1150
    return strlen(s);
}

// Address range: 0x1160 - 0x116b
void function_1160(void) {
    // 0x1160
    __stack_chk_fail();
}

// Address range: 0x1170 - 0x117b
int32_t function_1170(char * s, int32_t maxlen, char * format, ...) {
    // 0x1170
    return snprintf(s, maxlen, format);
}

// Address range: 0x1180 - 0x118b
int64_t * function_1180(int64_t * s, int32_t c, int32_t n) {
    // 0x1180
    return memset(s, c, n);
}

// Address range: 0x1190 - 0x119b
int32_t function_1190(int32_t fd) {
    // 0x1190
    return close(fd);
}

// Address range: 0x11a0 - 0x11ab
int32_t function_11a0(int32_t fd, int64_t * buf, int32_t nbytes) {
    // 0x11a0
    return read(fd, buf, nbytes);
}

// Address range: 0x11b0 - 0x11bb
int32_t function_11b0(struct _IO_FILE * stream, char * format, ...) {
    // 0x11b0
    return fprintf(stream, format);
}

// Address range: 0x11c0 - 0x11cb
struct _IO_FILE * function_11c0(char * filename, char * modes) {
    // 0x11c0
    return fopen(filename, modes);
}

// Address range: 0x11d0 - 0x11db
int32_t function_11d0(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x11d0
    return connect(fd, addr, len);
}

// Address range: 0x11e0 - 0x11eb
int32_t function_11e0(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x11e0
    return fwrite(ptr, size, n, s);
}

// Address range: 0x11f0 - 0x11fb
int32_t function_11f0(char * name, char * service, struct addrinfo * req, struct addrinfo ** pai) {
    // 0x11f0
    return getaddrinfo(name, service, req, pai);
}

// Address range: 0x1200 - 0x120b
void function_1200(struct addrinfo * ai) {
    // 0x1200
    freeaddrinfo(ai);
}

// Address range: 0x1210 - 0x121b
int32_t function_1210(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1210
    return socket(domain, type, protocol);
}

// Address range: 0x1220 - 0x1246
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1220
    int64_t v1; // 0x1220
    __libc_start_main(0x1309, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1250 - 0x1279
int64_t deregister_tm_clones(void) {
    // 0x1250
    return 0x4010;
}

// Address range: 0x1280 - 0x12b9
int64_t register_tm_clones(void) {
    // 0x1280
    return 0;
}

// Address range: 0x12c0 - 0x12f9
int64_t __do_global_dtors_aux(void) {
    // 0x12c0
    if (g3 != 0) {
        // 0x12f8
        int64_t result; // 0x12c0
        return result;
    }
    // 0x12cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x12db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x12e7
    g3 = 1;
    return result2;
}

// Address range: 0x1300 - 0x1309
int64_t frame_dummy(void) {
    // 0x1300
    return register_tm_clones();
}

// Address range: 0x1309 - 0x1599
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1331
    int64_t v2; // 0x1309
    if ((int32_t)argc == 4) {
        int64_t v3 = (int64_t)argv; // 0x137b
        int64_t v4 = *(int64_t *)(v3 + 24); // 0x13a6
        int64_t v5 = connect_to_server(*(int64_t *)(v3 + 8), *(int64_t *)(v3 + 16)); // 0x13c5
        int32_t fd = v5; // 0x13ca
        if (fd >= 0) {
            int64_t v6 = v5 & 0xffffffff; // 0x141f
            int64_t v7; // bp-4120, 0x1309
            if ((char)send_command(v6, ""USER anonymous\r\n"", &v7, 0x1000) == 1) {
                // 0x145a
                if ((char)send_command(v6, ""PASS guest\r\n"", &v7, 0x1000) == 1) {
                    // 0x14ae
                    int64_t str; // bp-5144, 0x1309
                    snprintf((char *)&str, (int32_t)&g1, ""RETR %s\r\n"", (char *)v4);
                    int64_t v8 = send_command(v6, (char *)&str, &v7, 0x1000); // 0x14f3
                    if ((char)v8 == 1) {
                        // 0x1529
                        if ((char)receive_data(v6, v4) == 1) {
                            // 0x1571
                            close(fd);
                            v2 = 0;
                        } else {
                            // 0x1547
                            fwrite((int64_t *)""Failed to receive data\n"", 1, 23, g2);
                            v2 = 1;
                        }
                    } else {
                        // 0x14ff
                        fwrite((int64_t *)""Failed to send RETR command\n"", 1, 28, g2);
                        v2 = 1;
                    }
                } else {
                    // 0x1481
                    fwrite((int64_t *)""Failed to send PASS command\n"", 1, 28, g2);
                    v2 = 1;
                }
            } else {
                // 0x142d
                fwrite((int64_t *)""Failed to send USER command\n"", 1, 28, g2);
                v2 = 1;
            }
        } else {
            // 0x13d9
            fwrite((int64_t *)""Failed to connect to server\n"", 1, 28, g2);
            v2 = 1;
        }
    } else {
        // 0x1349
        fprintf(g2, ""Usage: %s <hostname> <port> <filename>\n"", argv);
        v2 = 1;
    }
    int64_t result = v2; // 0x1590
    if (v1 != __readfsqword(40)) {
        // 0x1592
        __stack_chk_fail();
        result = &g4;
    }
    // 0x1597
    return result;
}

// Address range: 0x1599 - 0x16ae
int64_t connect_to_server(int64_t node, int64_t service) {
    int64_t v1 = __readfsqword(40); // 0x15ad
    int64_t hints; // bp-72, 0x1599
    memset(&hints, 0, 48);
    struct addrinfo * addr_info; // bp-88, 0x1599
    int32_t v2 = getaddrinfo((char *)node, (char *)service, (struct addrinfo *)&hints, &addr_info); // 0x15fa
    int64_t v3 = 0xffffffff; // 0x1601
    if (v2 == 0) {
        struct addrinfo * addr_info2 = addr_info; // 0x1684
        v3 = 0xffffffff;
        if (addr_info != NULL) {
            int64_t v4 = (int64_t)addr_info;
            int32_t type = *(int32_t *)(v4 + 8); // 0x1629
            int32_t domain = *(int32_t *)(v4 + 4); // 0x1630
            uint32_t sock_fd = socket(domain, type, *(int32_t *)(v4 + 12)); // 0x1637
            int64_t addr; // 0x1650
            if (sock_fd != -1) {
                // 0x1645
                addr = *(int64_t *)(v4 + 24);
                if (connect(sock_fd, (struct sockaddr *)addr, *(int32_t *)(v4 + 16)) != -1) {
                    // break -> 0x1689
                    break;
                }
                // 0x1666
                close(sock_fd);
            }
            int64_t v5 = *(int64_t *)(v4 + 40); // 0x1677
            while (v5 != 0) {
                // 0x161e
                v4 = v5;
                type = *(int32_t *)(v4 + 8);
                domain = *(int32_t *)(v4 + 4);
                sock_fd = socket(domain, type, *(int32_t *)(v4 + 12));
                if (sock_fd != -1) {
                    // 0x1645
                    addr = *(int64_t *)(v4 + 24);
                    if (connect(sock_fd, (struct sockaddr *)addr, *(int32_t *)(v4 + 16)) != -1) {
                        // break -> 0x1689
                        break;
                    }
                    // 0x1666
                    close(sock_fd);
                }
                // 0x1673
                v5 = *(int64_t *)(v4 + 40);
            }
            // 0x1689
            addr_info2 = addr_info;
            v3 = sock_fd;
        }
        // 0x1689
        freeaddrinfo(addr_info2);
    }
    int64_t result = v3; // 0x16a5
    if (v1 != __readfsqword(40)) {
        // 0x16a7
        __stack_chk_fail();
        result = &g4;
    }
    // 0x16ac
    return result;
}

// Address range: 0x16ae - 0x1732
int64_t send_command(int64_t a1, char * str, int64_t * buf, int64_t nbyte) {
    int32_t fd = a1; // 0x16ba
    if (write(fd, (int64_t *)str, strlen(str)) == -1) {
        // 0x1730
        return 0;
    }
    int32_t v1 = read(fd, buf, (int32_t)nbyte); // 0x1706
    int64_t result = 0; // 0x1714
    if (v1 != -1) {
        // 0x171d
        *(char *)((int64_t)v1 + (int64_t)buf) = 0;
        result = 1;
    }
    // 0x1730
    return result;
}

// Address range: 0x1732 - 0x1832
int64_t receive_data(int64_t fd, int64_t file_path) {
    int64_t v1 = __readfsqword(40); // 0x174e
    struct _IO_FILE * file = fopen((char *)file_path, ""wb""); // 0x1771
    int64_t v2 = 0; // 0x1785
    if (file != NULL) {
        int64_t buf; // bp-280, 0x1732
        int32_t nmemb = read((int32_t)fd, &buf, 256); // 0x17ec
        // 0x17d5
        while (nmemb >= 0 == (nmemb != 0)) {
            // 0x1791
            if (fwrite(&buf, 1, nmemb, file) != nmemb) {
                // 0x17bf
                fclose(file);
                v2 = 0;
                goto lab_0x181c;
            }
            nmemb = read((int32_t)fd, &buf, 256);
        }
        // 0x1802
        v2 = (int64_t)(fclose(file) & -256) | (int64_t)(nmemb == 0);
    }
    goto lab_0x181c;
  lab_0x181c:;
    int64_t result = v2; // 0x1829
    if (v1 != __readfsqword(40)) {
        // 0x182b
        __stack_chk_fail();
        result = &g4;
    }
    // 0x1830
    return result;
}

// Address range: 0x1834 - 0x1841
int64_t _fini(void) {
    // 0x1834
    int64_t result; // 0x1834
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 27

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <netdb.h>
        #include <sys/socket.h>
        #include <arpa/inet.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>
        #include <sys/mman.h>
        #include <sys/wait.h>
        #include <sys/time.h>
        #include <sys/resource.h>
        #include <sys/utsname.h>
        #include <sys/uio.h>
        #include <sys/syscall.h>
        #include <sys/prctl.h>
        #include <sys/ptrace.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
        #include <sys/personality.h>
     ",0
"//FormAI DATASET v1.0 Category: Math exercise ; Style: genious
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MIN_NUMBERS 5 // minimum numbers allowed for exercise
#define MAX_NUMBERS 10 // maximum numbers allowed for exercise

// menu options
enum {
    ADDITION = 1,
    SUBTRACTION,
    MULTIPLICATION,
    DIVISION,
    QUIT
};

int main() {
    srand(time(NULL)); // seed randomizer with current time

    int option, num1, num2, num3, result; // declare variables

    do {
        // display menu
        printf(""\n\n***********************\n"");
        printf(""*     Math Exercises   *\n"");
        printf(""***********************\n\n"");
        printf(""1. Addition\n"");
        printf(""2. Subtraction\n"");
        printf(""3. Multiplication\n"");
        printf(""4. Division\n"");
        printf(""5. Quit\n"");
        printf(""Enter an option (1-5): "");
        scanf(""%d"", &option);

        // check for invalid option
        if (option < ADDITION || option > QUIT) {
            printf(""\nInvalid option. Please try again.\n"");
        } else if (option != QUIT) {
            // generate random numbers
            num1 = rand() % 100 + 1;
            num2 = rand() % 100 + 1;
            num3 = rand() % 100 + 1;

            // choose random number of numbers to use
            int num_numbers = rand() % (MAX_NUMBERS - MIN_NUMBERS + 1) + MIN_NUMBERS;

            // declare array to hold random numbers
            int numbers[num_numbers];

            // fill array with random numbers
            for (int i = 0; i < num_numbers; i++) {
                numbers[i] = rand() % 100 + 1;
            }

            // perform calculation based on chosen operation
            switch (option) {
                case ADDITION:
                    // display addition exercise
                    printf(""\n"");
                    for (int i = 0; i < num_numbers; i++) {
                        printf(""%d + "", numbers[i]);
                        result += numbers[i];
                    }
                    printf("" = %d\n"", result);
                    break;
                case SUBTRACTION:
                    // display subtraction exercise
                    printf(""\n"");
                    for (int i = 0; i < num_numbers; i++) {
                        printf(""%d - "", numbers[i]);
                        if (i % 2 == 0) {
                            result += numbers[i];
                        } else {
                            result -= numbers[i];
                        }
                    }
                    printf("" = %d\n"", result);
                    break;
                case MULTIPLICATION:
                    // display multiplication exercise
                    printf(""\n"");
                    result = 1;
                    for (int i = 0; i < num_numbers; i++) {
                        printf(""%d * "", numbers[i]);
                        result *= numbers[i];
                    }
                    printf("" = %d\n"", result);
                    break;
                case DIVISION:
                    // display division exercise
                    printf(""\n"");
                    result = num1 / num2;
                    printf(""%d / %d = %d\n"", num1, num2, result);
                    if (num3 != 0) {
                        result /= num3;
                        printf("" / %d = %d\n"", num3, result);
                    }
                    break;
            }
        }
    } while (option != QUIT);

    printf(""\nThanks for using Math Exercises! Goodbye.\n"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10b0(int64_t * d);
int32_t function_10c0(int32_t c);
int32_t function_10d0(char * s);
void function_10e0(void);
int32_t function_10f0(char * format, ...);
void function_1100(int32_t seed);
int32_t function_1110(int32_t * timer);
int32_t function_1120(char * format, ...);
int32_t function_1130(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(int64_t * d) {
    // 0x10b0
    __cxa_finalize(d);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(int32_t c) {
    // 0x10c0
    return putchar(c);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * s) {
    // 0x10d0
    return puts(s);
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(void) {
    // 0x10e0
    __stack_chk_fail();
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * format, ...) {
    // 0x10f0
    return printf(format);
}

// Address range: 0x1100 - 0x110b
void function_1100(int32_t seed) {
    // 0x1100
    srand(seed);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int32_t * timer) {
    // 0x1110
    return time(timer);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(char * format, ...) {
    // 0x1120
    return scanf(format);
}

// Address range: 0x1130 - 0x113b
int32_t function_1130(void) {
    // 0x1130
    return rand();
}

// Address range: 0x1140 - 0x1166
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1140
    int64_t v1; // 0x1140
    __libc_start_main(0x1229, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1170 - 0x1199
int64_t deregister_tm_clones(void) {
    // 0x1170
    return &g1;
}

// Address range: 0x11a0 - 0x11d9
int64_t register_tm_clones(void) {
    // 0x11a0
    return 0;
}

// Address range: 0x11e0 - 0x1219
int64_t __do_global_dtors_aux(void) {
    // 0x11e0
    if (*(char *)&g1 != 0) {
        // 0x1218
        int64_t result; // 0x11e0
        return result;
    }
    // 0x11ed
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11fb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1207
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1220 - 0x1229
int64_t frame_dummy(void) {
    // 0x1220
    return register_tm_clones();
}

// Address range: 0x1229 - 0x1734
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x123e
    srand(time(NULL));
    puts(""\n\n***********************"");
    puts(""*     Math Exercises   *"");
    puts(""***********************\n"");
    puts(""1. Addition"");
    puts(""2. Subtraction"");
    puts(""3. Multiplication"");
    puts(""4. Division"");
    puts(""5. Quit"");
    printf(""Enter an option (1-5): "");
    int64_t v2; // bp-120, 0x1229
    scanf(""%d"", &v2);
    int32_t v3 = v2; // 0x1308
    int64_t v4; // 0x1229
    int64_t v5; // 0x1229
    int64_t v6; // 0x1229
    int64_t v7; // 0x1229
    int32_t v8; // 0x1229
    int32_t v9; // 0x1229
    int32_t v10; // 0x1229
    int32_t v11; // 0x1229
    int32_t v12; // 0x1229
    int32_t v13; // 0x1229
    int32_t v14; // 0x13e2
    int64_t v15; // 0x1229
    int64_t v16; // 0x1465
    uint32_t v17; // 0x14e5
    int32_t v18; // 0x135e
    uint32_t v19; // 0x13b2
    int64_t v20; // 0x169c
    int64_t v21; // 0x169c
    int64_t v22; // 0x169c
    int32_t v23; // 0x169c
    int64_t v24; // 0x16a2
    int64_t v25; // 0x16cb
    int64_t v26; // 0x16cb
    int32_t * v27; // 0x1638
    int32_t v28; // 0x1661
    int32_t * v29; // 0x1535
    int32_t v30; // 0x155b
    int32_t * v31; // 0x15a5
    int32_t v32; // 0x1229
    int32_t v33; // 0x133a
    int32_t v34; // 0x1364
    int32_t v35; // 0x138e
    if (v3 < 6) {
        // 0x1328
        v12 = v8;
        if (v3 != 5) {
            // 0x1334
            v33 = rand();
            v34 = rand();
            v35 = rand();
            v14 = rand() % 6 + 5;
            v15 = 16 * (4 * (int64_t)v14 + 15) / 16;
            v16 = (int64_t)&v2 - (v15 & -0x1000) - (v15 & 4080);
            if (v14 > 0) {
                // 0x14a2
                v4 = 0;
                *(int32_t *)(4 * v4 + v16) = rand() % 100 + 1;
                v4++;
                while (v4 != (int64_t)v14) {
                    // 0x14a2
                    *(int32_t *)(4 * v4 + v16) = rand() % 100 + 1;
                    v4++;
                }
            }
            // 0x14e2
            v17 = (int32_t)v2;
            if (v17 == 4) {
                // 0x168e
                v18 = v33 % 100 + 1;
                v19 = v35 % 100 + 1;
                putchar(10);
                v20 = v18;
                v21 = v34 % 100 + 1;
                v22 = (0x100000000 * (int64_t)(v18 >> 31) | v20) / v21;
                v23 = v22;
                v24 = v22 & 0xffffffff;
                printf(""%d / %d = %d\n"", v20, v21, v24);
                v12 = v23;
                if (v19 != 0) {
                    // 0x16c7
                    v25 = v19;
                    v26 = (0x100000000 * (int64_t)(v23 >> 31) | v24) / v25;
                    printf("" / %d = %d\n"", v25, v26 & 0xffffffff);
                    v12 = v26;
                }
            } else {
                // 0x14ee
                v12 = v8;
                if (v17 <= 4) {
                    // 0x14f7
                    v12 = v8;
                    switch (v17) {
                        case 3: {
                            // 0x1614
                            putchar(10);
                            v11 = 1;
                            if (v14 > 0) {
                                // 0x162e
                                v7 = 0;
                                v28 = 1;
                                v27 = (int32_t *)(4 * v7 + v16);
                                printf(""%d * "", (int64_t)*v27);
                                v28 *= *v27;
                                v7++;
                                v11 = v28;
                                while (v7 != (int64_t)v14) {
                                    // 0x162e
                                    v27 = (int32_t *)(4 * v7 + v16);
                                    printf(""%d * "", (int64_t)*v27);
                                    v28 *= *v27;
                                    v7++;
                                    v11 = v28;
                                }
                            }
                            // 0x1673
                            printf("" = %d\n"", (int64_t)v11);
                            v12 = v11;
                            // break -> 0x16f1
                            break;
                        }
                        case 1: {
                            // 0x1518
                            putchar(10);
                            v9 = v8;
                            if (v14 > 0) {
                                // 0x152b
                                v6 = 0;
                                v30 = v8;
                                v29 = (int32_t *)(4 * v6 + v16);
                                printf(""%d + "", (int64_t)*v29);
                                v30 += *v29;
                                v6++;
                                v9 = v30;
                                while (v6 != (int64_t)v14) {
                                    // 0x152b
                                    v29 = (int32_t *)(4 * v6 + v16);
                                    printf(""%d + "", (int64_t)*v29);
                                    v30 += *v29;
                                    v6++;
                                    v9 = v30;
                                }
                            }
                            // 0x156a
                            printf("" = %d\n"", (int64_t)v9);
                            v12 = v9;
                            // break -> 0x16f1
                            break;
                        }
                        case 2: {
                            // 0x1588
                            putchar(10);
                            v10 = v8;
                            if (v14 > 0) {
                                // 0x159b
                                v5 = 0;
                                v13 = v8;
                                v31 = (int32_t *)(4 * v5 + v16);
                                printf(""%d - "", (int64_t)*v31);
                                v32 = *v31;
                                v13 += (v5 % 2 != 0 ? -v32 : v32);
                                v5++;
                                v10 = v13;
                                while (v5 != (int64_t)v14) {
                                    // 0x159b
                                    v31 = (int32_t *)(4 * v5 + v16);
                                    printf(""%d - "", (int64_t)*v31);
                                    v32 = *v31;
                                    v13 += (v5 % 2 != 0 ? -v32 : v32);
                                    v5++;
                                    v10 = v13;
                                }
                            }
                            // 0x15f6
                            printf("" = %d\n"", (int64_t)v10);
                            v12 = v10;
                            // break -> 0x16f1
                            break;
                        }
                    }
                }
            }
        }
    } else {
        // 0x1314
        puts(""\nInvalid option. Please try again."");
        v12 = v8;
    }
    // 0x16f1
    while ((int32_t)v2 != 5) {
        int32_t v36 = v12;
        puts(""\n\n***********************"");
        puts(""*     Math Exercises   *"");
        puts(""***********************\n"");
        puts(""1. Addition"");
        puts(""2. Subtraction"");
        puts(""3. Multiplication"");
        puts(""4. Division"");
        puts(""5. Quit"");
        printf(""Enter an option (1-5): "");
        scanf(""%d"", &v2);
        v3 = v2;
        if (v3 < 6) {
            // 0x1328
            v12 = v36;
            if (v3 != 5) {
                // 0x1334
                v33 = rand();
                v34 = rand();
                v35 = rand();
                v14 = rand() % 6 + 5;
                v15 = 16 * (4 * (int64_t)v14 + 15) / 16;
                v16 = (int64_t)&v2 - (v15 & -0x1000) - (v15 & 4080);
                if (v14 > 0) {
                    // 0x14a2
                    v4 = 0;
                    *(int32_t *)(4 * v4 + v16) = rand() % 100 + 1;
                    v4++;
                    while (v4 != (int64_t)v14) {
                        // 0x14a2
                        *(int32_t *)(4 * v4 + v16) = rand() % 100 + 1;
                        v4++;
                    }
                }
                // 0x14e2
                v17 = (int32_t)v2;
                if (v17 == 4) {
                    // 0x168e
                    v18 = v33 % 100 + 1;
                    v19 = v35 % 100 + 1;
                    putchar(10);
                    v20 = v18;
                    v21 = v34 % 100 + 1;
                    v22 = (0x100000000 * (int64_t)(v18 >> 31) | v20) / v21;
                    v23 = v22;
                    v24 = v22 & 0xffffffff;
                    printf(""%d / %d = %d\n"", v20, v21, v24);
                    v12 = v23;
                    if (v19 != 0) {
                        // 0x16c7
                        v25 = v19;
                        v26 = (0x100000000 * (int64_t)(v23 >> 31) | v24) / v25;
                        printf("" / %d = %d\n"", v25, v26 & 0xffffffff);
                        v12 = v26;
                    }
                } else {
                    // 0x14ee
                    v12 = v36;
                    if (v17 <= 4) {
                        // 0x14f7
                        v12 = v36;
                        switch (v17) {
                            case 3: {
                                // 0x1614
                                putchar(10);
                                v11 = 1;
                                if (v14 > 0) {
                                    // 0x162e
                                    v7 = 0;
                                    v28 = 1;
                                    v27 = (int32_t *)(4 * v7 + v16);
                                    printf(""%d * "", (int64_t)*v27);
                                    v28 *= *v27;
                                    v7++;
                                    v11 = v28;
                                    while (v7 != (int64_t)v14) {
                                        // 0x162e
                                        v27 = (int32_t *)(4 * v7 + v16);
                                        printf(""%d * "", (int64_t)*v27);
                                        v28 *= *v27;
                                        v7++;
                                        v11 = v28;
                                    }
                                }
                                // 0x1673
                                printf("" = %d\n"", (int64_t)v11);
                                v12 = v11;
                                // break -> 0x16f1
                                break;
                            }
                            case 1: {
                                // 0x1518
                                putchar(10);
                                v9 = v36;
                                if (v14 > 0) {
                                    // 0x152b
                                    v6 = 0;
                                    v30 = v36;
                                    v29 = (int32_t *)(4 * v6 + v16);
                                    printf(""%d + "", (int64_t)*v29);
                                    v30 += *v29;
                                    v6++;
                                    v9 = v30;
                                    while (v6 != (int64_t)v14) {
                                        // 0x152b
                                        v29 = (int32_t *)(4 * v6 + v16);
                                        printf(""%d + "", (int64_t)*v29);
                                        v30 += *v29;
                                        v6++;
                                        v9 = v30;
                                    }
                                }
                                // 0x156a
                                printf("" = %d\n"", (int64_t)v9);
                                v12 = v9;
                                // break -> 0x16f1
                                break;
                            }
                            case 2: {
                                // 0x1588
                                putchar(10);
                                v10 = v36;
                                if (v14 > 0) {
                                    // 0x159b
                                    v5 = 0;
                                    v13 = v36;
                                    v31 = (int32_t *)(4 * v5 + v16);
                                    printf(""%d - "", (int64_t)*v31);
                                    v32 = *v31;
                                    v13 += (v5 % 2 != 0 ? -v32 : v32);
                                    v5++;
                                    v10 = v13;
                                    while (v5 != (int64_t)v14) {
                                        // 0x159b
                                        v31 = (int32_t *)(4 * v5 + v16);
                                        printf(""%d - "", (int64_t)*v31);
                                        v32 = *v31;
                                        v13 += (v5 % 2 != 0 ? -v32 : v32);
                                        v5++;
                                        v10 = v13;
                                    }
                                }
                                // 0x15f6
                                printf("" = %d\n"", (int64_t)v10);
                                v12 = v10;
                                // break -> 0x16f1
                                break;
                            }
                        }
                    }
                }
            }
        } else {
            // 0x1314
            puts(""\nInvalid option. Please try again."");
            v12 = v36;
        }
    }
    // 0x16fd
    puts(""\nThanks for using Math Exercises! Goodbye."");
    int64_t result = 0; // 0x171e
    if (v1 != __readfsqword(40)) {
        // 0x1720
        __stack_chk_fail();
        result = &g2;
    }
    // 0x1725
    return result;
}

// Address range: 0x1734 - 0x1741
int64_t _fini(void) {
    // 0x1734
    int64_t result; // 0x1734
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            puts(""\n\n***********************"");
            puts(""*     Math Exercises   *"");
            puts(""***********************\n"");
            puts(""1. Addition"");
            puts(""2. Subtraction"");
            puts(""3. Multiplication"");
            puts(""4. Division"");
            puts(""5. Quit"");
            printf(""Enter an option (1-5): "");
            int option;
            scanf(""%d"", &option);
            int result = 0;
            if (option < 6) {
                switch (option) {
                    case 3: {
                        int a = rand() % 100 + 1;
                        int b = rand() % 100 + 1;
                        putchar(10);
                        printf(""%d * %d = "", a, b);
                        result = a * b;
                        printf(""%d\n"", result);
                        break;
                    }
                    case 1: {
                        int a = rand() % 100 + 1;
                        int b = rand() % 100 + 1;
                        putchar(10);
                        printf(""%d + %d = "", a, b);
                        result = a + b;
                        printf(""%d\n"", result);
                        break;
                    }
                    case 2: {
                        int a = rand() % 100 + 1;
                        int b = rand() % 100 + 1;
                        putchar(10);
                        printf(""%d - %d = "", a, b);
                        result = a - b;
                        printf(""%d\n"", result);
                        break;
                    }
                    case 4: {
                        int a = rand() % 100 + 1;
                        int b = rand() % 100 + 1;
                        putchar(10);
                        printf(""%d / %d = "", a, b);
                        result = a / b;
                        printf(""%d\n"", result);
                        break;
                    }
                }
            } else {
                puts(""\nInvalid option. Please try again."");
            }
            while ((int)option != 5) {
                printf(""\n\n***********************"");
                puts(""*     Math Exercises   *"");
                puts(""***********************\n"");
                puts(""1. Addition"");
                puts(""2. Subtraction"");
                puts(""3. Multiplication"");
                puts(""4. Division"");
                puts(""5. Quit"");
                printf(""Enter an option (1-5): "");
                scanf(""%d"", &option);
                if (option < 6) {
                    switch (option) {
                        case 3: {
                            int a = rand() % 100 + 1;
                            int b = rand() % 100 + 1;
                            putchar(10);
                            printf(""%d * %d = "", a, b);
                            result = a * b;
                            printf(""%d\n"", result);
                            break;
                        }
                        case 1: {
                            int a = rand() % 100 + 1;
                            int b = rand() % 100 + 1;
                            putchar(10);
                            printf(""%d + %d = "", a, b);
                            result = a + b;
                            printf(""%d\n"", result);
                            break;
                        }
                        case 2: {
                            int a = rand() % 100 + 1;
                            int b = rand() % 100 + 1;
                            putchar(10);
                            printf(""%d - %d = "", a, b);
                            result = a - b;
                            printf(""%d\n"", result);
                            break;
                        }
                        case 4: {
                            int a = rand() % 100 + 1;
                            int b = rand() % 100 + 1;
                            putchar(10);
                            printf(""%d / %d = "", a, b);
                            result = a / b;
                            printf(""%d\n"", result);
                            break;
                        }
                    }
                } else {
                    puts(""\nInvalid option. Please try again."");
                }
            }
            puts(""\nThanks for using Math Exercises! Goodbye."");
            return 0;
        }

",2
"//FormAI DATASET v1.0. Category: Memory management ; Style: satisfied
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int* ptr;

    // Allocating memory dynamically using malloc() function
    ptr = (int*) malloc(sizeof(int) * 5);

    // Checking if memory allocation is successful or not
    if (ptr == NULL) 
    {
        printf(""Memory allocation failed\n"");
        exit(1);
    }
    else 
    {
        printf(""Memory allocation successful\n"");
    }

    // Putting element values
    ptr[0] = 1;
    ptr[1] = 5;
    ptr[2] = 10;
    ptr[3] = 15;
    ptr[4] = 20;

    // Printing array values using pointer arithmetic
    printf(""\nArray elements: "");
    for(int i = 0; i < 5; i++)
    {
        printf(""%d "", *(ptr+i));
    }

    // Reallocating memory using realloc() function
    ptr = (int*) realloc(ptr, sizeof(int) * 8);

    // Checking if memory reallocation is successful or not
    if (ptr == NULL) 
    {
        printf(""\nMemory reallocation failed\n"");
        exit(1);
    }
    else 
    {
        printf(""\nMemory reallocation successful\n"");
    }

    // Putting new element values
    ptr[5] = 25;
    ptr[6] = 30;
    ptr[7] = 35;

    // Printing array values including the new element values
    printf(""\nNew array elements: "");
    for(int i = 0; i < 8; i++)
    {
        printf(""%d "", *(ptr+i));
    }

    // Freeing the dynamically allocated memory using free() function
    free(ptr);
    
    printf(""\nMemory freed successfully\n"");

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
void function_10a0(int64_t * ptr);
int32_t function_10b0(char * s);
int32_t function_10c0(char * format, ...);
int64_t * function_10d0(int32_t size);
int64_t * function_10e0(int64_t * ptr, int32_t size);
void function_10f0(int32_t status);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * ptr) {
    // 0x10a0
    free(ptr);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * s) {
    // 0x10b0
    return puts(s);
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
int64_t * function_10d0(int32_t size) {
    // 0x10d0
    return malloc(size);
}

// Address range: 0x10e0 - 0x10eb
int64_t * function_10e0(int64_t * ptr, int32_t size) {
    // 0x10e0
    return realloc(ptr, size);
}

// Address range: 0x10f0 - 0x10fb
void function_10f0(int32_t status) {
    // 0x10f0
    exit(status);
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x11e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g1;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g1 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x13aa
int main(int argc, char ** argv) {
    int64_t * mem = malloc(20); // 0x11fa
    if (mem == NULL) {
        // 0x120a
        puts(""Memory allocation failed"");
        exit(1);
        // UNREACHABLE
    }
    int64_t v1 = (int64_t)mem; // 0x11fa
    puts(""Memory allocation successful"");
    *(int32_t *)mem = 1;
    *(int32_t *)(v1 + 4) = 5;
    *(int32_t *)(v1 + 8) = 10;
    *(int32_t *)(v1 + 12) = 15;
    *(int32_t *)(v1 + 16) = 20;
    printf(""\nArray elements: "");
    for (int64_t i = 0; i < 5; i++) {
        // 0x1291
        printf(""%d "", (int64_t)*(int32_t *)(4 * i + v1));
    }
    int64_t * mem2 = realloc(mem, 32); // 0x12d3
    if (mem2 == NULL) {
        // 0x12e3
        puts(""\nMemory reallocation failed"");
        exit(1);
        // UNREACHABLE
    }
    int64_t v2 = (int64_t)mem2; // 0x12d3
    puts(""\nMemory reallocation successful"");
    *(int32_t *)(v2 + 20) = 25;
    *(int32_t *)(v2 + 24) = 30;
    *(int32_t *)(v2 + 28) = 35;
    printf(""\nNew array elements: "");
    for (int64_t i = 0; i < 8; i++) {
        // 0x1352
        printf(""%d "", (int64_t)*(int32_t *)(4 * i + v2));
    }
    // 0x1388
    free(mem2);
    puts(""\nMemory freed successfully"");
    return 0;
}

// Address range: 0x13ac - 0x13b9
int64_t _fini(void) {
    // 0x13ac
    int64_t result; // 0x13ac
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","nclude <stdio.h>

int main(int argc, char ** argv) {
    int * mem = malloc(20);
    if (mem == NULL) {
        puts(""Memory allocation failed"");
        exit(1);
    }
    puts(""Memory allocation successful"");
    *mem = 1;
    *(mem + 4) = 5;
    *(mem + 8) = 10;
    *(mem + 12) = 15;
    *(mem + 16) = 20;
    printf(""\nArray elements: "");
    for (int i = 0; i < 5; i++) {
        printf(""%d "", *(mem + i));
    }
    int * mem2 = realloc(mem, 32);
    if (mem2 == NULL) {
        puts(""\nMemory reallocation failed"");
        exit(1);
    }
    puts(""\nMemory reallocation successful"");
    *(mem2 + 20) = 25;
    *(mem2 + 24) = 30;
    *(mem2 + 28) = 35;
    printf(""\nNew array elements: "");
    for (int i = 0; i < 8; i++) {
        printf(""%d "", *(mem2 + i));
    }
    free(mem2);
    puts(""\nMemory freed successfully"");
    return 0;
}

",2
"//FormAI DATASET v1.0 Category: Password management ; Style: statistical
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_PASSWORD_LENGTH 50
#define MAX_NUM_USERS 10

typedef struct {
    char username[20];
    char password[MAX_PASSWORD_LENGTH];
} User;

User users[MAX_NUM_USERS];
int numUsers = 0;

// function prototypes
void displayMenu();
void addNewUser();
void changePassword();
void listUsers();
void saveToFile();
void loadFromFile();

int main() {

    loadFromFile(); // load existing users

    while (1) {
        displayMenu();

        int choice;
        scanf(""%d"", &choice);

        switch (choice) {
            case 1:
                addNewUser();
                break;
            case 2:
                changePassword();
                break;
            case 3:
                listUsers();
                break;
            case 4:
                saveToFile();
                printf(""Passwords saved to file.\n"");
                break;
            case 5:
                printf(""Exiting program.\n"");
                exit(0);
            default:
                printf(""Invalid choice. Please try again.\n"");
                break;
        }
    }

    return 0;
}

void displayMenu() {
    printf(""\nPassword Management System\n"");
    printf(""--------------------------\n"");
    printf(""1. Add new user\n"");
    printf(""2. Change password\n"");
    printf(""3. List users\n"");
    printf(""4. Save to file\n"");
    printf(""5. Quit\n"");
    printf(""Enter your choice: "");
}

void addNewUser() {
    if (numUsers >= MAX_NUM_USERS) {
        printf(""Maximum number of users reached.\n"");
        return;
    }

    char username[20];
    char password[MAX_PASSWORD_LENGTH];
    printf(""Enter username: "");
    scanf(""%s"", username);

    // check if username already exists
    for (int i = 0; i < numUsers; i++) {
        if (strcmp(username, users[i].username) == 0) {
            printf(""Username already exists. Please choose another.\n"");
            return;
        }
    }

    printf(""Enter password: "");
    scanf(""%s"", password);

    // add new user to array
    User newUser;
    strcpy(newUser.username, username);
    strcpy(newUser.password, password);
    users[numUsers++] = newUser;
    printf(""User added successfully.\n"");
}

void changePassword() {
    char username[20];
    char currentPassword[MAX_PASSWORD_LENGTH];
    char newPassword[MAX_PASSWORD_LENGTH];

    printf(""Enter username: "");
    scanf(""%s"", username);

    int userIndex = -1;
    for (int i = 0; i < numUsers; i++) {
        if (strcmp(username, users[i].username) == 0) {
            userIndex = i;
            break;
        }
    }

    if (userIndex == -1) {
        printf(""User %s does not exist.\n"", username);
        return;
    }

    printf(""Enter current password: "");
    scanf(""%s"", currentPassword);

    if (strcmp(currentPassword, users[userIndex].password) != 0) {
        printf(""Incorrect password. Please try again.\n"");
        return;
    }

    printf(""Enter new password: "");
    scanf(""%s"", newPassword);
    strcpy(users[userIndex].password, newPassword);
    printf(""Password changed successfully.\n"");
}

void listUsers() {
    if (numUsers == 0) {
        printf(""No users yet.\n"");
        return;
    }

    printf(""List of users:\n"");
    for (int i = 0; i < numUsers; i++) {
        printf(""%s\n"", users[i].username);
    }
}

void saveToFile() {
    FILE* file = fopen(""passwords.txt"", ""w"");
    if (file == NULL) {
        printf(""Unable to open file.\n"");
        return;
    }

    for (int i = 0; i < numUsers; i++) {
        fprintf(file, ""%s %s\n"", users[i].username, users[i].password);
    }

    fclose(file);
}

void loadFromFile() {
    FILE* file = fopen(""passwords.txt"", ""r"");
    if (file == NULL) {
        printf(""Unable to open file.\n"");
        return;
    }

    char username[20];
    char password[MAX_PASSWORD_LENGTH];
    while (fscanf(file, ""%s %s"", username, password) == 2) {
        User newUser;
        strcpy(newUser.username, username);
        strcpy(newUser.password, password);
        users[numUsers++] = newUser;
    }

    fclose(file);
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t addNewUser(void);
int64_t changePassword(void);
int64_t deregister_tm_clones(void);
int64_t displayMenu(void);
int64_t frame_dummy(void);
void function_10e0(int64_t * d);
char * function_10f0(char * dest, char * src);
int32_t function_1100(struct _IO_FILE * stream, char * format, ...);
int32_t function_1110(char * s);
int32_t function_1120(struct _IO_FILE * stream);
void function_1130(void);
int32_t function_1140(char * format, ...);
int32_t function_1150(char * s1, char * s2);
int32_t function_1160(struct _IO_FILE * stream, char * format, ...);
struct _IO_FILE * function_1170(char * filename, char * modes);
int32_t function_1180(char * format, ...);
void function_1190(int32_t status);
int64_t listUsers(void);
int64_t loadFromFile(void);
int64_t register_tm_clones(void);
int64_t saveToFile(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xd5d00000d06; // 0x205c
char g2 = 0; // 0x4020
char * g3; // 0x4040
int128_t g4; // 0x42fc
int32_t g5; // 0x42fd
int32_t g6;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g6;
    }
    // 0x1016
    return result;
}

// Address range: 0x10e0 - 0x10eb
void function_10e0(int64_t * d) {
    // 0x10e0
    __cxa_finalize(d);
}

// Address range: 0x10f0 - 0x10fb
char * function_10f0(char * dest, char * src) {
    // 0x10f0
    return strcpy(dest, src);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(struct _IO_FILE * stream, char * format, ...) {
    // 0x1100
    return fscanf(stream, format);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(char * s) {
    // 0x1110
    return puts(s);
}

// Address range: 0x1120 - 0x112b
int32_t function_1120(struct _IO_FILE * stream) {
    // 0x1120
    return fclose(stream);
}

// Address range: 0x1130 - 0x113b
void function_1130(void) {
    // 0x1130
    __stack_chk_fail();
}

// Address range: 0x1140 - 0x114b
int32_t function_1140(char * format, ...) {
    // 0x1140
    return printf(format);
}

// Address range: 0x1150 - 0x115b
int32_t function_1150(char * s1, char * s2) {
    // 0x1150
    return strcmp(s1, s2);
}

// Address range: 0x1160 - 0x116b
int32_t function_1160(struct _IO_FILE * stream, char * format, ...) {
    // 0x1160
    return fprintf(stream, format);
}

// Address range: 0x1170 - 0x117b
struct _IO_FILE * function_1170(char * filename, char * modes) {
    // 0x1170
    return fopen(filename, modes);
}

// Address range: 0x1180 - 0x118b
int32_t function_1180(char * format, ...) {
    // 0x1180
    return scanf(format);
}

// Address range: 0x1190 - 0x119b
void function_1190(int32_t status) {
    // 0x1190
    exit(status);
}

// Address range: 0x11a0 - 0x11c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x11a0
    int64_t v1; // 0x11a0
    __libc_start_main(0x1289, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x11d0 - 0x11f9
int64_t deregister_tm_clones(void) {
    // 0x11d0
    return 0x4010;
}

// Address range: 0x1200 - 0x1239
int64_t register_tm_clones(void) {
    // 0x1200
    return 0;
}

// Address range: 0x1240 - 0x1279
int64_t __do_global_dtors_aux(void) {
    // 0x1240
    if (g2 != 0) {
        // 0x1278
        int64_t result; // 0x1240
        return result;
    }
    // 0x124d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x125b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1267
    g2 = 1;
    return result2;
}

// Address range: 0x1280 - 0x1289
int64_t frame_dummy(void) {
    // 0x1280
    return register_tm_clones();
}

// Address range: 0x1289 - 0x136b
int main(int argc, char ** argv) {
    // 0x1289
    __readfsqword(40);
    loadFromFile();
    displayMenu();
    int64_t v1; // bp-20, 0x1289
    scanf(""%d"", &v1);
    uint32_t v2; // 0x12ec
    if ((int32_t)v1 < 6) {
        // 0x12db
        v2 = *(int32_t *)((4 * v1 & 0x3fffffffc) + (int64_t)&g1);
        return (int64_t)v2 + (int64_t)&g1;
    }
    puts(""Invalid choice. Please try again."");
    displayMenu();
    scanf(""%d"", &v1);
    while ((int32_t)v1 >= 6) {
        // 0x1356
        puts(""Invalid choice. Please try again."");
        displayMenu();
        scanf(""%d"", &v1);
    }
    // 0x12db
    v2 = *(int32_t *)((4 * v1 & 0x3fffffffc) + (int64_t)&g1);
    return (int64_t)v2 + (int64_t)&g1;
}

// Address range: 0x136b - 0x13f3
int64_t displayMenu(void) {
    // 0x136b
    puts(""\nPassword Management System"");
    puts(""--------------------------"");
    puts(""1. Add new user"");
    puts(""2. Change password"");
    puts(""3. List users"");
    puts(""4. Save to file"");
    puts(""5. Quit"");
    return printf(""Enter your choice: "");
}

// Address range: 0x13f3 - 0x15d1
int64_t addNewUser(void) {
    int64_t v1 = __readfsqword(40); // 0x1403
    if (*(int32_t *)0x42fc < 10) {
        // 0x1431
        printf(""Enter username: "");
        int64_t str2; // bp-120, 0x13f3
        scanf(""%s"", &str2);
        int64_t v2 = 0; // 0x14bc
        int32_t v3 = 0; // 0x14bc
        if (*(int32_t *)&g4 == 0) {
          lab_0x14be:
            // 0x14be
            printf(""Enter password: "");
            int64_t str4; // bp-88, 0x13f3
            scanf(""%s"", &str4);
            int64_t str; // bp-200, 0x13f3
            strcpy((char *)&str, (char *)&str2);
            int64_t str3; // bp-180, 0x13f3
            strcpy((char *)&str3, (char *)&str4);
            *(int32_t *)&g4 = (int32_t)&g5;
            int64_t v4 = 70 * (int64_t)*(int32_t *)&g4; // 0x152e
            *(int64_t *)(v4 + (int64_t)&g3) = str;
            puts(""User added successfully."");
        } else {
            while (strcmp((char *)&str2, (char *)(70 * v2 + (int64_t)&g3)) != 0) {
                int32_t v5 = v3 + 1; // 0x14a9
                int64_t v6 = v5;
                v2 = v6;
                v3 = v5;
                if (v6 >= (int64_t)*(int32_t *)&g4) {
                    goto lab_0x14be;
                }
            }
            // 0x1495
            puts(""Username already exists. Please choose another."");
        }
    } else {
        // 0x141d
        puts(""Maximum number of users reached."");
    }
    int64_t result = 0; // 0x15c4
    if (v1 != __readfsqword(40)) {
        // 0x15c6
        __stack_chk_fail();
        result = &g6;
    }
    // 0x15cb
    return result;
}

// Address range: 0x15d1 - 0x17a4
int64_t changePassword(void) {
    int64_t v1 = __readfsqword(40); // 0x15e0
    printf(""Enter username: "");
    int64_t str; // bp-168, 0x15d1
    scanf(""%s"", &str);
    if (*(int32_t *)&g4 == 0) {
        // 0x168f
        printf(""User %s does not exist.\n"", &str);
        goto lab_0x178e;
    } else {
        int32_t v2 = 0;
        int64_t v3 = 0; // 0x163f
        while (strcmp((char *)&str, (char *)(v3 + (int64_t)&g3)) != 0) {
            int32_t v4 = v2 + 1; // 0x1671
            int64_t v5 = v4;
            if (v5 >= (int64_t)*(int32_t *)&g4) {
                // 0x168f
                printf(""User %s does not exist.\n"", &str);
                goto lab_0x178e;
            }
            v2 = v4;
            v3 = 70 * v5;
        }
        if (v2 != -1) {
            // 0x16b2
            printf(""Enter current password: "");
            int64_t str2; // bp-136, 0x15d1
            scanf(""%s"", &str2);
            char * str3 = (char *)(v3 + (int64_t)&g3 + 20); // 0x1709
            if (strcmp((char *)&str2, str3) == 0) {
                // 0x1723
                printf(""Enter new password: "");
                int64_t str4; // bp-72, 0x15d1
                scanf(""%s"", &str4);
                strcpy(str3, (char *)&str4);
                puts(""Password changed successfully."");
            } else {
                // 0x1712
                puts(""Incorrect password. Please try again."");
            }
            goto lab_0x178e;
        } else {
            // 0x168f
            printf(""User %s does not exist.\n"", &str);
            goto lab_0x178e;
        }
    }
  lab_0x178e:;
    int64_t result = 0; // 0x179b
    if (v1 != __readfsqword(40)) {
        // 0x179d
        __stack_chk_fail();
        result = &g6;
    }
    // 0x17a2
    return result;
}

// Address range: 0x17a4 - 0x180f
int64_t listUsers(void) {
    // 0x17a4
    if (*(int32_t *)&g4 == 0) {
        // 0x180d
        return puts(""No users yet."");
    }
    // 0x17cb
    puts(""List of users:"");
    if (*(int32_t *)&g4 == 0) {
        // 0x180d
        return 0;
    }
    int32_t v1 = 0; // 0x180b
    puts((char *)(int64_t)&g3);
    v1++;
    int64_t v2 = v1;
    int64_t result = (int64_t)*(int32_t *)&g4; // 0x1802
    while (v2 < result) {
        // 0x17e3
        puts((char *)(70 * v2 + (int64_t)&g3));
        v1++;
        v2 = v1;
        result = (int64_t)*(int32_t *)&g4;
    }
    // 0x180d
    return result;
}

// Address range: 0x180f - 0x18bc
int64_t saveToFile(void) {
    struct _IO_FILE * file = fopen(""passwords.txt"", ""w""); // 0x182f
    if (file == NULL) {
        // 0x18ba
        return puts(""Unable to open file."");
    }
    int32_t v1 = 0; // 0x18ac
    if (*(int32_t *)&g4 != 0) {
        int64_t v2 = 0; // 0x185e
        fprintf(file, ""%s %s\n"", (char *)(v2 + (int64_t)&g3), (char *)(v2 + (int64_t)&g3 + 20));
        v1++;
        int64_t v3 = v1;
        while (v3 < (int64_t)*(int32_t *)&g4) {
            // 0x1859
            v2 = 70 * v3;
            fprintf(file, ""%s %s\n"", (char *)(v2 + (int64_t)&g3), (char *)(v2 + (int64_t)&g3 + 20));
            v1++;
            v3 = v1;
        }
    }
    // 0x18ba
    return fclose(file);
}

// Address range: 0x18bc - 0x1a2d
int64_t loadFromFile(void) {
    int64_t v1 = __readfsqword(40); // 0x18cc
    struct _IO_FILE * file = fopen(""passwords.txt"", ""r""); // 0x18ef
    if (file != NULL) {
        // 0x19d8
        int64_t str2; // bp-120, 0x18bc
        int64_t str4; // bp-88, 0x18bc
        if (fscanf(file, ""%s %s"", &str2, &str4) == 2) {
            int64_t str; // bp-200, 0x18bc
            strcpy((char *)&str, (char *)&str2);
            int64_t str3; // bp-180, 0x18bc
            strcpy((char *)&str3, (char *)&str4);
            *(int32_t *)&g4 = (int32_t)&g5;
            int64_t v2 = 70 * (int64_t)*(int32_t *)&g4; // 0x195e
            *(int64_t *)(v2 + (int64_t)&g3) = str;
            while (fscanf(file, ""%s %s"", &str2, &str4) == 2) {
                // 0x191d
                strcpy((char *)&str, (char *)&str2);
                strcpy((char *)&str3, (char *)&str4);
                *(int32_t *)&g4 = (int32_t)&g5;
                v2 = 70 * (int64_t)*(int32_t *)&g4;
                *(int64_t *)(v2 + (int64_t)&g3) = str;
            }
        }
        // 0x1a04
        fclose(file);
    } else {
        // 0x1909
        puts(""Unable to open file."");
    }
    int64_t result = 0; // 0x1a20
    if (v1 != __readfsqword(40)) {
        // 0x1a22
        __stack_chk_fail();
        result = &g6;
    }
    // 0x1a27
    return result;
}

// Address range: 0x1a30 - 0x1a3d
int64_t _fini(void) {
    // 0x1a30
    int64_t result; // 0x1a30
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 26

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        // ---------------- Integer Types Definitions -----------------

        typedef int64_t int128_t;

        // ------------------------ Structures ------------------------

        struct _IO_FILE {
            int32_t e0;
        };

        // ------------------- Function Prototypes --------------------

        int64_t __do_global_dtors_aux(void);
        int64_t _fini(void);
        int64_t _init(void);
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
        int64_t addNewUser(void);
        int64_t changePassword(void);
        int64_t deregister_tm_clones(void);
        int64_t displayMenu(void);
        int64_t frame_dummy(void);
        void function_10e0(int64_t * d);
        char * function_10f0(char * dest, char * src);
        int32_t function_1100(struct _IO_FILE * stream, char * format, ...);
        int32_t function_1110(char * s);
        int32_t function_1120(struct _IO_FILE * stream);
        void function_1130(void);
        int32_t function_1140(char * format, ...);
        int32_t function_1150(char * s1, char * s2);
        int32_t function_1160(struct _IO_FILE * stream, char * format, ...);
        struct _IO_FILE * function_1170(char * filename, char * modes);
        int32_t function_1180(char * format, ...);
        void function_1190(int32_t status);
        int64_t listUsers(void);
        int64_t loadFromFile(void);
        int64_t register_tm_clones(void);
        int64_t saveToFile(void);

        // --------------------- Global Variables ---------------------

        int64_t g1 = -0xd5d00000d06; // 0x205c
        char g2 = 0; // 0x4020
        char * g3; // 0x4040
        int128_t g4; // 0x42fc
        int32_t g5; // 0x42fd
        int32_t g6;

        // ------- Dynamically Linked Functions Without Header --------

        void __cxa_finalize(int64_t * a1);
        void __gmon_start__(void);
        int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
        void __stack_chk_fail(void);

        // ------------------------ Functions -------------------------

        // Address range: 0x1000 - 0x101b
        int64_t _init(void) {
            int64_t result = 0; // 0x1012
            if (*(int64_t *)0x3fe8 != 0) {
                // 0x1014
                __gmon_start__();
                result = &g6;
            }
            // 0x1016
            return result;
        }

        // Address range: 0x10e0 - 0x10eb
        void function_10e0(int64_t * d) {
            // 0x10e0
            __cxa_finalize(d);
        }

        // Address range: 0x10f0 - 0x10fb
        char * function_10f0(char * dest, char * src) {
            // 0x10f0
            return strcpy(dest, src);
        }

        // Address range: 0x1100 - 0x110b
        int32_t function_1100(struct _IO_FILE * stream, char * format, ...) {
            // 0x1100
            return fscanf(stream, format);
        }

        // Address range: 0x1110 - 0x111b
        int32_t function_1110(char * s) {
            // 0x1110
            return puts(s);
        }

        // Address range: 0x1120 - 0x112b
        int32_t function_1120(struct _IO_FILE * stream) {
            // 0x1120
            return fclose(stream);
        }

        // Address range: 0x1130 - 0x113b
        void function_1130(void) {
            // 0x1130
            __stack_chk_fail();
        }

        // Address range: 0x1140 - 0x114b
        int32_t function_1140(char * format, ...) {
            // 0x1140
            return printf(format);
        }

        // Address range: 0x1150 - 0x115b
        int32_t function_1150(char * s1, char * s2) {
            // 0x1150
            return strcmp(s1, s2);
        }

        // Address range: 0x1160 - 0x116b
        int32_t function_1160(struct _IO_FILE * stream, char * format, ...) {
            // 0x1160
            return fprintf(stream, format);
        }

        // Address range: 0x1170 - 0x117b
        struct _IO_FILE * function_1170(char * filename, char * modes) {
            // 0x1170
            return fopen(filename, modes);
        }

        // Address range: 0x1180 - 0x118b
        int32_t function_1180(char * format, ...) {
            // 0x1180
            return scanf(format);
        }

        // Address range: 0x1190 - 0x119b
        void function_1190(int32_t status) {
            // 0x1190
            exit(status);
        }

        // Address range: 0x11a0 - 0x11c6
        int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
            // 0x11a0
            int64_t v1; // 0x11a0
            __libc_start_main(0x1289, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
            __asm_hlt();
            // UNREACHABLE
        }

        // Address range: 0x11d0 - 0x11f9
        int64_t deregister_tm_clones(void) {
            // 0x11d0
            return 0x4010;
        }

        // Address range: 0x1200 - 0x1239
     ",0
"//FormAI DATASET v1.0 Category: Elevator Simulation ; Style: sophisticated
#include <stdio.h>

int main()
{
  int currentFloor = 0;
  int requestedFloor;
  int direction = 0; // 0 = stationary, 1 = up, 2 = down

  printf(""Welcome to the elevator!\n"");

  while(1)
  {
    printf(""You are currently on floor %d.\n"", currentFloor);
    printf(""Which floor would you like to go to? (Enter -1 to exit)\n"");
    scanf(""%d"", &requestedFloor);

    if(requestedFloor == -1)
      break;

    if(requestedFloor == currentFloor)
      printf(""You are already on that floor.\n"");

    else if(requestedFloor > currentFloor)
    {
      direction = 1;
      printf(""Going up...\n"");

      // Travel up to requested floor
      while(currentFloor != requestedFloor)
      {
        currentFloor++;
        printf(""Floor %d...\n"", currentFloor);
      }

      printf(""You have arrived at floor %d.\n"", currentFloor);
      direction = 0;
    }

    else if(requestedFloor < currentFloor)
    {
      direction = 2;
      printf(""Going down...\n"");

      // Travel down to requested floor
      while(currentFloor != requestedFloor)
      {
        currentFloor--;
        printf(""Floor %d...\n"", currentFloor);
      }

      printf(""You have arrived at floor %d.\n"", currentFloor);
      direction = 0;
    }

    else // Invalid input
      printf(""Invalid input.\n"");
  }

  printf(""Thank you for using the elevator."");
  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1361
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    puts(""Welcome to the elevator!"");
    printf(""You are currently on floor %d.\n"", 0);
    puts(""Which floor would you like to go to? (Enter -1 to exit)"");
    int64_t v2; // bp-28, 0x11a9
    scanf(""%d"", &v2);
    int32_t v3 = v2; // 0x1224
    int32_t v4 = v3; // 0x122a
    int64_t v5 = 0; // 0x122a
    int32_t v6 = 0; // 0x122a
    int64_t v7; // 0x11a9
    int64_t v8; // 0x11a9
    int32_t v9; // 0x11a9
    int32_t v10; // 0x11a9
    if (v3 != -1) {
        while (true) {
          lab_0x1230:;
            int32_t v11 = v6;
            int64_t v12 = v5;
            int64_t v13 = v11;
            int32_t v14 = v4; // 0x1224
            while (true) {
                // 0x1230
                if (v11 != v14) {
                    int64_t v15 = v2 & 0xffffffff; // 0x1249
                    if (v15 > v13) {
                        // break -> 0x1251
                        break;
                    }
                    if (v15 < v13) {
                        // 0x12bb
                        puts(""Going down..."");
                        v9 = v11;
                        if (v11 != (int32_t)v2) {
                            goto lab_0x12d3;
                        } else {
                            // 0x12bb
                            v7 = v11;
                            v10 = v11;
                            goto lab_0x12f8;
                        }
                    }
                    // 0x131d
                    puts(""Invalid input."");
                } else {
                    // 0x1238
                    puts(""You are already on that floor."");
                }
                // 0x11e1
                printf(""You are currently on floor %d.\n"", v12);
                puts(""Which floor would you like to go to? (Enter -1 to exit)"");
                scanf(""%d"", &v2);
                v14 = v2;
                if (v14 == -1) {
                    // break (via goto) -> 0x1331
                    goto lab_0x1331_2;
                }
            }
            // 0x1251
            puts(""Going up..."");
            int32_t v16 = v11; // 0x128c
            int64_t v17; // 0x11a9
            int32_t v18; // 0x11a9
            if (v11 != (int32_t)v2) {
                int32_t v19 = v16 + 1; // 0x1269
                int64_t v20 = v19;
                printf(""Floor %d...\n"", v20);
                v16 = v19;
                v17 = v20;
                v18 = v19;
                while (v19 != (int32_t)v2) {
                    // 0x1269
                    v19 = v16 + 1;
                    v20 = v19;
                    printf(""Floor %d...\n"", v20);
                    v16 = v19;
                    v17 = v20;
                    v18 = v19;
                }
            } else {
                // 0x1251
                v17 = v11;
                v18 = v11;
            }
            // 0x128e
            printf(""You have arrived at floor %d.\n"", v17);
            v8 = v17;
            v6 = v18;
            goto lab_0x11e1;
        }
    }
  lab_0x1331_2:
    // 0x1331
    printf(""Thank you for using the elevator."");
    int64_t result = 0; // 0x1358
    if (v1 != __readfsqword(40)) {
        // 0x135a
        __stack_chk_fail();
        result = &g2;
    }
    // 0x135f
    return result;
  lab_0x11e1:
    // 0x11e1
    v5 = v8;
    printf(""You are currently on floor %d.\n"", v5);
    puts(""Which floor would you like to go to? (Enter -1 to exit)"");
    scanf(""%d"", &v2);
    v4 = v2;
    if (v4 == -1) {
        // break -> 0x1331
        goto lab_0x1331_2;
    }
    goto lab_0x1230;
  lab_0x12d3:;
    int32_t v21 = v9 - 1; // 0x12d3
    int64_t v22 = v21;
    printf(""Floor %d...\n"", v22);
    v9 = v21;
    v7 = v22;
    v10 = v21;
    if (v21 != (int32_t)v2) {
        goto lab_0x12d3;
    } else {
        goto lab_0x12f8;
    }
  lab_0x12f8:
    // 0x12f8
    printf(""You have arrived at floor %d.\n"", v7);
    v8 = v7;
    v6 = v10;
    goto lab_0x11e1;
}

// Address range: 0x1364 - 0x1371
int64_t _fini(void) {
    // 0x1364
    int64_t result; // 0x1364
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>
        #include <stdbool.h>

        int main(int argc, char ** argv) {
            puts(""Welcome to the elevator!"");
            printf(""You are currently on floor %d.\n"", 0);
            puts(""Which floor would you like to go to? (Enter -1 to exit)"");
            int floor;
            scanf(""%d"", &floor);
            int32_t v1 = floor;
            int32_t v2 = v1;
            int64_t v3 = 0;
            int32_t v4 = 0;
            int64_t v5 = 0;
            int32_t v6 = 0;
            int64_t v7;
            int64_t v8;
            int32_t v9;
            int32_t v10;
            if (v1 != -1) {
                while (true) {
                  lab_0x1230:;
                    int32_t v11 = v6;
                    int64_t v12 = v5;
                    int64_t v13 = v11;
                    int32_t v14 = v4;
                    while (true) {
                        // 0x1230
                        if (v11 != v14) {
                            int64_t v15 = v2 & 0xffffffff;
                            if (v15 > v13) {
                                // break -> 0x1251
                                break;
                            }
                            if (v15 < v13) {
                                // 0x12bb
                                puts(""Going down..."");
                                v9 = v11;
                                if (v11 != (int32_t)v2) {
                                    goto lab_0x12d3;
                                } else {
                                    // 0x12bb
                                    v7 = v11;
                                    v10 = v11;
                                    goto lab_0x12f8;
                                }
                            }
                            // 0x131d
                            puts(""Invalid input."");
                        } else {
                            // 0x1238
                            puts(""You are already on that floor."");
                        }
                        // 0x11e1
                        printf(""You are currently on floor %d.\n"", v12);
                        puts(""Which floor would you like to go to? (Enter -1 to exit)"");
                        scanf(""%d"", &v2);
                        v14 = v2;
                        if (v14 == -1) {
                            // break (via goto) -> 0x1331
                            goto lab_0x1331_2;
                        }
                    }
                    // 0x1251
                    puts(""Going up..."");
                    int32_t v16 = v11;
                    int64_t v17;
                    int32_t v18;
                    if (v11 != (int32_t)v2) {
                        int32_t v19 = v16 + 1;
                        int64_t v20 = v19;
                        printf(""Floor %d...\n"", v20);
                        v16 = v19;
                        v17 = v20;
                        v18 = v19;
                        while (v19 != (int32_t)v2) {
                            // 0x1269
                            v19 = v16 + 1;
                            v20 = v19;
                            printf(""Floor %d...\n"", v20);
                            v16 = v19;
                            v17 = v20;
                            v18 = v19;
                        }
                    } else {
                        // 0x1251
                        v17 = v11;
                        v18 = v11;
                    }
                    // 0x128e
                    printf(""You have arrived at floor %d.\n"", v17);
                    v8 = v17;
                    v6 = v18;
                    goto lab_0x11e1;
                }
            }
          lab_0x1331_2:
            // 0x1331
            printf(""Thank you for using the elevator."");
            int64_t result = 0;
            if (v3 != __readfsqword(40)) {
                // 0x135a
                __stack_chk_fail();
                result = &g2;
            }
            // 0x135f
            return result;
          lab_0x11e1:
            // 0x11e1
            v5 = v8;
            printf(""You are currently on floor %d.\n"", v5);
            puts(""Which floor would you like to go to? (Enter -1 to exit)"");
            scanf(""%d"", &v2);
            v4 = v2;
            if (v4 == -1) {
                // break -> 0x1331
                goto lab_0x1331_2;
            }
            goto lab_0x1230;
          lab_0x12d3:;
            int32_t v21 = v9 - 1;
            int64_t v22 = v21;
            printf(""Floor %d...\n"", v22);
            v9 = v21;
            v7 = v22;
            v10 = v21;
            if (v21 != (int32_t)v2) {
                goto lab_0x12d3;
            } else {
                goto lab_0x12f8;
            }
          lab_0x12f8:
            // 0x12f8
            printf(""You have arrived at floor %d.\n"", v7);
            v8 = v7;
            v6 = v10;
            goto lab_0x11e1;
        }

",1
"//FormAI DATASET v1.0 Category: Product Inventory System ; Style: modular
#include <stdio.h>
#include <string.h>

// Define a Product structure
struct Product {
    int id;
    char name[50];
    int quantity;
};

// Declare global variables
struct Product inventory[100];
int count = 0;

// Declare function prototypes
void add_product();
void remove_product();
void update_quantity();
void display_inventory();

int main() {
    int choice;
    do {
        printf(""\n===== Product Inventory System =====\n"");
        printf(""| 1. Add a Product                  |\n"");
        printf(""| 2. Remove a Product               |\n"");
        printf(""| 3. Update Quantity of a Product   |\n"");
        printf(""| 4. Display Inventory              |\n"");
        printf(""| 5. Exit                           |\n"");
        printf(""====================================\n"");
        printf(""Enter your choice: "");
        scanf(""%d"", &choice);
        switch(choice) {
            case 1:
                add_product();
                break;
            case 2:
                remove_product();
                break;
            case 3:
                update_quantity();
                break;
            case 4:
                display_inventory();
                break;
            case 5:
                printf(""\nThank you for using Product Inventory System!\n"");
                break;
            default:
                printf(""\nInvalid choice. Please try again.\n"");
        }
    } while (choice != 5);
    return 0;
}

// Function to add a product
void add_product() {
    struct Product p;
    printf(""\nEnter Product ID: "");
    scanf(""%d"", &p.id);
    printf(""Enter Product Name: "");
    scanf(""%s"", p.name);
    printf(""Enter Product Quantity: "");
    scanf(""%d"", &p.quantity);
    inventory[count] = p;
    count++;
    printf(""\nProduct added successfully!\n"");
}

// Function to remove a product
void remove_product() {
    int id, flag = 0, i;
    printf(""\nEnter Product ID to remove: "");
    scanf(""%d"", &id);
    for (i = 0; i < count; i++) {
        if (inventory[i].id == id) {
            inventory[i] = inventory[count - 1];
            count--;
            flag = 1;
        }
    }
    if (flag == 1) {
        printf(""\nProduct removed successfully!\n"");
    } else {
        printf(""\nProduct not found.\n"");
    }
}

// Function to update quantity of a product
void update_quantity() {
    int id, quantity, flag = 0, i;
    printf(""\nEnter Product ID to update quantity: "");
    scanf(""%d"", &id);
    for (i = 0; i < count; i++) {
        if (inventory[i].id == id) {
            printf(""Enter new quantity: "");
            scanf(""%d"", &quantity);
            inventory[i].quantity = quantity;
            flag = 1;
        }
    }
    if (flag == 1) {
        printf(""\nQuantity updated successfully!\n"");
    } else {
        printf(""\nProduct not found.\n"");
    }
}

// Function to display inventory
void display_inventory() {
    printf(""\n===== Product Inventory =====\n"");
    printf(""| ID\t| Name\t\t| Quantity\t|\n"");
    printf(""===============================\n"");
    for (int i = 0; i < count; i++) {
        printf(""| %d\t| %s\t| %d\t\t|\n"", inventory[i].id, inventory[i].name, inventory[i].quantity);
    }
    printf(""===============================\n"");
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t add_product(void);
int64_t deregister_tm_clones(void);
int64_t display_inventory(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(char * s);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);
int64_t remove_product(void);
int64_t update_quantity(void);

// --------------------- Global Variables ---------------------

int64_t g1 = -0xf0400000ec4; // 0x218c
char g2 = 0; // 0x4020
int64_t g3 = 0; // 0x4040
int64_t g4 = 0; // 0x4078
int32_t g5 = 0; // 0x57af
int32_t g6 = 0; // 0x57b0
int32_t g7 = 0; // 0x57b1
int32_t g8;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g8;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * s) {
    // 0x1080
    return puts(s);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return 0x4010;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (g2 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    g2 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x12fe
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    puts(""\n===== Product Inventory System ====="");
    puts(""| 1. Add a Product                  |"");
    puts(""| 2. Remove a Product               |"");
    puts(""| 3. Update Quantity of a Product   |"");
    puts(""| 4. Display Inventory              |"");
    puts(""| 5. Exit                           |"");
    puts(""===================================="");
    printf(""Enter your choice: "");
    int64_t v2; // bp-20, 0x11a9
    scanf(""%d"", &v2);
    while ((int32_t)v2 >= 6) {
        // 0x12c8
        puts(""\nInvalid choice. Please try again."");
        if ((int32_t)v2 == 5) {
            // 0x12e3
            if (v1 == __readfsqword(40)) {
                // 0x12fc
                return 0;
            }
            // 0x12f7
            __stack_chk_fail();
            // 0x12fc
            return &g8;
        }
        puts(""\n===== Product Inventory System ====="");
        puts(""| 1. Add a Product                  |"");
        puts(""| 2. Remove a Product               |"");
        puts(""| 3. Update Quantity of a Product   |"");
        puts(""| 4. Display Inventory              |"");
        puts(""| 5. Exit                           |"");
        puts(""===================================="");
        printf(""Enter your choice: "");
        scanf(""%d"", &v2);
    }
    int32_t v3 = *(int32_t *)((4 * v2 & 0x3fffffffc) + (int64_t)&g1); // 0x1275
    return (int64_t)v3 + (int64_t)&g1;
}

// Address range: 0x12fe - 0x144e
int64_t add_product(void) {
    int64_t v1 = __readfsqword(40); // 0x130b
    printf(""\nEnter Product ID: "");
    int64_t v2; // bp-104, 0x12fe
    scanf(""%d"", &v2);
    printf(""Enter Product Name: "");
    int64_t v3; // bp-100, 0x12fe
    scanf(""%s"", &v3);
    printf(""Enter Product Quantity: "");
    int64_t v4; // bp-48, 0x12fe
    scanf(""%d"", &v4);
    int64_t v5 = 60 * (int64_t)g6; // 0x13c2
    *(int64_t *)(v5 + (int64_t)&g3) = v2;
    *(int32_t *)(v5 + (int64_t)&g3 + 56) = (int32_t)v4;
    g6 = &g7;
    puts(""\nProduct added successfully!"");
    int64_t result = 0; // 0x1441
    if (v1 != __readfsqword(40)) {
        // 0x1443
        __stack_chk_fail();
        result = &g8;
    }
    // 0x1448
    return result;
}

// Address range: 0x144e - 0x15cb
int64_t remove_product(void) {
    int64_t v1 = __readfsqword(40); // 0x145a
    printf(""\nEnter Product ID to remove: "");
    int64_t v2; // bp-28, 0x144e
    scanf(""%d"", &v2);
    int32_t v3 = 0; // 0x1588
    if (g6 == 0) {
        // 0x15a5
        puts(""\nProduct not found."");
        goto lab_0x15b4;
    } else {
        int64_t v4 = 0; // 0x14bb
        int64_t v5 = v4 + (int64_t)&g3; // 0x14c9
        int32_t v6 = g6; // 0x14d1
        int32_t v7 = 0; // 0x14d1
        int64_t v8; // 0x1519
        int64_t v9; // 0x151d
        int64_t v10; // 0x152b
        int64_t v11; // 0x1530
        int64_t v12; // 0x153f
        int64_t v13; // 0x1544
        int64_t v14; // 0x1553
        int32_t v15; // 0x155d
        if (*(int32_t *)v5 == (int32_t)v2) {
            // 0x14d7
            v8 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + (int64_t)&g3);
            v9 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 8 + (int64_t)&g3);
            *(int64_t *)v5 = v8;
            *(int64_t *)(v4 + (int64_t)&g3 + 8) = v9;
            v10 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 16 + (int64_t)&g3);
            v11 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 24 + (int64_t)&g3);
            *(int64_t *)(v4 + (int64_t)&g3 + 16) = v10;
            *(int64_t *)(v4 + (int64_t)&g3 + 24) = v11;
            v12 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 32 + (int64_t)&g3);
            v13 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 40 + (int64_t)&g3);
            *(int64_t *)(v4 + (int64_t)&g3 + 32) = v12;
            *(int64_t *)(v4 + (int64_t)&g3 + 40) = v13;
            v14 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 48 + (int64_t)&g3);
            *(int64_t *)(v4 + (int64_t)&g3 + 48) = v14;
            v15 = *(int32_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 56 + (int64_t)&g3);
            *(int32_t *)(v4 + (int64_t)&g3 + 56) = v15;
            v6 = g6 - 1;
            g6 = v6;
            v7 = 1;
        }
        int32_t v16 = v7;
        int32_t v17 = v6; // 0x157f
        v3++;
        int64_t v18 = v3; // 0x1588
        while (v18 < (int64_t)v17) {
            // 0x14ab
            v4 = 60 * v18;
            v5 = v4 + (int64_t)&g3;
            v6 = v17;
            v7 = v16;
            if (*(int32_t *)v5 == (int32_t)v2) {
                // 0x14d7
                v8 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + (int64_t)&g3);
                v9 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 8 + (int64_t)&g3);
                *(int64_t *)v5 = v8;
                *(int64_t *)(v4 + (int64_t)&g3 + 8) = v9;
                v10 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 16 + (int64_t)&g3);
                v11 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 24 + (int64_t)&g3);
                *(int64_t *)(v4 + (int64_t)&g3 + 16) = v10;
                *(int64_t *)(v4 + (int64_t)&g3 + 24) = v11;
                v12 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 32 + (int64_t)&g3);
                v13 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 40 + (int64_t)&g3);
                *(int64_t *)(v4 + (int64_t)&g3 + 32) = v12;
                *(int64_t *)(v4 + (int64_t)&g3 + 40) = v13;
                v14 = *(int64_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 48 + (int64_t)&g3);
                *(int64_t *)(v4 + (int64_t)&g3 + 48) = v14;
                v15 = *(int32_t *)(4 * (16 * (int64_t)(int32_t)&g5 - (int64_t)(int32_t)&g5) + 56 + (int64_t)&g3);
                *(int32_t *)(v4 + (int64_t)&g3 + 56) = v15;
                v6 = g6 - 1;
                g6 = v6;
                v7 = 1;
            }
            // 0x157b
            v16 = v7;
            v17 = v6;
            v3++;
            v18 = v3;
        }
        if (v16 != 1) {
            // 0x15a5
            puts(""\nProduct not found."");
            goto lab_0x15b4;
        } else {
            // 0x1594
            puts(""\nProduct removed successfully!"");
            goto lab_0x15b4;
        }
    }
  lab_0x15b4:;
    int64_t result = 0; // 0x15c2
    if (v1 != __readfsqword(40)) {
        // 0x15c4
        __stack_chk_fail();
        result = &g8;
    }
    // 0x15c9
    return result;
}

// Address range: 0x15cb - 0x16fa
int64_t update_quantity(void) {
    int64_t v1 = __readfsqword(40); // 0x15d7
    printf(""\nEnter Product ID to update quantity: "");
    int64_t v2; // bp-32, 0x15cb
    scanf(""%d"", &v2);
    int32_t v3 = 0; // 0x16b7
    if (g6 == 0) {
        // 0x16d4
        puts(""\nProduct not found."");
        goto lab_0x16e3;
    } else {
        int64_t v4 = 0; // 0x1638
        int32_t v5 = *(int32_t *)(v4 + (int64_t)&g3); // 0x1646
        int32_t v6 = 0; // 0x164e
        int64_t v7; // bp-28, 0x15cb
        if (v5 == (int32_t)v2) {
            // 0x1650
            printf(""Enter new quantity: "");
            scanf(""%d"", &v7);
            *(int32_t *)(v4 + (int64_t)&g4) = (int32_t)v7;
            v6 = 1;
        }
        int32_t v8 = v6;
        int32_t v9 = g6; // 0x16ae
        v3++;
        int64_t v10 = v3; // 0x16b7
        while (v10 < (int64_t)v9) {
            // 0x1628
            v4 = 60 * v10;
            v5 = *(int32_t *)(v4 + (int64_t)&g3);
            int32_t v11 = v9; // 0x164e
            v6 = v8;
            if (v5 == (int32_t)v2) {
                // 0x1650
                printf(""Enter new quantity: "");
                scanf(""%d"", &v7);
                *(int32_t *)(v4 + (int64_t)&g4) = (int32_t)v7;
                v11 = g6;
                v6 = 1;
            }
            // 0x16aa
            v8 = v6;
            v9 = v11;
            v3++;
            v10 = v3;
        }
        if (v8 != 1) {
            // 0x16d4
            puts(""\nProduct not found."");
            goto lab_0x16e3;
        } else {
            // 0x16c3
            puts(""\nQuantity updated successfully!"");
            goto lab_0x16e3;
        }
    }
  lab_0x16e3:;
    int64_t result = 0; // 0x16f1
    if (v1 != __readfsqword(40)) {
        // 0x16f3
        __stack_chk_fail();
        result = &g8;
    }
    // 0x16f8
    return result;
}

// Address range: 0x16fa - 0x17e3
int64_t display_inventory(void) {
    // 0x16fa
    puts(""\n===== Product Inventory ====="");
    puts(""| ID\t| Name\t\t| Quantity\t|"");
    puts(""==============================="");
    if (g6 == 0) {
        // 0x17d1
        return puts(""==============================="");
    }
    int32_t v1 = 0; // 0x17cb
    int64_t v2 = 0; // 0x174f
    uint32_t v3 = *(int32_t *)(v2 + (int64_t)&g4); // 0x175d
    uint32_t v4 = *(int32_t *)(v2 + (int64_t)&g3); // 0x17a0
    printf(""| %d\t| %s\t| %d\t\t|\n"", (int64_t)v4, (char *)(v2 + (int64_t)&g3 + 4), (int64_t)v3);
    v1++;
    int64_t v5 = v1; // 0x17cb
    while (v5 < (int64_t)g6) {
        // 0x173f
        v2 = 60 * v5;
        v3 = *(int32_t *)(v2 + (int64_t)&g4);
        v4 = *(int32_t *)(v2 + (int64_t)&g3);
        printf(""| %d\t| %s\t| %d\t\t|\n"", (int64_t)v4, (char *)(v2 + (int64_t)&g3 + 4), (int64_t)v3);
        v1++;
        v5 = v1;
    }
    // 0x17d1
    return puts(""==============================="");
}

// Address range: 0x17e4 - 0x17f1
int64_t _fini(void) {
    // 0x17e4
    int64_t result; // 0x17e4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 17

","      #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char ** argv) {
            int choice;
            int product_id;
            char product_name[20];
            int quantity;

            printf(""\n===== Product Inventory System ====="");
            printf(""\n| 1. Add a Product                  |"");
            printf(""\n| 2. Remove a Product               |"");
            printf(""\n| 3. Update Quantity of a Product   |"");
            printf(""\n| 4. Display Inventory              |"");
            printf(""\n| 5. Exit                           |"");
            printf(""\n===================================="");
            printf(""\nEnter your choice: "");
            scanf(""%d"", &choice);

            while (choice >= 6) {
                printf(""\nInvalid choice. Please try again."");
                if (choice == 5) {
                    return 0;
                }
                printf(""\nEnter your choice: "");
                scanf(""%d"", &choice);
            }

            switch (choice) {
                case 1:
                    printf(""\nEnter Product ID: "");
                    scanf(""%d"", &product_id);
                    printf(""Enter Product Name: "");
                    scanf(""%s"", product_name);
                    printf(""Enter Product Quantity: "");
                    scanf(""%d"", &quantity);
                    printf(""\nProduct added successfully!"");
                    break;
                case 2:
                    printf(""\nEnter Product ID to remove: "");
                    scanf(""%d"", &product_id);
                    printf(""\nProduct removed successfully!"");
                    break;
                case 3:
                    printf(""\nEnter Product ID to update quantity: "");
                    scanf(""%d"", &product_id);
                    printf(""Enter new quantity: "");
                    scanf(""%d"", &quantity);
                    printf(""\nQuantity updated successfully!"");
                    break;
                case 4:
                    printf(""\n===== Product Inventory ====="");
                    printf(""\n| ID\t| Name\t\t| Quantity\t|"");
                    printf(""\n==============================="");
                    if (quantity == 0) {
                        printf(""\n==============================="");
                        break;
                    }
                    printf(""\n| %d\t| %s\t| %d\t\t|"", product_id, product_name, quantity);
                    break;
                default:
                    printf(""\nInvalid choice. Please try again."");
                    break;
            }

            return 0;
        }

",2
"//FormAI DATASET v1.0 Category: Port Scanner ; Style: Cyberpunk
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

// Define some colors for a cyberpunk style output
#define COLOR_CYAN ""\x1b[36m""
#define COLOR_YELLOW ""\x1b[33m""
#define COLOR_RESET ""\x1b[0m""

// Function to print the usage instructions
void usage(char *program_name) {
    printf(COLOR_CYAN ""Usage: %s <ip_address>\n"" COLOR_RESET, program_name);
    printf(COLOR_CYAN ""Scans for open ports on the given IP address.\n"" COLOR_RESET);
    printf(COLOR_CYAN ""Example: %s 192.168.0.1\n"" COLOR_RESET, program_name);
}

// Function to create a socket and connect to the given port
int check_port(char *ip_address, int port) {
    int sock;
    struct sockaddr_in server;

    // Create the socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        printf(COLOR_YELLOW ""[-] Error: Could not create socket\n"" COLOR_RESET);
        return 1;
    }

    // Configure the server address
    server.sin_addr.s_addr = inet_addr(ip_address);
    server.sin_family = AF_INET;
    server.sin_port = htons(port);

    // Try to connect to the port
    if (connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0) {
        // Port is closed
        close(sock);
        return 0;
    }
    
    // Port is open
    close(sock);
    return 1;
}

int main(int argc, char *argv[]) {
    char *ip_address;
    int ports[] = {21, 22, 23, 80, 443, 3306, 8080, 9999}; // List of common ports to scan
    int i;

    // Check if the correct number of arguments are provided
    if (argc != 2) {
        usage(argv[0]);
        return 1;
    }

    // Get the IP address to scan
    ip_address = argv[1];

    // Scan the ports
    printf(COLOR_CYAN ""[*] Scanning %s...\n"" COLOR_RESET, ip_address);
    printf(COLOR_CYAN ""-----------------------\n"" COLOR_RESET);
    for (i = 0; i < sizeof(ports) / sizeof(ports[0]); i++) {
        printf(COLOR_CYAN ""[*] Checking port %d..."" COLOR_RESET, ports[i]);
        if (check_port(ip_address, ports[i])) {
            printf(COLOR_CYAN "" OPEN\n"" COLOR_RESET);
        } else {
            printf(COLOR_YELLOW "" CLOSED\n"" COLOR_RESET);
        }
    }
    printf(COLOR_CYAN ""-----------------------\n"" COLOR_RESET);

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct sockaddr {
    int64_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t check_port(int64_t cp, int64_t host_short);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_10a0(int64_t * d);
void function_10b0(void);
int16_t function_10c0(int16_t hostshort);
int32_t function_10d0(char * format, ...);
int32_t function_10e0(int32_t fd);
int32_t function_10f0(char * cp);
int32_t function_1100(int32_t fd, struct sockaddr * addr, int32_t len);
int32_t function_1110(int32_t domain, int32_t type, int32_t protocol);
int64_t register_tm_clones(void);
int64_t usage(int64_t a1);

// --------------------- Global Variables ---------------------

char * g1 = ""\x1b[36mUsage: %s <ip_address>\n\x1b[0m""; // 0x2008
char * g2 = ""\x1b[36mScans for open ports on the given IP address.\n\x1b[0m""; // 0x2030
char * g3 = ""\x1b[36mExample: %s 192.168.0.1\n\x1b[0m""; // 0x2068
char * g4 = ""\x1b[33m[-] Error: Could not create socket\n\x1b[0m""; // 0x2090
char * g5 = ""\x1b[36m[*] Scanning %s...\n\x1b[0m""; // 0x20bd
char * g6 = ""\x1b[36m-----------------------\n\x1b[0m""; // 0x20e0
char * g7 = ""\x1b[36m[*] Checking port %d...\x1b[0m""; // 0x2108
char * g8 = ""\x1b[36m OPEN\n\x1b[0m""; // 0x2129
char * g9 = ""\x1b[33m CLOSED\n\x1b[0m""; // 0x2139
int64_t g10 = 0; // 0x4010
int32_t g11;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g11;
    }
    // 0x1016
    return result;
}

// Address range: 0x10a0 - 0x10ab
void function_10a0(int64_t * d) {
    // 0x10a0
    __cxa_finalize(d);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int16_t function_10c0(int16_t hostshort) {
    // 0x10c0
    return htons(hostshort);
}

// Address range: 0x10d0 - 0x10db
int32_t function_10d0(char * format, ...) {
    // 0x10d0
    return printf(format);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(int32_t fd) {
    // 0x10e0
    return close(fd);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(char * cp) {
    // 0x10f0
    return inet_addr(cp);
}

// Address range: 0x1100 - 0x110b
int32_t function_1100(int32_t fd, struct sockaddr * addr, int32_t len) {
    // 0x1100
    return connect(fd, addr, len);
}

// Address range: 0x1110 - 0x111b
int32_t function_1110(int32_t domain, int32_t type, int32_t protocol) {
    // 0x1110
    return socket(domain, type, protocol);
}

// Address range: 0x1120 - 0x1146
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1120
    int64_t v1; // 0x1120
    __libc_start_main(0x1336, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1150 - 0x1179
int64_t deregister_tm_clones(void) {
    // 0x1150
    return &g10;
}

// Address range: 0x1180 - 0x11b9
int64_t register_tm_clones(void) {
    // 0x1180
    return 0;
}

// Address range: 0x11c0 - 0x11f9
int64_t __do_global_dtors_aux(void) {
    // 0x11c0
    if (*(char *)&g10 != 0) {
        // 0x11f8
        int64_t result; // 0x11c0
        return result;
    }
    // 0x11cd
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11db
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11e7
    *(char *)&g10 = 1;
    return result2;
}

// Address range: 0x1200 - 0x1209
int64_t frame_dummy(void) {
    // 0x1200
    return register_tm_clones();
}

// Address range: 0x1209 - 0x1266
int64_t usage(int64_t a1) {
    // 0x1209
    printf((char *)&g1);
    printf((char *)&g2);
    return printf((char *)&g3);
}

// Address range: 0x1266 - 0x1336
int64_t check_port(int64_t cp, int64_t host_short) {
    int64_t v1 = __readfsqword(40); // 0x1279
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x1297
    int64_t v2; // 0x1266
    if (sock_fd != -1) {
        // 0x12c0
        inet_addr((char *)cp);
        int16_t addr = 2; // bp-40, 0x12cf
        htons((int16_t)host_short);
        int32_t v3 = connect(sock_fd, (struct sockaddr *)&addr, 16); // 0x12f7
        close(sock_fd);
        v2 = v3 >= 0;
    } else {
        // 0x12a5
        printf((char *)&g4);
        v2 = 1;
    }
    int64_t result = v2; // 0x132d
    if (v1 != __readfsqword(40)) {
        // 0x132f
        __stack_chk_fail();
        result = &g11;
    }
    // 0x1334
    return result;
}

// Address range: 0x1336 - 0x1492
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1349
    int64_t v2 = (int64_t)argv;
    int64_t v3; // 0x1336
    if ((int32_t)argc == 2) {
        // 0x13af
        printf((char *)&g5);
        printf((char *)&g6);
        for (int64_t i = 0; i < 8; i++) {
            // 0x13f3
            printf((char *)&g7);
            int64_t v4; // bp-8, 0x1336
            uint32_t v5 = *(int32_t *)((int64_t)&v4 - 48 + 4 * i); // 0x1417
            if ((int32_t)check_port(*(int64_t *)(v2 + 8), (int64_t)v5) == 0) {
                // 0x1443
                printf((char *)&g9);
            } else {
                // 0x142d
                printf((char *)&g8);
            }
        }
        // 0x1463
        printf((char *)&g6);
        v3 = 0;
    } else {
        // 0x1396
        usage(v2);
        v3 = 1;
    }
    int64_t result = v3; // 0x1489
    if (v1 != __readfsqword(40)) {
        // 0x148b
        __stack_chk_fail();
        result = &g11;
    }
    // 0x1490
    return result;
}

// Address range: 0x1494 - 0x14a1
int64_t _fini(void) {
    // 0x1494
    int64_t result; // 0x1494
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 18

","      #include <stdio.h>
        #include <stdlib.h>
        #include <arpa/inet.h>
        #include <netinet/in.h>
        #include <sys/socket.h>
        #include <unistd.h>

        int main(int argc, char ** argv) {
            if ((int32_t)argc == 2) {
                printf(""Scanning %s...\n"", argv[1]);
                for (int i = 0; i < 8; i++) {
                    printf(""Checking port %d..."", 2 + i * 4);
                    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
                    if (sock_fd != -1) {
                        inet_addr(argv[1]);
                        int16_t addr = 2;
                        htons((int16_t)2 + i * 4);
                        int32_t v3 = connect(sock_fd, (struct sockaddr *)&addr, 16);
                        close(sock_fd);
                        if (v3 >= 0) {
                            printf(""OPEN\n"");
                        } else {
                            printf(""CLOSED\n"");
                        }
                    } else {
                        printf(""Could not create socket\n"");
                    }
                }
            } else {
                printf(""Usage: %s <ip_address>\n"", argv[0]);
                printf(""Scans for open ports on the given IP address.\n"");
                printf(""Example: %s 192.168.0.1\n"", argv[0]);
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Tower of Hanoi Problem ; Style: safe
#include <stdio.h>

// function to perform tower of hanoi
void towerOfHanoi(int n, char sourceRod, char destRod, char auxRod)
{
    if (n == 1) // base case
    {
        printf(""Move disk 1 from %c rod to %c rod\n"", sourceRod, destRod);
        return;
    }
    towerOfHanoi(n - 1, sourceRod, auxRod, destRod); // recursive call
    printf(""Move disk %d from %c rod to %c rod\n"", n, sourceRod, destRod);
    towerOfHanoi(n - 1, auxRod, destRod, sourceRod); // recursive call
}

int main()
{
    int n;
    printf(""Enter the number of disks: "");
    scanf(""%d"", &n);
    if (n < 1)
    {
        printf(""Invalid input! Number of disks should be greater than or equal to 1."");
        return 1;
    }
    printf(""Solution for Tower of Hanoi with %d disks:\n"", n);
    towerOfHanoi(n, 'A', 'C', 'B');
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
void function_1070(void);
int32_t function_1080(char * format, ...);
int32_t function_1090(char * format, ...);
int64_t register_tm_clones(void);
int64_t towerOfHanoi(int64_t a1, int64_t a2, int64_t a3, char a4);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
void function_1070(void) {
    // 0x1070
    __stack_chk_fail();
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * format, ...) {
    // 0x1080
    return printf(format);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * format, ...) {
    // 0x1090
    return scanf(format);
}

// Address range: 0x10a0 - 0x10c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10a0
    int64_t v1; // 0x10a0
    __libc_start_main(0x1220, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10d0 - 0x10f9
int64_t deregister_tm_clones(void) {
    // 0x10d0
    return &g1;
}

// Address range: 0x1100 - 0x1139
int64_t register_tm_clones(void) {
    // 0x1100
    return 0;
}

// Address range: 0x1140 - 0x1179
int64_t __do_global_dtors_aux(void) {
    // 0x1140
    if (*(char *)&g1 != 0) {
        // 0x1178
        int64_t result; // 0x1140
        return result;
    }
    // 0x114d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x115b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1167
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1180 - 0x1189
int64_t frame_dummy(void) {
    // 0x1180
    return register_tm_clones();
}

// Address range: 0x1189 - 0x1220
int64_t towerOfHanoi(int64_t a1, int64_t a2, int64_t a3, char a4) {
    int64_t v1 = 0x100000000000000 * a2 >> 56; // 0x119c
    int64_t v2 = 0x100000000000000 * a3 >> 56; // 0x119f
    char v3 = v2;
    int64_t chars_printed; // 0x1189
    if ((int32_t)a1 != 1) {
        int64_t v4 = 0x100000000 * a1 >> 32; // 0x1195
        int64_t v5 = a4; // 0x11cf
        int64_t v6 = v4 + 0xffffffff & 0xffffffff; // 0x11da
        towerOfHanoi(v6, (int64_t)(0x1000000 * (int32_t)a2 >> 24), v5, v3);
        char v7 = v1; // 0x11e8
        printf(""Move disk %d from %c rod to %c rod\n"", v4 & 0xffffffff, v7, v3);
        chars_printed = towerOfHanoi(v6, v5 & 0xffffffff, v2, v7);
    } else {
        // 0x11ab
        chars_printed = printf(""Move disk 1 from %c rod to %c rod\n"", (char)v1, v3);
    }
    // 0x121e
    return chars_printed;
}

// Address range: 0x1220 - 0x12d9
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x122c
    printf(""Enter the number of disks: "");
    int64_t v2; // bp-20, 0x1220
    scanf(""%d"", &v2);
    int32_t v3 = v2; // 0x126d
    int64_t v4; // 0x1220
    if (v3 >= 0 == (v3 != 0)) {
        // 0x128c
        printf(""Solution for Tower of Hanoi with %d disks:\n"", v2 & 0xffffffff);
        towerOfHanoi(v2 & 0xffffffff, 65, 67, 66);
        v4 = 0;
    } else {
        // 0x1271
        printf(""Invalid input! Number of disks should be greater than or equal to 1."");
        v4 = 1;
    }
    int64_t result = v4; // 0x12d0
    if (v1 != __readfsqword(40)) {
        // 0x12d2
        __stack_chk_fail();
        result = &g2;
    }
    // 0x12d7
    return result;
}

// Address range: 0x12dc - 0x12e9
int64_t _fini(void) {
    // 0x12dc
    int64_t result; // 0x12dc
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>

        int main(int argc, char ** argv) {
            int n;
            printf(""Enter the number of disks: "");
            scanf(""%d"", &n);
            int chars_printed;
            if (n >= 0 == (n != 0)) {
                printf(""Solution for Tower of Hanoi with %d disks:\n"", n);
                chars_printed = towerOfHanoi(n, 'A', 'B', 'C');
            } else {
                printf(""Invalid input! Number of disks should be greater than or equal to 1."");
            }
            return chars_printed;
        }

        int towerOfHanoi(int n, char from, char to, char spare) {
            if (n == 1) {
                printf(""Move disk 1 from %c rod to %c rod\n"", from, to);
                return 1;
            }
            chars_printed = towerOfHanoi(n - 1, from, spare, to);
            printf(""Move disk %d from %c rod to %c rod\n"", n, from, to);
            chars_printed += towerOfHanoi(n - 1, spare, to, from);
            return chars_printed;
        }

",2
"//FormAI DATASET v1.0 Category: Pattern printing ; Style: real-life
#include <stdio.h>

int main() {
	// Getting the user input for length of the pattern
    int length;
    printf(""Enter the length of the pattern: "");
    scanf(""%d"", &length);

    // Printing the C pattern
    for (int row = 0; row < length; row++) {
        for (int column = 0; column < length; column++) {
            // Check if first column or last row or last row column where C needs to be printed
            if (column == 0 || row == 0 || row == length - 1 && column > 0 && column < length - 1) {
                printf(""C"");
            } else {
                printf("" "");
            }
        }
        printf(""\n"");
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
int32_t function_1080(int32_t c);
void function_1090(void);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(int32_t c) {
    // 0x1080
    return putchar(c);
}

// Address range: 0x1090 - 0x109b
void function_1090(void) {
    // 0x1090
    __stack_chk_fail();
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return printf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(char * format, ...) {
    // 0x10b0
    return scanf(format);
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x1280
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    printf(""Enter the length of the pattern: "");
    int64_t v2; // bp-28, 0x11a9
    scanf(""%d"", &v2);
    int32_t v3 = 0; // 0x1263
    int64_t v4; // 0x11a9
    int32_t v5; // 0x11a9
    int32_t v6; // 0x11a9
    if ((v2 & 0xffffffff) != 0) {
        while (true) {
            int32_t v7 = v3;
            if ((v2 & 0xffffffff) != 0) {
                // 0x1205
                v4 = 0;
                v5 = 0;
                while (true) {
                  lab_0x1205:
                    // 0x1205
                    v6 = v5;
                    if (v7 == 0 || v6 == 0) {
                        // 0x122d
                        putchar(67);
                        goto lab_0x1243;
                    } else {
                        // 0x1211
                        if (v6 < 1 || v7 != (int32_t)v2 - 1) {
                            // 0x1239
                            putchar(32);
                            goto lab_0x1243;
                        } else {
                            // 0x1222
                            if ((v2 + 0xffffffff & 0xffffffff) > v4) {
                                // 0x122d
                                putchar(67);
                                goto lab_0x1243;
                            } else {
                                // 0x1239
                                putchar(32);
                                goto lab_0x1243;
                            }
                        }
                    }
                }
            }
          lab_0x124f:
            // 0x124f
            putchar(10);
            v3 = v7 + 1;
            if ((v2 & 0xffffffff) <= (int64_t)v3) {
                // break -> 0x1265
                break;
            }
        }
    }
    int64_t result = 0; // 0x1277
    if (v1 != __readfsqword(40)) {
        // 0x1279
        __stack_chk_fail();
        result = &g2;
    }
    // 0x127e
    return result;
  lab_0x1243:;
    int32_t v8 = v6 + 1; // 0x1243
    int64_t v9 = v8; // 0x124d
    v4 = v9;
    v5 = v8;
    if ((v2 & 0xffffffff) <= v9) {
        // break -> 0x124f
        goto lab_0x124f;
    }
    goto lab_0x1205;
}

// Address range: 0x1280 - 0x128d
int64_t _fini(void) {
    // 0x1280
    int64_t result; // 0x1280
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdint.h>
        #include <stdbool.h>

        int main(int argc, char ** argv) {
            int length;
            scanf(""%d"", &length);
            int i = 0;
            while (true) {
                if (i == 0 || i != length - 1) {
                    printf("" "");
                } else {
                    printf(""*"");
                }
                i++;
                if (i == length) {
                    break;
                }
            }
            printf(""\n"");
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Random Conspiracy Theory Generator ; Style: calm
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  char *conspiracy[] = {
    ""The moon landing was faked."",
    ""9/11 was an inside job."",
    ""The government is controlling our minds through chemtrails."",
    ""The earth is flat."",
    ""Aliens are among us and the government is covering it up."",
    ""The Illuminati controls everything."",
    ""The vaccine industry is a scam to make money and control populations."",
    ""The government is hiding evidence of time travel."",
    ""The Bermuda Triangle is a portal to another dimension."",
    ""The Titanic sinking was planned and not an accident.""
  };
  
  int size = sizeof(conspiracy)/sizeof(int); //Calculate size of the array
  time_t t;
  srand((unsigned) time(&t)); //Seed random number generator
  
  printf(""Random Conspiracy Theory Generator\n"");
  printf(""----------------------------\n"");
  
  int i;
  for (i=0; i<5; i++) { //Generate 5 random conspiracy theories
    int r = rand() % size;
    printf(""%d. %s\n"", i+1, conspiracy[r]);
  }

  return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1090(int64_t * d);
int32_t function_10a0(char * s);
void function_10b0(void);
int32_t function_10c0(char * format, ...);
void function_10d0(int32_t seed);
int32_t function_10e0(int32_t * timer);
int32_t function_10f0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1090 - 0x109b
void function_1090(int64_t * d) {
    // 0x1090
    __cxa_finalize(d);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * s) {
    // 0x10a0
    return puts(s);
}

// Address range: 0x10b0 - 0x10bb
void function_10b0(void) {
    // 0x10b0
    __stack_chk_fail();
}

// Address range: 0x10c0 - 0x10cb
int32_t function_10c0(char * format, ...) {
    // 0x10c0
    return printf(format);
}

// Address range: 0x10d0 - 0x10db
void function_10d0(int32_t seed) {
    // 0x10d0
    srand(seed);
}

// Address range: 0x10e0 - 0x10eb
int32_t function_10e0(int32_t * timer) {
    // 0x10e0
    return time(timer);
}

// Address range: 0x10f0 - 0x10fb
int32_t function_10f0(void) {
    // 0x10f0
    return rand();
}

// Address range: 0x1100 - 0x1126
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x1100
    int64_t v1; // 0x1100
    __libc_start_main(0x11e9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x1130 - 0x1159
int64_t deregister_tm_clones(void) {
    // 0x1130
    return &g1;
}

// Address range: 0x1160 - 0x1199
int64_t register_tm_clones(void) {
    // 0x1160
    return 0;
}

// Address range: 0x11a0 - 0x11d9
int64_t __do_global_dtors_aux(void) {
    // 0x11a0
    if (*(char *)&g1 != 0) {
        // 0x11d8
        int64_t result; // 0x11a0
        return result;
    }
    // 0x11ad
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x11bb
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x11c7
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11e0 - 0x11e9
int64_t frame_dummy(void) {
    // 0x11e0
    return register_tm_clones();
}

// Address range: 0x11e9 - 0x130d
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11f5
    int64_t t; // bp-112, 0x11e9
    srand(time((int32_t *)&t));
    puts(""Random Conspiracy Theory Generator"");
    puts(""----------------------------"");
    int64_t v2; // bp-8, 0x11e9
    int64_t v3 = (int64_t)&v2 - 96;
    int64_t v4 = 0;
    int32_t v5 = rand(); // 0x12b3
    int64_t v6 = *(int64_t *)(v3 + 8 * ((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 20)); // 0x12c4
    v4++;
    printf(""%d. %s\n"", v4, (char *)v6);
    while (v4 != 5) {
        // 0x12b3
        v5 = rand();
        v6 = *(int64_t *)(v3 + 8 * ((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 20));
        v4++;
        printf(""%d. %s\n"", v4, (char *)v6);
    }
    int64_t result = 0; // 0x1304
    if (v1 != __readfsqword(40)) {
        // 0x1306
        __stack_chk_fail();
        result = &g2;
    }
    // 0x130b
    return result;
}

// Address range: 0x1310 - 0x131d
int64_t _fini(void) {
    // 0x1310
    int64_t result; // 0x1310
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 15

","      #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>

        int main(int argc, char ** argv) {
            srand(time(NULL));
            puts(""Random Conspiracy Theory Generator"");
            puts(""----------------------------"");
            int i = 1;
            while (i != 5) {
                int r = rand();
                int index = (0x100000000 * (r >> 31) | r) % 20;
                printf(""%d. %s\n"", i, (char *)(0x100000000 * (r >> 31) | r));
                i++;
            }
            return 0;
        }

",0
"//FormAI DATASET v1.0 Category: Binary Converter ; Style: decentralized
#include<stdio.h>

void binary(int decimal){
    int binary[32], n = 0;
    while(decimal > 0){
        binary[n] = decimal%2;
        decimal /= 2;
        n++;
    }
    for(int i=n-1; i>=0; i--){
        printf(""%d"", binary[i]);
    }
}

int main(){
    int decimal;
    printf(""Enter a decimal number: "");
    scanf(""%d"", &decimal);
    printf(""The binary equivalent of %d is: "", decimal);
    binary(decimal);
    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t binary(int64_t a1);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1060(int64_t * d);
void function_1070(void);
int32_t function_1080(char * format, ...);
int32_t function_1090(char * format, ...);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1060 - 0x106b
void function_1060(int64_t * d) {
    // 0x1060
    __cxa_finalize(d);
}

// Address range: 0x1070 - 0x107b
void function_1070(void) {
    // 0x1070
    __stack_chk_fail();
}

// Address range: 0x1080 - 0x108b
int32_t function_1080(char * format, ...) {
    // 0x1080
    return printf(format);
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * format, ...) {
    // 0x1090
    return scanf(format);
}

// Address range: 0x10a0 - 0x10c6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10a0
    int64_t v1; // 0x10a0
    __libc_start_main(0x125d, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10d0 - 0x10f9
int64_t deregister_tm_clones(void) {
    // 0x10d0
    return &g1;
}

// Address range: 0x1100 - 0x1139
int64_t register_tm_clones(void) {
    // 0x1100
    return 0;
}

// Address range: 0x1140 - 0x1179
int64_t __do_global_dtors_aux(void) {
    // 0x1140
    if (*(char *)&g1 != 0) {
        // 0x1178
        int64_t result; // 0x1140
        return result;
    }
    // 0x114d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x115b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1167
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x1180 - 0x1189
int64_t frame_dummy(void) {
    // 0x1180
    return register_tm_clones();
}

// Address range: 0x1189 - 0x125d
int64_t binary(int64_t a1) {
    int64_t v1 = 0x100000000 * a1 >> 32; // 0x1198
    int64_t v2 = __readfsqword(40); // 0x119e
    int32_t v3 = v1; // 0x11f7
    if (v3 >= 0 == (v3 != 0)) {
        // 0x11b9
        int64_t v4; // bp-8, 0x1189
        int64_t v5 = (int64_t)&v4 - 144; // 0x11d4
        int32_t v6 = 0;
        int32_t v7 = v3;
        int32_t v8 = v1 < 0; // 0x11c3
        *(int32_t *)(4 * (int64_t)v6 + v5) = (v7 + v8) % 2 - v8;
        int32_t v9 = v7 + (int32_t)(v7 < 0); // 0x11e6
        int32_t v10 = v9 >> 1; // 0x11e8
        int32_t v11 = v6 + 1; // 0x11fe
        while (v9 >= 0 == (v10 != 0)) {
            // 0x11b9
            v6 = v11;
            v7 = v10;
            v8 = (int64_t)v10 < 0;
            *(int32_t *)(4 * (int64_t)v6 + v5) = (v7 + v8) % 2 - v8;
            v9 = v7 + (int32_t)(v7 < 0);
            v10 = v9 >> 1;
            v11 = v6 + 1;
        }
        // 0x123d
        if (v6 >= 0) {
            printf(""%d"", (int64_t)*(int32_t *)(4 * (int64_t)v6 + v5));
            int32_t v12 = v6 - 1;
            int32_t v13 = v12; // 0x1244
            while (v12 >= 0) {
                // 0x1211
                printf(""%d"", (int64_t)*(int32_t *)(4 * (int64_t)v13 + v5));
                v12 = v13 - 1;
                v13 = v12;
            }
        }
    }
    int64_t result = 0; // 0x1254
    if (v2 != __readfsqword(40)) {
        // 0x1256
        __stack_chk_fail();
        result = &g2;
    }
    // 0x125b
    return result;
}

// Address range: 0x125d - 0x12e5
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x1269
    printf(""Enter a decimal number: "");
    int64_t v2; // bp-20, 0x125d
    scanf(""%d"", &v2);
    printf(""The binary equivalent of %d is: "", v2 & 0xffffffff);
    binary(v2 & 0xffffffff);
    int64_t result = 0; // 0x12dc
    if (v1 != __readfsqword(40)) {
        // 0x12de
        __stack_chk_fail();
        result = &g2;
    }
    // 0x12e3
    return result;
}

// Address range: 0x12e8 - 0x12f5
int64_t _fini(void) {
    // 0x12e8
    int64_t result; // 0x12e8
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        int main(int argc, char ** argv) {
            int n;
            printf(""Enter a decimal number: "");
            scanf(""%d"", &n);
            printf(""The binary equivalent of %d is: "", n);
            for (int i = 31; i >= 0; i--) {
                printf(""%d"", (n >> i) & 1);
            }
            return 0;
        }

",1
"//FormAI DATASET v1.0 Category: Robot movement control ; Style: Dennis Ritchie
#include <stdio.h>
#include <stdlib.h>

int main() {
    int current_x = 0, current_y = 0; // starting position
    char direction = 'N'; // starting direction
    int steps;

    printf(""Starting position: (%d,%d), facing %c\n"", current_x, current_y, direction);

    // get user input for steps
    printf(""Enter number of steps: "");
    scanf(""%d"", &steps);

    for(int i = 1; i <= steps; i++) {
        // randomly generate movement direction (left, right, forward)
        int move = rand() % 3; // possible values: 0, 1, 2

        // handle movement and update position and direction accordingly
        switch(move) {
            case 0:
                // turn left
                switch(direction) {
                    case 'N':
                        direction = 'W';
                        break;
                    case 'E':
                        direction = 'N';
                        break;
                    case 'S':
                        direction = 'E';
                        break;
                    case 'W':
                        direction = 'S';
                        break;
                }
                break;
            case 1:
                // turn right
                switch(direction) {
                    case 'N':
                        direction = 'E';
                        break;
                    case 'E':
                        direction = 'S';
                        break;
                    case 'S':
                        direction = 'W';
                        break;
                    case 'W':
                        direction = 'N';
                        break;
                }
                break;
            case 2:
                // move forward
                switch(direction) {
                    case 'N':
                        current_y++;
                        break;
                    case 'E':
                        current_x++;
                        break;
                    case 'S':
                        current_y--;
                        break;
                    case 'W':
                        current_x--;
                        break;
                }
                break;
        }

        // print current position and direction
        printf(""Step %d: moved %s, now at (%d,%d) facing %c\n"",
               i,
               (move == 0 ? ""left"" : (move == 1 ? ""right"" : ""forward"")),
               current_x,
               current_y,
               direction);
    }

    return 0;
}","//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t _fini(void);
int64_t _init(void);
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6);
int64_t deregister_tm_clones(void);
int64_t frame_dummy(void);
void function_1070(int64_t * d);
void function_1080(void);
int32_t function_1090(char * format, ...);
int32_t function_10a0(char * format, ...);
int32_t function_10b0(void);
int64_t register_tm_clones(void);

// --------------------- Global Variables ---------------------

int64_t g1 = 0; // 0x4010
int32_t g2;

// ------- Dynamically Linked Functions Without Header --------

void __cxa_finalize(int64_t * a1);
void __gmon_start__(void);
int32_t __libc_start_main(int64_t a1, int32_t a2, char ** a3, void (*a4)(), void (*a5)(), void (*a6)());
void __stack_chk_fail(void);

// ------------------------ Functions -------------------------

// Address range: 0x1000 - 0x101b
int64_t _init(void) {
    int64_t result = 0; // 0x1012
    if (*(int64_t *)0x3fe8 != 0) {
        // 0x1014
        __gmon_start__();
        result = &g2;
    }
    // 0x1016
    return result;
}

// Address range: 0x1070 - 0x107b
void function_1070(int64_t * d) {
    // 0x1070
    __cxa_finalize(d);
}

// Address range: 0x1080 - 0x108b
void function_1080(void) {
    // 0x1080
    __stack_chk_fail();
}

// Address range: 0x1090 - 0x109b
int32_t function_1090(char * format, ...) {
    // 0x1090
    return printf(format);
}

// Address range: 0x10a0 - 0x10ab
int32_t function_10a0(char * format, ...) {
    // 0x10a0
    return scanf(format);
}

// Address range: 0x10b0 - 0x10bb
int32_t function_10b0(void) {
    // 0x10b0
    return rand();
}

// Address range: 0x10c0 - 0x10e6
int64_t _start(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6) {
    // 0x10c0
    int64_t v1; // 0x10c0
    __libc_start_main(0x11a9, (int32_t)a6, (char **)&v1, NULL, NULL, (void (*)())a3);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x10f0 - 0x1119
int64_t deregister_tm_clones(void) {
    // 0x10f0
    return &g1;
}

// Address range: 0x1120 - 0x1159
int64_t register_tm_clones(void) {
    // 0x1120
    return 0;
}

// Address range: 0x1160 - 0x1199
int64_t __do_global_dtors_aux(void) {
    // 0x1160
    if (*(char *)&g1 != 0) {
        // 0x1198
        int64_t result; // 0x1160
        return result;
    }
    // 0x116d
    if (*(int64_t *)0x3ff8 != 0) {
        // 0x117b
        __cxa_finalize((int64_t *)*(int64_t *)0x4008);
    }
    int64_t result2 = deregister_tm_clones(); // 0x1187
    *(char *)&g1 = 1;
    return result2;
}

// Address range: 0x11a0 - 0x11a9
int64_t frame_dummy(void) {
    // 0x11a0
    return register_tm_clones();
}

// Address range: 0x11a9 - 0x13c1
int main(int argc, char ** argv) {
    int64_t v1 = __readfsqword(40); // 0x11b5
    printf(""Starting position: (%d,%d), facing %c\n"", 0, 0, 78);
    printf(""Enter number of steps: "");
    int64_t v2; // bp-36, 0x11a9
    scanf(""%d"", &v2);
    int32_t v3 = 1; // 0x13a0
    char v4 = 78; // 0x13a0
    int32_t v5 = 0; // 0x13a0
    int32_t v6 = 0; // 0x13a0
    int64_t v7; // 0x11a9
    int32_t v8; // 0x11a9
    int32_t v9; // 0x11a9
    int32_t v10; // 0x11a9
    int32_t v11; // 0x11a9
    char v12; // 0x11a9
    char v13; // 0x11a9
    int32_t v14; // 0x11a9
    if ((v2 & 0xffffffff) != 0) {
        while (true) {
          lab_0x1231:;
            int32_t v15 = v6;
            int32_t v16 = v5;
            char v17 = v4;
            v14 = rand() % 3;
            if (v14 == 2) {
                if (v17 == 87) {
                    // 0x1337
                    v11 = v15 - 1;
                    v9 = v16;
                    v13 = 87;
                } else {
                    // 0x130c
                    v11 = v15;
                    v9 = v16;
                    v13 = v17;
                    if (v17 <= 87) {
                        if (v17 == 83) {
                            // 0x1331
                            v11 = v15;
                            v9 = v16 - 1;
                            v13 = 83;
                        } else {
                            // 0x1316
                            v11 = v15;
                            v9 = v16;
                            v13 = v17;
                            if (v17 <= 83) {
                                if (v17 == 69) {
                                    // 0x132b
                                    v11 = v15 + 1;
                                    v9 = v16;
                                    v13 = 69;
                                } else {
                                    // 0x1320
                                    v11 = v15;
                                    v9 = v16 + (int32_t)(v17 == 78);
                                    v13 = v17;
                                }
                            }
                        }
                    }
                }
                goto lab_0x134f;
            } else {
                // 0x1266
                v11 = v15;
                v9 = v16;
                v13 = v17;
                // 0x1270
                v11 = v15;
                v9 = v16;
                v13 = v17;
                switch (v14) {
                    case 0: {
                        // 0x1281
                        v12 = 83;
                        v8 = v16;
                        v10 = v15;
                        v7 = (int64_t)""left"";
                        if (v17 != 87) {
                            // 0x128a
                            v12 = v17;
                            v8 = v16;
                            v10 = v15;
                            v7 = (int64_t)""left"";
                            if (v17 <= 87) {
                                // 0x1293
                                v12 = 69;
                                v8 = v16;
                                v10 = v15;
                                v7 = (int64_t)""left"";
                                if (v17 != 83) {
                                    // 0x1298
                                    v12 = v17;
                                    v8 = v16;
                                    v10 = v15;
                                    v7 = (int64_t)""left"";
                                    if (v17 <= 83) {
                                        // 0x12a1
                                        v12 = 78;
                                        v8 = v16;
                                        v10 = v15;
                                        v7 = (int64_t)""left"";
                                        if (v17 != 69) {
                                            // 0x12a6
                                            v12 = v17 != 78 ? v17 : 87;
                                            v8 = v16;
                                            v10 = v15;
                                            v7 = (int64_t)""left"";
                                        }
                                    }
                                }
                            }
                        }
                        goto lab_0x136e;
                    }
                    case 1: {
                        // 0x12c8
                        v11 = v15;
                        v9 = v16;
                        v13 = 78;
                        if (v17 != 87) {
                            // 0x12d1
                            v11 = v15;
                            v9 = v16;
                            v13 = v17;
                            if (v17 <= 87) {
                                // 0x12d6
                                v11 = v15;
                                v9 = v16;
                                v13 = 87;
                                if (v17 != 83) {
                                    // 0x12db
                                    v11 = v15;
                                    v9 = v16;
                                    v13 = v17;
                                    if (v17 <= 83) {
                                        // 0x12e0
                                        v11 = v15;
                                        v9 = v16;
                                        v13 = 83;
                                        if (v17 != 69) {
                                            // 0x12e5
                                            v11 = v15;
                                            v9 = v16;
                                            v13 = v17 != 78 ? v17 : 69;
                                        }
                                    }
                                }
                            }
                        }
                        goto lab_0x134f;
                    }
                    default: {
                        goto lab_0x134f;
                    }
                }
            }
        }
    }
  lab_0x13a6:;
    int64_t result = 0; // 0x13b8
    if (v1 != __readfsqword(40)) {
        // 0x13ba
        __stack_chk_fail();
        result = &g2;
    }
    // 0x13bf
    return result;
  lab_0x134f:
    // 0x134f
    v12 = v13;
    v8 = v9;
    v10 = v11;
    v7 = v14 != 1 ? (int64_t)""forward"" : (int64_t)""right"";
    goto lab_0x136e;
  lab_0x136e:
    // 0x136e
    v6 = v10;
    v5 = v8;
    v4 = v12;
    printf(""Step %d: moved %s, now at (%d,%d) facing %c\n"", (int64_t)v3, (char *)v7, (int64_t)v6, (int64_t)v5, v4);
    v3++;
    if ((v2 & 0xffffffff) < (int64_t)v3) {
        // break -> 0x13a6
        goto lab_0x13a6;
    }
    goto lab_0x1231;
}

// Address range: 0x13c4 - 0x13d1
int64_t _fini(void) {
    // 0x13c4
    int64_t result; // 0x13c4
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.4.0)
// Detected functions: 13

","      #include <stdio.h>
        #include <stdlib.h>
        #include <stdbool.h>
        #include <stdint.h>

        int main(int argc, char ** argv) {
            int steps = 0;
            int x = 0;
            int y = 0;
            char direction = '>';
            printf(""Starting position: (%d,%d), facing %c\n"", x, y, direction);
            printf(""Enter number of steps: "");
            scanf(""%d"", &steps);
            int step = 1;
            while (step <= steps) {
                int new_x = 0;
                int new_y = 0;
                char new_direction = 0;
                switch (direction) {
                    case '>':
                        new_x = x + 1;
                        new_y = y;
                        new_direction = '>';
                        break;
                    case '<':
                        new_x = x - 1;
                        new_y = y;
                        new_direction = '<';
                        break;
                    case '^':
                        new_x = x;
                        new_y = y + 1;
                        new_direction = '^';
                        break;
                    case 'v':
                        new_x = x;
                        new_y = y - 1;
                        new_direction = 'v';
                        break;
                }
                printf(""Step %d: moved %c, now at (%d,%d) facing %c\n"", step, direction, new_x, new_y, new_direction);
                x = new_x;
                y = new_y;
                direction = new_direction;
                step++;
            }
            return 0;
        }

",2
